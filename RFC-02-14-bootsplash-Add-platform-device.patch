diff --git a/drivers/video/fbdev/core/bootsplash.c b/drivers/video/fbdev/core/bootsplash.c
index 7a6fd6f8076a..7eb2126c3a31 100644
--- a/drivers/video/fbdev/core/bootsplash.c
+++ b/drivers/video/fbdev/core/bootsplash.c
@@ -198,6 +198,58 @@ void bootsplash_enable(void)
 
 
 /*
+ * Userland API via platform device in sysfs
+ */
+
+static ssize_t splash_show_enabled(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", splash_global.enabled);
+}
+
+static ssize_t splash_store_enabled(struct device *device,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	bool enable;
+	int err;
+
+	if (!buf || !count)
+		return -EFAULT;
+
+	err = kstrtobool(buf, &enable);
+	if (err)
+		return err;
+
+	if (enable)
+		bootsplash_enable();
+	else
+		bootsplash_disable();
+
+	return count;
+}
+
+static DEVICE_ATTR(enabled, 0644, splash_show_enabled, splash_store_enabled);
+
+
+static struct attribute *splash_dev_attrs[] = {
+	&dev_attr_enabled.attr,
+	NULL
+};
+
+ATTRIBUTE_GROUPS(splash_dev);
+
+
+static struct platform_driver splash_driver = {
+	.driver = {
+		.name = "bootsplash",
+	},
+};
+
+
+
+
+/*
  * Main init/exit functions
  */
 
@@ -208,6 +260,32 @@ void bootsplash_init(void)
 		return;
 
 
+	/* Register platform device to export user API */
+	if (!splash_global.splash_device) {
+		int ret;
+
+		ret = platform_driver_register(&splash_driver);
+		if (ret) {
+			pr_err("platform_driver_register() failed: %d\n", ret);
+			goto err;
+		}
+
+		splash_global.splash_device
+			= platform_device_alloc("bootsplash", 0);
+
+		if (!splash_global.splash_device) {
+			goto err_driver;
+		}
+
+		splash_global.splash_device->dev.groups = splash_dev_groups;
+
+		platform_device_add(splash_global.splash_device);
+		if (ret) {
+			pr_err("platform_device_add() failed: %d\n", ret);
+			goto err_device;
+		}
+	}
+
 	spin_lock_init(&splash_global.state_lock);
 	if (!splash_global.wq)
 		splash_global.wq = alloc_workqueue("bootsplash",
@@ -220,6 +298,11 @@ void bootsplash_init(void)
 
 	return;
 
+err_device:
+	platform_device_put(splash_global.splash_device);
+	splash_global.splash_device = NULL;
+err_driver:
+	platform_driver_unregister(&splash_driver);
 err:
 	pr_err("Failed to initialize.\n");
 }
diff --git a/drivers/video/fbdev/core/bootsplash_internal.h b/drivers/video/fbdev/core/bootsplash_internal.h
index 4cec02774652..41d519d88baa 100644
--- a/drivers/video/fbdev/core/bootsplash_internal.h
+++ b/drivers/video/fbdev/core/bootsplash_internal.h
@@ -41,6 +41,9 @@ struct splash_priv {
 	spinlock_t state_lock;
 	bool enabled;
 
+	/* Our gateway to userland via sysfs */
+	struct platform_device *splash_device;
+
 	/* We use our own workqueue so we don't have to worry about blocking
 	 * on console_lock() while animating and thus freezing the system
 	 * during suspend.
