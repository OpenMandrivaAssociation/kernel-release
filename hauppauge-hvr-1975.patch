--- linux-4.15/drivers/media/common/tveeprom.c.0140~	2018-01-28 22:20:33.000000000 +0100
+++ linux-4.15/drivers/media/common/tveeprom.c	2018-02-12 11:32:52.760582121 +0100
@@ -551,7 +551,8 @@ void tveeprom_hauppauge_analog(struct tv
 				(eeprom_data[i+7] << 16)+
 				(eeprom_data[i+8] << 24);
 
-			if (eeprom_data[i + 8] == 0xf0) {
+			if ((eeprom_data[i + 8] & 0xf0) &&
+					(tvee->serial_number < 0xffffff)) {
 				tvee->MAC_address[0] = 0x00;
 				tvee->MAC_address[1] = 0x0D;
 				tvee->MAC_address[2] = 0xFE;
--- linux-4.15/drivers/media/dvb-frontends/Kconfig.0140~	2018-01-28 22:20:33.000000000 +0100
+++ linux-4.15/drivers/media/dvb-frontends/Kconfig	2018-02-12 11:32:52.760582121 +0100
@@ -529,6 +529,13 @@ config DVB_SI2168
 	help
 	  Say Y when you want to support this frontend.
 
+config DVB_SI2168B
+	tristate "Silicon Labs Si2168B"
+	depends on DVB_CORE && I2C && I2C_MUX
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  Say Y when you want to support this frontend.
+
 config DVB_AS102_FE
 	tristate
 	depends on DVB_CORE
@@ -829,6 +836,14 @@ config DVB_SP2
 	help
 	  CIMaX SP2/SP2HF Common Interface module.
 
+config DVB_SILG
+	tristate "SILG SiLabs + LG Dual Demodulator"
+	depends on DVB_CORE && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  A DVB-T/T2/C + ATSC demodulator module. Say Y when
+	  you want to support this frontend.
+
 config DVB_LGS8GL5
 	tristate "Silicon Legend LGS-8GL5 demodulator (OFDM)"
 	depends on DVB_CORE && I2C
--- linux-4.15/drivers/media/dvb-frontends/Makefile.0140~	2018-02-12 11:32:52.007576605 +0100
+++ linux-4.15/drivers/media/dvb-frontends/Makefile	2018-02-12 11:32:52.760582121 +0100
@@ -87,6 +87,7 @@ obj-$(CONFIG_DVB_CX24117) += cx24117.o
 obj-$(CONFIG_DVB_CX24120) += cx24120.o
 obj-$(CONFIG_DVB_SI21XX) += si21xx.o
 obj-$(CONFIG_DVB_SI2168) += si2168.o
+obj-$(CONFIG_DVB_SI2168B) += si2168b.o
 obj-$(CONFIG_DVB_STV0288) += stv0288.o
 obj-$(CONFIG_DVB_STB6000) += stb6000.o
 obj-$(CONFIG_DVB_S921) += s921.o
@@ -129,3 +130,4 @@ obj-$(CONFIG_DVB_HORUS3A) += horus3a.o
 obj-$(CONFIG_DVB_ASCOT2E) += ascot2e.o
 obj-$(CONFIG_DVB_HELENE) += helene.o
 obj-$(CONFIG_DVB_ZD1301_DEMOD) += zd1301_demod.o
+obj-$(CONFIG_DVB_SILG) += silg.o
--- linux-4.15/drivers/media/dvb-frontends/si2168b.c.0140~	2018-02-12 11:32:52.764582151 +0100
+++ linux-4.15/drivers/media/dvb-frontends/si2168b.c	2018-02-12 11:32:52.764582151 +0100
@@ -0,0 +1,6900 @@
+/* DVB compliant Linux driver for the DVB-T/T2/C Si2168B demodulator
+*
+* Copyright (C) 2015 PCTV Systems S.Ã  r.l & Silicon Laboratories Inc.
+*
+*/
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <asm/div64.h>
+
+#include "dvb_frontend.h"
+#include "si2168b_priv.h"
+#include "silabs_tercab.h"
+
+static int sidebug = 0;
+module_param_named(debug, sidebug, int, 0644);
+
+int _sitrace = 0;
+module_param_named(sitrace, _sitrace, int, 0644);
+
+int mutex_on = 1;
+module_param_named(mutex, mutex_on, int, 0644);
+
+/* #define __MCNS__ */
+
+#define siprintk(args...) \
+	do { \
+		if (sidebug) \
+			printk(KERN_DEBUG "Si2168B: " args); \
+	} while (0)
+
+static inline void _mutex_lock(struct mutex *lock)
+{
+	if (mutex_on) {
+		mutex_lock(lock);
+	}
+}
+
+static inline void _mutex_unlock(struct mutex *lock)
+{
+	if (mutex_on) {
+		mutex_unlock(lock);
+	}
+}
+
+/* names of the delivery systems for debugging purposes only */
+static char *delsys_name(enum fe_delivery_system delsys)
+{
+	switch (delsys)	{
+	case SYS_UNDEFINED    : {return (char*)"SYS_UNDEFINED"   ;}
+	case SYS_DVBC_ANNEX_A : {return (char*)"SYS_DVBC_ANNEX_A";}
+	case SYS_DVBC_ANNEX_B : {return (char*)"SYS_DVBC_ANNEX_B";}
+	case SYS_DVBT         : {return (char*)"SYS_DVBT"        ;}
+	case SYS_DSS          : {return (char*)"SYS_DSS"         ;}
+	case SYS_DVBS         : {return (char*)"SYS_DVBS"        ;}
+	case SYS_DVBS2        : {return (char*)"SYS_DVBS2"       ;}
+	case SYS_DVBH         : {return (char*)"SYS_DVBH"        ;}
+	case SYS_ISDBT        : {return (char*)"SYS_ISDBT"       ;}
+	case SYS_ISDBS        : {return (char*)"SYS_ISDBS"       ;}
+	case SYS_ISDBC        : {return (char*)"SYS_ISDBC"       ;}
+	case SYS_ATSC         : {return (char*)"SYS_ATSC"        ;}
+	case SYS_ATSCMH       : {return (char*)"SYS_ATSCMH"      ;}
+	case SYS_DTMB         : {return (char*)"SYS_DTMB"        ;}
+	case SYS_CMMB         : {return (char*)"SYS_CMMB"        ;}
+	case SYS_DAB          : {return (char*)"SYS_DAB"         ;}
+	case SYS_DVBT2        : {return (char*)"SYS_DVBT2"       ;}
+	case SYS_TURBO        : {return (char*)"SYS_TURBO"       ;}
+	case SYS_DVBC_ANNEX_C : {return (char*)"SYS_DVBC_ANNEX_C";}
+    default:
+    	break;
+	}
+	return (char*)"* UNKNOWN *";
+}
+
+typedef enum custom_ts_mode_enum {
+	SILABS_TS_TRISTATE = 0,
+	SILABS_TS_SERIAL = 1,
+	SILABS_TS_PARALLEL = 2,
+	SILABS_TS_GPIF = 3,
+	SILABS_TS_OFF = 4
+} custom_ts_mode_enum;
+
+/* Standard code values used by the top-level application               */
+/* <porting> set these values to match the top-level application values */
+typedef enum custom_standard_enum {
+	SILABS_ANALOG = 4,
+	SILABS_DVB_T = 0,
+	SILABS_DVB_C = 1,
+	SILABS_DVB_S = 2,
+	SILABS_DVB_S2 = 3,
+	SILABS_DVB_T2 = 5,
+	SILABS_DSS = 6,
+	SILABS_MCNS = 7,
+	SILABS_DVB_C2 = 8,
+	SILABS_SLEEP = 100
+} custom_standard_enum;
+
+typedef enum custom_constel_enum {
+	SILABS_QAMAUTO = -1,
+	SILABS_QAM16 = 0,
+	SILABS_QAM32 = 1,
+	SILABS_QAM64 = 2,
+	SILABS_QAM128 = 3,
+	SILABS_QAM256 = 4,
+	SILABS_QPSK = 5,
+	SILABS_8PSK = 6,
+	SILABS_QAM1024 = 7,
+	SILABS_QAM4096 = 8
+} custom_constel_enum;
+
+typedef enum custom_stream_enum {
+	SILABS_HP = 0,
+	SILABS_LP = 1
+} custom_stream_enum;
+
+typedef enum custom_t2_plp_type {
+	SILABS_PLP_TYPE_COMMON = 0,
+	SILABS_PLP_TYPE_DATA_TYPE1 = 1,
+	SILABS_PLP_TYPE_DATA_TYPE2 = 2
+} custom_t2_plp_type;
+
+typedef enum custom_hierarchy_enum {
+	SILABS_HIERARCHY_NONE = 0,
+	SILABS_HIERARCHY_ALFA1 = 1,
+	SILABS_HIERARCHY_ALFA2 = 2,
+	SILABS_HIERARCHY_ALFA4 = 3
+} custom_hierarchy_enum;
+
+/************************************************************************************************************************
+  system_time function
+  Use:        current system time retrieval function
+              Used to retrieve the current system time in milliseconds
+  Returns:    The current system time in milliseconds
+  Porting:    Needs to use the final system call
+************************************************************************************************************************/
+static inline u32 system_time(void)
+{
+  /* <porting> Replace 'clock' by whatever is necessary to return the system time in milliseconds */
+  /* return (int)clock()*1000/CLOCKS_PER_SEC; */
+  return (u32)jiffies_to_msecs(jiffies);
+}
+
+#ifdef SiTRACES
+#define SiTRACES_BUFFER_LENGTH  100000
+#define SiTRACES_NAMESIZE           30
+#define SiTRACES_FUNCTION_NAMESIZE  30
+
+#define CUSTOM_PRINTF(args...) \
+	do { \
+		if (_sitrace) \
+			printk(KERN_INFO "si2168b: " args); \
+	} while (0)
+
+typedef enum TYPE_OF_OUTPUT {
+    TRACE_NONE = 0,
+    TRACE_STDOUT,
+    TRACE_EXTERN_FILE,
+    TRACE_MEMORY
+} TYPE_OF_OUTPUT;
+
+static TYPE_OF_OUTPUT trace_output_type;
+
+static u8  trace_init_done        = 0;
+static u8  trace_suspend          = 0;
+static u8  trace_config_lines     = 0;
+static u8  trace_config_functions = 0;
+static u8  trace_config_time      = 0;
+static u8  trace_config_verbose   = 0;
+static u32 trace_linenumber       = 0;
+
+static char trace_timer[50];
+static char trace_elapsed_time[20];
+static char trace_source_function[SiTRACES_FUNCTION_NAMESIZE+1];
+static u8 trace_skip_info = 0;
+
+/************************************************************************************************************************
+  traceElapsedTime function
+  Use:        SiTRACES time formatting function.
+              It allows the user to know when the trace has been treated.
+              It is used to insert the time before the trace when -time 'on'.
+  Returns:    text containing the execution time in HH:MM:SS.ms format.
+  Porting:    Not compiled if SiTRACES is not defined in Silabs_L0_API.h.
+ ************************************************************************************************************************/
+static char *get_elapsed_time(void)
+{
+	u32 time_elapsed, ms, sec, min, hours;
+
+	time_elapsed = system_time();
+	ms = time_elapsed % 1000;
+	time_elapsed = time_elapsed/1000;
+	sec = time_elapsed % 60;
+	time_elapsed = time_elapsed/60;
+	min = time_elapsed % 60;
+	time_elapsed = time_elapsed/60;
+	hours = time_elapsed % 60;
+	sprintf(trace_elapsed_time, "%02u:%02u:%02u.%03u ", hours, min, sec, ms);
+
+	return trace_elapsed_time;
+}
+
+/************************************************************************************************************************
+  traceToStdout function
+  Use:        SiTRACES stdout display function.
+              It displays the current trace in the command window.
+              It adds file name, line number,function name and time if selected.
+  Parameter:  trace
+  Returns:    void
+ ************************************************************************************************************************/
+static void trace_to_stdout(char* trace)
+{
+	if (!trace_skip_info) {
+		if (trace_config_lines) {
+			CUSTOM_PRINTF("%5u "  , trace_linenumber);
+		}
+		if (trace_config_functions) {
+			CUSTOM_PRINTF("%-30s ", trace_source_function);
+		}
+	}
+	if (trace_config_time) {
+		CUSTOM_PRINTF("%s ", get_elapsed_time());
+	}
+	CUSTOM_PRINTF("%s", trace);
+}
+
+/************************************************************************************************************************
+  traceToDestination function
+  Use:        switch the trace in the selected output mode.
+  Comment:    In verbose mode, the trace is always displayed in stdout.
+  Parameter:  trace, the trace string
+  Returns:    void
+  Porting:    Not compiled if SiTRACES is not defined in Silabs_L0_API.h.
+************************************************************************************************************************/
+static void trace_to_destination(char* trace)
+{
+	int last;
+
+	if (trace_suspend) {
+		return;
+	}
+	/* If trace is a single CrLf, do not print the file/line/function info           */
+	if (strcmp(trace,"\n")==0) {
+		trace_skip_info = 1;
+	}
+	/* If file/line/function info printed, make sure there is a CrLf after each line */
+	if (trace_config_lines + trace_config_functions + trace_config_time) {
+		last = (int)strlen(trace)-1;
+		if (trace[last] != 0x0a) {
+			sprintf(trace, "%s\n", trace);
+		}
+	}
+	trace_to_stdout(trace);
+	if ((trace_config_verbose) & (trace_output_type!=TRACE_STDOUT)) {
+		trace_to_stdout(trace);
+	}
+	if (strcmp(trace,"\n")==0) {
+		trace_skip_info = 0;
+	}
+}
+
+/************************************************************************************************************************
+  SiTraceFunction function
+  Use:        SiTRACES trace formatting function.
+              It formats the trace message with file name and line number and time if selected
+              then saves it to the trace output.
+  Parameter:  name    the file name where the trace is written.
+  Parameter:  number  the line number where the trace is written.
+  Parameter:  fmt     string content of trace message. Others arguments are sent thanks to the ellipse.
+  Returns:    void
+  Porting:    Not compiled if SiTRACES is not defined in Silabs_L0_API.h.
+************************************************************************************************************************/
+static void sitrace_function(const char *name, int number, const char *func, const char *fmt, ...)
+{
+	char message[850];
+	const char *pfunc;
+	va_list ap;
+
+	if (trace_output_type == TRACE_NONE)
+		return;
+
+	/* print the line number in trace_linenumber */
+	trace_linenumber = number;
+
+	/*print the function name in trace_source_function */
+	pfunc = func;
+	sprintf(trace_source_function, "%s", "");
+	if (strlen(pfunc) > SiTRACES_FUNCTION_NAMESIZE) {
+		pfunc += (strlen(pfunc) - SiTRACES_FUNCTION_NAMESIZE) + 2;
+		strcpy(trace_source_function, "..");
+	}
+	strncat(trace_source_function, pfunc, SiTRACES_FUNCTION_NAMESIZE-2);
+
+	va_start(ap, fmt);
+	vsnprintf(message, 900, fmt, ap);
+	trace_to_destination(message);
+	va_end(ap);
+}
+
+/************************************************************************************************************************
+  SiTraceDefaultConfiguration function
+  Use:        SiTRACES initialization function.
+              It is called on the first call to L0_Init (only once).
+              It defines the default output and inserts date and time in the default file.
+  Returns:    void
+  Porting:    Not compiled if SiTRACES is not defined in Silabs_L0_API.h.
+************************************************************************************************************************/
+static void sitrace_default_configuration(void)
+{
+    if (trace_init_done)
+    	return;
+
+    trace_output_type = TRACE_STDOUT;
+    trace_init_done = 1;
+    sprintf(trace_timer, "time");
+}
+
+static inline void sitraces_suspend(void)
+{
+	trace_suspend = 1;
+}
+
+static inline void sitraces_resume(void)
+{
+	trace_suspend = 0;
+}
+
+/***********************************************************************************************************************
+  si2168b_error_text function
+  Use:        Error information function
+              Used to retrieve a text based on an error code
+  Returns:    the error text
+  Parameter:  error_code the error code.
+  Porting:    Useful for application development for debug purposes.
+  Porting:    May not be required for the final application, can be removed if not used.
+ ***********************************************************************************************************************/
+static char* si2168b_error_text(int error_code)
+{
+	switch (error_code) {
+	case NO_Si2168B_ERROR                     : return (char *)"No Si2168B error";
+	case ERROR_Si2168B_ALLOCATING_CONTEXT     : return (char *)"Error while allocating Si2168B context";
+	case ERROR_Si2168B_PARAMETER_OUT_OF_RANGE : return (char *)"Si2168B parameter(s) out of range";
+	case ERROR_Si2168B_SENDING_COMMAND        : return (char *)"Error while sending Si2168B command";
+	case ERROR_Si2168B_CTS_TIMEOUT            : return (char *)"Si2168B CTS timeout";
+	case ERROR_Si2168B_ERR                    : return (char *)"Si2168B Error (status 'err' bit 1)";
+	case ERROR_Si2168B_POLLING_CTS            : return (char *)"Si2168B Error while polling CTS";
+	case ERROR_Si2168B_POLLING_RESPONSE       : return (char *)"Si2168B Error while polling response";
+	case ERROR_Si2168B_LOADING_FIRMWARE       : return (char *)"Si2168B Error while loading firmware";
+	case ERROR_Si2168B_LOADING_BOOTBLOCK      : return (char *)"Si2168B Error while loading bootblock";
+	case ERROR_Si2168B_STARTING_FIRMWARE      : return (char *)"Si2168B Error while starting firmware";
+	case ERROR_Si2168B_SW_RESET               : return (char *)"Si2168B Error during software reset";
+	case ERROR_Si2168B_INCOMPATIBLE_PART      : return (char *)"Si2168B Error Incompatible part";
+	case ERROR_Si2168B_UNKNOWN_COMMAND        : return (char *)"Si2168B Error unknown command";
+	case ERROR_Si2168B_UNKNOWN_PROPERTY       : return (char *)"Si2168B Error unknown property";
+	default:
+		return (char *)"Unknown Si2168B error code";
+	}
+}
+
+/************************************************************************************************************************
+  NAME: si2168b_trace_scan_status
+  DESCRIPTION: traces the scan_status
+  Parameter:  Pointer to Si2168B Context
+  Returns:    void
+************************************************************************************************************************/
+static const char *si2168b_trace_scan_status(int scan_status)
+{
+	switch (scan_status) {
+	case  Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_ANALOG_CHANNEL_FOUND  : { return "ANALOG  CHANNEL_FOUND"; break; }
+	case  Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_DIGITAL_CHANNEL_FOUND : { return "DIGITAL CHANNEL_FOUND"; break; }
+	case  Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_DEBUG                 : { return "DEBUG"                ; break; }
+	case  Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_ERROR                 : { return "ERROR"                ; break; }
+	case  Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_ENDED                 : { return "ENDED"                ; break; }
+	case  Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_IDLE                  : { return "IDLE"                 ; break; }
+	case  Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_SEARCHING             : { return "SEARCHING"            ; break; }
+	case  Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_TUNE_REQUEST          : { return "TUNE_REQUEST"         ; break; }
+	default                                                              : { return "Unknown!"             ; break; }
+	}
+}
+
+/***********************************************************************************************************************
+  si2168b_tag_text function
+  Use:        Error information function
+              Used to retrieve a text containing the TAG information (related to the code version)
+  Returns:    the TAG text
+  Porting:    May not be required for the final application, can be removed if not used.
+ ***********************************************************************************************************************/
+char* si2168b_tag_text(void)
+{
+	return (char *)"V0.2.6";
+}
+
+#else /* SiTRACES */
+#define SiTRACE(...)               /* empty */
+#define SiTracesSuspend()          /* empty */
+#define SiTracesResume()           /* empty */
+#endif /* SiTRACES */
+
+static const struct dvb_frontend_ops si2168b_ops;
+
+static int enable_tuner_i2c(void *p)
+{
+	/* nothing to do */
+	return NO_Si2168B_ERROR;
+}
+
+static int disable_tuner_i2c(void *p)
+{
+	/* nothing to do */
+	return NO_Si2168B_ERROR;
+}
+
+static int i2c_callback(void *p)
+{
+	/* nothing to do */
+	return NO_Si2168B_ERROR;
+}
+
+/************************************************************************************************************************
+  L0_ReadBytes function
+  Use:        lowest layer read function
+              Used to read a given number of bytes from the Layer 1 instance.
+  Parameters: i2c, a pointer to the Layer 0 context.
+              iI2CIndex, the index of the first byte to read.
+              iNbBytes, the number of bytes to read.
+              *pbtDataBuffer, a pointer to a buffer used to store the bytes.
+  Returns:    the number of bytes read.
+  Porting:    If a single connection mode is allowed, the entire switch can be replaced by a call to the final i2c read function
+************************************************************************************************************************/
+static u16 i2c_read_bytes(struct i2c_adapter *i2c_adap, u8 i2c_addr, u16 iNbBytes, u8 *pucDataBuffer)
+{
+	struct i2c_msg msg = {
+			.addr  = i2c_addr,
+			.flags = I2C_M_RD,
+			.buf   = pucDataBuffer,
+			.len   = iNbBytes,
+	};
+
+	if (i2c_adap == NULL) {
+		SiTRACE("%s(): FATAL ERROR: i2c_adap is undefined!\n", __func__);
+		return 0;
+	}
+
+	if (i2c_transfer(i2c_adap, &msg, 1) != 1) {
+		SiTRACE("%s(): i2c transfer failed\n", __func__);
+		return 0;
+	}
+
+	return iNbBytes;
+}
+
+/************************************************************************************************************************
+  i2c_write_bytes function
+  Use:        lowest layer write function
+              Used to write a given number of bytes from the Layer 1 instance.
+  Parameters: i2c, a pointer to the Layer 0 context.
+              iNbBytes, the number of bytes to write.
+              *pbtDataBuffer, a pointer to a buffer containing the bytes to write.
+  Returns:    the number of bytes read.
+  Porting:    If a single connection mode is allowed, the entire switch can be replaced by a call to the final i2c write function
+************************************************************************************************************************/
+static int i2c_write_bytes(struct i2c_adapter *i2c_adap, u8 i2c_addr, u16 iNbBytes, u8 *pucDataBuffer)
+{
+	struct i2c_msg msg = {
+			.addr  = i2c_addr,
+			.flags = 0,
+			.buf   = pucDataBuffer,
+			.len   = iNbBytes,
+	};
+
+	if (i2c_adap == NULL) {
+		SiTRACE("%s(): FATAL ERROR: i2c_adap is undefined!\n", __func__);
+		return 0;
+	}
+
+	if (iNbBytes > 64) {
+		SiTRACE("%s(): numbers of bytes (%u) exceeds limit of 64\n", __func__, iNbBytes);
+		return 0;
+	}
+
+	if (i2c_transfer(i2c_adap, &msg, 1) != 1) {
+		SiTRACE("%s(): i2c transfer failed\n", __func__);
+		return 0;
+	}
+
+	return iNbBytes;
+}
+
+/***********************************************************************************************************************
+  si2168b_current_response_status function
+  Use:        status checking function
+              Used to fill the Si2168B_COMMON_REPLY_struct members with the ptDataBuffer byte's bits
+  Comments:   The status byte definition being identical for all commands,
+              using this function to fill the status structure helps reducing the code size
+  Parameter: ptDataBuffer  a single byte received when reading a command's response (the first byte)
+  Returns:   0 if the err bit (bit 6) is unset, 1 otherwise
+ ***********************************************************************************************************************/
+static u8 si2168b_current_response_status(si2168b_context *ctx, u8 databuffer)
+{
+	ctx->status_ddint   = ((databuffer >> 0 ) & 0x01);
+	ctx->status_scanint = ((databuffer >> 1 ) & 0x01);
+	ctx->status_err     = ((databuffer >> 6 ) & 0x01);
+	ctx->status_cts     = ((databuffer >> 7 ) & 0x01);
+
+	return (ctx->status_err ? ERROR_Si2168B_ERR : NO_Si2168B_ERROR);
+}
+
+/***********************************************************************************************************************
+  si2168b_poll_for_response function
+  Use:        command response retrieval function
+              Used to retrieve the command response in the provided buffer
+  Comments:   The status byte definition being identical for all commands,
+              using this function to fill the status structure helps reducing the code size
+              max timeout = 1000 ms
+
+  Parameter:  nbBytes          the number of response bytes to read
+  Parameter:  pByteBuffer      a buffer into which bytes will be stored
+  Returns:    0 if no error, an error code otherwise
+ ***********************************************************************************************************************/
+static u8 si2168b_poll_for_response(si2168b_context *ctx, u16 count, u8 *buffer)
+{
+	u8 dbg[7];
+	u32 start_time = system_time();
+
+	do {
+		if (i2c_read_bytes(ctx->i2c_adap, ctx->i2c_addr, count, buffer) != count) {
+			SiTRACE("%s(): ERROR reading byte 0!\n", __func__);
+			return ERROR_Si2168B_POLLING_RESPONSE;
+		}
+		/* return response err flag if CTS set */
+		if (buffer[0] & 0x80)  {
+			/* for debug purpose, read and trace 2 bytes in case the error bit is set */
+			if (buffer[0] & 0x40)  {
+				i2c_read_bytes(ctx->i2c_adap, ctx->i2c_addr, 7, &(dbg[0]) );
+				SiTRACE("Si2168B debug bytes 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n", dbg[0], dbg[1], dbg[2], dbg[3], dbg[4], dbg[5], dbg[6]);
+			}
+			return si2168b_current_response_status(ctx, buffer[0]);
+		}
+		msleep(10); /* FGR - pause a bit rather than just spinning on I2C */
+	} while (system_time() - start_time < 1000); /* wait a maximum of 1000ms */
+
+	SiTRACE("%s(): ERROR CTS Timeout!\n", __func__);
+	return ERROR_Si2168B_CTS_TIMEOUT;
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_I2C_PASSTHROUGH COMMAND                  */
+/*---------------------------------------------------*/
+static u8 si2168b_i2c_passthrough(si2168b_context *ctx,
+		u8 subcode,
+		u8 i2c_passthru,
+		u8 reserved)
+{
+	u8 cmdByteBuffer[3];
+	u8 ret = NO_Si2168B_ERROR;
+
+	/*ctx->rsp->i2c_passthrough.STATUS = ctx->status;*/
+
+	SiTRACE("%s()\n", __func__);
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_I2C_PASSTHROUGH_CMD;
+	cmdByteBuffer[1] = (u8) ( ( subcode      & Si2168B_I2C_PASSTHROUGH_CMD_SUBCODE_MASK      ) << Si2168B_I2C_PASSTHROUGH_CMD_SUBCODE_LSB     );
+	cmdByteBuffer[2] = (u8) ( ( i2c_passthru & Si2168B_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_MASK ) << Si2168B_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_LSB|
+			( reserved     & Si2168B_I2C_PASSTHROUGH_CMD_RESERVED_MASK     ) << Si2168B_I2C_PASSTHROUGH_CMD_RESERVED_LSB    );
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 3, cmdByteBuffer) != 3) {
+		SiTRACE("Error writing I2C_PASSTHROUGH bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+	}
+
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+/************************************************************************************************************************
+  si2168b_tuner_i2c_enable function
+  Use:        Tuner i2c bus connection
+              Used to allow communication with the tuners
+  Parameter:  *front_end, the front-end handle
+************************************************************************************************************************/
+static u8 si2168b_tuner_i2c_enable(Si2168B_L2_Context *front_end)
+{
+    return si2168b_i2c_passthrough(front_end->demod, Si2168B_I2C_PASSTHROUGH_CMD_SUBCODE_CODE,
+    		Si2168B_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_CLOSE, Si2168B_I2C_PASSTHROUGH_CMD_RESERVED_RESERVED);
+}
+
+/************************************************************************************************************************
+  si2168b_tuner_i2c_disable function
+  Use:        Tuner i2c bus connection
+              Used to disconnect i2c communication with the tuners
+  Parameter:  *front_end, the front-end handle
+************************************************************************************************************************/
+static u8 si2168b_tuner_i2c_disable(Si2168B_L2_Context *front_end)
+{
+    return si2168b_i2c_passthrough(front_end->demod, Si2168B_I2C_PASSTHROUGH_CMD_SUBCODE_CODE,
+    		Si2168B_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_OPEN, Si2168B_I2C_PASSTHROUGH_CMD_RESERVED_RESERVED);
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_SET_PROPERTY COMMAND                     */
+/*---------------------------------------------------*/
+static u8 si2168_set_property_cmd(si2168b_context *ctx, u16 prop, u16 data, Si2168B_SET_PROPERTY_CMD_REPLY_struct *set_property)
+{
+	const u8 reserved = 0;
+	u8 error_code = 0;
+	u8 cmdByteBuffer[6];
+	u8 rspByteBuffer[4];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B SET_PROPERTY\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_SET_PROPERTY_CMD;
+	cmdByteBuffer[1] = (u8) ( ( reserved & Si2168B_SET_PROPERTY_CMD_RESERVED_MASK ) << Si2168B_SET_PROPERTY_CMD_RESERVED_LSB);
+	cmdByteBuffer[2] = (u8) ( ( prop     & Si2168B_SET_PROPERTY_CMD_PROP_MASK     ) << Si2168B_SET_PROPERTY_CMD_PROP_LSB    );
+	cmdByteBuffer[3] = (u8) ((( prop     & Si2168B_SET_PROPERTY_CMD_PROP_MASK     ) << Si2168B_SET_PROPERTY_CMD_PROP_LSB    )>>8);
+	cmdByteBuffer[4] = (u8) ( ( data     & Si2168B_SET_PROPERTY_CMD_DATA_MASK     ) << Si2168B_SET_PROPERTY_CMD_DATA_LSB    );
+	cmdByteBuffer[5] = (u8) ((( data     & Si2168B_SET_PROPERTY_CMD_DATA_MASK     ) << Si2168B_SET_PROPERTY_CMD_DATA_LSB    )>>8);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 6, cmdByteBuffer) != 6) {
+		SiTRACE("Error writing SET_PROPERTY bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 4, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling SET_PROPERTY response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	set_property->reserved =   (( ( (rspByteBuffer[1]  )) >> Si2168B_SET_PROPERTY_RESPONSE_RESERVED_LSB ) & Si2168B_SET_PROPERTY_RESPONSE_RESERVED_MASK );
+	set_property->data     =   (( ( (rspByteBuffer[2]  ) | (rspByteBuffer[3]  << 8 )) >> Si2168B_SET_PROPERTY_RESPONSE_DATA_LSB     ) & Si2168B_SET_PROPERTY_RESPONSE_DATA_MASK     );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+/***********************************************************************************************************************
+  si2168b_set_property function
+  Use:        property set function
+              Used to call L1_SET_PROPERTY with the property Id and data provided.
+  Parameter: *api     the Si2168B context
+  Parameter: prop     the property Id
+  Parameter: data     the property bytes
+  Behavior:  This function will only download the property if required.
+               Conditions to download the property are:
+                - The property changes
+                - The propertyWriteMode is set to Si2168B_DOWNLOAD_ALWAYS
+                - The property is unknown to Si2168B_PackProperty (this may be useful for debug purpose)
+  Returns:    0 if no error, an error code otherwise
+ ***********************************************************************************************************************/
+static u8 si2168b_set_property(si2168b_context *ctx, u16 prop_code, u16 data)
+{
+	u8  res;
+	Si2168B_SET_PROPERTY_CMD_REPLY_struct set_property;
+
+	res = si2168_set_property_cmd(ctx, prop_code, data, &set_property);
+	SiTRACE("si2168b_set_property: Setting Property 0x%04x to 0x%04x(%d)\n", prop_code, data, data);
+	if (res != NO_Si2168B_ERROR) {
+		SiTRACE("ERROR: si2168b_set_property: %s 0x%04x!\n\n", si2168b_error_text(res), prop_code);
+	}
+	return res;
+}
+
+/************************************************************************************************************************
+ si2168b_set_ts_mode function
+ Use:      Transport Stream control function
+ Used to switch the TS output in the desired mode
+ Parameter: mode the mode to switch to,
+ clock mode
+ ************************************************************************************************************************/
+static u8 si2168b_set_ts_mode(struct Si2168B_Priv *priv, u8 ts_bus_mode)
+{
+	si2168b_context *demod = priv->si_front_end->demod;
+
+	const u8 ts_clk_invert              = priv->config->ts_par_clk_invert;
+	const u8 ts_clk_shift               = priv->config->ts_par_clk_shift;
+	const u8 ts_mode_clk_gapped_en      = priv->config->clk_gapped_en; /* (default 'DISABLED') */
+	const u8 ts_mode_clock              = priv->config->ts_clock_mode; /* (default 'AUTO_FIXED') */
+	const u8 ts_data_strength           = 3; /* (default     3) */
+	const u8 ts_clk_strength            = 3; /* (default     3) */
+	const u8 ts_parallel_data_shape     = 2;
+	const u8 ts_parallel_clk_shape      = 2;
+	const u8 ts_gpif_data_shape         = 7;
+	const u8 ts_gpif_clk_shape          = 7;
+	const u8 ts_mode_special            = Si2168B_DD_TS_MODE_PROP_SPECIAL_FULL_TS;              /* (default 'FULL_TS') */
+	const u8 ts_mode_ts_err_polarity    = Si2168B_DD_TS_MODE_PROP_TS_ERR_POLARITY_NOT_INVERTED; /* (default 'NOT_INVERTED') */
+	const u8 ts_mode_ts_freq_resolution = Si2168B_DD_TS_MODE_PROP_TS_FREQ_RESOLUTION_NORMAL;    /* (default 'NORMAL') */
+
+	u8  ts_mode_mode = Si2168B_DD_TS_MODE_PROP_MODE_TRISTATE; /* (default 'TRISTATE') */
+	u8  ret = NO_Si2168B_ERROR;
+	u16 data;
+
+	siprintk("%s() ts_bus_mode=%u\n", __func__, ts_bus_mode);
+
+	switch (ts_bus_mode) {
+	case SILABS_TS_SERIAL:
+		ts_mode_mode = Si2168B_DD_TS_MODE_PROP_MODE_SERIAL;
+		break;
+	case SILABS_TS_PARALLEL:
+	    data = (ts_data_strength       & Si2168B_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_MASK) << Si2168B_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_LSB  |
+	           (ts_parallel_data_shape & Si2168B_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_MASK   ) << Si2168B_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_LSB  |
+	           (ts_clk_strength        & Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_MASK ) << Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_LSB  |
+	           (ts_parallel_clk_shape  & Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_MASK    ) << Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_LSB  |
+	           (ts_clk_invert          & Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_MASK   ) << Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_LSB  |
+	           (ts_clk_shift           & Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_MASK    ) << Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_LSB;
+        ret = si2168b_set_property(demod, Si2168B_DD_TS_SETUP_PAR_PROP, data);
+		ts_mode_mode = Si2168B_DD_TS_MODE_PROP_MODE_PARALLEL;
+		break;
+	case SILABS_TS_TRISTATE:
+		ts_mode_mode = Si2168B_DD_TS_MODE_PROP_MODE_TRISTATE;
+		break;
+	case SILABS_TS_OFF:
+		ts_mode_mode = Si2168B_DD_TS_MODE_PROP_MODE_OFF;
+		break;
+	case SILABS_TS_GPIF:
+	    data = (ts_data_strength   & Si2168B_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_MASK) << Si2168B_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_LSB  |
+	           (ts_gpif_data_shape & Si2168B_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_MASK   ) << Si2168B_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_LSB  |
+	           (ts_clk_strength    & Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_MASK ) << Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_LSB  |
+	           (ts_gpif_clk_shape  & Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_MASK    ) << Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_LSB  |
+	           (ts_clk_invert      & Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_MASK   ) << Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_LSB  |
+	           (ts_clk_shift       & Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_MASK    ) << Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_LSB;
+		ret = si2168b_set_property(demod, Si2168B_DD_TS_SETUP_PAR_PROP, data);
+		ts_mode_mode = Si2168B_DD_TS_MODE_PROP_MODE_GPIF;
+		break;
+	default:
+		/* return si2168b_set_ts_mode(priv, SILABS_TS_TRISTATE); */
+		ts_mode_mode = Si2168B_DD_TS_MODE_PROP_MODE_TRISTATE;
+		break;
+	}
+
+	if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): si2168b_set_property(Si2168B_DD_TS_SETUP_PAR_PROP) failed\n", __func__);
+	}
+
+    data = (ts_mode_mode               & Si2168B_DD_TS_MODE_PROP_MODE_MASK              ) << Si2168B_DD_TS_MODE_PROP_MODE_LSB  |
+           (ts_mode_clock              & Si2168B_DD_TS_MODE_PROP_CLOCK_MASK             ) << Si2168B_DD_TS_MODE_PROP_CLOCK_LSB  |
+           (ts_mode_clk_gapped_en      & Si2168B_DD_TS_MODE_PROP_CLK_GAPPED_EN_MASK     ) << Si2168B_DD_TS_MODE_PROP_CLK_GAPPED_EN_LSB  |
+           (ts_mode_ts_err_polarity    & Si2168B_DD_TS_MODE_PROP_TS_ERR_POLARITY_MASK   ) << Si2168B_DD_TS_MODE_PROP_TS_ERR_POLARITY_LSB  |
+           (ts_mode_special            & Si2168B_DD_TS_MODE_PROP_SPECIAL_MASK           ) << Si2168B_DD_TS_MODE_PROP_SPECIAL_LSB  |
+           (ts_mode_ts_freq_resolution & Si2168B_DD_TS_MODE_PROP_TS_FREQ_RESOLUTION_MASK) << Si2168B_DD_TS_MODE_PROP_TS_FREQ_RESOLUTION_LSB;
+    ret = si2168b_set_property(demod, Si2168B_DD_TS_MODE_PROP, data);
+
+	if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): si2168b_set_property(Si2168B_DD_TS_MODE_PROP) failed\n", __func__);
+	}
+	siprintk("%s() DONE (ret=%d)\n", __func__, ret);
+	return ret;
+}
+
+static int si2168b_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+
+	siprintk("%s() enable=%d\n", __func__, enable);
+
+	if (enable) {
+		if ( priv->config->indirect_i2c_connection ) { /* INDIRECT_I2C_CONNECTION? */
+			if (priv->si_front_end->f_TER_tuner_enable(priv->si_front_end->callback) != NO_Si2168B_ERROR) {
+				siprintk("%s(): f_TER_tuner_enable() failed\n", __func__);
+				return -EIO;
+			}
+		} else {
+			if (si2168b_tuner_i2c_enable(priv->si_front_end) != NO_Si2168B_ERROR) {
+				siprintk("%s(): si2168b_tuner_i2c_enable() failed\n", __func__);
+				return -EIO;
+			}
+		}
+	} else {
+		if ( priv->config->indirect_i2c_connection ) { /* INDIRECT_I2C_CONNECTION? */
+			if (priv->si_front_end->f_TER_tuner_disable(priv->si_front_end->callback) != NO_Si2168B_ERROR) {
+				siprintk("%s(): f_TER_tuner_disable() failed\n", __func__);
+				return -EIO;
+			}
+		} else {
+			if (si2168b_tuner_i2c_disable(priv->si_front_end) != NO_Si2168B_ERROR) {
+				siprintk("%s(): si2168b_tuner_i2c_disable() failed\n", __func__);
+				return -EIO;
+			}
+		}
+	}
+	siprintk("%s() I2C gate on Si2168B %sabled\n", __func__, enable ? "en" : "dis");
+	return 0;
+}
+
+/************************************************************************************************************************
+  si2168b_infos function
+  Use:        software information function
+              Used to retrieve information about the compilation
+  Parameter:  front_end, a pointer to the Si2168B_L2_Context context to be initialized
+  Parameter:  infoString, a text buffer to be filled with teh information. It must be initialized by the caller.
+  Return:     the length of the information string
+************************************************************************************************************************/
+static int si2168b_infos(Si2168B_L2_Context *front_end, char *infoString_UNUSED)
+{
+	if (infoString_UNUSED == NULL)
+		return 0;
+
+	if (front_end == NULL) {
+		SiTRACE("Si2168B front-end not initialized yet. Call si2168b_sw_init first!\n");
+		return strlen(infoString_UNUSED);
+	}
+
+	SiTRACE("\n");
+	SiTRACE("--------------------------------------\n");
+	SiTRACE("Demod                Si2168B  at 0x%02x\n", front_end->demod->i2c_addr);
+	SiTRACE("Demod                Source code %s\n", si2168b_tag_text() );
+	SiTRACE("Terrestrial tuner    SiLabs\n");
+
+	if ( front_end->demod->tuner_ter_clock_source == Si2168B_TER_Tuner_clock)
+		SiTRACE("TER clock from  TER Tuner (%d MHz)\n", front_end->demod->tuner_ter_clock_freq);
+	if ( front_end->demod->tuner_ter_clock_source == Si2168B_SAT_Tuner_clock)
+		SiTRACE("TER clock from  SAT Tuner (%d MHz)\n", front_end->demod->tuner_ter_clock_freq);
+	if ( front_end->demod->tuner_ter_clock_source == Si2168B_Xtal_clock)
+		SiTRACE("TER clock from  Xtal      (%d MHz)\n", front_end->demod->tuner_ter_clock_freq);
+	if ( front_end->demod->tuner_ter_clock_input == Si2168B_START_CLK_CMD_CLK_MODE_CLK_CLKIO)
+		SiTRACE("TER clock input CLKIO\n");
+	if ( front_end->demod->tuner_ter_clock_input == Si2168B_START_CLK_CMD_CLK_MODE_CLK_XTAL_IN)
+		SiTRACE("TER clock input XTAL_IN\n");
+	if ( front_end->demod->tuner_ter_clock_input == Si2168B_START_CLK_CMD_CLK_MODE_XTAL)
+		SiTRACE("TER clock input XTAL\n");
+
+	if (front_end->demod->fef_mode == Si2168B_FEF_MODE_SLOW_NORMAL_AGC)
+		SiTRACE("FEF mode 'SLOW NORMAL AGC'\n");
+	if (front_end->demod->fef_mode == Si2168B_FEF_MODE_SLOW_INITIAL_AGC)
+		SiTRACE("FEF mode 'SLOW INITIAL AGC'\n");
+	if (front_end->demod->fef_mode == Si2168B_FEF_MODE_FREEZE_PIN)
+		SiTRACE("FEF mode 'FREEZE PIN'\n");
+	if (front_end->demod->fef_mode != front_end->demod->fef_selection)
+		SiTRACE("(CHANGED!)\n");
+
+	SiTRACE("--------------------------------------\n");
+	return strlen(infoString_UNUSED);
+}
+
+/***********************************************************************************************************************
+  Si2168B_L1_API_Init function
+  Use:        software initialisation function
+              Used to initialize the software context
+  Returns:    0 if no error
+  Comments:   It should be called first and once only when starting the application
+  Parameter:   **ppapi         a pointer to the api context to initialize
+  Parameter:  add            the Si2168B I2C address
+  Porting:    Allocation errors need to be properly managed.
+  Porting:    I2C initialization needs to be adapted to use the available I2C functions
+ ***********************************************************************************************************************/
+static u8 si2168b_ctx_init(si2168b_context *ctx, u8 addr, struct i2c_adapter *i2c_adap, const struct si2168b_config *config)
+{
+	mutex_init(&ctx->lock);
+	mutex_init(&ctx->ts_bus_ctrl_lock);
+	ctx->i2c_addr = addr;
+	ctx->i2c_adap = i2c_adap;
+	ctx->address  = addr;
+
+#ifdef SiTRACES
+	if (!trace_init_done) {
+		CUSTOM_PRINTF("********** SiTRACES activated *********\n");
+		CUSTOM_PRINTF("Comment the '#define SiTRACES' line\n");
+		CUSTOM_PRINTF("in Silabs_L0_API.h to de-activate all traces.\n");
+		CUSTOM_PRINTF("***************************************\n");
+		sitrace_default_configuration();
+	}
+#endif /* SiTRACES */
+
+	/* Clock settings as per compilation flags                     */
+	/*  For multi-frontend HW, these may be adapted later on,      */
+	/*   using Si2168B_L1_API_TER_Clock and Si2168B_L1_API_SAT_Clock */
+	/* ctx->dvbt2_fef_tuner_flag  = Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_NOT_USED; */
+	ctx->tuner_ter_clock_source  = Si2168B_TER_Tuner_clock;
+	ctx->tuner_ter_clock_control = Si2168B_CLOCK_MANAGED;
+	ctx->tuner_ter_clock_input   = Si2168B_CLOCK_MODE_TER;
+	ctx->tuner_ter_clock_freq    = Si2168B_REF_FREQUENCY_TER;
+
+	ctx->Si2168B_in_standby      = 0;
+
+	ctx->dd_mode_modulation      = Si2168B_DD_MODE_PROP_MODULATION_DEFAULT;
+	ctx->dd_mode_auto_detect     = Si2168B_DD_MODE_PROP_AUTO_DETECT_DEFAULT;
+	ctx->dd_mode_invert_spectrum = Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_DEFAULT;
+	ctx->dd_mode_bw              = Si2168B_DD_MODE_PROP_BW_DEFAULT;
+
+	ctx->dvbt_hierarchy_stream   = Si2168B_DVBT_HIERARCHY_PROP_STREAM_DEFAULT;
+	ctx->dvbc_symbol_rate        = Si2168B_DVBC_SYMBOL_RATE_PROP_RATE_DEFAULT;
+
+	ctx->scan_fmin               = Si2168B_SCAN_FMIN_PROP_SCAN_FMIN_DEFAULT;
+	ctx->scan_fmax               = Si2168B_SCAN_FMAX_PROP_SCAN_FMAX_DEFAULT;
+	ctx->scan_symb_rate_min      = Si2168B_SCAN_SYMB_RATE_MIN_PROP_SCAN_SYMB_RATE_MIN_DEFAULT;
+	ctx->scan_symb_rate_max      = Si2168B_SCAN_SYMB_RATE_MAX_PROP_SCAN_SYMB_RATE_MAX_DEFAULT;
+
+	ctx->fef_mode                = config->fef_mode;
+	ctx->fef_selection           = config->fef_mode;
+	ctx->fef_pin                 = config->fef_pin;
+	ctx->fef_level               = config->fef_level;
+
+#ifdef L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP
+	/* If the TER tuner has initial AGC speed control and it's the selected mode, activate it */
+	if (ctx->fef_selection == Si2168B_FEF_MODE_SLOW_INITIAL_AGC) {
+		SiTRACE("TER tuner FEF set to 'SLOW_INITIAL_AGC' mode\n");
+		ctx->fef_mode = Si2168B_FEF_MODE_SLOW_INITIAL_AGC;
+	}
+#ifdef L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN_SETUP
+	/* If the TER tuner has an AGC freeze pin and it's the selected mode, activate it */
+	if (ctx->fef_selection == Si2168B_FEF_MODE_FREEZE_PIN) {
+		SiTRACE("TER tuner FEF set to 'FREEZE_PIN' mode\n");
+		ctx->fef_mode = Si2168B_FEF_MODE_FREEZE_PIN;
+	}
+#else /* L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN_SETUP */
+	if (ctx->fef_selection == Si2168B_FEF_MODE_FREEZE_PIN) {
+		SiTRACE("TER tuner FEF can not use 'FREEZE_PIN' mode, using 'SLOW_INITIAL_AGC' mode instead\n");
+		ctx->fef_mode = Si2168B_FEF_MODE_SLOW_INITIAL_AGC;
+	}
+#endif /* L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN_SETUP */
+#else  /* L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP */
+	SiTRACE("TER tuner FEF set to 'SLOW_NORMAL_AGC' mode\n");
+#endif /* L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP */
+
+	return NO_Si2168B_ERROR;
+}
+
+/************************************************************************************************************************
+  si2168b_sw_init function
+  Use:        software initialization function
+              Used to initialize the Si2168B and tuner structures
+  Behavior:   This function performs all the steps necessary to initialize the Si2168B and tuner instances
+  Parameter:  front_end, a pointer to the Si2168B_L2_Context context to be initialized
+  Parameter:  demodAdd, the I2C address of the demod
+  Parameter:  tunerAdd, the I2C address of the tuner
+  Comments:     It MUST be called first and once before using any other function.
+                It can be used to build a multi-demod/multi-tuner application, if called several times from the upper layer with different pointers and addresses
+                After execution, all demod and tuner functions are accessible.
+************************************************************************************************************************/
+static char si2168b_sw_init(struct Si2168B_Priv *priv
+		, int tunerAdd_Ter
+		, Si2168B_INDIRECT_I2C_FUNC TER_tuner_enable_func
+		, Si2168B_INDIRECT_I2C_FUNC TER_tuner_disable_func
+		, void *p_context)
+{
+	Si2168B_L2_Context *front_end = priv->si_front_end;
+	char infoStringBuffer[1000] = { 0 };
+	char *infoString;
+	infoString = &(infoStringBuffer[0]);
+
+	/* Pointers initialization */
+	front_end->Si2168B_init_done   = 0;
+	front_end->first_init_done     = 0;
+	front_end->handshakeUsed       = 0; /* set to '0' by default for compatibility with previous versions */
+	front_end->handshakeOn         = 0;
+	front_end->handshakePeriod_ms  = 1000;
+	front_end->TER_init_done       = 0;
+	front_end->auto_detect_TER     = 1;
+	front_end->f_TER_tuner_enable  = TER_tuner_enable_func;
+	front_end->f_TER_tuner_disable = TER_tuner_disable_func;
+	front_end->tuner_indirect_i2c_connection = priv->config->indirect_i2c_connection;
+
+	/* Calling underlying SW initialization functions */
+	si2168b_ctx_init(front_end->demod, priv->config->demod_address, priv->i2c, priv->config);
+	SiTRACE("Si2168B_L2_EVB_SW_Init starting...\n");
+
+	/* SiLabs_TER_Tuner_L1_API_Init(front_end->tuner_ter, tunerAdd_Ter, i2c_adap); */
+	/* done in tuner module startup */
+
+	front_end->callback = p_context;
+#ifdef SiTRACE
+	if (si2168b_infos(front_end, infoString))  {
+		SiTRACE("%s\n", infoString);
+	}
+#endif /* SiTRACE */
+	SiTRACE("Si2168B_L2_EVB_SW_Init complete\n");
+	return 1;
+}
+
+/************************************************************************************************************************
+  si2168b_media function
+  Use:        media retrieval function
+              Used to retrieve the media used by the Si2168B
+************************************************************************************************************************/
+static u8 si2168b_media(si2168b_context *ctx)
+{
+	switch (ctx->dd_mode_modulation) {
+	default:
+	case Si2168B_DD_MODE_PROP_MODULATION_AUTO_DETECT:
+		switch (ctx->dd_mode_auto_detect) {
+		default:
+			break;
+		case Si2168B_DD_MODE_PROP_AUTO_DETECT_AUTO_DVB_T_T2:
+			return Si2168B_TERRESTRIAL;
+		}
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBT:
+			return Si2168B_TERRESTRIAL;
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBT2:
+		return Si2168B_TERRESTRIAL;
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBC:
+#ifdef __MCNS__
+	case Si2168B_DD_MODE_PROP_MODULATION_MCNS:
+#endif /* __MCNS__ */
+		return Si2168B_TERRESTRIAL;
+	}
+	return 0;
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_START_CLK COMMAND                        */
+/*---------------------------------------------------*/
+static u8 si2168b_start_clk(si2168b_context *ctx,
+		u8  subcode,
+		u8  reserved1,
+		u8  tune_cap,
+		u8  reserved2,
+		u16 clk_mode,
+		u8  reserved3,
+		u8  reserved4,
+		u8  start_clk)
+{
+	u8 cmdByteBuffer[13];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B START_CLK\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_START_CLK_CMD;
+	cmdByteBuffer[1] = (u8) ( ( subcode   & Si2168B_START_CLK_CMD_SUBCODE_MASK   ) << Si2168B_START_CLK_CMD_SUBCODE_LSB  );
+	cmdByteBuffer[2] = (u8) ( ( reserved1 & Si2168B_START_CLK_CMD_RESERVED1_MASK ) << Si2168B_START_CLK_CMD_RESERVED1_LSB);
+	cmdByteBuffer[3] = (u8) ( ( tune_cap  & Si2168B_START_CLK_CMD_TUNE_CAP_MASK  ) << Si2168B_START_CLK_CMD_TUNE_CAP_LSB |
+			( reserved2 & Si2168B_START_CLK_CMD_RESERVED2_MASK ) << Si2168B_START_CLK_CMD_RESERVED2_LSB);
+	cmdByteBuffer[4] = (u8) ( ( clk_mode  & Si2168B_START_CLK_CMD_CLK_MODE_MASK  ) << Si2168B_START_CLK_CMD_CLK_MODE_LSB );
+	cmdByteBuffer[5] = (u8) ((( clk_mode  & Si2168B_START_CLK_CMD_CLK_MODE_MASK  ) << Si2168B_START_CLK_CMD_CLK_MODE_LSB )>>8);
+	cmdByteBuffer[6] = (u8) ( ( reserved3 & Si2168B_START_CLK_CMD_RESERVED3_MASK ) << Si2168B_START_CLK_CMD_RESERVED3_LSB);
+	cmdByteBuffer[7] = (u8) ( ( reserved4 & Si2168B_START_CLK_CMD_RESERVED4_MASK ) << Si2168B_START_CLK_CMD_RESERVED4_LSB);
+	cmdByteBuffer[8] = (u8)0x00;
+	cmdByteBuffer[9] = (u8)0x00;
+	cmdByteBuffer[10] = (u8)0x00;
+	cmdByteBuffer[11] = (u8)0x00;
+	cmdByteBuffer[12] = (u8) ( ( start_clk & Si2168B_START_CLK_CMD_START_CLK_MASK ) << Si2168B_START_CLK_CMD_START_CLK_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 13, cmdByteBuffer) != 13) {
+		SiTRACE("Error writing START_CLK bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+	}
+
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_POWER_UP COMMAND                         */
+/*---------------------------------------------------*/
+static u8 si2168b_power_up(si2168b_context *ctx,
+		u8   subcode,
+		u8   reset,
+		u8   reserved2,
+		u8   reserved4,
+		u8   reserved1,
+		u8   addr_mode,
+		u8   reserved5,
+		u8   func,
+		u8   clock_freq,
+		u8   ctsien,
+		u8   wake_up)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[8];
+	u8 rspByteBuffer[1];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B POWER_UP\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_POWER_UP_CMD;
+	cmdByteBuffer[1] = (u8) ( ( subcode    & Si2168B_POWER_UP_CMD_SUBCODE_MASK    ) << Si2168B_POWER_UP_CMD_SUBCODE_LSB   );
+	cmdByteBuffer[2] = (u8) ( ( reset      & Si2168B_POWER_UP_CMD_RESET_MASK      ) << Si2168B_POWER_UP_CMD_RESET_LSB     );
+	cmdByteBuffer[3] = (u8) ( ( reserved2  & Si2168B_POWER_UP_CMD_RESERVED2_MASK  ) << Si2168B_POWER_UP_CMD_RESERVED2_LSB );
+	cmdByteBuffer[4] = (u8) ( ( reserved4  & Si2168B_POWER_UP_CMD_RESERVED4_MASK  ) << Si2168B_POWER_UP_CMD_RESERVED4_LSB );
+	cmdByteBuffer[5] = (u8) ( ( reserved1  & Si2168B_POWER_UP_CMD_RESERVED1_MASK  ) << Si2168B_POWER_UP_CMD_RESERVED1_LSB |
+			( addr_mode  & Si2168B_POWER_UP_CMD_ADDR_MODE_MASK  ) << Si2168B_POWER_UP_CMD_ADDR_MODE_LSB |
+			( reserved5  & Si2168B_POWER_UP_CMD_RESERVED5_MASK  ) << Si2168B_POWER_UP_CMD_RESERVED5_LSB );
+	cmdByteBuffer[6] = (u8) ( ( func       & Si2168B_POWER_UP_CMD_FUNC_MASK       ) << Si2168B_POWER_UP_CMD_FUNC_LSB      |
+			( clock_freq & Si2168B_POWER_UP_CMD_CLOCK_FREQ_MASK ) << Si2168B_POWER_UP_CMD_CLOCK_FREQ_LSB|
+			( ctsien     & Si2168B_POWER_UP_CMD_CTSIEN_MASK     ) << Si2168B_POWER_UP_CMD_CTSIEN_LSB    );
+	cmdByteBuffer[7] = (u8) ( ( wake_up    & Si2168B_POWER_UP_CMD_WAKE_UP_MASK    ) << Si2168B_POWER_UP_CMD_WAKE_UP_LSB   );
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 8, cmdByteBuffer) != 8) {
+		SiTRACE("Error writing POWER_UP bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 1, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling POWER_UP response\n");
+		ret = error_code;
+	}
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+/************************************************************************************************************************
+  NAME: si2168b_wakeup
+  DESCRIPTION:
+  Parameter:  Pointer to Si2168B Context
+  Returns:    I2C transaction error code, NO_Si2168B_ERROR if successful
+************************************************************************************************************************/
+static int si2168b_wakeup(si2168b_context *ctx)
+{
+	u8  start_clk_tune_cap;
+	u16 start_clk_mode;
+	u8  power_up_clock_freq;
+
+	int return_code;
+	int media;
+
+	return_code = NO_Si2168B_ERROR;
+	media       = si2168b_media(ctx);
+	SiTRACE ("si2168b_wakeup: media %d\n", media);
+
+	/* Clock source selection */
+	switch (media) {
+	default:
+	case Si2168B_TERRESTRIAL:
+		start_clk_mode = ctx->tuner_ter_clock_input;
+		break;
+	}
+	if (start_clk_mode == Si2168B_START_CLK_CMD_CLK_MODE_XTAL) {
+		start_clk_tune_cap = Si2168B_START_CLK_CMD_TUNE_CAP_15P6;
+	} else {
+		start_clk_tune_cap = Si2168B_START_CLK_CMD_TUNE_CAP_EXT_CLK;
+	}
+	si2168b_start_clk (ctx,
+			Si2168B_START_CLK_CMD_SUBCODE_CODE,
+			Si2168B_START_CLK_CMD_RESERVED1_RESERVED,
+			start_clk_tune_cap,
+			Si2168B_START_CLK_CMD_RESERVED2_RESERVED,
+			start_clk_mode,
+			Si2168B_START_CLK_CMD_RESERVED3_RESERVED,
+			Si2168B_START_CLK_CMD_RESERVED4_RESERVED,
+			Si2168B_START_CLK_CMD_START_CLK_START_CLK);
+	/* Reference frequency selection */
+	switch (media) {
+	default:
+	case Si2168B_TERRESTRIAL : {
+		if (ctx->tuner_ter_clock_freq == 16) {
+			SiTRACE("Si2168B_POWER_UP_CMD_CLOCK_FREQ_CLK_16MHZ\n");
+			power_up_clock_freq = Si2168B_POWER_UP_CMD_CLOCK_FREQ_CLK_16MHZ;
+		} else if (ctx->tuner_ter_clock_freq == 24) {
+			SiTRACE("Si2168B_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ\n");
+			power_up_clock_freq = Si2168B_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ;
+		} else {
+			SiTRACE("Si2168B_POWER_UP_CMD_CLOCK_FREQ_CLK_27MHZ\n");
+			power_up_clock_freq = Si2168B_POWER_UP_CMD_CLOCK_FREQ_CLK_27MHZ;
+		}
+		break;
+	}
+	}
+
+	return_code = si2168b_power_up(ctx,
+			Si2168B_POWER_UP_CMD_SUBCODE_CODE,
+			ctx->power_up_reset,
+			Si2168B_POWER_UP_CMD_RESERVED2_RESERVED,
+			Si2168B_POWER_UP_CMD_RESERVED4_RESERVED,
+			Si2168B_POWER_UP_CMD_RESERVED1_RESERVED,
+			Si2168B_POWER_UP_CMD_ADDR_MODE_CURRENT,
+			Si2168B_POWER_UP_CMD_RESERVED5_RESERVED,
+			ctx->power_up_func,
+			power_up_clock_freq,
+			Si2168B_POWER_UP_CMD_CTSIEN_DISABLE,
+			Si2168B_POWER_UP_CMD_WAKE_UP_WAKE_UP);
+
+	if (start_clk_mode == Si2168B_START_CLK_CMD_CLK_MODE_CLK_CLKIO) {
+		SiTRACE ("Si2168B_START_CLK_CMD_CLK_MODE_CLK_CLKIO\n");
+	} else if (start_clk_mode == Si2168B_START_CLK_CMD_CLK_MODE_CLK_XTAL_IN) {
+		SiTRACE ("Si2168B_START_CLK_CMD_CLK_MODE_CLK_XTAL_IN\n");
+	} else if (start_clk_mode == Si2168B_START_CLK_CMD_CLK_MODE_XTAL) {
+		SiTRACE ("Si2168B_START_CLK_CMD_CLK_MODE_XTAL\n");
+	}
+
+	if (ctx->power_up_reset == Si2168B_POWER_UP_CMD_RESET_RESET) {
+		SiTRACE ("Si2168B_POWER_UP_CMD_RESET_RESET\n");
+	} else if (ctx->power_up_reset == Si2168B_POWER_UP_CMD_RESET_RESUME ) {
+		SiTRACE ("Si2168B_POWER_UP_CMD_RESET_RESUME\n");
+	}
+
+	if (return_code != NO_Si2168B_ERROR ) {
+		SiTRACE("si2168b_wakeup: POWER_UP ERROR!\n");
+		/* second try with reset... */
+		return_code = si2168b_power_up(ctx,
+				Si2168B_POWER_UP_CMD_SUBCODE_CODE,
+				Si2168B_POWER_UP_CMD_RESET_RESET,
+				Si2168B_POWER_UP_CMD_RESERVED2_RESERVED,
+				Si2168B_POWER_UP_CMD_RESERVED4_RESERVED,
+				Si2168B_POWER_UP_CMD_RESERVED1_RESERVED,
+				Si2168B_POWER_UP_CMD_ADDR_MODE_CURRENT,
+				Si2168B_POWER_UP_CMD_RESERVED5_RESERVED,
+				ctx->power_up_func,
+				power_up_clock_freq,
+				Si2168B_POWER_UP_CMD_CTSIEN_DISABLE,
+				Si2168B_POWER_UP_CMD_WAKE_UP_WAKE_UP);
+		if (return_code != NO_Si2168B_ERROR ) {
+			SiTRACE("si2168b_wakeup: POWER_UP ERROR (2)!\n");
+			return return_code;
+		}
+	}
+#if 1
+	/* After a successful POWER_UP, set values for 'resume' only */
+	ctx->power_up_reset = Si2168B_POWER_UP_CMD_RESET_RESUME;
+#else /* reset always */
+	ctx->power_up_reset = Si2168B_POWER_UP_CMD_RESET_RESET;
+#endif
+	ctx->power_up_func  = Si2168B_POWER_UP_CMD_FUNC_NORMAL;
+
+	return NO_Si2168B_ERROR;
+}
+
+static int si2168b_ts_bus_ctrl(struct dvb_frontend* fe, int acquire)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+	Si2168B_L2_Context *front_end = priv->si_front_end;
+	u8 ts_bus_mode = 0;
+	int ret = 0;
+
+	siprintk("%s() acquire=%d\n", __func__, acquire);
+
+	_mutex_lock(&front_end->demod->ts_bus_ctrl_lock);
+
+	if (front_end->demod->Si2168B_in_standby) {
+		/* nothing to do */
+		siprintk("%s() Si2168B is in standby mode. Nothing to do.\n", __func__);
+		ret = 0;
+		goto unlock_mutex;
+	}
+
+	if (acquire) {
+		ts_bus_mode = priv->config->ts_bus_mode;
+	} else {
+		ts_bus_mode = SILABS_TS_TRISTATE;
+	}
+	siprintk("%s() setting the Si2168B ts bus to mode %d\n", __func__, ts_bus_mode);
+
+    if (si2168b_set_ts_mode(priv, ts_bus_mode) != NO_Si2168B_ERROR) {
+		printk(KERN_WARNING "%s(): si2168b_set_ts_mode(%u) failed\n", __func__, priv->config->ts_bus_mode);
+		/* try to wake up... */
+		front_end->demod->Si2168B_in_standby = 1;
+		if (si2168b_wakeup(priv->si_front_end->demod) != NO_Si2168B_ERROR) {
+			SiTRACE("si2168b_ts_bus_ctrl(): WAKEUP error!\n");
+			ret = -EIO;
+			goto unlock_mutex;
+		}
+		/* second try... */
+		if (si2168b_set_ts_mode(priv, ts_bus_mode) != NO_Si2168B_ERROR) {
+			printk(KERN_ERR "%s(): si2168b_set_ts_mode(%u) failed after wake up\n", __func__, priv->config->ts_bus_mode);
+			ret = -EIO;
+			goto unlock_mutex;
+		}
+	}
+
+	siprintk("%s() DONE.\n", __func__);
+
+unlock_mutex:
+	_mutex_unlock(&front_end->demod->ts_bus_ctrl_lock);
+	return ret;
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_DD_STATUS COMMAND                        */
+/*---------------------------------------------------*/
+static u8 si2168b_dd_status(si2168b_context *ctx, u8 intack, Si2168B_DD_STATUS_CMD_REPLY_struct *dd_status)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[8];
+	u8 ret = NO_Si2168B_ERROR;
+
+	/*SiTRACE("Si2168B DD_STATUS ");*/
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DD_STATUS_CMD;
+	cmdByteBuffer[1] = (u8) ( ( intack & Si2168B_DD_STATUS_CMD_INTACK_MASK ) << Si2168B_DD_STATUS_CMD_INTACK_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing DD_STATUS bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 8, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DD_STATUS response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	dd_status->pclint       = (( ( (rspByteBuffer[1] )) >> Si2168B_DD_STATUS_RESPONSE_PCLINT_LSB       ) & Si2168B_DD_STATUS_RESPONSE_PCLINT_MASK       );
+	dd_status->dlint        = (( ( (rspByteBuffer[1] )) >> Si2168B_DD_STATUS_RESPONSE_DLINT_LSB        ) & Si2168B_DD_STATUS_RESPONSE_DLINT_MASK        );
+	dd_status->berint       = (( ( (rspByteBuffer[1] )) >> Si2168B_DD_STATUS_RESPONSE_BERINT_LSB       ) & Si2168B_DD_STATUS_RESPONSE_BERINT_MASK       );
+	dd_status->uncorint     = (( ( (rspByteBuffer[1] )) >> Si2168B_DD_STATUS_RESPONSE_UNCORINT_LSB     ) & Si2168B_DD_STATUS_RESPONSE_UNCORINT_MASK     );
+	dd_status->rsqint_bit5  = (( ( (rspByteBuffer[1] )) >> Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT5_LSB  ) & Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT5_MASK  );
+	dd_status->rsqint_bit6  = (( ( (rspByteBuffer[1] )) >> Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT6_LSB  ) & Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT6_MASK  );
+	dd_status->rsqint_bit7  = (( ( (rspByteBuffer[1] )) >> Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT7_LSB  ) & Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT7_MASK  );
+	dd_status->pcl          = (( ( (rspByteBuffer[2] )) >> Si2168B_DD_STATUS_RESPONSE_PCL_LSB          ) & Si2168B_DD_STATUS_RESPONSE_PCL_MASK          );
+	dd_status->dl           = (( ( (rspByteBuffer[2] )) >> Si2168B_DD_STATUS_RESPONSE_DL_LSB           ) & Si2168B_DD_STATUS_RESPONSE_DL_MASK           );
+	dd_status->ber          = (( ( (rspByteBuffer[2] )) >> Si2168B_DD_STATUS_RESPONSE_BER_LSB          ) & Si2168B_DD_STATUS_RESPONSE_BER_MASK          );
+	dd_status->uncor        = (( ( (rspByteBuffer[2] )) >> Si2168B_DD_STATUS_RESPONSE_UNCOR_LSB        ) & Si2168B_DD_STATUS_RESPONSE_UNCOR_MASK        );
+	dd_status->rsqstat_bit5 = (( ( (rspByteBuffer[2] )) >> Si2168B_DD_STATUS_RESPONSE_RSQSTAT_BIT5_LSB ) & Si2168B_DD_STATUS_RESPONSE_RSQSTAT_BIT5_MASK );
+	dd_status->rsqstat_bit6 = (( ( (rspByteBuffer[2] )) >> Si2168B_DD_STATUS_RESPONSE_RSQSTAT_BIT6_LSB ) & Si2168B_DD_STATUS_RESPONSE_RSQSTAT_BIT6_MASK );
+	dd_status->rsqstat_bit7 = (( ( (rspByteBuffer[2] )) >> Si2168B_DD_STATUS_RESPONSE_RSQSTAT_BIT7_LSB ) & Si2168B_DD_STATUS_RESPONSE_RSQSTAT_BIT7_MASK );
+	dd_status->modulation   = (( ( (rspByteBuffer[3] )) >> Si2168B_DD_STATUS_RESPONSE_MODULATION_LSB   ) & Si2168B_DD_STATUS_RESPONSE_MODULATION_MASK   );
+	dd_status->ts_bit_rate  = (( ( (rspByteBuffer[4] ) | (rspByteBuffer[5]  << 8 )) >> Si2168B_DD_STATUS_RESPONSE_TS_BIT_RATE_LSB  ) & Si2168B_DD_STATUS_RESPONSE_TS_BIT_RATE_MASK  );
+	dd_status->ts_clk_freq  = (( ( (rspByteBuffer[6] ) | (rspByteBuffer[7]  << 8 )) >> Si2168B_DD_STATUS_RESPONSE_TS_CLK_FREQ_LSB  ) & Si2168B_DD_STATUS_RESPONSE_TS_CLK_FREQ_MASK  );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_DVBT_STATUS COMMAND                      */
+/*---------------------------------------------------*/
+static u8 si2168b_dvbt_status(si2168b_context *ctx, u8 intack, Si2168B_DVBT_STATUS_CMD_REPLY_struct *dvbt_status)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[13];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B DVBT_STATUS\n");
+
+	_mutex_lock(&ctx->lock);
+	cmdByteBuffer[0] = Si2168B_DVBT_STATUS_CMD;
+	cmdByteBuffer[1] = (u8) ( ( intack & Si2168B_DVBT_STATUS_CMD_INTACK_MASK ) << Si2168B_DVBT_STATUS_CMD_INTACK_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing DVBT_STATUS bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 13, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DVBT_STATUS response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	dvbt_status->pclint        =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBT_STATUS_RESPONSE_PCLINT_LSB        ) & Si2168B_DVBT_STATUS_RESPONSE_PCLINT_MASK        );
+	dvbt_status->dlint         =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBT_STATUS_RESPONSE_DLINT_LSB         ) & Si2168B_DVBT_STATUS_RESPONSE_DLINT_MASK         );
+	dvbt_status->berint        =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBT_STATUS_RESPONSE_BERINT_LSB        ) & Si2168B_DVBT_STATUS_RESPONSE_BERINT_MASK        );
+	dvbt_status->uncorint      =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBT_STATUS_RESPONSE_UNCORINT_LSB      ) & Si2168B_DVBT_STATUS_RESPONSE_UNCORINT_MASK      );
+	dvbt_status->notdvbtint    =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBT_STATUS_RESPONSE_NOTDVBTINT_LSB    ) & Si2168B_DVBT_STATUS_RESPONSE_NOTDVBTINT_MASK    );
+	dvbt_status->pcl           =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DVBT_STATUS_RESPONSE_PCL_LSB           ) & Si2168B_DVBT_STATUS_RESPONSE_PCL_MASK           );
+	dvbt_status->dl            =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DVBT_STATUS_RESPONSE_DL_LSB            ) & Si2168B_DVBT_STATUS_RESPONSE_DL_MASK            );
+	dvbt_status->ber           =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DVBT_STATUS_RESPONSE_BER_LSB           ) & Si2168B_DVBT_STATUS_RESPONSE_BER_MASK           );
+	dvbt_status->uncor         =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DVBT_STATUS_RESPONSE_UNCOR_LSB         ) & Si2168B_DVBT_STATUS_RESPONSE_UNCOR_MASK         );
+	dvbt_status->notdvbt       =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DVBT_STATUS_RESPONSE_NOTDVBT_LSB       ) & Si2168B_DVBT_STATUS_RESPONSE_NOTDVBT_MASK       );
+	dvbt_status->cnr           =   (( ( (rspByteBuffer[3]  )) >> Si2168B_DVBT_STATUS_RESPONSE_CNR_LSB           ) & Si2168B_DVBT_STATUS_RESPONSE_CNR_MASK           );
+	dvbt_status->afc_freq      = (((( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 )) >> Si2168B_DVBT_STATUS_RESPONSE_AFC_FREQ_LSB      ) & Si2168B_DVBT_STATUS_RESPONSE_AFC_FREQ_MASK) <<Si2168B_DVBT_STATUS_RESPONSE_AFC_FREQ_SHIFT ) >>Si2168B_DVBT_STATUS_RESPONSE_AFC_FREQ_SHIFT      );
+	dvbt_status->timing_offset = (((( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2168B_DVBT_STATUS_RESPONSE_TIMING_OFFSET_LSB ) & Si2168B_DVBT_STATUS_RESPONSE_TIMING_OFFSET_MASK) <<Si2168B_DVBT_STATUS_RESPONSE_TIMING_OFFSET_SHIFT ) >>Si2168B_DVBT_STATUS_RESPONSE_TIMING_OFFSET_SHIFT );
+	dvbt_status->constellation =   (( ( (rspByteBuffer[8]  )) >> Si2168B_DVBT_STATUS_RESPONSE_CONSTELLATION_LSB ) & Si2168B_DVBT_STATUS_RESPONSE_CONSTELLATION_MASK );
+	dvbt_status->sp_inv        =   (( ( (rspByteBuffer[8]  )) >> Si2168B_DVBT_STATUS_RESPONSE_SP_INV_LSB        ) & Si2168B_DVBT_STATUS_RESPONSE_SP_INV_MASK        );
+	dvbt_status->rate_hp       =   (( ( (rspByteBuffer[9]  )) >> Si2168B_DVBT_STATUS_RESPONSE_RATE_HP_LSB       ) & Si2168B_DVBT_STATUS_RESPONSE_RATE_HP_MASK       );
+	dvbt_status->rate_lp       =   (( ( (rspByteBuffer[9]  )) >> Si2168B_DVBT_STATUS_RESPONSE_RATE_LP_LSB       ) & Si2168B_DVBT_STATUS_RESPONSE_RATE_LP_MASK       );
+	dvbt_status->fft_mode      =   (( ( (rspByteBuffer[10] )) >> Si2168B_DVBT_STATUS_RESPONSE_FFT_MODE_LSB      ) & Si2168B_DVBT_STATUS_RESPONSE_FFT_MODE_MASK      );
+	dvbt_status->guard_int     =   (( ( (rspByteBuffer[10] )) >> Si2168B_DVBT_STATUS_RESPONSE_GUARD_INT_LSB     ) & Si2168B_DVBT_STATUS_RESPONSE_GUARD_INT_MASK     );
+	dvbt_status->hierarchy     =   (( ( (rspByteBuffer[11] )) >> Si2168B_DVBT_STATUS_RESPONSE_HIERARCHY_LSB     ) & Si2168B_DVBT_STATUS_RESPONSE_HIERARCHY_MASK     );
+	dvbt_status->tps_length    = (((( ( (rspByteBuffer[12] )) >> Si2168B_DVBT_STATUS_RESPONSE_TPS_LENGTH_LSB    ) & Si2168B_DVBT_STATUS_RESPONSE_TPS_LENGTH_MASK) <<Si2168B_DVBT_STATUS_RESPONSE_TPS_LENGTH_SHIFT ) >>Si2168B_DVBT_STATUS_RESPONSE_TPS_LENGTH_SHIFT    );
+
+	unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_DVBT2_STATUS COMMAND                     */
+/*---------------------------------------------------*/
+static u8 si2168b_dvbt2_status(si2168b_context *ctx, u8 intack, Si2168B_DVBT2_STATUS_CMD_REPLY_struct *dvbt2_status)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[14];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B DVBT2_STATUS\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DVBT2_STATUS_CMD;
+	cmdByteBuffer[1] = (u8) ( ( intack & Si2168B_DVBT2_STATUS_CMD_INTACK_MASK ) << Si2168B_DVBT2_STATUS_CMD_INTACK_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing DVBT2_STATUS bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 14, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DVBT2_STATUS response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	dvbt2_status->pclint        =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBT2_STATUS_RESPONSE_PCLINT_LSB        ) & Si2168B_DVBT2_STATUS_RESPONSE_PCLINT_MASK        );
+	dvbt2_status->dlint         =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBT2_STATUS_RESPONSE_DLINT_LSB         ) & Si2168B_DVBT2_STATUS_RESPONSE_DLINT_MASK         );
+	dvbt2_status->berint        =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBT2_STATUS_RESPONSE_BERINT_LSB        ) & Si2168B_DVBT2_STATUS_RESPONSE_BERINT_MASK        );
+	dvbt2_status->uncorint      =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBT2_STATUS_RESPONSE_UNCORINT_LSB      ) & Si2168B_DVBT2_STATUS_RESPONSE_UNCORINT_MASK      );
+	dvbt2_status->notdvbt2int   =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBT2_STATUS_RESPONSE_NOTDVBT2INT_LSB   ) & Si2168B_DVBT2_STATUS_RESPONSE_NOTDVBT2INT_MASK   );
+	dvbt2_status->pcl           =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DVBT2_STATUS_RESPONSE_PCL_LSB           ) & Si2168B_DVBT2_STATUS_RESPONSE_PCL_MASK           );
+	dvbt2_status->dl            =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DVBT2_STATUS_RESPONSE_DL_LSB            ) & Si2168B_DVBT2_STATUS_RESPONSE_DL_MASK            );
+	dvbt2_status->ber           =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DVBT2_STATUS_RESPONSE_BER_LSB           ) & Si2168B_DVBT2_STATUS_RESPONSE_BER_MASK           );
+	dvbt2_status->uncor         =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DVBT2_STATUS_RESPONSE_UNCOR_LSB         ) & Si2168B_DVBT2_STATUS_RESPONSE_UNCOR_MASK         );
+	dvbt2_status->notdvbt2      =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DVBT2_STATUS_RESPONSE_NOTDVBT2_LSB      ) & Si2168B_DVBT2_STATUS_RESPONSE_NOTDVBT2_MASK      );
+	dvbt2_status->cnr           =   (( ( (rspByteBuffer[3]  )) >> Si2168B_DVBT2_STATUS_RESPONSE_CNR_LSB           ) & Si2168B_DVBT2_STATUS_RESPONSE_CNR_MASK           );
+	dvbt2_status->afc_freq      = (((( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 )) >> Si2168B_DVBT2_STATUS_RESPONSE_AFC_FREQ_LSB      ) & Si2168B_DVBT2_STATUS_RESPONSE_AFC_FREQ_MASK) <<Si2168B_DVBT2_STATUS_RESPONSE_AFC_FREQ_SHIFT ) >>Si2168B_DVBT2_STATUS_RESPONSE_AFC_FREQ_SHIFT      );
+	dvbt2_status->timing_offset = (((( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2168B_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_LSB ) & Si2168B_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_MASK) <<Si2168B_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_SHIFT ) >>Si2168B_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_SHIFT );
+	dvbt2_status->constellation =   (( ( (rspByteBuffer[8]  )) >> Si2168B_DVBT2_STATUS_RESPONSE_CONSTELLATION_LSB ) & Si2168B_DVBT2_STATUS_RESPONSE_CONSTELLATION_MASK );
+	dvbt2_status->sp_inv        =   (( ( (rspByteBuffer[8]  )) >> Si2168B_DVBT2_STATUS_RESPONSE_SP_INV_LSB        ) & Si2168B_DVBT2_STATUS_RESPONSE_SP_INV_MASK        );
+	dvbt2_status->fef           =   (( ( (rspByteBuffer[8]  )) >> Si2168B_DVBT2_STATUS_RESPONSE_FEF_LSB           ) & Si2168B_DVBT2_STATUS_RESPONSE_FEF_MASK           );
+	dvbt2_status->fft_mode      =   (( ( (rspByteBuffer[9]  )) >> Si2168B_DVBT2_STATUS_RESPONSE_FFT_MODE_LSB      ) & Si2168B_DVBT2_STATUS_RESPONSE_FFT_MODE_MASK      );
+	dvbt2_status->guard_int     =   (( ( (rspByteBuffer[9]  )) >> Si2168B_DVBT2_STATUS_RESPONSE_GUARD_INT_LSB     ) & Si2168B_DVBT2_STATUS_RESPONSE_GUARD_INT_MASK     );
+	dvbt2_status->bw_ext        =   (( ( (rspByteBuffer[9]  )) >> Si2168B_DVBT2_STATUS_RESPONSE_BW_EXT_LSB        ) & Si2168B_DVBT2_STATUS_RESPONSE_BW_EXT_MASK        );
+	dvbt2_status->num_plp       =   (( ( (rspByteBuffer[10] )) >> Si2168B_DVBT2_STATUS_RESPONSE_NUM_PLP_LSB       ) & Si2168B_DVBT2_STATUS_RESPONSE_NUM_PLP_MASK       );
+	dvbt2_status->pilot_pattern =   (( ( (rspByteBuffer[11] )) >> Si2168B_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_LSB ) & Si2168B_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_MASK );
+	dvbt2_status->tx_mode       =   (( ( (rspByteBuffer[11] )) >> Si2168B_DVBT2_STATUS_RESPONSE_TX_MODE_LSB       ) & Si2168B_DVBT2_STATUS_RESPONSE_TX_MODE_MASK       );
+	dvbt2_status->rotated       =   (( ( (rspByteBuffer[11] )) >> Si2168B_DVBT2_STATUS_RESPONSE_ROTATED_LSB       ) & Si2168B_DVBT2_STATUS_RESPONSE_ROTATED_MASK       );
+	dvbt2_status->short_frame   =   (( ( (rspByteBuffer[11] )) >> Si2168B_DVBT2_STATUS_RESPONSE_SHORT_FRAME_LSB   ) & Si2168B_DVBT2_STATUS_RESPONSE_SHORT_FRAME_MASK   );
+	dvbt2_status->t2_mode       =   (( ( (rspByteBuffer[11] )) >> Si2168B_DVBT2_STATUS_RESPONSE_T2_MODE_LSB       ) & Si2168B_DVBT2_STATUS_RESPONSE_T2_MODE_MASK       );
+	dvbt2_status->code_rate     =   (( ( (rspByteBuffer[12] )) >> Si2168B_DVBT2_STATUS_RESPONSE_CODE_RATE_LSB     ) & Si2168B_DVBT2_STATUS_RESPONSE_CODE_RATE_MASK     );
+	dvbt2_status->t2_version    =   (( ( (rspByteBuffer[12] )) >> Si2168B_DVBT2_STATUS_RESPONSE_T2_VERSION_LSB    ) & Si2168B_DVBT2_STATUS_RESPONSE_T2_VERSION_MASK    );
+	dvbt2_status->plp_id        =   (( ( (rspByteBuffer[13] )) >> Si2168B_DVBT2_STATUS_RESPONSE_PLP_ID_LSB        ) & Si2168B_DVBT2_STATUS_RESPONSE_PLP_ID_MASK        );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_DVBC_STATUS COMMAND                      */
+/*---------------------------------------------------*/
+static u8 si2168b_dvbc_status(si2168b_context *ctx, u8 intack, Si2168B_DVBC_STATUS_CMD_REPLY_struct *dvbc_status)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[9];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B DVBC_STATUS\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DVBC_STATUS_CMD;
+	cmdByteBuffer[1] = (u8) ( ( intack & Si2168B_DVBC_STATUS_CMD_INTACK_MASK ) << Si2168B_DVBC_STATUS_CMD_INTACK_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing DVBC_STATUS bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 9, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DVBC_STATUS response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	dvbc_status->pclint        =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBC_STATUS_RESPONSE_PCLINT_LSB        ) & Si2168B_DVBC_STATUS_RESPONSE_PCLINT_MASK        );
+	dvbc_status->dlint         =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBC_STATUS_RESPONSE_DLINT_LSB         ) & Si2168B_DVBC_STATUS_RESPONSE_DLINT_MASK         );
+	dvbc_status->berint        =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBC_STATUS_RESPONSE_BERINT_LSB        ) & Si2168B_DVBC_STATUS_RESPONSE_BERINT_MASK        );
+	dvbc_status->uncorint      =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBC_STATUS_RESPONSE_UNCORINT_LSB      ) & Si2168B_DVBC_STATUS_RESPONSE_UNCORINT_MASK      );
+	dvbc_status->pcl           =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DVBC_STATUS_RESPONSE_PCL_LSB           ) & Si2168B_DVBC_STATUS_RESPONSE_PCL_MASK           );
+	dvbc_status->dl            =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DVBC_STATUS_RESPONSE_DL_LSB            ) & Si2168B_DVBC_STATUS_RESPONSE_DL_MASK            );
+	dvbc_status->ber           =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DVBC_STATUS_RESPONSE_BER_LSB           ) & Si2168B_DVBC_STATUS_RESPONSE_BER_MASK           );
+	dvbc_status->uncor         =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DVBC_STATUS_RESPONSE_UNCOR_LSB         ) & Si2168B_DVBC_STATUS_RESPONSE_UNCOR_MASK         );
+	dvbc_status->cnr           =   (( ( (rspByteBuffer[3]  )) >> Si2168B_DVBC_STATUS_RESPONSE_CNR_LSB           ) & Si2168B_DVBC_STATUS_RESPONSE_CNR_MASK           );
+	dvbc_status->afc_freq      = (((( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 )) >> Si2168B_DVBC_STATUS_RESPONSE_AFC_FREQ_LSB      ) & Si2168B_DVBC_STATUS_RESPONSE_AFC_FREQ_MASK) <<Si2168B_DVBC_STATUS_RESPONSE_AFC_FREQ_SHIFT ) >>Si2168B_DVBC_STATUS_RESPONSE_AFC_FREQ_SHIFT      );
+	dvbc_status->timing_offset = (((( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2168B_DVBC_STATUS_RESPONSE_TIMING_OFFSET_LSB ) & Si2168B_DVBC_STATUS_RESPONSE_TIMING_OFFSET_MASK) <<Si2168B_DVBC_STATUS_RESPONSE_TIMING_OFFSET_SHIFT ) >>Si2168B_DVBC_STATUS_RESPONSE_TIMING_OFFSET_SHIFT );
+	dvbc_status->constellation =   (( ( (rspByteBuffer[8]  )) >> Si2168B_DVBC_STATUS_RESPONSE_CONSTELLATION_LSB ) & Si2168B_DVBC_STATUS_RESPONSE_CONSTELLATION_MASK );
+	dvbc_status->sp_inv        =   (( ( (rspByteBuffer[8]  )) >> Si2168B_DVBC_STATUS_RESPONSE_SP_INV_LSB        ) & Si2168B_DVBC_STATUS_RESPONSE_SP_INV_MASK        );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+/* Receive Signal Strength Indicator (RSSI) */
+
+static int si2168b_read_rssi(struct dvb_frontend *fe, u16 *rssi)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+	int ret = 0;
+
+	if (fe->ops.tuner_ops.get_rf_strength == NULL) {
+		siprintk("%s(): WARNING: get_rf_strength() not available\n", __func__);
+		return -ENODEV;
+	}
+
+	if ( priv->config->indirect_i2c_connection ) { /* INDIRECT_I2C_CONNECTION? */
+		if (priv->si_front_end->f_TER_tuner_enable(priv->si_front_end->callback) != NO_Si2168B_ERROR) {
+			siprintk("%s(): f_TER_tuner_enable() failed\n", __func__);
+			return -EFAULT;
+		}
+	} else {
+		if (si2168b_tuner_i2c_enable(priv->si_front_end) != NO_Si2168B_ERROR) {
+			siprintk("%s(): si2168b_tuner_i2c_enable() failed\n", __func__);
+			return -EFAULT;
+		}
+	}
+	ret = fe->ops.tuner_ops.get_rf_strength(fe, rssi);
+
+	if (ret == 0) {
+		siprintk("%s(): RSSI %3d dBm\n", __func__, *rssi);
+	} else {
+		siprintk("%s(): get_rf_strength() failed\n", __func__);
+	}
+
+	if ( priv->config->indirect_i2c_connection ) { /* INDIRECT_I2C_CONNECTION? */
+		if (priv->si_front_end->f_TER_tuner_disable(priv->si_front_end->callback) != NO_Si2168B_ERROR) {
+			siprintk("%s(): f_TER_tuner_disable() failed\n", __func__);
+			return -EFAULT;
+		}
+	} else {
+		if (si2168b_tuner_i2c_disable(priv->si_front_end) != NO_Si2168B_ERROR) {
+			siprintk("%s(): si2168b_tuner_i2c_disable() failed\n", __func__);
+			return -EFAULT;
+		}
+	}
+
+	return 0;
+}
+
+/* read carrier-to-noise ratio (C/N) */
+
+static int si2168b_read_cnr(struct dvb_frontend *fe, u16 *cnr)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+	si2168b_context *demod = priv->si_front_end->demod;
+
+	Si2168B_DD_STATUS_CMD_REPLY_struct    dd_status;
+	Si2168B_DVBT_STATUS_CMD_REPLY_struct  dvbt_status;
+	Si2168B_DVBT2_STATUS_CMD_REPLY_struct dvbt2_status;
+	Si2168B_DVBC_STATUS_CMD_REPLY_struct  dvbc_status;
+
+	/* Call the demod global status function */
+	si2168b_dd_status(demod, Si2168B_DD_STATUS_CMD_INTACK_OK, &dd_status);
+
+	/* Call the standard-specific status function */
+	switch (dd_status.modulation) {
+	case Si2168B_DD_STATUS_RESPONSE_MODULATION_DVBT:
+		if (si2168b_dvbt_status(demod, Si2168B_DVBT_STATUS_CMD_INTACK_OK, &dvbt_status) != NO_Si2168B_ERROR) {
+			siprintk("%s(): si2168b_dvbt_status() failed\n", __func__);
+			return -EFAULT;
+		}
+		*cnr = dvbt_status.cnr;
+		break;
+	case Si2168B_DD_STATUS_RESPONSE_MODULATION_DVBT2:
+		if (si2168b_dvbt2_status(demod, Si2168B_DVBT2_STATUS_CMD_INTACK_OK, &dvbt2_status) != NO_Si2168B_ERROR) {
+			siprintk("%s(): si2168b_dvbt2_status() failed\n", __func__);
+			return -EFAULT;
+		}
+		*cnr = dvbt2_status.cnr;
+		break;
+	case Si2168B_DD_STATUS_RESPONSE_MODULATION_DVBC:
+		if (si2168b_dvbc_status(demod, Si2168B_DVBC_STATUS_CMD_INTACK_OK, &dvbc_status) != NO_Si2168B_ERROR) {
+			siprintk("%s(): si2168b_dvbc_status() failed\n", __func__);
+			return -EFAULT;
+		}
+		*cnr = dvbc_status.cnr;
+		break;
+	default:
+		siprintk("%s(): invalid mode\n", __func__);
+		return -EINVAL;
+	}
+
+	siprintk("%s(): C/N  %d dB\n", __func__, ((*cnr) / 4));
+
+	/**cnr *= 160;*/ /* linux value adjustment */
+
+	return 0;
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_DD_BER COMMAND                           */
+/*---------------------------------------------------*/
+static u8 si2168b_dd_ber(si2168b_context *ctx, u8 rst, Si2168B_DD_BER_CMD_REPLY_struct *dd_ber)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[3];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B DD_BER\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DD_BER_CMD;
+	cmdByteBuffer[1] = (u8) ( ( rst & Si2168B_DD_BER_CMD_RST_MASK ) << Si2168B_DD_BER_CMD_RST_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing DD_BER bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 3, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DD_BER response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	dd_ber->exp  = (( ( (rspByteBuffer[1]  )) >> Si2168B_DD_BER_RESPONSE_EXP_LSB  ) & Si2168B_DD_BER_RESPONSE_EXP_MASK  );
+	dd_ber->mant = (( ( (rspByteBuffer[2]  )) >> Si2168B_DD_BER_RESPONSE_MANT_LSB ) & Si2168B_DD_BER_RESPONSE_MANT_MASK );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_DD_UNCOR COMMAND                         */
+/*---------------------------------------------------*/
+static u8 si2168b_dd_uncor(si2168b_context *ctx, u8 rst, Si2168B_DD_UNCOR_CMD_REPLY_struct *dd_uncor)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[3];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B DD_UNCOR\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DD_UNCOR_CMD;
+	cmdByteBuffer[1] = (u8) ( ( rst & Si2168B_DD_UNCOR_CMD_RST_MASK ) << Si2168B_DD_UNCOR_CMD_RST_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing DD_UNCOR bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 3, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DD_UNCOR response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	dd_uncor->uncor_lsb =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DD_UNCOR_RESPONSE_UNCOR_LSB_LSB ) & Si2168B_DD_UNCOR_RESPONSE_UNCOR_LSB_MASK );
+	dd_uncor->uncor_msb =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DD_UNCOR_RESPONSE_UNCOR_MSB_LSB ) & Si2168B_DD_UNCOR_RESPONSE_UNCOR_MSB_MASK );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+static inline int exp_10(int m)
+{
+	int i;
+	int p = 1;
+
+	for (i = 1; i <= m; i++) {
+		p *= 10;
+	}
+	return p;
+}
+
+static int si2168b_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	si2168b_context *demod = priv->si_front_end->demod;
+	Si2168B_DD_BER_CMD_REPLY_struct dd_ber;
+
+	/* Retrieving BER values */
+	switch (p->delivery_system) {
+	case SYS_DVBT:
+	case SYS_DVBT2:
+	case SYS_DVBC_ANNEX_A:
+/*  case SILABS_MCNS : */
+		if (si2168b_dd_ber(demod, Si2168B_DD_BER_CMD_RST_RUN, &dd_ber) != NO_Si2168B_ERROR) {
+			siprintk("%s(): si2168b_dd_ber() failed\n", __func__);
+			return -EFAULT;
+		}
+		/* CHECK the exponent value to know if the BER is available or not */
+		if (dd_ber.exp != 0) {
+			*ber = (dd_ber.mant / 10) / exp_10(dd_ber.exp);
+		} else {
+			*ber = 0;
+		}
+		siprintk("%s(): BER=%u\n", __func__, *ber);
+		break;
+	default:
+		return 0;
+		break;
+	}
+
+	return 0;
+}
+
+static int si2168b_read_uncorrs(struct dvb_frontend *fe, u32 *uncorrs)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+	si2168b_context *demod = priv->si_front_end->demod;
+	Si2168B_DD_UNCOR_CMD_REPLY_struct dd_uncor = { .uncor_msb=0, .uncor_lsb=0 };
+
+	if (si2168b_dd_uncor(demod, Si2168B_DD_UNCOR_CMD_RST_RUN, &dd_uncor) != NO_Si2168B_ERROR) {
+		siprintk("%s(): si2168b_dd_uncor() failed\n", __func__);
+		return 0;
+	}
+	*uncorrs = (((u32) dd_uncor.uncor_msb) << 8) + dd_uncor.uncor_lsb;
+
+	siprintk("%s(): uncorrs=%u\n", __func__, *uncorrs);
+
+	return 0;
+}
+
+static int si2168b_get_stats(struct dvb_frontend *fe, enum fe_status *status)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+	si2168b_context *demod = priv->si_front_end->demod;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	Si2168B_DD_STATUS_CMD_REPLY_struct dd_status;
+	u16 rssi;
+	u16 cnr;
+	u32 ber;
+
+	if (si2168b_dd_status(demod, Si2168B_DD_STATUS_CMD_INTACK_OK, &dd_status) != NO_Si2168B_ERROR) {
+		siprintk("%s(): si2168b_dd_status() failed\n", __func__);
+		return -EFAULT;
+	}
+
+	/* reset status */
+	*status = 0;
+
+	/* demod lock? */
+	if (dd_status.pcl == Si2168B_DD_STATUS_RESPONSE_PCL_LOCKED) {
+		*status |= FE_HAS_SIGNAL;
+	}
+
+	/* fec lock */
+	if (dd_status.dl == Si2168B_DD_STATUS_RESPONSE_DL_LOCKED) {
+		*status |= FE_HAS_LOCK;
+		*status |= FE_HAS_VITERBI;
+
+		/* ToDo: set the other flags correctly */
+		*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_SYNC;
+		/* if fec is locked signal, carrier and sync flags should be set too */
+	}
+
+	c->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	c->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	c->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	c->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+
+	/* read RSSI from tuner */
+
+	if (si2168b_read_rssi(fe, &rssi)) {
+		c->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	} else {
+		c->strength.stat[0].scale = FE_SCALE_DECIBEL;
+		c->strength.stat[0].uvalue = rssi;
+	}
+
+	if (si2168b_read_cnr(fe, &cnr)) {
+		c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	} else {
+		c->cnr.stat[0].uvalue = cnr * 1/*00*/;
+		c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+	}
+
+	if (dd_status.dl != Si2168B_DD_STATUS_RESPONSE_DL_LOCKED) {
+		c->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		c->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		return 0;
+	}
+
+	/* read BER */
+
+	if (si2168b_read_ber(fe, &ber)) {
+		c->block_error.stat[0].scale = FE_SCALE_COUNTER;
+		c->block_error.stat[0].uvalue = ber;
+		c->block_count.stat[0].scale = FE_SCALE_COUNTER;
+		c->block_count.stat[0].uvalue = 0;
+	} else {
+		c->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		c->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+
+	return 0;
+}
+
+static int si2168b_read_status(struct dvb_frontend *fe, enum fe_status *status)
+{
+	return si2168b_get_stats(fe, status);
+}
+
+/************************************************************************************************************************
+  NAME: Si2168B_L2_Channel_Seek_End
+  DESCRIPTION: returns the chip back to normal use following a seek sequence
+  Programming Guide Reference:    Flowchart TBD (Channel Scan flowchart)
+
+  Parameter:  Pointer to Si2168B Context
+  Returns:    0 if successful, otherwise an error.
+************************************************************************************************************************/
+static int si2168b_channel_seek_end(struct dvb_frontend *fe)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+	Si2168B_L2_Context *front_end = priv->si_front_end;
+	const u8 dd_mode_bw = Si2168B_DD_MODE_PROP_BW_DEFAULT;
+	const u8 dd_mode_invert_spectrum = Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_DEFAULT;
+	u8 dd_mode_modulation = Si2168B_DD_MODE_PROP_MODULATION_DEFAULT;
+	u8 dd_mode_auto_detect = Si2168B_DD_MODE_PROP_AUTO_DETECT_NONE;
+    u16 data;
+
+	const u8 scan_ien_buzien = Si2168B_SCAN_IEN_PROP_BUZIEN_DISABLE ; /* (default 'DISABLE') */
+	const u8 scan_ien_reqien = Si2168B_SCAN_IEN_PROP_REQIEN_DISABLE ; /* (default 'DISABLE') */
+    data = (scan_ien_buzien & Si2168B_SCAN_IEN_PROP_BUZIEN_MASK) << Si2168B_SCAN_IEN_PROP_BUZIEN_LSB  |
+           (scan_ien_reqien & Si2168B_SCAN_IEN_PROP_REQIEN_MASK) << Si2168B_SCAN_IEN_PROP_REQIEN_LSB ;
+	si2168b_set_property(front_end->demod, Si2168B_SCAN_IEN_PROP, data);
+
+	switch (front_end->standard) {
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBT:
+		dd_mode_modulation = Si2168B_DD_MODE_PROP_MODULATION_DVBT;
+		break;
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBC:
+		dd_mode_modulation = Si2168B_DD_MODE_PROP_MODULATION_DVBC;
+		break;
+#ifdef __MCNS__
+		case Si2168B_DD_MODE_PROP_MODULATION_MCNS:
+		dd_mode_modulation = Si2168B_DD_MODE_PROP_MODULATION_MCNS;
+		break;
+#endif /* __MCNS__ */
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBT2:
+		dd_mode_modulation = Si2168B_DD_MODE_PROP_MODULATION_DVBT2;
+		break;
+	default:
+		SiTRACE("UNKNOWN standard %d\n", front_end->standard);
+		break;
+	}
+
+	SiTRACE("auto_detect_TER %d\n",front_end->auto_detect_TER);
+	if (front_end->auto_detect_TER) {
+		switch (front_end->standard)	{
+		case Si2168B_DD_MODE_PROP_MODULATION_DVBT:
+		case Si2168B_DD_MODE_PROP_MODULATION_DVBT2:
+			dd_mode_modulation  = Si2168B_DD_MODE_PROP_MODULATION_AUTO_DETECT;
+			dd_mode_auto_detect = Si2168B_DD_MODE_PROP_AUTO_DETECT_AUTO_DVB_T_T2;
+			break;
+		default:
+			break;
+		}
+	}
+    data = (dd_mode_bw              & Si2168B_DD_MODE_PROP_BW_MASK             ) << Si2168B_DD_MODE_PROP_BW_LSB |
+           (dd_mode_modulation      & Si2168B_DD_MODE_PROP_MODULATION_MASK     ) << Si2168B_DD_MODE_PROP_MODULATION_LSB |
+           (dd_mode_invert_spectrum & Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_MASK) << Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_LSB |
+           (dd_mode_auto_detect     & Si2168B_DD_MODE_PROP_AUTO_DETECT_MASK    ) << Si2168B_DD_MODE_PROP_AUTO_DETECT_LSB;
+	si2168b_set_property(front_end->demod, Si2168B_DD_MODE_PROP, data);
+
+	return 0;
+}
+
+/************************************************************************************************************************
+  Si2168B_DVB_C_max_lock_ms function
+  Use:        DVB-C lock time retrieval function
+              Used to know how much time DVB-C lock will take in the worst case
+************************************************************************************************************************/
+static int si2168b_dvbc_max_lock_ms(si2168b_context *ctx, u8 constellation, u32 symbol_rate_baud)
+{
+	/* HG: replaced floating point operations by integer operations */
+	/* calculation errors included now - but tolerated */
+	u32 afc_khz = 100; /* (default 100 for DVB-C) */
+	u32 swt;
+	u32 swt_coeff;
+	u32 lock_ms = 0;
+
+	/* To avoid division by 0, return 5000 if SR is 0 */
+	if (symbol_rate_baud < 1000) {
+		return 5000; /* HG: to avoid division by 0 */
+	}
+	if (afc_khz*1000 > symbol_rate_baud*11/100 ) {
+		afc_khz = symbol_rate_baud*11/100000;
+	}
+	swt = (1 + (afc_khz* (22369621 / (symbol_rate_baud/1000)) / (symbol_rate_baud/1000) ) ) / 2;
+	switch (constellation) {
+	case Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM64:
+	case Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM16:
+	case Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM256:
+		swt_coeff = 3;
+		break;
+	case Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM128:
+		swt_coeff = 5;
+		break;
+	case Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_AUTO:
+	default:
+		swt_coeff = 11;
+		break;
+	}
+	lock_ms = (720000000/symbol_rate_baud + swt*swt_coeff)+ 100;
+	SiTRACE("afc_khz %3u, swt %6u, swt_coeff %u DVB_C_max_lock_ms %u\n", afc_khz, swt, swt_coeff, lock_ms);
+	return lock_ms;
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_DVBT2_PLP_SELECT COMMAND                 */
+/*---------------------------------------------------*/
+static u8 si2168b_dvbt2_plp_select(si2168b_context *ctx, u8 plp_id, u8 plp_id_sel_mode)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[3];
+	u8 rspByteBuffer[1];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B DVBT2_PLP_SELECT ID=%u MODE=%u\n", plp_id, plp_id_sel_mode);
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DVBT2_PLP_SELECT_CMD;
+	cmdByteBuffer[1] = (u8) ( ( plp_id          & Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_MASK          ) << Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_LSB         );
+	cmdByteBuffer[2] = (u8) ( ( plp_id_sel_mode & Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MASK ) << Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 3, cmdByteBuffer) != 3) {
+		SiTRACE("Error writing DVBT2_PLP_SELECT bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 1, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DVBT2_PLP_SELECT response\n");
+		ret = error_code;
+	}
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_DD_RESTART COMMAND                       */
+/*---------------------------------------------------*/
+static u8 si2168b_dd_restart(si2168b_context *ctx)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[1];
+	u8 rspByteBuffer[1];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B DD_RESTART\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DD_RESTART_CMD;
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 1, cmdByteBuffer) != 1) {
+		SiTRACE("Error writing DD_RESTART bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 1, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DD_RESTART response\n");
+		ret = error_code;
+	}
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+/************************************************************************************************************************
+  si2168b_standard_name function
+  Use:        standard text retrieval function
+              Used to retrieve the standard text used by the Si2168B
+  Parameter:  standard, the value of the standard
+************************************************************************************************************************/
+static char *si2168b_standard_name(u8 standard)
+{
+	switch (standard) {
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBT:
+		return (char*)"DVB-T";
+#ifdef __MCNS__
+	case Si2168B_DD_MODE_PROP_MODULATION_MCNS:
+		return (char*)"MCNS";
+#endif /* __MCNS__ */
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBC:
+		return (char*)"DVB-C";
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBT2:
+		return (char*)"DVB-T2";
+	default:
+		return (char*)"UNKNOWN";
+	}
+}
+
+/************************************************************************************************************************
+  si2168b_ter_fef function
+  Use:        TER tuner FEF activation function
+              Used to enable/disable the FEF mode in the terrestrial tuner
+  Comments:   If the tuner is connected via the demodulator's I2C switch, enabling/disabling the i2c_passthru is required before/after tuning.
+  Parameter:  *front_end, the front-end handle
+  Parameter:  fef, a flag controlling the selection between FEF 'off'(0) and FEF 'on'(1)
+  Returns:    1
+************************************************************************************************************************/
+static int si2168b_ter_fef(Si2168B_L2_Context *front_end, u8 fef)
+{
+	SiTRACE("si2168b_ter_fef %d\n", fef);
+
+	if (front_end->demod->fef_mode == Si2168B_FEF_MODE_FREEZE_PIN) {
+		SiTRACE("FEF mode Si2168B_FEF_MODE_FREEZE_PIN\n");
+		/* handled in tuner module now */
+	}
+
+#ifdef    L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP
+	if (front_end->demod->fef_mode == Si2168B_FEF_MODE_SLOW_INITIAL_AGC) {
+		SiTRACE("FEF mode Si2168B_FEF_MODE_SLOW_INITIAL_AGC (AGC slowed down after tuning)\n");
+	}
+#endif /* L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP */
+
+#ifdef    L1_RF_TER_TUNER_FEF_MODE_SLOW_NORMAL_AGC_SETUP
+	if (front_end->demod->fef_mode == Si2168B_FEF_MODE_SLOW_NORMAL_AGC ) {
+		SiTRACE("FEF mode Si2168B_FEF_MODE_SLOW_NORMAL_AGC: AGC slowed down\n");
+		/* handled in tuner module now */
+	}
+#endif /* L1_RF_TER_TUNER_FEF_MODE_SLOW_NORMAL_AGC_SETUP */
+
+	return 1;
+}
+
+/************************************************************************************************************************
+  si2168b_tune function
+  Use:        tuner current frequency retrieval function
+              Used to retrieve the current RF from the tuner's driver.
+  Porting:    Replace the internal TUNER function calls by the final tuner's corresponding calls
+  Comments:   If the tuner is connected via the demodulator's I2C switch, enabling/disabling the i2c_passthru is required before/after tuning.
+  Behavior:   This function closes the Si2168B's I2C switch then tunes and finally reopens the I2C switch
+  Parameter:  *front_end, the front-end handle
+  Parameter:  rf, the frequency to tune at
+  Returns:    rf
+************************************************************************************************************************/
+static u32 si2168b_set_tuner_params(struct dvb_frontend *fe, u32 rf)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+	Si2168B_L2_Context *front_end = priv->si_front_end;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+
+	SiTRACE("si2168b_set_tuner_params() frequency=%u\n", rf);
+
+	if (front_end->tuner_indirect_i2c_connection) {  /* INDIRECT_I2C_CONNECTION? */
+		/*  I2C connection will be done later on, depending on the media */
+	} else {
+		si2168b_tuner_i2c_enable(front_end);
+	}
+
+	if (front_end->demod->media == Si2168B_TERRESTRIAL) {
+		if ( front_end->tuner_indirect_i2c_connection ) {  /* INDIRECT_I2C_CONNECTION? */
+			front_end->f_TER_tuner_enable(front_end->callback);
+		}
+		c->frequency = rf;
+		if (fe->ops.tuner_ops.set_params) {
+			if (fe->ops.tuner_ops.set_params(fe)) {
+				SiTRACE("Terrestrial tuner set_params() error!\n");
+			}
+		} else {
+			SiTRACE("WARNING: set_params() not available\n");
+		}
+		if ( front_end->tuner_indirect_i2c_connection ) {  /* INDIRECT_I2C_CONNECTION? */
+			front_end->f_TER_tuner_disable(front_end->callback);
+		}
+	}
+	if ( front_end->tuner_indirect_i2c_connection ) {  /* INDIRECT_I2C_CONNECTION? */
+	} else {
+		si2168b_tuner_i2c_disable(front_end);
+	}
+
+	return rf;
+}
+
+/************************************************************************************************************************
+  Si2168B_lock_to_carrier function
+  Use:      relocking function
+            Used to relock on a channel for the current standard
+            options:
+              if freq = 0, do not tune. This is useful to test the lock time without the tuner delays.
+              if freq < 0, do not tune and don't change settings. Just do a DD_RESTART. This is useful to test the relock time upom a reset.
+  Parameter: standard the standard to lock to
+  Parameter: freq                the frequency to lock to    (in Hz for TER, in kHz for SAT)
+  Parameter: dvb_t_bandwidth_hz  the channel bandwidth in Hz (only for DVB-T and DVB-T2)
+  Parameter: dvb_t_stream        the HP/LP stream            (only for DVB-T)
+  Parameter: symbol_rate_bps     the symbol rate             (for DVB-C, MCNS and SAT)
+  Parameter: dvb_c_constellation the DVB-C constellation     (only for DVB-C)
+  Parameter: data_slice_id       the DVB-C2 data slice Id    (only for DVB-C2)
+  Parameter: plp_id              the PLP Id                  (only for DVB-T2 and DVB-C2 when num_dslice  > 1)
+  Parameter: T2_lock_mode        the DVB-T2 lock mode        (0='ANY', 1='T2-Base', 2='T2-Lite')
+  Return:    1 if locked, 0 otherwise
+************************************************************************************************************************/
+static int si2168b_lock_to_carrier(struct dvb_frontend *fe
+		, u8  standard
+		, u32 freq
+		, u32 dvb_t_bandwidth_hz
+		, u8  dvb_t_stream
+		, u32 symbol_rate_bps
+		, u8  dvb_c_constellation
+		, int plp_id
+		, u8  T2_lock_mode
+)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+	Si2168B_L2_Context *front_end = priv->si_front_end;
+	Si2168B_DD_STATUS_CMD_REPLY_struct dd_status;
+	Si2168B_DD_BER_CMD_REPLY_struct dd_ber;
+
+	int return_code;
+	u32 lock_start_time;       /* lockStartTime is used to trace the time spent in si2168b_lock_to_carrier and is only set at when entering the function                       */
+	u32 start_time;           /* startTime is used to measure internal durations. It is set in various places, whenever required                                                */
+	u32 search_start_time = 0; /* searchStartTime is used to trace the time spent trying to lock. It is set differently from lockStartTime when returning from a handshake       */
+	u32 search_delay;
+	u32 handshake_delay;
+	int lock;
+	int new_lock;
+	u32 max_lock_time_ms = 0;
+	u32 min_lock_time_ms = 0;
+	u16 data;
+	u8  dd_mode_bw;
+	u8  dd_mode_modulation;
+	u8  dd_mode_invert_spectrum = Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_NORMAL;
+	u8  dd_mode_auto_detect = Si2168B_DD_MODE_PROP_AUTO_DETECT_NONE;
+	u8  dvbt_hierarchy_stream;
+	u8  dvbt2_mode_lock_mode;
+	u8  u_plp_id;
+	u8  plp_id_sel_mode;
+	u16 dvbc_symbol_rate_rate;
+	u8  dvbc_constellation_constellation;
+#ifdef __MCNS__
+	u16 mcns_symbol_rate_rate;
+	u8  mcns_constellation_constellation;
+#endif /* __MCNS__ */
+	u8  dvbt2_plp_select_plp_id;
+	u8  dvbt2_plp_select_plp_id_sel_mode;
+	u8  lockAbort = 0;
+
+	lock_start_time = system_time(); /* lockStartTime is used to trace the time spent in si2168b_lock_to_carrier and is only set here */
+	lock = 0;
+
+	SiTRACE ("relock to %s at %u\n", si2168b_standard_name(standard), freq);
+
+	if (front_end->handshakeUsed == 0) {
+		new_lock = 1;
+		search_start_time = lock_start_time;
+	}
+	if (front_end->handshakeUsed == 1) {
+		if (front_end->handshakeOn == 1) {
+			new_lock = 0;
+			SiTRACE("lock_to_carrier_handshake : recalled after   handshake.\n");
+		}
+		if (front_end->handshakeOn == 0) {
+			new_lock = 1;
+			front_end->handshakeStart_ms = lock_start_time;
+		}
+		search_start_time = front_end->handshakeStart_ms;
+		SiTRACE("lock_to_carrier_handshake : handshake start %d\n", front_end->handshakeStart_ms);
+	}
+
+	/* Setting max_lock_time_ms and min_lock_time_ms for locking on required standard */
+	switch (standard) {
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBT:
+		max_lock_time_ms = Si2168B_DVBT_MAX_LOCK_TIME;
+		min_lock_time_ms = Si2168B_DVBT_MIN_LOCK_TIME;
+		if (front_end->auto_detect_TER) {
+			max_lock_time_ms = Si2168B_DVBT2_MAX_LOCK_TIME;
+		}
+		break;
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBT2:
+		max_lock_time_ms = Si2168B_DVBT2_MAX_LOCK_TIME;
+		min_lock_time_ms = Si2168B_DVBT2_MIN_LOCK_TIME;
+		if (front_end->auto_detect_TER) {
+			min_lock_time_ms = Si2168B_DVBT_MIN_LOCK_TIME;
+		}
+		break;
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBC:
+		max_lock_time_ms = si2168b_dvbc_max_lock_ms(front_end->demod, dvb_c_constellation, symbol_rate_bps);
+		min_lock_time_ms = Si2168B_DVBC_MIN_LOCK_TIME;
+		break;
+#ifdef __MCNS__
+	case Si2168B_DD_MODE_PROP_MODULATION_MCNS:
+		max_lock_time_ms = si2168b_dvbc_max_lock_ms(front_end->demod, dvb_c_constellation, symbol_rate_bps);
+		min_lock_time_ms = Si2168B_DVBC_MIN_LOCK_TIME;
+		break;
+#endif /* __MCNS__ */
+	default: /* ATV */
+		break;
+	}
+
+	/* change settings only if not testing the relock time upon a reset (activated if freq<0) */
+	if ( (freq >= 0 ) && (new_lock == 1) ) {
+		/* Setting demod for locking on required standard */
+		switch (standard) {
+		case Si2168B_DD_MODE_PROP_MODULATION_DVBT2:
+		case Si2168B_DD_MODE_PROP_MODULATION_DVBT: {
+			dd_mode_bw = dvb_t_bandwidth_hz / 1000000;
+			dvbt_hierarchy_stream = dvb_t_stream;
+			data = (dvbt_hierarchy_stream & Si2168B_DVBT_HIERARCHY_PROP_STREAM_MASK) << Si2168B_DVBT_HIERARCHY_PROP_STREAM_LSB;
+			return_code = si2168b_set_property(front_end->demod, Si2168B_DVBT_HIERARCHY_PROP, data);
+			if (dvb_t_bandwidth_hz == 1700000) {
+				dd_mode_bw = Si2168B_DD_MODE_PROP_BW_BW_1D7MHZ;
+			}
+			if (front_end->auto_detect_TER) {
+				SiTRACE("DVB-T/T2 auto detect\n");
+				if (plp_id != -1) {
+					plp_id_sel_mode = Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MANUAL;
+					u_plp_id = (u8)plp_id;
+				} else {
+					plp_id_sel_mode = Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_AUTO;
+					u_plp_id = 0;
+				}
+				si2168b_dvbt2_plp_select(front_end->demod, u_plp_id, plp_id_sel_mode);
+				dd_mode_modulation   = Si2168B_DD_MODE_PROP_MODULATION_AUTO_DETECT;
+				dd_mode_auto_detect  = Si2168B_DD_MODE_PROP_AUTO_DETECT_AUTO_DVB_T_T2;
+				dvbt2_mode_lock_mode = T2_lock_mode;
+				data = (dvbt2_mode_lock_mode & Si2168B_DVBT2_MODE_PROP_LOCK_MODE_MASK) << Si2168B_DVBT2_MODE_PROP_LOCK_MODE_LSB ;
+				si2168b_set_property(front_end->demod, Si2168B_DVBT2_MODE_PROP, data);
+				SiTRACE ("T2_lock_mode %u\n", T2_lock_mode);
+			} else {
+				if (standard == Si2168B_DD_MODE_PROP_MODULATION_DVBT) {
+					dvbt_hierarchy_stream = dvb_t_stream;
+					data = (dvbt_hierarchy_stream & Si2168B_DVBT_HIERARCHY_PROP_STREAM_MASK) << Si2168B_DVBT_HIERARCHY_PROP_STREAM_LSB;
+					return_code = si2168b_set_property(front_end->demod, Si2168B_DVBT_HIERARCHY_PROP, data);
+				}
+				if (standard == Si2168B_DD_MODE_PROP_MODULATION_DVBT2) {
+					if (plp_id != -1) {
+						dvbt2_plp_select_plp_id_sel_mode = Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MANUAL;
+						dvbt2_plp_select_plp_id = (u8)plp_id;
+					} else {
+						dvbt2_plp_select_plp_id_sel_mode = Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_AUTO;
+						dvbt2_plp_select_plp_id = 0;
+					}
+					si2168b_dvbt2_plp_select(front_end->demod, dvbt2_plp_select_plp_id, dvbt2_plp_select_plp_id_sel_mode);
+					dvbt2_mode_lock_mode = T2_lock_mode;
+					data = (dvbt2_mode_lock_mode & Si2168B_DVBT2_MODE_PROP_LOCK_MODE_MASK) << Si2168B_DVBT2_MODE_PROP_LOCK_MODE_LSB ;
+					si2168b_set_property(front_end->demod, Si2168B_DVBT2_MODE_PROP, data);
+					SiTRACE ("T2_lock_mode %d\n", T2_lock_mode);
+				}
+			}
+			data = (dd_mode_bw              & Si2168B_DD_MODE_PROP_BW_MASK             ) << Si2168B_DD_MODE_PROP_BW_LSB  |
+					(dd_mode_modulation      & Si2168B_DD_MODE_PROP_MODULATION_MASK     ) << Si2168B_DD_MODE_PROP_MODULATION_LSB  |
+					(dd_mode_invert_spectrum & Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_MASK) << Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_LSB  |
+					(dd_mode_auto_detect     & Si2168B_DD_MODE_PROP_AUTO_DETECT_MASK    ) << Si2168B_DD_MODE_PROP_AUTO_DETECT_LSB ;
+			si2168b_set_property(front_end->demod, Si2168B_DD_MODE_PROP, data);
+			SiTRACE("bw %d Hz\n", dvb_t_bandwidth_hz);
+			break;
+		}
+		case Si2168B_DD_MODE_PROP_MODULATION_DVBC:
+			dd_mode_bw                       = 8;
+			dd_mode_modulation   = Si2168B_DD_MODE_PROP_MODULATION_DVBC;
+			dd_mode_auto_detect  = Si2168B_DD_MODE_PROP_AUTO_DETECT_DEFAULT;
+			dvbc_symbol_rate_rate            = symbol_rate_bps / 1000;
+			dvbc_constellation_constellation = dvb_c_constellation;
+			data = (dd_mode_bw              & Si2168B_DD_MODE_PROP_BW_MASK             ) << Si2168B_DD_MODE_PROP_BW_LSB  |
+					(dd_mode_modulation      & Si2168B_DD_MODE_PROP_MODULATION_MASK     ) << Si2168B_DD_MODE_PROP_MODULATION_LSB  |
+					(dd_mode_invert_spectrum & Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_MASK) << Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_LSB  |
+					(dd_mode_auto_detect     & Si2168B_DD_MODE_PROP_AUTO_DETECT_MASK    ) << Si2168B_DD_MODE_PROP_AUTO_DETECT_LSB ;
+			si2168b_set_property(front_end->demod, Si2168B_DD_MODE_PROP, data);
+			data = (dvbc_symbol_rate_rate & Si2168B_DVBC_SYMBOL_RATE_PROP_RATE_MASK) << Si2168B_DVBC_SYMBOL_RATE_PROP_RATE_LSB ;
+			si2168b_set_property(front_end->demod, Si2168B_DVBC_SYMBOL_RATE_PROP, data);
+			data = (dvbc_constellation_constellation & Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_MASK) << Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_LSB ;
+			si2168b_set_property(front_end->demod, Si2168B_DVBC_CONSTELLATION_PROP, data);
+			SiTRACE("sr %d bps, constel %d\n", symbol_rate_bps, dvb_c_constellation);
+			break;
+#ifdef __MCNS__
+		case Si2168B_DD_MODE_PROP_MODULATION_MCNS:
+			dd_mode_bw                       = 8;
+			mcns_symbol_rate_rate            = symbol_rate_bps / 1000;
+			mcns_constellation_constellation = dvb_c_constellation;
+			si2168b_set_property(front_end->demod, Si2168B_DD_MODE_PROP, data);
+			data = (mcns_symbol_rate_rate & Si2168B_MCNS_SYMBOL_RATE_PROP_RATE_MASK) << Si2168B_MCNS_SYMBOL_RATE_PROP_RATE_LSB ;
+			si2168b_set_property(front_end->demod, Si2168B_MCNS_SYMBOL_RATE_PROP, data);
+			data = (mcns_constellation_constellation & Si2168B_MCNS_CONSTELLATION_PROP_CONSTELLATION_MASK) << Si2168B_MCNS_CONSTELLATION_PROP_CONSTELLATION_LSB ;
+			si2168b_set_property(front_end->demod, Si2168B_MCNS_CONSTELLATION_PROP, data);
+			SiTRACE("sr %d bps, constel %d\n", mcns_symbol_rate_rate, mcns_constellation_constellation);
+			break;
+#endif /* __MCNS__ */
+		default: /* ATV */
+			SiTRACE("'%d' standard (%s) is not managed by Si2168B_lock_to_carrier\n", standard, si2168b_standard_name(standard));
+			return 0;
+			break;
+		}
+
+		if (lockAbort) {
+			SiTRACE("si2168b_lock_to_carrier : lock aborted before tuning, after %d ms.\n", system_time() - lock_start_time );
+			return 0;
+		}
+
+		/* ALlow using this function without tuning */
+		if (freq != 0) {
+			start_time = system_time();
+			si2168b_set_tuner_params(fe, freq);
+			SiTRACE("Si2168B_lock_to_carrier 'tune'  took %3d ms\n", system_time() - start_time);
+		}
+
+		start_time = system_time();
+		si2168b_dd_restart(front_end->demod);
+		SiTRACE("Si2168B_lock_to_carrier 'reset' took %3d ms\n", system_time() - start_time);
+
+		/* as we will not lock in less than min_lock_time_ms, wait a while..., but check for a possible 'abort' from the application */
+		start_time = system_time();
+		while (system_time() - start_time < min_lock_time_ms) {
+			if (lockAbort) {
+				SiTRACE("si2168b_lock_to_carrier : lock aborted before checking lock status, after %d ms.\n", system_time() - lock_start_time);
+				return 0;
+			}
+			/* Adapt here the minimal 'reaction time' of the application*/
+			msleep(20);
+		}
+	}
+	/* testing the relock time upon a reset (activated if freq<0) */
+	if (freq < 0) {
+		SiTRACE("Si2168B_lock_to_carrier 'only_reset'\n");
+		si2168b_dd_restart(front_end->demod);
+	}
+
+	/* The actual lock check loop */
+	while (1) {
+		search_delay = system_time() - search_start_time;
+
+		/* Check the status for the current modulation */
+
+		switch (standard)
+		default:
+		case Si2168B_DD_MODE_PROP_MODULATION_DVBT:
+		case Si2168B_DD_MODE_PROP_MODULATION_DVBT2: {
+			/* DVB-T/T2 auto detect seek loop, using si2168b_dd_status                                          */
+			/* if DL LOCKED                            : demod is locked on a dd_status->modulation signal        */
+			/* if DL NO_LOCK and rsqint_bit5 NO_CHANGE : demod is searching for a DVB-T/T2 signal                 */
+			/* if DL NO_LOCK and rsqint_bit5 CHANGE    : demod says this is not a DVB-T/T2 signal (= 'neverlock') */
+			return_code = si2168b_dd_status(front_end->demod, Si2168B_DD_STATUS_CMD_INTACK_CLEAR, &dd_status);
+			if (return_code != NO_Si2168B_ERROR) {
+				SiTRACE("Si2168B_lock_to_carrier: si2168b_dd_status error\n");
+				goto exit_lock;
+				break;
+			}
+
+			if (dd_status.dl == Si2168B_DD_STATUS_RESPONSE_DL_LOCKED) {
+				/* Return 1 to signal that the Si2168B is locked on a valid DVB-T/T2 channel */
+				SiTRACE("Si2168B_lock_to_carrier: locked on a %s signal\n", si2168b_standard_name(dd_status.modulation) );
+				lock = 1;
+				/* Make sure FEF mode is ON when locked on a T2 channel */
+				if (dd_status.modulation == Si2168B_DD_MODE_PROP_MODULATION_DVBT2) {
+					if (front_end->tuner_indirect_i2c_connection ) {  /* INDIRECT_I2C_CONNECTION? */
+						front_end->f_TER_tuner_enable(front_end->callback);
+					} else {
+						si2168b_tuner_i2c_enable(front_end);
+					}
+					SiTRACE("Si2168B_lock_to_carrier: tuner should enable FEF for DVBT2\n");
+					si2168b_ter_fef(front_end, 1);
+					if ( front_end->tuner_indirect_i2c_connection ) {  /* INDIRECT_I2C_CONNECTION? */
+						front_end->f_TER_tuner_disable(front_end->callback);
+					} else {
+						si2168b_tuner_i2c_disable(front_end);
+					}
+				}
+				goto exit_lock;
+			} else {
+				/* SiTRACE("Si2168B_lock_to_carrier: NO LOCK\n"); */
+				if (dd_status.rsqint_bit5 == Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT5_CHANGED ) {
+					/* Return 0 if firmware signals 'no DVB-T/T2 channel' */
+					SiTRACE ("'no DVB-T/T2 channel': not locked after %3d ms\n", search_delay);
+					goto exit_lock;
+				}
+			}
+			break;
+		case Si2168B_DD_MODE_PROP_MODULATION_DVBC:
+			return_code = si2168b_dd_status(front_end->demod, Si2168B_DD_STATUS_CMD_INTACK_CLEAR, &dd_status);
+
+			if (return_code != NO_Si2168B_ERROR) {
+				SiTRACE("Si2168B_lock_to_carrier: si2168b_dd_status error\n");
+				goto exit_lock;
+				break;
+			}
+
+			if (dd_status.dl == Si2168B_DD_STATUS_RESPONSE_DL_LOCKED) {
+				/* Return 1 to signal that the Si2168B is locked on a valid SAT channel */
+				SiTRACE("%s lock\n", si2168b_standard_name(dd_status.modulation));
+				lock = 1;
+				goto exit_lock;
+			}
+			break;
+#ifdef __MCNS__
+		case Si2168B_DD_MODE_PROP_MODULATION_MCNS:
+			return_code = si2168b_dd_status(front_end->demod, Si2168B_DD_STATUS_CMD_INTACK_CLEAR, &dd_status);
+
+			if (return_code != NO_Si2168B_ERROR) {
+				SiTRACE("Si2168B_lock_to_carrier: si2168b_dd_status error\n");
+				goto exit_lock;
+				break;
+			}
+
+			if (dd_status.dl == Si2168B_DD_STATUS_RESPONSE_DL_LOCKED) {
+				/* Return 1 to signal that the Si2168B is locked on a valid SAT channel */
+				SiTRACE("%s lock\n", si2168b_standard_name(dd_status.modulation));
+				lock = 1;
+				goto exit_lock;
+			}
+			break;
+#endif /* __MCNS__ */
+		}
+
+		/* timeout management (this should never happen if timeout values are correctly set) */
+		search_delay = system_time() - search_start_time;
+		if (search_delay >= max_lock_time_ms) {
+			SiTRACE ("Si2168B_lock_to_carrier timeout(%d) after %d ms\n", max_lock_time_ms, search_delay);
+			goto exit_lock;
+			break;
+		}
+
+		if (front_end->handshakeUsed == 1) {
+			handshake_delay = system_time() - lock_start_time;
+			if (handshake_delay >= front_end->handshakePeriod_ms) {
+				SiTRACE ("lock_to_carrier_handshake : handshake after %5d ms (at %10d). (search delay %6d ms)\n\n", handshake_delay, freq, search_delay);
+				front_end->handshakeOn = 1;
+				/* The application will check handshakeStart_ms to know whether the lock is complete or not */
+				return search_delay;
+			} else {
+				SiTRACE ("lock_to_carrier_handshake : no handshake yet. (handshake delay %6d ms, search delay %6d ms)\n", handshake_delay, search_delay);
+			}
+		}
+
+		if (lockAbort) {
+			SiTRACE("si2168b_lock_to_carrier : lock aborted after %d ms.\n", system_time() - lock_start_time);
+			goto exit_lock;
+		}
+
+		/* Check status every 10 ms */
+		msleep(5);
+	}
+
+	exit_lock:
+
+	front_end->handshakeOn = 0;
+	search_delay = system_time() - search_start_time;
+
+	if (lock) {
+		si2168b_dd_ber(front_end->demod, Si2168B_DD_BER_CMD_RST_CLEAR, &dd_ber);
+		SiTRACE ("Si2168B_lock_to_carrier 'lock'  took %3d ms\n", search_delay);
+	} else {
+		SiTRACE ("Si2168B_lock_to_carrier at %10d (%s) failed after %d ms\n", freq, si2168b_standard_name(dd_status.modulation), search_delay);
+	}
+
+	return lock;
+}
+
+/***********************************************************************************************************************
+  si2168b_check_status function
+  Use:        Status information function
+              Used to retrieve the status byte
+  Returns:    0 if no error
+  Parameter:  error_code the error code.
+ ***********************************************************************************************************************/
+static u8 si2168b_check_status(si2168b_context *ctx)
+{
+    u8 rspByteBuffer[1];
+    u8 ret;
+
+	_mutex_lock(&ctx->lock);
+    ret = si2168b_poll_for_response(ctx, 1, rspByteBuffer);
+	_mutex_unlock(&ctx->lock);
+    return ret;
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_SCAN_STATUS COMMAND                      */
+/*---------------------------------------------------*/
+static u8 si2168b_scan_status(si2168b_context *ctx, u8 intack, Si2168B_SCAN_STATUS_CMD_REPLY_struct *scan_status)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[11];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B SCAN_STATUS\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_SCAN_STATUS_CMD;
+	cmdByteBuffer[1] = (u8) ( ( intack & Si2168B_SCAN_STATUS_CMD_INTACK_MASK ) << Si2168B_SCAN_STATUS_CMD_INTACK_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing SCAN_STATUS bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 11, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling SCAN_STATUS response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	scan_status->buzint      =   (( ( (rspByteBuffer[1]  )) >> Si2168B_SCAN_STATUS_RESPONSE_BUZINT_LSB      ) & Si2168B_SCAN_STATUS_RESPONSE_BUZINT_MASK      );
+	scan_status->reqint      =   (( ( (rspByteBuffer[1]  )) >> Si2168B_SCAN_STATUS_RESPONSE_REQINT_LSB      ) & Si2168B_SCAN_STATUS_RESPONSE_REQINT_MASK      );
+	scan_status->buz         =   (( ( (rspByteBuffer[2]  )) >> Si2168B_SCAN_STATUS_RESPONSE_BUZ_LSB         ) & Si2168B_SCAN_STATUS_RESPONSE_BUZ_MASK         );
+	scan_status->req         =   (( ( (rspByteBuffer[2]  )) >> Si2168B_SCAN_STATUS_RESPONSE_REQ_LSB         ) & Si2168B_SCAN_STATUS_RESPONSE_REQ_MASK         );
+	scan_status->scan_status =   (( ( (rspByteBuffer[3]  )) >> Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_LSB ) & Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_MASK );
+	scan_status->rf_freq     =   (( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 ) | (rspByteBuffer[6]  << 16 ) | (rspByteBuffer[7]  << 24 )) >> Si2168B_SCAN_STATUS_RESPONSE_RF_FREQ_LSB     ) & Si2168B_SCAN_STATUS_RESPONSE_RF_FREQ_MASK     );
+	scan_status->symb_rate   =   (( ( (rspByteBuffer[8]  ) | (rspByteBuffer[9]  << 8 )) >> Si2168B_SCAN_STATUS_RESPONSE_SYMB_RATE_LSB   ) & Si2168B_SCAN_STATUS_RESPONSE_SYMB_RATE_MASK   );
+	scan_status->modulation  =   (( ( (rspByteBuffer[10] )) >> Si2168B_SCAN_STATUS_RESPONSE_MODULATION_LSB  ) & Si2168B_SCAN_STATUS_RESPONSE_MODULATION_MASK  );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+#ifdef __MCNS__
+/*---------------------------------------------------*/
+/* Si2168B_MCNS_STATUS COMMAND                      */
+/*---------------------------------------------------*/
+static u8 si2168b_mcns_status(si2168b_context *ctx, u8 intack)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[10];
+	u8 ret = NO_Si2168B_ERROR;
+	ctx->rsp->mcns_status.STATUS = ctx->status;
+
+	SiTRACE("Si2168B MCNS_STATUS\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_MCNS_STATUS_CMD;
+	cmdByteBuffer[1] = (u8) ( ( intack & Si2168B_MCNS_STATUS_CMD_INTACK_MASK ) << Si2168B_MCNS_STATUS_CMD_INTACK_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing MCNS_STATUS bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 10, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling MCNS_STATUS response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	ctx->rsp->mcns_status.pclint        =   (( ( (rspByteBuffer[1]  )) >> Si2168B_MCNS_STATUS_RESPONSE_PCLINT_LSB        ) & Si2168B_MCNS_STATUS_RESPONSE_PCLINT_MASK        );
+	ctx->rsp->mcns_status.dlint         =   (( ( (rspByteBuffer[1]  )) >> Si2168B_MCNS_STATUS_RESPONSE_DLINT_LSB         ) & Si2168B_MCNS_STATUS_RESPONSE_DLINT_MASK         );
+	ctx->rsp->mcns_status.berint        =   (( ( (rspByteBuffer[1]  )) >> Si2168B_MCNS_STATUS_RESPONSE_BERINT_LSB        ) & Si2168B_MCNS_STATUS_RESPONSE_BERINT_MASK        );
+	ctx->rsp->mcns_status.uncorint      =   (( ( (rspByteBuffer[1]  )) >> Si2168B_MCNS_STATUS_RESPONSE_UNCORINT_LSB      ) & Si2168B_MCNS_STATUS_RESPONSE_UNCORINT_MASK      );
+	ctx->rsp->mcns_status.pcl           =   (( ( (rspByteBuffer[2]  )) >> Si2168B_MCNS_STATUS_RESPONSE_PCL_LSB           ) & Si2168B_MCNS_STATUS_RESPONSE_PCL_MASK           );
+	ctx->rsp->mcns_status.dl            =   (( ( (rspByteBuffer[2]  )) >> Si2168B_MCNS_STATUS_RESPONSE_DL_LSB            ) & Si2168B_MCNS_STATUS_RESPONSE_DL_MASK            );
+	ctx->rsp->mcns_status.ber           =   (( ( (rspByteBuffer[2]  )) >> Si2168B_MCNS_STATUS_RESPONSE_BER_LSB           ) & Si2168B_MCNS_STATUS_RESPONSE_BER_MASK           );
+	ctx->rsp->mcns_status.uncor         =   (( ( (rspByteBuffer[2]  )) >> Si2168B_MCNS_STATUS_RESPONSE_UNCOR_LSB         ) & Si2168B_MCNS_STATUS_RESPONSE_UNCOR_MASK         );
+	ctx->rsp->mcns_status.cnr           =   (( ( (rspByteBuffer[3]  )) >> Si2168B_MCNS_STATUS_RESPONSE_CNR_LSB           ) & Si2168B_MCNS_STATUS_RESPONSE_CNR_MASK           );
+	ctx->rsp->mcns_status.afc_freq      = (((( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 )) >> Si2168B_MCNS_STATUS_RESPONSE_AFC_FREQ_LSB      ) & Si2168B_MCNS_STATUS_RESPONSE_AFC_FREQ_MASK) <<Si2168B_MCNS_STATUS_RESPONSE_AFC_FREQ_SHIFT ) >>Si2168B_MCNS_STATUS_RESPONSE_AFC_FREQ_SHIFT      );
+	ctx->rsp->mcns_status.timing_offset = (((( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2168B_MCNS_STATUS_RESPONSE_TIMING_OFFSET_LSB ) & Si2168B_MCNS_STATUS_RESPONSE_TIMING_OFFSET_MASK) <<Si2168B_MCNS_STATUS_RESPONSE_TIMING_OFFSET_SHIFT ) >>Si2168B_MCNS_STATUS_RESPONSE_TIMING_OFFSET_SHIFT );
+	ctx->rsp->mcns_status.constellation =   (( ( (rspByteBuffer[8]  )) >> Si2168B_MCNS_STATUS_RESPONSE_CONSTELLATION_LSB ) & Si2168B_MCNS_STATUS_RESPONSE_CONSTELLATION_MASK );
+	ctx->rsp->mcns_status.sp_inv        =   (( ( (rspByteBuffer[8]  )) >> Si2168B_MCNS_STATUS_RESPONSE_SP_INV_LSB        ) & Si2168B_MCNS_STATUS_RESPONSE_SP_INV_MASK        );
+	ctx->rsp->mcns_status.interleaving  =   (( ( (rspByteBuffer[9]  )) >> Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_LSB  ) & Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_MASK  );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+#endif /* __MCNS__ */
+
+/************************************************************************************************************************
+  NAME: si2168b_set_invert_spectrum
+  DESCRIPTION: return the required invert_spectrum value depending on the settings:
+              front_end->demod->media
+              front_end->satellite_spectrum_inversion
+              front_end->lnb_type
+              front_end->unicable_spectrum_inversion
+
+  Parameter:  Pointer to Si2168B Context
+  Returns:    the required invert_spectrum value
+************************************************************************************************************************/
+static u8 si2168b_set_invert_spectrum(Si2168B_L2_Context *front_end)
+{
+	u8 inversion;
+
+	if (front_end->demod->media == Si2168B_TERRESTRIAL) {
+		inversion = Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_NORMAL;
+	}
+	return inversion;
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_SCAN_CTRL COMMAND                        */
+/*---------------------------------------------------*/
+static u8 si2168b_scan_ctrl(si2168b_context *ctx,
+		u8 action,
+		u32 tuned_rf_freq)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[8];
+	u8 rspByteBuffer[1];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B SCAN_CTRL\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_SCAN_CTRL_CMD;
+	cmdByteBuffer[1] = (u8) ( ( action        & Si2168B_SCAN_CTRL_CMD_ACTION_MASK        ) << Si2168B_SCAN_CTRL_CMD_ACTION_LSB);
+	cmdByteBuffer[2] = (u8)0x00;
+	cmdByteBuffer[3] = (u8)0x00;
+	cmdByteBuffer[4] = (u8) ( ( tuned_rf_freq & Si2168B_SCAN_CTRL_CMD_TUNED_RF_FREQ_MASK ) << Si2168B_SCAN_CTRL_CMD_TUNED_RF_FREQ_LSB);
+	cmdByteBuffer[5] = (u8) ((( tuned_rf_freq & Si2168B_SCAN_CTRL_CMD_TUNED_RF_FREQ_MASK ) << Si2168B_SCAN_CTRL_CMD_TUNED_RF_FREQ_LSB)>>8);
+	cmdByteBuffer[6] = (u8) ((( tuned_rf_freq & Si2168B_SCAN_CTRL_CMD_TUNED_RF_FREQ_MASK ) << Si2168B_SCAN_CTRL_CMD_TUNED_RF_FREQ_LSB)>>16);
+	cmdByteBuffer[7] = (u8) ((( tuned_rf_freq & Si2168B_SCAN_CTRL_CMD_TUNED_RF_FREQ_MASK ) << Si2168B_SCAN_CTRL_CMD_TUNED_RF_FREQ_LSB)>>24);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 8, cmdByteBuffer) != 8) {
+		SiTRACE("Error writing SCAN_CTRL bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 1, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling SCAN_CTRL response\n");
+		ret = error_code;
+	}
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+/************************************************************************************************************************
+  NAME: si2168b_channel_seek_init
+  DESCRIPTION: logs the seek parameters in the context structure
+  Programming Guide Reference:    Flowchart TBD (Channel Scan flowchart)
+
+  Parameter:  Pointer to Si2168B Context
+  Parameter:  starting Frequency Hz
+  Parameter:  ending Frequency Hz
+  Parameter:  min RSSI dBm
+  Parameter:  max RSSI dBm
+  Parameter:  min SNR 1/2 dB
+  Parameter:  max SNR 1/2 dB
+  Returns:    0 if successful, otherwise an error.
+************************************************************************************************************************/
+static int si2168b_channel_seek_init(struct dvb_frontend *fe, Si2168B_CHANNEL_SEEK_PARAM_struct *seek_param)
+{
+	const u8 scan_ien_buzien = Si2168B_SCAN_IEN_PROP_BUZIEN_ENABLE; /* (default 'DISABLE') */
+	const u8 scan_ien_reqien = Si2168B_SCAN_IEN_PROP_REQIEN_ENABLE; /* (default 'DISABLE') */
+	const u8 scan_int_sense_reqnegen = Si2168B_SCAN_INT_SENSE_PROP_REQNEGEN_DISABLE; /* (default 'DISABLE') */
+	const u8 scan_int_sense_reqposen = Si2168B_SCAN_INT_SENSE_PROP_REQPOSEN_ENABLE;  /* (default 'ENABLE') */
+	const u8 scan_int_sense_buznegen = Si2168B_SCAN_INT_SENSE_PROP_BUZNEGEN_ENABLE;  /* (default 'ENABLE') */
+	const u8 scan_int_sense_buzposen = Si2168B_SCAN_INT_SENSE_PROP_BUZPOSEN_DISABLE; /* (default 'DISABLE') */
+    const u8 scan_ter_config_analog_bw = Si2168B_SCAN_TER_CONFIG_PROP_ANALOG_BW_8MHZ;
+    const u8 scan_ter_config_search_analog = Si2168B_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_DISABLE;
+
+#ifdef ALLOW_Si2168B_BLINDSCAN_DEBUG
+	const u8 scan_ter_config_scan_debug = 0x0f;
+#else
+	const u8 scan_ter_config_scan_debug = 0;
+#endif /* ALLOW_Si2168B_BLINDSCAN_DEBUG */
+
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+	Si2168B_L2_Context *front_end = priv->si_front_end;
+	Si2168B_SCAN_STATUS_CMD_REPLY_struct scan_status;
+	u8  modulation = 0;
+	u16 data;
+	u8  dd_mode_bw = seek_param->seekBWHz / 1000000;
+	u8  dd_mode_modulation = front_end->standard;
+	u8  dd_mode_auto_detect = Si2168B_DD_MODE_PROP_AUTO_DETECT_NONE;
+	u8  dd_mode_invert_spectrum = Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_DEFAULT;
+	u8  dvbt2_mode_lock_mode;
+	u8  dvbt_hierarchy_stream;
+	u8  dvbc_constellation_constellation;
+#ifdef __MCNS__
+	u8  mcns_constellation_constellation;
+#endif
+	u16 scan_fmin = front_end->demod->scan_fmin;
+	u16 scan_fmax = front_end->demod->scan_fmax;
+	u16 scan_symb_rate_min = front_end->demod->scan_symb_rate_min;
+	u16 scan_symb_rate_max = front_end->demod->scan_symb_rate_max;
+    u8  scan_ter_config_mode;
+
+	if (front_end->demod->media == Si2168B_TERRESTRIAL) {
+		SiTRACE("media TERRESTRIAL\n");
+		front_end->tuneUnitHz = 1;
+	}
+	SiTRACE ("blindscan_interaction >> (init  ) si2168b_scan_ctrl( front_end->demod, Si2168B_SCAN_CTRL_CMD_ACTION_ABORT)\n");
+	si2168b_scan_ctrl(front_end->demod, Si2168B_SCAN_CTRL_CMD_ACTION_ABORT, 0);
+	/* Check detection standard based on dd_mode.modulation and dd_mode.auto_detect */
+	SiTRACE("dd_mode.modulation %d, dd_mode.auto_detect %d\n",  dd_mode_modulation, dd_mode_auto_detect);
+	switch (dd_mode_modulation) {
+	case Si2168B_DD_MODE_PROP_MODULATION_AUTO_DETECT:
+		switch (dd_mode_auto_detect) {
+		case Si2168B_DD_MODE_PROP_AUTO_DETECT_AUTO_DVB_T_T2:
+			modulation = Si2168B_DD_MODE_PROP_MODULATION_DVBT2;
+			break;
+		default:
+			SiTRACE("AUTO DETECT '%d' is not managed by si2168b_channel_seek_init\n", dd_mode_auto_detect);
+			break;
+		}
+		break;
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBC:
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBT2:
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBT:
+		modulation = dd_mode_modulation;
+		break;
+	default:
+		SiTRACE("'%d' modulation (%s) is not managed by si2168b_channel_seek_init\n", dd_mode_modulation, si2168b_standard_name(dd_mode_modulation));
+		break;
+	}
+	SiTRACE("si2168b_channel_seek_init for %s (%d)\n", si2168b_standard_name(modulation), modulation );
+	switch (modulation) {
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBC:
+		/* Forcing BW to 8 MHz for DVB-C */
+		seek_param->seekBWHz = 8000000;
+		dd_mode_modulation  = Si2168B_DD_MODE_PROP_MODULATION_DVBC;
+		dd_mode_auto_detect = Si2168B_DD_MODE_PROP_AUTO_DETECT_NONE;
+		dvbc_constellation_constellation = Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_AUTO;
+		data = (dvbc_constellation_constellation & Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_MASK) << Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_LSB;
+		si2168b_set_property(front_end->demod, Si2168B_DVBC_CONSTELLATION_PROP, data);
+		SiTRACE("DVB-C AFC range %d\n", 100);
+		break;
+#ifdef __MCNS__
+	case Si2168B_DD_MODE_PROP_MODULATION_MCNS:
+		/* Forcing BW to 8 MHz for MCNS */
+		seekBWHz = 8000000;
+		dd_mode_modulation  = Si2168B_DD_MODE_PROP_MODULATION_MCNS;
+		dd_mode_auto_detect = Si2168B_DD_MODE_PROP_AUTO_DETECT_NONE;
+		mcns_constellation_constellation = Si2168B_MCNS_CONSTELLATION_PROP_CONSTELLATION_AUTO;
+		data = (mcns_constellation_constellation & Si2168B_MCNS_CONSTELLATION_PROP_CONSTELLATION_MASK) << Si2168B_MCNS_CONSTELLATION_PROP_CONSTELLATION_LSB;
+		si2168b_set_property(front_end->demod, Si2168B_MCNS_CONSTELLATION_PROP, data);
+		SiTRACE("MCNS AFC range %d\n", front_end->demod->prop->mcns_afc_range);
+		break;
+#endif /* __MCNS__ */
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBT2:
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBT:
+		dvbt_hierarchy_stream = Si2168B_DVBT_HIERARCHY_PROP_STREAM_LP;
+		data = (dvbt_hierarchy_stream & Si2168B_DVBT_HIERARCHY_PROP_STREAM_MASK) << Si2168B_DVBT_HIERARCHY_PROP_STREAM_LSB;
+		si2168b_set_property(front_end->demod, Si2168B_DVBT_HIERARCHY_PROP, data);
+		dd_mode_modulation  = Si2168B_DD_MODE_PROP_MODULATION_AUTO_DETECT;
+		dd_mode_auto_detect = Si2168B_DD_MODE_PROP_AUTO_DETECT_AUTO_DVB_T_T2;
+		SiTRACE("DVB-T AFC range %d DVB-T2 AFC range %d\n", 550, 550);
+		si2168b_dvbt2_plp_select(front_end->demod, 0, Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_AUTO);
+		dvbt2_mode_lock_mode = Si2168B_DVBT2_MODE_PROP_LOCK_MODE_ANY;
+		data = (dvbt2_mode_lock_mode & Si2168B_DVBT2_MODE_PROP_LOCK_MODE_MASK) << Si2168B_DVBT2_MODE_PROP_LOCK_MODE_LSB;
+		si2168b_set_property(front_end->demod, Si2168B_DVBT2_MODE_PROP, data);
+		break;
+	default:
+		SiTRACE("'%d' modulation (%s) is not managed by si2168b_channel_seek_init\n", modulation, si2168b_standard_name(modulation));
+		break;
+	}
+
+	front_end->seekAbort = 0;
+
+	SiTRACE("si2168b_channel_seek_init with %d to  %d, sawBW %d, minSR %d, maxSR %d\n", seek_param->rangeMin, seek_param->rangeMax, seek_param->seekBWHz, seek_param->minSRbps, seek_param->maxSRbps);
+	SiTRACE("spectrum inversion %d\n",front_end->demod->dd_mode_invert_spectrum );
+	scan_fmin = front_end->tuneUnitHz ? seek_param->rangeMin >> 16 : seek_param->rangeMin & 0x0000FFFF;
+	scan_fmax = front_end->tuneUnitHz ? seek_param->rangeMax >> 16 : seek_param->rangeMax & 0x0000FFFF;
+	scan_symb_rate_min = seek_param->minSRbps / 1000;
+	scan_symb_rate_max = seek_param->maxSRbps / 1000;
+
+	data = (scan_fmin & Si2168B_SCAN_FMIN_PROP_SCAN_FMIN_MASK) << Si2168B_SCAN_FMIN_PROP_SCAN_FMIN_LSB;
+	si2168b_set_property(front_end->demod, Si2168B_SCAN_FMIN_PROP, data);
+	data = (scan_fmax & Si2168B_SCAN_FMAX_PROP_SCAN_FMAX_MASK) << Si2168B_SCAN_FMAX_PROP_SCAN_FMAX_LSB;
+	si2168b_set_property(front_end->demod, Si2168B_SCAN_FMAX_PROP, data);
+	data = (scan_symb_rate_min & Si2168B_SCAN_SYMB_RATE_MIN_PROP_SCAN_SYMB_RATE_MIN_MASK) << Si2168B_SCAN_SYMB_RATE_MIN_PROP_SCAN_SYMB_RATE_MIN_LSB;
+	si2168b_set_property(front_end->demod, Si2168B_SCAN_SYMB_RATE_MIN_PROP, data);
+	data = (scan_symb_rate_max & Si2168B_SCAN_SYMB_RATE_MAX_PROP_SCAN_SYMB_RATE_MAX_MASK) << Si2168B_SCAN_SYMB_RATE_MAX_PROP_SCAN_SYMB_RATE_MAX_LSB;
+	si2168b_set_property(front_end->demod, Si2168B_SCAN_SYMB_RATE_MAX_PROP, data);
+
+	data = (scan_ien_buzien & Si2168B_SCAN_IEN_PROP_BUZIEN_MASK) << Si2168B_SCAN_IEN_PROP_BUZIEN_LSB |
+           (scan_ien_reqien & Si2168B_SCAN_IEN_PROP_REQIEN_MASK) << Si2168B_SCAN_IEN_PROP_REQIEN_LSB;
+	si2168b_set_property(front_end->demod, Si2168B_SCAN_IEN_PROP, data);
+
+    data = (scan_int_sense_buznegen & Si2168B_SCAN_INT_SENSE_PROP_BUZNEGEN_MASK) << Si2168B_SCAN_INT_SENSE_PROP_BUZNEGEN_LSB |
+           (scan_int_sense_reqnegen & Si2168B_SCAN_INT_SENSE_PROP_REQNEGEN_MASK) << Si2168B_SCAN_INT_SENSE_PROP_REQNEGEN_LSB |
+           (scan_int_sense_buzposen & Si2168B_SCAN_INT_SENSE_PROP_BUZPOSEN_MASK) << Si2168B_SCAN_INT_SENSE_PROP_BUZPOSEN_LSB |
+           (scan_int_sense_reqposen & Si2168B_SCAN_INT_SENSE_PROP_REQPOSEN_MASK) << Si2168B_SCAN_INT_SENSE_PROP_REQPOSEN_LSB ;
+	si2168b_set_property(front_end->demod, Si2168B_SCAN_INT_SENSE_PROP, data);
+
+	if (front_end->demod->media == Si2168B_TERRESTRIAL) {
+		if ( seek_param->rangeMin == seek_param->rangeMax ) {
+			scan_ter_config_mode = Si2168B_SCAN_TER_CONFIG_PROP_MODE_BLIND_LOCK;
+			SiTRACE("Blindlock < %8d %8d > < %8d %8d >\n", front_end->demod->scan_fmin, front_end->demod->scan_fmax, front_end->demod->scan_symb_rate_min, front_end->demod->scan_symb_rate_max);
+		} else {
+			scan_ter_config_mode = Si2168B_SCAN_TER_CONFIG_PROP_MODE_BLIND_SCAN;
+			SiTRACE("Blindscan < %8d %8d > < %8d %8d >\n", front_end->demod->scan_fmin, front_end->demod->scan_fmax, front_end->demod->scan_symb_rate_min, front_end->demod->scan_symb_rate_max);
+		}
+	    data = (scan_ter_config_mode          & Si2168B_SCAN_TER_CONFIG_PROP_MODE_MASK         ) << Si2168B_SCAN_TER_CONFIG_PROP_MODE_LSB  |
+	           (scan_ter_config_analog_bw     & Si2168B_SCAN_TER_CONFIG_PROP_ANALOG_BW_MASK    ) << Si2168B_SCAN_TER_CONFIG_PROP_ANALOG_BW_LSB  |
+	           (scan_ter_config_search_analog & Si2168B_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_MASK) << Si2168B_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_LSB |
+	           (scan_ter_config_scan_debug    & Si2168B_SCAN_TER_CONFIG_PROP_SCAN_DEBUG_MASK   ) << Si2168B_SCAN_TER_CONFIG_PROP_SCAN_DEBUG_LSB ;
+		si2168b_set_property(front_end->demod, Si2168B_SCAN_TER_CONFIG_PROP, data);
+		if (seek_param->seekBWHz == 1700000) {
+			dd_mode_bw = Si2168B_DD_MODE_PROP_BW_BW_1D7MHZ;
+		} else {
+			dd_mode_bw = seek_param->seekBWHz / 1000000;
+		}
+	}
+    data = (dd_mode_bw              & Si2168B_DD_MODE_PROP_BW_MASK             ) << Si2168B_DD_MODE_PROP_BW_LSB  |
+           (dd_mode_modulation      & Si2168B_DD_MODE_PROP_MODULATION_MASK     ) << Si2168B_DD_MODE_PROP_MODULATION_LSB  |
+           (dd_mode_invert_spectrum & Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_MASK) << Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_LSB  |
+           (dd_mode_auto_detect     & Si2168B_DD_MODE_PROP_AUTO_DETECT_MASK    ) << Si2168B_DD_MODE_PROP_AUTO_DETECT_LSB ;
+	si2168b_set_property(front_end->demod, Si2168B_DD_MODE_PROP, data);
+
+	si2168b_dd_restart(front_end->demod);
+
+	si2168b_scan_status(front_end->demod, Si2168B_SCAN_STATUS_CMD_INTACK_OK, &scan_status);
+	SiTRACE("blindscan_status leaving Seek_Init %s\n", si2168b_trace_scan_status(scan_status.scan_status) );
+	/* Preparing the next call to si2168b_scan_ctrl which needs to be a 'START'*/
+	front_end->demod->scan_ctrl_action = Si2168B_SCAN_CTRL_CMD_ACTION_START;
+	front_end->handshakeOn = 0;
+	SiTRACE("blindscan_handshake : Seek_Next will return every ~%d ms\n", front_end->handshakePeriod_ms );
+	return 0;
+}
+
+/************************************************************************************************************************
+  NAME: si2168b_channel_seek_next
+  DESCRIPTION: Looks for the next channel, starting from the last detected channel
+  Programming Guide Reference:    Flowchart TBD (Channel Scan flowchart)
+
+  Parameter:  Pointer to Si2168B Context
+  Returns:    1 if channel is found, 0 otherwise (either abort or end of range)
+              Any other value represents the time spent searching (if front_end->handshakeUsed == 1)
+************************************************************************************************************************/
+static int si2168b_channel_seek_next(struct dvb_frontend *fe, Si2168B_CHANNEL_SEEK_PARAM_struct *seek_param, Si2168B_CHANNEL_SEEK_NEXT_REPLY_struct *channel_status)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+	Si2168B_L2_Context *front_end = priv->si_front_end;
+	Si2168B_DD_STATUS_CMD_REPLY_struct    dd_status = { 0 };
+	Si2168B_DVBT_STATUS_CMD_REPLY_struct  dvbt_status = { 0 };
+	Si2168B_DVBT2_STATUS_CMD_REPLY_struct dvbt2_status = { 0 };
+	Si2168B_DVBC_STATUS_CMD_REPLY_struct  dvbc_status = { 0 };
+	Si2168B_SCAN_STATUS_CMD_REPLY_struct  scan_status = { 0 };
+	int return_code;
+	int seek_freq;
+	int seek_freq_kHz;
+	s32 detected_rf;
+	int channelIncrement;
+	int startTime;        /* startTime is used to measure internal durations. It is set in various places, whenever required                                                       */
+	int seekStartTime;    /* seekStartTime    is used to trace the time spent in si2168b_channel_seek_next and is only set when entering the function                            */
+	int buzyStartTime;    /* buzyStartTime   is used to trace the time spent waiting for scan_status.buz to be different from 'BUZY'                                               */
+	int timeoutStartTime; /* timeoutStartTime is used to make sure the FW is correctly responding. It is set differently from seekStartTime when returning from a handshake        */
+	int searchStartTime = 0;  /* searchStartTime  is used to trace the time spent trying to detect a channel. It is set differently from seekStartTime when returning from a handshake */
+	int timeoutDelay;
+	int handshakeDelay;
+	int searchDelay;
+	int max_lock_time_ms;
+	int min_lock_time_ms;
+	int max_decision_time_ms;
+	int blind_mode = 0;
+	int skip_resume;
+	int start_resume;
+	u8 previous_scan_status;
+	u8 jump_to_next_channel;
+	si2168b_context *ctx;
+
+	scan_status.scan_status = Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_IDLE;
+
+	ctx = front_end->demod;
+
+	/* Clear all return values which may not be used depending on the standard */
+	channel_status->bandwidth_Hz    = 0;
+	channel_status->stream          = 0;
+	channel_status->symbol_rate_bps = 0;
+	channel_status->constellation   = 0;
+	channel_status->num_plp         = 0;
+	channel_status->T2_base_lite    = 0;
+
+	if (front_end->seekAbort) {
+		SiTRACE("si2168b_channel_seek_next : previous run aborted. Please si2168b_channel_seek_init to perform a new search.\n");
+		return 0;
+	}
+
+	SiTRACE("front_end->standard %d (%s)\n",front_end->standard, si2168b_standard_name(front_end->standard) );
+
+	/* Setting max and max lock times and blind_mode flag */
+	switch ( front_end->standard ) {
+	/* For T/T2 detection, use the max value between Si2168B_DVBT_MAX_LOCK_TIME and Si2168B_DVBT2_MAX_LOCK_TIME */
+	/* With Si2168B-A, it's Si2168B_DVBT2_MAX_LOCK_TIME                                                         */
+	/* This value will be refined as soon as the standard is known, i.e. when PCL = 1                         */
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBT2:
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBT:
+		blind_mode = 0;
+		max_lock_time_ms = Si2168B_DVBT_MAX_LOCK_TIME;
+		max_lock_time_ms = Si2168B_DVBT2_MAX_LOCK_TIME;
+		min_lock_time_ms = Si2168B_DVBT_MIN_LOCK_TIME;
+		break;
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBC:
+		blind_mode = 1;
+		max_lock_time_ms = Si2168B_DVBC_MAX_SEARCH_TIME;
+		min_lock_time_ms = Si2168B_DVBC_MIN_LOCK_TIME;
+		break;
+	default:
+		SiTRACE("'%d' standard (%s) is not managed by si2168b_channel_seek_next\n", front_end->demod->dd_mode_modulation, si2168b_standard_name(front_end->demod->dd_mode_modulation));
+		front_end->seekAbort = 1;
+		return 0;
+	}
+	SiTRACE("blindscan : max_lock_time_ms %d\n", max_lock_time_ms);
+
+	seekStartTime = system_time();
+
+	if (front_end->handshakeUsed == 0) {
+		start_resume = 1;
+		searchStartTime = seekStartTime;
+	}
+
+	if (front_end->handshakeUsed == 1) {
+		/* Skip tuner and demod settings if recalled after handshaking */
+		if (front_end->handshakeOn == 1) {
+			start_resume = 0;
+			SiTRACE("blindscan_handshake : recalled after handshake. Skipping tuner and demod settings\n");
+		}
+		if (front_end->handshakeOn == 0) {
+			start_resume = 1;
+			if (front_end->demod->scan_ctrl_action == Si2168B_SCAN_CTRL_CMD_ACTION_START) {
+				SiTRACE("blindscan_handshake : no handshake : starting.\n");
+			} else {
+				SiTRACE("blindscan_handshake : no handshake : resuming.\n");
+			}
+			front_end->handshakeStart_ms = seekStartTime;
+			SiTRACE("blindscan_handshake : handshake start %d\n", front_end->handshakeStart_ms);
+		}
+		searchStartTime = front_end->handshakeStart_ms;
+	}
+
+	if (start_resume == 1) {
+		/* Enabling FEF control for T/T2 */
+		switch ( front_end->standard ) {
+		case Si2168B_DD_MODE_PROP_MODULATION_DVBT2:
+		case Si2168B_DD_MODE_PROP_MODULATION_DVBT:
+			if ( front_end->tuner_indirect_i2c_connection ) {  /* INDIRECT_I2C_CONNECTION? */
+				front_end->f_TER_tuner_enable(front_end->callback);
+			} else {
+				si2168b_tuner_i2c_enable(front_end);
+			}
+			si2168b_ter_fef(front_end,1);
+			if ( front_end->tuner_indirect_i2c_connection ) {  /* INDIRECT_I2C_CONNECTION? */
+				front_end->f_TER_tuner_disable(front_end->callback);
+			} else {
+				si2168b_tuner_i2c_disable(front_end);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	max_decision_time_ms = max_lock_time_ms;
+
+	/* Select TER channel increment (this value will only be used for 'TER' scanning) */
+	channelIncrement = seek_param->seekStepHz;
+
+	/* Start Seeking */
+	SiTRACE("si2168b_channel_seek_next rangeMin %10d, rangeMax %10d blind_mode %d\n", seek_param->rangeMin, seek_param->rangeMax, blind_mode);
+
+	seek_freq = seek_param->rangeMin;
+
+	if (blind_mode == 0) { /* DVB-T / DVB-T2 */
+		while ( seek_freq <= seek_param->rangeMax ) {
+			/* Call the si2168b_tune command to tune the frequency */
+			if (si2168b_set_tuner_params(fe, seek_freq )!= seek_freq) {
+				/* Manage possible tune error */
+				SiTRACE("si2168b_channel_seek_next Tune error at %d, aborting (skipped)\n", seek_freq);
+				front_end->seekAbort = 1;
+				return 0;
+			}
+
+			timeoutStartTime = system_time();
+			si2168b_dd_restart(ctx);
+
+			/* as we will not lock in less than min_lock_time_ms, wait a while... */
+			msleep(min_lock_time_ms);
+
+			jump_to_next_channel = 0;
+
+			while (!jump_to_next_channel) {
+
+				if ((front_end->standard == Si2168B_DD_MODE_PROP_MODULATION_DVBT) || (front_end->standard == Si2168B_DD_MODE_PROP_MODULATION_DVBT2) ) {
+
+					return_code = si2168b_dd_status(ctx, Si2168B_DD_STATUS_CMD_INTACK_CLEAR, &dd_status);
+					if (return_code != NO_Si2168B_ERROR) {
+						SiTRACE("si2168b_channel_seek_next: si2168b_dd_status error at %d, aborting\n", seek_freq);
+						front_end->seekAbort = 1;
+						return 0;
+					}
+
+					searchDelay = system_time() - searchStartTime;
+
+					if ( (dd_status.dl == Si2168B_DD_STATUS_RESPONSE_DL_NO_LOCK) && (dd_status.rsqstat_bit5 == Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT5_NO_CHANGE ) ) {
+						/* Check PCL to refine the max_lock_time_ms value if the standard has been detected */
+						if (dd_status.pcl == Si2168B_DD_STATUS_RESPONSE_PCL_LOCKED) {
+							if (dd_status.modulation == Si2168B_DD_STATUS_RESPONSE_MODULATION_DVBT) {
+								max_lock_time_ms = Si2168B_DVBT_MAX_LOCK_TIME ;
+							}
+						}
+					}
+					if ( (dd_status.dl == Si2168B_DD_STATUS_RESPONSE_DL_NO_LOCK) && (dd_status.rsqstat_bit5 == Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT5_CHANGED) ) {
+						SiTRACE ("NO DVBT/T2. Jumping from  %d after %3d ms\n", seek_freq/1000000, searchDelay);
+						if (seek_freq == seek_param->rangeMax) {
+							seek_param->rangeMin = seek_freq;
+						}
+						seek_freq = seek_freq + channelIncrement;
+						jump_to_next_channel = 1;
+						break;
+					}
+					if ( (dd_status.dl == Si2168B_DD_STATUS_RESPONSE_DL_LOCKED) && (dd_status.rsqstat_bit5 == Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT5_NO_CHANGE ) ) {
+						channel_status->standard = dd_status.modulation;
+						if (channel_status->standard == Si2168B_DD_STATUS_RESPONSE_MODULATION_DVBT) {
+							si2168b_dvbt_status(ctx, Si2168B_DVBT_STATUS_CMD_INTACK_CLEAR, &dvbt_status);
+							detected_rf = seek_freq + dvbt_status.afc_freq * 1000;
+							if (dvbt_status.hierarchy == Si2168B_DVBT_STATUS_RESPONSE_HIERARCHY_NONE) {
+								channel_status->stream = Si2168B_DVBT_HIERARCHY_PROP_STREAM_HP;
+							} else {
+								channel_status->stream = dvbt_status.hierarchy;
+							}
+							channel_status->bandwidth_Hz = front_end->demod->dd_mode_bw * 1000000;
+							channel_status->freq         = detected_rf;
+							SiTRACE ("DVB-T  lock at %d after %3d ms\n", (detected_rf)/1000000, searchDelay);
+						}
+						if (channel_status->standard == Si2168B_DD_STATUS_RESPONSE_MODULATION_DVBT2) {
+							if ( front_end->tuner_indirect_i2c_connection ) {  /* INDIRECT_I2C_CONNECTION? */
+								front_end->f_TER_tuner_enable(front_end->callback);
+							} else {
+								si2168b_tuner_i2c_enable(front_end);
+							}
+							si2168b_ter_fef(front_end,1);
+							if ( front_end->tuner_indirect_i2c_connection ) {  /* INDIRECT_I2C_CONNECTION? */
+								front_end->f_TER_tuner_disable(front_end->callback);
+							} else {
+								si2168b_tuner_i2c_disable(front_end);
+							}
+							si2168b_dvbt2_status(ctx, Si2168B_DVBT_STATUS_CMD_INTACK_CLEAR, &dvbt2_status);
+							channel_status->num_plp = dvbt2_status.num_plp;
+							detected_rf = seek_freq + dvbt2_status.afc_freq * 1000;
+							SiTRACE ("DVB-T2 lock at %d after %3d ms\n", detected_rf / 1000000, searchDelay);
+							switch (front_end->demod->dd_mode_bw) {
+							case Si2168B_DD_MODE_PROP_BW_BW_1D7MHZ : {
+								channel_status->bandwidth_Hz = 1700000;
+								break;
+							}
+							default: {
+								channel_status->bandwidth_Hz = front_end->demod->dd_mode_bw * 1000000;
+								break; }
+							}
+							channel_status->T2_base_lite = dvbt2_status.t2_mode;
+							channel_status->freq         = detected_rf;
+						}
+						/* Set min seek_freq for next seek */
+						seek_param->rangeMin = seek_freq + seek_param->seekBWHz;
+						/* Return 1 to signal that the Si2168B is locked on a valid channel */
+						return 1;
+					}
+				}
+
+				/* timeout management (this should only trigger if the channel is very difficult, i.e. when pcl = 1 and dl = 0 until the timeout) */
+				timeoutDelay = system_time() - timeoutStartTime;
+				if (timeoutDelay >= max_lock_time_ms) {
+					SiTRACE ("Timeout (blind_mode = 0) from  %d after %3d ms\n", seek_freq/1000000, timeoutDelay);
+					seek_freq = seek_freq + channelIncrement;
+					jump_to_next_channel = 1;
+					break;
+				}
+				/* Check status every n ms */
+				msleep(10);
+			}
+		}
+	}
+
+	if (blind_mode == 1) { /* DVB-C / DVB-S / DVB-S2 / MCNS */
+
+		if (front_end->tuneUnitHz == 1) {
+			seek_freq_kHz = seek_freq / 1000;
+		} else {
+			seek_freq_kHz = seek_freq;
+		}
+
+		previous_scan_status = scan_status.scan_status;
+		/* Checking blindscan status before issuing a 'start' or 'resume' */
+		si2168b_scan_status(front_end->demod, Si2168B_SCAN_STATUS_CMD_INTACK_OK, &scan_status);
+		SiTRACE("blindscan_status      %s buz %d\n", si2168b_trace_scan_status(scan_status.scan_status), scan_status.buz);
+
+		if (scan_status.scan_status != previous_scan_status) {
+			SiTRACE ("scan_status changed from %s to %s\n", si2168b_trace_scan_status(previous_scan_status), si2168b_trace_scan_status(scan_status.scan_status));
+		}
+
+		if (start_resume) {
+			/* Wait for scan_status.buz to be '0' before issuing SCAN_CTRL */
+			buzyStartTime = system_time();
+			while (scan_status.buz == Si2168B_SCAN_STATUS_RESPONSE_BUZ_BUSY) {
+				si2168b_scan_status(front_end->demod, Si2168B_SCAN_STATUS_CMD_INTACK_OK, &scan_status);
+				SiTRACE ("blindscan_interaction ?? (buzy)   si2168b_scan_status scan_status.buz %d after %d ms\n", scan_status.buz, system_time() - buzyStartTime);
+				if (system_time() - buzyStartTime > 100) {
+					SiTRACE ("blindscan_interaction -- (error)  si2168b_scan_status is always 'BUZY'\n");
+					return 0;
+				}
+			}
+			if (front_end->demod->scan_ctrl_action == Si2168B_SCAN_CTRL_CMD_ACTION_START) {
+				SiTRACE ("blindscan_interaction >> (start ) si2168b_scan_ctrl( front_end->demod, %d, %8d) \n", front_end->demod->scan_ctrl_action, seek_freq_kHz);
+			} else {
+				SiTRACE ("blindscan_interaction >> (resume) si2168b_scan_ctrl( front_end->demod, %d, %8d) \n", front_end->demod->scan_ctrl_action, seek_freq_kHz);
+			}
+			return_code = si2168b_scan_ctrl (front_end->demod, front_end->demod->scan_ctrl_action, seek_freq_kHz);
+			if (return_code != NO_Si2168B_ERROR) {
+				SiTRACE ("blindscan_interaction -- (error1) si2168b_scan_ctrl %d      ERROR at %10d (%d)\n!!!!!!!!!!!!!!!!!!!!!!!\n", front_end->demod->scan_ctrl_action, seek_freq_kHz, scan_status.scan_status);
+				SiTRACE("scan_status.buz %d\n", scan_status.buz);
+				return 0;
+			}
+		}
+		front_end->demod->scan_ctrl_action = Si2168B_SCAN_CTRL_CMD_ACTION_RESUME;
+
+		startTime = system_time();
+		/* as we will not lock in less than min_lock_time_ms, wait a while... */
+		while (system_time() - startTime < min_lock_time_ms) {
+			if (front_end->seekAbort) {
+				break;
+			}
+			/* Adapt here the minimal 'reaction time' of the application*/
+			msleep(20);
+		}
+
+		timeoutStartTime = system_time();
+
+		/* The actual search loop... */
+		while ( 1 ) {
+
+			si2168b_check_status(front_end->demod);
+
+			searchDelay = system_time() - searchStartTime;
+
+			if ( (front_end->demod->status_scanint == Si2168B_STATUS_SCANINT_TRIGGERED) ) {
+
+				/* There is an interaction with the FW, refresh the timeoutStartTime */
+				timeoutStartTime = system_time();
+
+				si2168b_scan_status(front_end->demod, Si2168B_SCAN_STATUS_CMD_INTACK_CLEAR, &scan_status);
+				SiTRACE("blindscan_status      %s\n", si2168b_trace_scan_status(scan_status.scan_status) );
+				skip_resume = 0;
+
+				switch (scan_status.scan_status) {
+				case  Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_TUNE_REQUEST          : {
+					SiTRACE ("blindscan_interaction -- (tune  ) SCAN TUNE_REQUEST at %8ld kHz\n", scan_status.rf_freq);
+					if (front_end->tuneUnitHz == 1) {
+						seek_freq = si2168b_set_tuner_params(fe, scan_status.rf_freq*1000);
+						seek_freq_kHz = seek_freq/1000;
+					} else {
+						seek_freq = si2168b_set_tuner_params(fe, scan_status.rf_freq);
+						seek_freq_kHz = seek_freq;
+					}
+					channel_status->freq = seek_param->rangeMin = seek_freq;
+					/* as we will not lock in less than min_lock_time_ms, wait a while... */
+					msleep(min_lock_time_ms);
+					break;
+				}
+				case  Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_DIGITAL_CHANNEL_FOUND : {
+					channel_status->standard = scan_status.modulation;
+					switch (scan_status.modulation) {
+					case Si2168B_SCAN_STATUS_RESPONSE_MODULATION_DVBC : {
+						channel_status->freq            = scan_status.rf_freq * 1000;
+						channel_status->symbol_rate_bps = scan_status.symb_rate * 1000;
+						si2168b_dvbc_status(front_end->demod, Si2168B_DVBC_STATUS_CMD_INTACK_OK, &dvbc_status);
+						front_end->demod->dvbc_symbol_rate = scan_status.symb_rate;
+						channel_status->constellation = dvbc_status.constellation;
+						break;
+					}
+#ifdef __MCNS__
+					case Si2168B_SCAN_STATUS_RESPONSE_MODULATION_MCNS : {
+						*freq            = front_end->demod->rsp->scan_status.rf_freq * 1000;
+						*symbol_rate_bps = front_end->demod->rsp->scan_status.symb_rate * 1000;
+						si2168b_mcns_status(front_end->demod, Si2168B_MCNS_STATUS_CMD_INTACK_OK);
+						front_end->demod->prop->mcns_symbol_rate.rate = front_end->demod->rsp->scan_status.symb_rate;
+						*constellation   = front_end->demod->rsp->mcns_status.constellation;
+						break;
+					}
+#endif /* __MCNS__ */
+					default : {
+						SiTRACE("si2168b_channel_seek_next DIGITAL_CHANNEL_FOUND error at %d: un-handled modulation (%d), aborting (skipped)\n", seek_freq, scan_status.modulation);
+						front_end->seekAbort = 1;
+						return 0;
+					}
+					}
+					SiTRACE ("blindscan_interaction -- (locked) SCAN DIGITAL lock at %d MHz after %3d ms. modulation %3d (%s)\n", channel_status->freq/1000, searchDelay, channel_status->standard, si2168b_standard_name(channel_status->standard));
+					front_end->handshakeOn = 0;
+					return 1;
+				}
+				case  Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_ERROR: {
+					SiTRACE ("blindscan_interaction -- (error2) SCAN error at %d after %4d ms\n", seek_freq/1000000, searchDelay);
+					front_end->handshakeOn = 0;
+					return 0;
+				}
+				case  Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_SEARCHING: {
+					SiTRACE("SCAN Searching...\n");
+					skip_resume = 1;
+					break;
+				}
+				case  Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_ENDED: {
+					SiTRACE ("blindscan_interaction -- (ended ) SCAN ENDED\n");
+					si2168b_scan_ctrl (front_end->demod, Si2168B_SCAN_CTRL_CMD_ACTION_ABORT , 0);
+					front_end->handshakeOn = 0;
+					return 0;
+				}
+#ifdef ALLOW_Si2168B_BLINDSCAN_DEBUG
+				case  Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_DEBUG                 : {
+					SiTRACE ("blindscan_interaction -- (debug) SCAN DEBUG code %d\n", front_end->demod->rsp->scan_status.symb_rate);
+					switch (front_end->demod->rsp->scan_status.symb_rate) {
+					case 4: { /* SPECTRUM */
+#ifndef DO_NOT_DRAW_SPECTRUM
+						Si2168B_plot(front_end, "spectrum", 0, seek_freq);
+#endif /* DO_NOT_DRAW_SPECTRUM */
+						break;
+					}
+					case 9: { /* TRYLOCK */
+#ifndef DO_NOT_TRACK_TRYLOCKS
+						Si2168B_plot(front_end, "trylock", 0, seek_freq);
+#endif /* DO_NOT_DRAW_SPECTRUM */
+						break;
+					}
+					default: {}
+					}
+					/* There has been a debug request by the FW, refresh the timeoutStartTime */
+					timeoutStartTime = system_time();
+					break;
+				}
+#else /* ALLOW_Si2168B_BLINDSCAN_DEBUG */
+				case  63                 : {
+					SiTRACE("blindscan_interaction -- (warning) You probably run a DEBUG fw, so you need to define ALLOW_Si2168B_BLINDSCAN_DEBUG at project level\n");
+					break;
+				}
+#endif /* ALLOW_Si2168B_BLINDSCAN_DEBUG */
+				default : {
+					SiTRACE("unknown scan_status %d\n", scan_status.scan_status);
+					skip_resume = 1;
+					break;
+				}
+				}
+
+				if (skip_resume == 0) {
+					SiTRACE ("blindscan_interaction >> (resume) si2168b_scan_ctrl( front_end->demod, %d, %8d)\n", front_end->demod->scan_ctrl_action, seek_freq_kHz);
+					return_code = si2168b_scan_ctrl(front_end->demod, front_end->demod->scan_ctrl_action, seek_freq_kHz);
+					if (return_code != NO_Si2168B_ERROR) {
+						SiTRACE("si2168b_scan_ctrl ERROR at %d (%d)\n!!!!!!!!!!!!!!!!!!!!!!!\n", seek_freq_kHz, scan_status.scan_status);
+						SiTRACE("si2168b_scan_ctrl 'RESUME' ERROR during seek loop\n");
+					}
+				}
+			}
+
+			/* timeout management (this should never happen if timeout values are correctly set) */
+			timeoutDelay = system_time() - timeoutStartTime;
+			if (system_time() - timeoutStartTime >= max_decision_time_ms) {
+				SiTRACE ("Scan decision timeout (blind_mode = 1) from  %d after %d ms. Check your timeout limits!\n", seek_freq_kHz/1000, timeoutDelay);
+				front_end->seekAbort   = 1;
+				front_end->handshakeOn = 0;
+				break;
+			}
+
+			if (front_end->handshakeUsed) {
+				handshakeDelay = system_time() - seekStartTime;
+				if (handshakeDelay >= front_end->handshakePeriod_ms) {
+					SiTRACE ("blindscan_handshake : handshake after %5d ms (at %10d). (search delay %6d ms) %*s\n", handshakeDelay, seek_param->rangeMin, searchDelay, (searchDelay)/1000, "*");
+					channel_status->freq = seek_freq;
+					front_end->handshakeOn = 1;
+					/* The application will check handshakeStart_ms to know whether the blindscan is ended or not */
+					return searchDelay;
+				} else {
+					SiTRACE ("blindscan_handshake : no handshake yet. (handshake delay %6d ms, search delay %6d ms)\n", handshakeDelay, searchDelay);
+				}
+			}
+
+			/* Check seekAbort flag (set in case of timeout or by the top-level application) */
+			if (front_end->seekAbort) {
+				/* Abort the SCAN loop to allow it to restart with the new rangeMin frequency */
+				SiTRACE ("blindscan_interaction >> (abort!) si2168b_scan_ctrl(front_end->demod, Si2168B_SCAN_CTRL_CMD_ACTION_ABORT)\n");
+				si2168b_scan_ctrl (front_end->demod, Si2168B_SCAN_CTRL_CMD_ACTION_ABORT , 0);
+				front_end->handshakeOn = 0;
+				return 0;
+			}
+
+			/* Check status every 100 ms */
+			msleep(100);
+		}
+	}
+	front_end->handshakeOn = 0;
+	return 0;
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_POWER_DOWN COMMAND                       */
+/*---------------------------------------------------*/
+static u8 si2168b_power_down(si2168b_context *ctx)
+{
+	u8 cmdByteBuffer[1];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("si2168b_power_down\n");
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_POWER_DOWN_CMD;
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 1, cmdByteBuffer) != 1) {
+		SiTRACE("Error writing POWER_DOWN bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+	}
+
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+/************************************************************************************************************************
+  NAME: si2168b_standby
+  DESCRIPTION:
+  Parameter:  Pointer to Si2168B Context
+  Returns:    I2C transaction error code, NO_Si2168B_ERROR if successful
+************************************************************************************************************************/
+static int si2168b_standby(si2168b_context *ctx)
+{
+	SiTRACE("si2168b_standby()\n");
+	return si2168b_power_down(ctx);
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_PART_INFO COMMAND                        */
+/*---------------------------------------------------*/
+static u8 si2168b_part_info(si2168b_context *ctx, Si2168B_PART_INFO_CMD_REPLY_struct *part_info)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[1];
+	u8 rspByteBuffer[13];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B PART_INFO\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_PART_INFO_CMD;
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 1, cmdByteBuffer) != 1) {
+		SiTRACE("Error writing PART_INFO bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 13, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling PART_INFO response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	part_info->chiprev  =   (( ( (rspByteBuffer[1]  )) >> Si2168B_PART_INFO_RESPONSE_CHIPREV_LSB  ) & Si2168B_PART_INFO_RESPONSE_CHIPREV_MASK  );
+	part_info->part     =   (( ( (rspByteBuffer[2]  )) >> Si2168B_PART_INFO_RESPONSE_PART_LSB     ) & Si2168B_PART_INFO_RESPONSE_PART_MASK     );
+	part_info->pmajor   =   (( ( (rspByteBuffer[3]  )) >> Si2168B_PART_INFO_RESPONSE_PMAJOR_LSB   ) & Si2168B_PART_INFO_RESPONSE_PMAJOR_MASK   );
+	part_info->pminor   =   (( ( (rspByteBuffer[4]  )) >> Si2168B_PART_INFO_RESPONSE_PMINOR_LSB   ) & Si2168B_PART_INFO_RESPONSE_PMINOR_MASK   );
+	part_info->pbuild   =   (( ( (rspByteBuffer[5]  )) >> Si2168B_PART_INFO_RESPONSE_PBUILD_LSB   ) & Si2168B_PART_INFO_RESPONSE_PBUILD_MASK   );
+	part_info->reserved =   (( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2168B_PART_INFO_RESPONSE_RESERVED_LSB ) & Si2168B_PART_INFO_RESPONSE_RESERVED_MASK );
+	part_info->serial   =   (( ( (rspByteBuffer[8]  ) | (rspByteBuffer[9]  << 8 ) | (rspByteBuffer[10] << 16 ) | (rspByteBuffer[11] << 24 )) >> Si2168B_PART_INFO_RESPONSE_SERIAL_LSB   ) & Si2168B_PART_INFO_RESPONSE_SERIAL_MASK   );
+	part_info->romid    =   (( ( (rspByteBuffer[12] )) >> Si2168B_PART_INFO_RESPONSE_ROMID_LSB    ) & Si2168B_PART_INFO_RESPONSE_ROMID_MASK    );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+/***********************************************************************************************************************
+  si2168b_patch function
+  Use:        Patch information function
+              Used to send a number of bytes to the Si2168B. Useful to download the firmware.
+  Returns:    0 if no error
+  Parameter:  error_code the error code.
+  Porting:    Useful for application development for debug purposes.
+  Porting:    May not be required for the final application, can be removed if not used.
+ ***********************************************************************************************************************/
+static u8 si2168b_patch(si2168b_context *ctx, int iNbBytes, u8 *pucDataBuffer)
+{
+	int res;
+	u8 ret = NO_Si2168B_ERROR;
+	u8 rspByteBuffer[1];
+
+	SiTRACE("Si2168B Patch %d bytes\n",iNbBytes);
+
+	_mutex_lock(&ctx->lock);
+
+	res = i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, iNbBytes, pucDataBuffer);
+	if (res!=iNbBytes) {
+		SiTRACE("si2168b_patch error writing bytes: %s\n", si2168b_error_text(ERROR_Si2168B_LOADING_FIRMWARE) );
+		ret = ERROR_Si2168B_LOADING_FIRMWARE;
+		goto unlock_mutex;
+	}
+
+	res = si2168b_poll_for_response(ctx, 1, rspByteBuffer);
+	if (res != NO_Si2168B_ERROR) {
+		SiTRACE("si2168b_patch error 0x%02x polling response: %s\n", res, si2168b_error_text(res) );
+		ret = ERROR_Si2168B_POLLING_RESPONSE;
+	}
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+/************************************************************************************************************************
+  NAME: si2168b_load_firmware_16
+  DESCRIPTON: Load firmware from firmware_struct array in Si2168B_Firmware_x_y_build_z.h file into Si2168B
+              Requires Si2168B to be in bootloader mode after PowerUp
+
+  Parameter:  Si2168B Context (I2C address)
+  Parameter:  pointer to firmware_struct array
+  Parameter:  number of lines in firmware table array (size in bytes / firmware_struct)
+  Returns:    Si2168B/I2C transaction error code, NO_Si2168B_ERROR if successful
+************************************************************************************************************************/
+static int si2168b_load_firmware_16(si2168b_context *ctx, firmware_struct fw_table[], int nbLines)
+{
+	int return_code = NO_Si2168B_ERROR;
+	int line;
+
+	SiTRACE ("si2168b_load_firmware_16 starting...\n");
+	SiTRACE ("si2168b_load_firmware_16 nbLines %d\n", nbLines);
+
+	/* for each line in fw_table */
+	for (line = 0; line < nbLines; line++) {
+		if (fw_table[line].firmware_len > 0)  /* don't download if length is 0 , e.g. dummy firmware */
+		{
+			/* send firmware_len bytes (up to 16) to Si2168B */
+			if ((return_code = si2168b_patch(ctx, fw_table[line].firmware_len, fw_table[line].firmware_table)) != NO_Si2168B_ERROR)
+			{
+				SiTRACE("si2168b_load_firmware_16 error 0x%02x patching line %d: %s\n", return_code, line, si2168b_error_text(return_code) );
+				if (line == 0) {
+					SiTRACE("The firmware is incompatible with the part!\n");
+				}
+				return ERROR_Si2168B_LOADING_FIRMWARE;
+			}
+			if (line==3) {
+				sitraces_suspend();
+			}
+		}
+	}
+	sitraces_resume();
+	SiTRACE ("si2168b_load_firmware_16 complete...\n");
+	return NO_Si2168B_ERROR;
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_EXIT_BOOTLOADER COMMAND                  */
+/*---------------------------------------------------*/
+static u8 si2168b_exit_bootloader(si2168b_context *ctx,
+		u8 func,
+		u8 ctsien)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[1];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B EXIT_BOOTLOADER\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_EXIT_BOOTLOADER_CMD;
+	cmdByteBuffer[1] = (u8) ( ( func   & Si2168B_EXIT_BOOTLOADER_CMD_FUNC_MASK   ) << Si2168B_EXIT_BOOTLOADER_CMD_FUNC_LSB  |
+			( ctsien & Si2168B_EXIT_BOOTLOADER_CMD_CTSIEN_MASK ) << Si2168B_EXIT_BOOTLOADER_CMD_CTSIEN_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing EXIT_BOOTLOADER bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 1, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling EXIT_BOOTLOADER response\n");
+		ret = error_code;
+	}
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+/************************************************************************************************************************
+  NAME: si2168b_start_firmware
+  DESCRIPTION: Start Si2168B firmware (put the Si2168B into run mode)
+  Parameter:   Si2168B Context (I2C address)
+  Parameter (passed by Reference):   ExitBootloadeer Response Status byte : tunint, atvint, dtvint, err, cts
+  Returns:     I2C transaction error code, NO_Si2168B_ERROR if successful
+ ************************************************************************************************************************/
+static int si2168b_start_firmware(si2168b_context *ctx)
+{
+	int ret = NO_Si2168B_ERROR;
+
+	ret = si2168b_exit_bootloader(ctx, Si2168B_EXIT_BOOTLOADER_CMD_FUNC_NORMAL, Si2168B_EXIT_BOOTLOADER_CMD_CTSIEN_OFF);
+	if (ret != NO_Si2168B_ERROR) {
+		return ERROR_Si2168B_STARTING_FIRMWARE;
+	}
+
+	return NO_Si2168B_ERROR;
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_GET_REV COMMAND                          */
+/*---------------------------------------------------*/
+static u8 si2168b_get_revision(si2168b_context *ctx, Si2168B_GET_REV_CMD_REPLY_struct *get_rev)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[1];
+	u8 rspByteBuffer[10];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B GET_REV\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_GET_REV_CMD;
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 1, cmdByteBuffer) != 1) {
+		SiTRACE("Error writing GET_REV bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 10, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling GET_REV response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	get_rev->pn       =   (( ( (rspByteBuffer[1]  )) >> Si2168B_GET_REV_RESPONSE_PN_LSB       ) & Si2168B_GET_REV_RESPONSE_PN_MASK       );
+	get_rev->fwmajor  =   (( ( (rspByteBuffer[2]  )) >> Si2168B_GET_REV_RESPONSE_FWMAJOR_LSB  ) & Si2168B_GET_REV_RESPONSE_FWMAJOR_MASK  );
+	get_rev->fwminor  =   (( ( (rspByteBuffer[3]  )) >> Si2168B_GET_REV_RESPONSE_FWMINOR_LSB  ) & Si2168B_GET_REV_RESPONSE_FWMINOR_MASK  );
+	get_rev->patch    =   (( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 )) >> Si2168B_GET_REV_RESPONSE_PATCH_LSB    ) & Si2168B_GET_REV_RESPONSE_PATCH_MASK    );
+	get_rev->cmpmajor =   (( ( (rspByteBuffer[6]  )) >> Si2168B_GET_REV_RESPONSE_CMPMAJOR_LSB ) & Si2168B_GET_REV_RESPONSE_CMPMAJOR_MASK );
+	get_rev->cmpminor =   (( ( (rspByteBuffer[7]  )) >> Si2168B_GET_REV_RESPONSE_CMPMINOR_LSB ) & Si2168B_GET_REV_RESPONSE_CMPMINOR_MASK );
+	get_rev->cmpbuild =   (( ( (rspByteBuffer[8]  )) >> Si2168B_GET_REV_RESPONSE_CMPBUILD_LSB ) & Si2168B_GET_REV_RESPONSE_CMPBUILD_MASK );
+	get_rev->chiprev  =   (( ( (rspByteBuffer[9]  )) >> Si2168B_GET_REV_RESPONSE_CHIPREV_LSB  ) & Si2168B_GET_REV_RESPONSE_CHIPREV_MASK  );
+	get_rev->mcm_die  =   (( ( (rspByteBuffer[9]  )) >> Si2168B_GET_REV_RESPONSE_MCM_DIE_LSB  ) & Si2168B_GET_REV_RESPONSE_MCM_DIE_MASK  );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+/************************************************************************************************************************
+  NAME: si2168b_power_up_with_patch
+  DESCRIPTION: Send Si2168B API PowerUp Command with PowerUp to bootloader,
+  Check the Chip rev and part, and ROMID are compared to expected values.
+  Load the Firmware Patch then Start the Firmware.
+  Programming Guide Reference:    Flowchart A.2 (POWER_UP with patch flowchart)
+
+  Parameter:  pointer to Si2168B Context
+  Returns:    Si2168B/I2C transaction error code, NO_Si2168B_ERROR if successful
+************************************************************************************************************************/
+static int si2168b_power_up_with_patch(si2168b_context *ctx)
+{
+	int return_code = NO_Si2168B_ERROR;
+	int fw_loaded = 0;
+	Si2168B_GET_REV_CMD_REPLY_struct get_rev;
+	Si2168B_PART_INFO_CMD_REPLY_struct part_info = { 0 };
+
+	/* Before patching, set POWER_UP values for 'RESET' and 'BOOTLOADER' */
+	ctx->power_up_reset = Si2168B_POWER_UP_CMD_RESET_RESET;
+	ctx->power_up_func  = Si2168B_POWER_UP_CMD_FUNC_BOOTLOADER,
+
+	return_code = si2168b_wakeup(ctx);
+
+	if (return_code != NO_Si2168B_ERROR) {
+		SiTRACE("si2168b_power_up_with_patch: WAKEUP error!\n");
+		return return_code;
+	}
+
+	ctx->Si2168B_in_standby = 0;
+
+	/* Get the Part Info from the chip.   This command is only valid in Bootloader mode */
+	if ((return_code = si2168b_part_info(ctx, &part_info)) != NO_Si2168B_ERROR) {
+		SiTRACE ("si2168b_part_info error 0x%02x: %s\n", return_code, si2168b_error_text(return_code) );
+		return return_code;
+	}
+	SiTRACE("part    Si21%02d", part_info.part   );
+	if (part_info.chiprev == Si2168B_PART_INFO_RESPONSE_CHIPREV_A) {
+		SiTRACE("A\n");
+	} else if (part_info.chiprev == Si2168B_PART_INFO_RESPONSE_CHIPREV_B) {
+		SiTRACE("B\n");
+	} else {
+		SiTRACE("\nchiprev %d\n", part_info.chiprev);
+	}
+	SiTRACE("romid   %d\n",     part_info.romid  );
+	SiTRACE("pmajor  0x%02x\n", part_info.pmajor );
+	SiTRACE("pminor  0x%02x\n", part_info.pminor );
+	SiTRACE("pbuild  %d\n",     part_info.pbuild );
+	if ((part_info.pmajor >= 0x30) & (part_info.pminor >= 0x30)) {
+		SiTRACE("Full Info       'Si21%02d-%c%c%c ROM%x NVM%c_%cb%d'\n\n\n", part_info.part, part_info.chiprev + 0x40, part_info.pmajor, part_info.pminor, part_info.romid, part_info.pmajor, part_info.pminor, part_info.pbuild );
+	}
+
+	/* Check part info values and load the proper firmware */
+#ifdef    Si2168B_A40_COMPATIBLE
+#ifdef    Si2168B_PATCH16_4_4b7_LINES
+	if (!fw_loaded) {
+		SiTRACE  ("Is this part a  'Si21%2d_ROM%x_%c_%c_b%d'?\n", Si2168B_PATCH16_4_4b7_PART, Si2168B_PATCH16_4_4b7_ROM, Si2168B_PATCH16_4_4b7_PMAJOR, Si2168B_PATCH16_4_4b7_PMINOR, Si2168B_PATCH16_4_4b7_PBUILD );
+		if ((ctx->rsp->part_info.romid  == Si2168B_PATCH16_4_4b7_ROM   )
+				&(  (ctx->rsp->part_info.part == 64 )
+						|| (ctx->rsp->part_info.part == 62 )
+						|| (ctx->rsp->part_info.part == 60 )
+				)
+				& (ctx->rsp->part_info.pmajor == Si2168B_PATCH16_4_4b7_PMAJOR)
+				& (ctx->rsp->part_info.pminor == Si2168B_PATCH16_4_4b7_PMINOR)
+				& (ctx->rsp->part_info.pbuild == Si2168B_PATCH16_4_4b7_PBUILD)
+		) {
+			SiTRACE("Updating FW for 'Si21%2d NVM%c_%cb%d'\n", ctx->rsp->part_info.part, ctx->rsp->part_info.pmajor, ctx->rsp->part_info.pminor, ctx->rsp->part_info.pbuild );
+#ifdef    Si2168B_PATCH16_4_4b7_INFOS
+			SiTRACE(Si2168B_PATCH16_4_4b7_INFOS);
+#endif /* Si2168B_PATCH16_4_4b7_INFOS */
+			if ((return_code = si2168b_load_firmware_16(ctx, Si2168B_PATCH16_4_4b7, Si2168B_PATCH16_4_4b7_LINES)) != NO_Si2168B_ERROR) {
+				SiTRACE ("si2168b_load_firmware_16 error 0x%02x: %s\n", return_code, si2168b_error_text(return_code) );
+				return return_code;
+			}
+			fw_loaded++;
+		}
+	}
+#endif /* Si2168B_PATCH16_4_4b7_LINES */
+#ifdef    Si2168B_PATCH16_4_0b9_LINES
+	if (!fw_loaded) {
+		SiTRACE  ("Is this part a  'Si21%2d_ROM%x_%c_%c_b%d'?\n", Si2168B_PATCH16_4_0b9_PART, Si2168B_PATCH16_4_0b9_ROM, Si2168B_PATCH16_4_0b9_PMAJOR, Si2168B_PATCH16_4_0b9_PMINOR, Si2168B_PATCH16_4_0b9_PBUILD );
+		if ((part_info.romid  == Si2168B_PATCH16_4_0b9_ROM   )
+				&& (  (part_info.part == 69 )
+						|| (part_info.part == 68 )
+				)
+				&& (part_info.pmajor == Si2168B_PATCH16_4_0b9_PMAJOR)
+				&& (part_info.pminor == Si2168B_PATCH16_4_0b9_PMINOR)
+				&& (part_info.pbuild == Si2168B_PATCH16_4_0b9_PBUILD)
+		) {
+			SiTRACE("Updating FW for 'Si21%2d NVM%c_%cb%d'\n", part_info.part, part_info.pmajor, part_info.pminor, part_info.pbuild);
+#ifdef    Si2168B_PATCH16_4_0b9_INFOS
+			SiTRACE(Si2168B_PATCH16_4_0b9_INFOS);
+#endif /* Si2168B_PATCH16_4_0b9_INFOS */
+			if ((return_code = si2168b_load_firmware_16(ctx, Si2168B_PATCH16_4_0b9, Si2168B_PATCH16_4_0b9_LINES)) != NO_Si2168B_ERROR) {
+				SiTRACE ("si2168b_load_firmware_16 error 0x%02x: %s\n", return_code, si2168b_error_text(return_code) );
+				return return_code;
+			}
+			fw_loaded++;
+		}
+	}
+#endif /* Si2168B_PATCH16_4_0b9_LINES */
+#endif /* Si2168B_A40_COMPATIBLE */
+#ifdef    Si2168B_ES_COMPATIBLE
+#ifdef    Si2168B_FIRMWARE_3_Ab12_LINES
+	if (!fw_loaded) {
+		SiTRACE  ("Is this part a  'Si21%2d_ROM%x_%c_%c_b%d'?\n", Si2168B_FIRMWARE_3_Ab12_PART, Si2168B_FIRMWARE_3_Ab12_ROM, Si2168B_FIRMWARE_3_Ab12_PMAJOR, Si2168B_FIRMWARE_3_Ab12_PMINOR, Si2168B_FIRMWARE_3_Ab12_PBUILD );
+		if ((ctx->rsp->part_info.romid  == Si2168B_FIRMWARE_3_Ab12_ROM   )
+				&(  (ctx->rsp->part_info.part == 69 )
+						|| (ctx->rsp->part_info.part == 68 )
+						|| (ctx->rsp->part_info.part == 64 )
+						|| (ctx->rsp->part_info.part == 62 )
+						|| (ctx->rsp->part_info.part == 60 )
+						|| (ctx->rsp->part_info.part == 0  )
+				)
+				/*
+        & (ctx->rsp->part_info.pmajor == Si2168B_FIRMWARE_3_Ab12_PMAJOR)
+        & (ctx->rsp->part_info.pminor == Si2168B_FIRMWARE_3_Ab12_PMINOR)
+        & (ctx->rsp->part_info.pbuild == Si2168B_FIRMWARE_3_Ab12_PBUILD)
+				 */
+		) {
+			SiTRACE("Updating FW for 'Si21%2d NVM%c_%cb%d' (full download)\n", ctx->rsp->part_info.part, ctx->rsp->part_info.pmajor, ctx->rsp->part_info.pminor, ctx->rsp->part_info.pbuild );
+#ifdef    Si2168B_FIRMWARE_3_Ab12_INFOS
+			SiTRACE(Si2168B_FIRMWARE_3_Ab12_INFOS);
+#endif /* Si2168B_FIRMWARE_3_Ab12_INFOS */
+			if ((return_code = Si2168B_LoadFirmware(ctx, Si2168B_FIRMWARE_3_Ab12, Si2168B_FIRMWARE_3_Ab12_LINES)) != NO_Si2168B_ERROR) {
+				SiTRACE ("Si2168B_LoadFirmware error 0x%02x: %s\n", return_code, si2168b_error_text(return_code) );
+				return return_code;
+			}
+			fw_loaded++;
+		}
+	}
+#endif /* Si2168B_FIRMWARE_3_Ab12_LINES */
+#endif /* Si2168B_ES_COMPATIBLE */
+#ifdef    Si2169_30_COMPATIBLE
+#ifdef    Si2169_PATCH_3_0b18_LINES
+	if (!fw_loaded) {
+		SiTRACE  ("Is this part a  'Si21%2d_ROM%x_%c_%c_b%d'?\n", Si2169_PATCH_3_0b18_PART, Si2169_PATCH_3_0b18_ROM, Si2169_PATCH_3_0b18_PMAJOR, Si2169_PATCH_3_0b18_PMINOR, Si2169_PATCH_3_0b18_PBUILD );
+		if ((ctx->rsp->part_info.romid  == Si2169_PATCH_3_0b18_ROM   )
+				&((ctx->rsp->part_info.part   == 69 ) || (ctx->rsp->part_info.part == 68 ))
+				& (ctx->rsp->part_info.pmajor == Si2169_PATCH_3_0b18_PMAJOR)
+				& (ctx->rsp->part_info.pminor == Si2169_PATCH_3_0b18_PMINOR)
+				& (ctx->rsp->part_info.pbuild == Si2169_PATCH_3_0b18_PBUILD)) {
+			SiTRACE("Updating FW for 'Si21%2d_ROM%x %c_%c_b%d'\n", ctx->rsp->part_info.part, ctx->rsp->part_info.romid, ctx->rsp->part_info.pmajor, ctx->rsp->part_info.pminor, ctx->rsp->part_info.pbuild );
+#ifdef    Si2169_PATCH_3_0b18_INFOS
+			SiTRACE(Si2169_PATCH_3_0b18_INFOS);
+#endif /* Si2169_PATCH_3_0b18_INFOS */
+			if ((return_code = Si2168B_LoadFirmware(ctx, Si2169_PATCH_3_0b18, Si2169_PATCH_3_0b18_LINES)) != NO_Si2168B_ERROR) {
+				SiTRACE ("Si2169_LoadFirmware error 0x%02x: %s\n", return_code, si2168b_error_text(return_code) );
+				return return_code;
+			}
+			fw_loaded++;
+		}
+	}
+#endif /* Si2169_PATCH_3_0b18_LINES */
+#endif /* Si2169_0_COMPATIBLE */
+#ifdef    Si2167B_20_COMPATIBLE
+#ifdef    Si2167B_PATCH_2_0b5_LINES
+	if (!fw_loaded) {
+		SiTRACE  ("Is this part a  'Si21%2d_ROM%x_%c_%c_b%d'?\n", Si2167B_PATCH_2_0b5_PART, Si2167B_PATCH_2_0b5_ROM, Si2167B_PATCH_2_0b5_PMAJOR, Si2167B_PATCH_2_0b5_PMINOR, Si2167B_PATCH_2_0b5_PBUILD );
+		if ((ctx->rsp->part_info.romid  == Si2167B_PATCH_2_0b5_ROM   )
+				&((ctx->rsp->part_info.part   == 67 ) || (ctx->rsp->part_info.part == 66 ))
+				& (ctx->rsp->part_info.pmajor == Si2167B_PATCH_2_0b5_PMAJOR)
+				& (ctx->rsp->part_info.pminor == Si2167B_PATCH_2_0b5_PMINOR)
+				& (ctx->rsp->part_info.pbuild == Si2167B_PATCH_2_0b5_PBUILD)) {
+			SiTRACE("Updating FW for 'Si21%2d_FW_%c_%c_b%d'\n", ctx->rsp->part_info.part, ctx->rsp->part_info.pmajor, ctx->rsp->part_info.pminor, ctx->rsp->part_info.pbuild );
+#ifdef    Si2167B_PATCH_2_0b5_INFOS
+			SiTRACE("%s\n", Si2167B_PATCH_2_0b5_INFOS);
+#endif /* Si2167B_PATCH_2_0b5_INFOS */
+			if ((return_code = Si2167B_LoadFirmware(ctx, Si2167B_PATCH_2_0b5, Si2167B_PATCH_2_0b5_LINES)) != NO_Si2167B_ERROR) {
+				SiTRACE ("Si2167B_LoadPatch error 0x%02x: %s\n", return_code, Si2167B_L1_API_ERROR_TEXT(return_code) );
+				return return_code;
+			}
+			fw_loaded++;
+		}
+	}
+#endif /* Si2167B_PATCH_2_0b5_LINES */
+#ifdef    Si2167B_20_PATCH_CUSTOMER_LINES
+	if (!fw_loaded) {
+		SiTRACE  ("Is this part a  'Si21%2d_ROM%x_%c_%c_b%d'?\n", Si2167B_20_PATCH_CUSTOMER_PART, Si2167B_20_PATCH_CUSTOMER_ROM, Si2167B_20_PATCH_CUSTOMER_PMAJOR, Si2167B_20_PATCH_CUSTOMER_PMINOR, Si2167B_20_PATCH_CUSTOMER_PBUILD );
+		if ((ctx->rsp->part_info.romid  == Si2167B_20_PATCH_CUSTOMER_ROM   )
+				&((ctx->rsp->part_info.part   == 67 ) || (ctx->rsp->part_info.part == 66 ))
+				& (ctx->rsp->part_info.pmajor == Si2167B_20_PATCH_CUSTOMER_PMAJOR)
+				& (ctx->rsp->part_info.pminor == Si2167B_20_PATCH_CUSTOMER_PMINOR)
+				& (ctx->rsp->part_info.pbuild == Si2167B_20_PATCH_CUSTOMER_PBUILD)) {
+			SiTRACE("Updating FW for 'Si21%2d_ROM%x %c_%c_b%d'\n", ctx->rsp->part_info.part, ctx->rsp->part_info.romid, ctx->rsp->part_info.pmajor, ctx->rsp->part_info.pminor, ctx->rsp->part_info.pbuild );
+#ifdef    Si2167B_20_PATCH_CUSTOMER_INFOS
+			SiTRACE(Si2167B_20_PATCH_CUSTOMER_INFOS);
+#endif /* Si2167B_20_PATCH_CUSTOMER_INFOS */
+			if ((return_code = Si2167B_LoadFirmware(ctx, Si2167B_20_PATCH_CUSTOMER, Si2167B_20_PATCH_CUSTOMER_LINES)) != NO_Si2167B_ERROR) {
+				SiTRACE ("Si2167B_LoadFirmware error 0x%02x: %s\n", return_code, Si2167B_L1_API_ERROR_TEXT(return_code) );
+				return return_code;
+			}
+			fw_loaded++;
+		}
+	}
+#endif /* Si2167B_20_PATCH_CUSTOMER_LINES */
+#ifdef    Si2167B_PATCH_2_0b21_LINES
+	if (!fw_loaded) {
+		SiTRACE  ("Is this part a  'Si21%2d_ROM%x_%c_%c_b%d'?\n", Si2167B_PATCH_2_0b21_PART, Si2167B_PATCH_2_0b21_ROM, Si2167B_PATCH_2_0b21_PMAJOR, Si2167B_PATCH_2_0b21_PMINOR, Si2167B_PATCH_2_0b21_PBUILD );
+		if ((ctx->rsp->part_info.romid  == Si2167B_PATCH_2_0b21_ROM   )
+				&((ctx->rsp->part_info.part   == 67 ) || (ctx->rsp->part_info.part == 66 ))
+				& (ctx->rsp->part_info.pmajor == Si2167B_PATCH_2_0b21_PMAJOR)
+				& (ctx->rsp->part_info.pminor == Si2167B_PATCH_2_0b21_PMINOR)
+				& (ctx->rsp->part_info.pbuild == Si2167B_PATCH_2_0b21_PBUILD)) {
+			SiTRACE("Updating FW for 'Si21%2d_FW_%c_%c_b%d'\n", ctx->rsp->part_info.part, ctx->rsp->part_info.pmajor, ctx->rsp->part_info.pminor, ctx->rsp->part_info.pbuild );
+#ifdef    Si2167B_PATCH_2_0b21_INFOS
+			SiTRACE("%s\n", Si2167B_PATCH_2_0b21_INFOS);
+#endif /* Si2167B_PATCH_2_0b21_INFOS */
+			if ((return_code = Si2168B_LoadFirmware(ctx, Si2167B_PATCH_2_0b21, Si2167B_PATCH_2_0b21_LINES)) != NO_Si2168B_ERROR) {
+				SiTRACE ("Si2167B_LoadPatch error 0x%02x: %s\n", return_code, si2168b_error_text(return_code) );
+				return return_code;
+			}
+			fw_loaded++;
+		}
+	}
+#endif /* Si2167B_PATCH_2_0b21_LINES */
+#endif /* Si2167B_20_COMPATIBLE */
+
+	if (!fw_loaded) {
+		SiTRACE ("Si2168B_LoadFirmware error: NO Firmware Loaded! Possible part/code incompatibility !\n");
+		return ERROR_Si2168B_LOADING_FIRMWARE;
+	}
+
+	/*Start the Firmware */
+	return_code = si2168b_start_firmware(ctx);
+	if (return_code != NO_Si2168B_ERROR) {
+		/* Start firmware */
+		SiTRACE ("si2168b_start_firmware error 0x%02x: %s\n", return_code, si2168b_error_text(return_code) );
+		return return_code;
+	}
+
+	return_code = si2168b_get_revision(ctx, &get_rev);
+	if (return_code == NO_Si2168B_ERROR) {
+		if ((get_rev.mcm_die) != Si2168B_GET_REV_RESPONSE_MCM_DIE_SINGLE) {
+			SiTRACE("Si21%2d%d-%c%c%c Die %c Part running 'FW_%c_%cb%d'\n", part_info.part
+					, 2
+					, part_info.chiprev + 0x40
+					, part_info.pmajor
+					, part_info.pminor
+					, get_rev.mcm_die   + 0x40
+					, get_rev.cmpmajor
+					, get_rev.cmpminor
+					, get_rev.cmpbuild );
+		} else {
+			SiTRACE("Si21%2d-%c%c%c Part running 'FW_%c_%cb%d'\n", part_info.part
+					, part_info.chiprev + 0x40
+					, part_info.pmajor
+					, part_info.pminor
+					, get_rev.cmpmajor
+					, get_rev.cmpminor
+					, get_rev.cmpbuild );
+		}
+	}
+
+	return NO_Si2168B_ERROR;
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_CONFIG_PINS COMMAND                      */
+/*---------------------------------------------------*/
+static u8 si2168b_config_pins(si2168b_context *ctx,
+		u8   gpio0_mode,
+		u8   gpio0_read,
+		u8   gpio1_mode,
+		u8   gpio1_read,
+		Si2168B_CONFIG_PINS_CMD_REPLY_struct *config_pins)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[3];
+	u8 rspByteBuffer[3];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B CONFIG_PINS\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_CONFIG_PINS_CMD;
+	cmdByteBuffer[1] = (u8) ( ( gpio0_mode & Si2168B_CONFIG_PINS_CMD_GPIO0_MODE_MASK ) << Si2168B_CONFIG_PINS_CMD_GPIO0_MODE_LSB|
+			( gpio0_read & Si2168B_CONFIG_PINS_CMD_GPIO0_READ_MASK ) << Si2168B_CONFIG_PINS_CMD_GPIO0_READ_LSB);
+	cmdByteBuffer[2] = (u8) ( ( gpio1_mode & Si2168B_CONFIG_PINS_CMD_GPIO1_MODE_MASK ) << Si2168B_CONFIG_PINS_CMD_GPIO1_MODE_LSB|
+			( gpio1_read & Si2168B_CONFIG_PINS_CMD_GPIO1_READ_MASK ) << Si2168B_CONFIG_PINS_CMD_GPIO1_READ_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 3, cmdByteBuffer) != 3) {
+		SiTRACE("Error writing CONFIG_PINS bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 3, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling CONFIG_PINS response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	config_pins->gpio0_mode  = (( ( (rspByteBuffer[1]  )) >> Si2168B_CONFIG_PINS_RESPONSE_GPIO0_MODE_LSB  ) & Si2168B_CONFIG_PINS_RESPONSE_GPIO0_MODE_MASK  );
+	config_pins->gpio0_state = (( ( (rspByteBuffer[1]  )) >> Si2168B_CONFIG_PINS_RESPONSE_GPIO0_STATE_LSB ) & Si2168B_CONFIG_PINS_RESPONSE_GPIO0_STATE_MASK );
+	config_pins->gpio1_mode  = (( ( (rspByteBuffer[2]  )) >> Si2168B_CONFIG_PINS_RESPONSE_GPIO1_MODE_LSB  ) & Si2168B_CONFIG_PINS_RESPONSE_GPIO1_MODE_MASK  );
+	config_pins->gpio1_state = (( ( (rspByteBuffer[2]  )) >> Si2168B_CONFIG_PINS_RESPONSE_GPIO1_STATE_LSB ) & Si2168B_CONFIG_PINS_RESPONSE_GPIO1_STATE_MASK );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+#ifdef __EXTRA_COMMANDS__
+/*---------------------------------------------------*/
+/* Si2168B_DVBT2_TX_ID COMMAND                      */
+/*---------------------------------------------------*/
+static u8 si2168b_dvbt2_tx_id(si2168b_context *ctx)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[1];
+	u8 rspByteBuffer[8];
+	u8 ret = NO_Si2168B_ERROR;
+#ifdef __COMMONREPLYOBJ__
+	dvbt2_tx_id->STATUS = ctx->status;
+#endif
+
+	SiTRACE("Si2168B DVBT2_TX_ID\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DVBT2_TX_ID_CMD;
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 1, cmdByteBuffer) != 1) {
+		SiTRACE("Error writing DVBT2_TX_ID bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 8, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DVBT2_TX_ID response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	ctx->rsp->dvbt2_tx_id.tx_id_availability =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBT2_TX_ID_RESPONSE_TX_ID_AVAILABILITY_LSB ) & Si2168B_DVBT2_TX_ID_RESPONSE_TX_ID_AVAILABILITY_MASK );
+	ctx->rsp->dvbt2_tx_id.cell_id            =   (( ( (rspByteBuffer[2]  ) | (rspByteBuffer[3]  << 8 )) >> Si2168B_DVBT2_TX_ID_RESPONSE_CELL_ID_LSB            ) & Si2168B_DVBT2_TX_ID_RESPONSE_CELL_ID_MASK            );
+	ctx->rsp->dvbt2_tx_id.network_id         =   (( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 )) >> Si2168B_DVBT2_TX_ID_RESPONSE_NETWORK_ID_LSB         ) & Si2168B_DVBT2_TX_ID_RESPONSE_NETWORK_ID_MASK         );
+	ctx->rsp->dvbt2_tx_id.t2_system_id       =   (( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2168B_DVBT2_TX_ID_RESPONSE_T2_SYSTEM_ID_LSB       ) & Si2168B_DVBT2_TX_ID_RESPONSE_T2_SYSTEM_ID_MASK       );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+#endif
+
+#ifdef __EXTRA_COMMANDS__
+/*---------------------------------------------------*/
+/* Si2168B_SPI_PASSTHROUGH COMMAND                  */
+/*---------------------------------------------------*/
+static u8 si2168b_spi_passthrough(si2168b_context *ctx,
+		u8   subcode,
+		u8   spi_passthr_clk,
+		u8   spi_passth_data)
+{
+	u8 cmdByteBuffer[4];
+	u8 ret = NO_Si2168B_ERROR;
+#ifdef __COMMONREPLYOBJ__
+	ctx->rsp->spi_passthrough.STATUS = ctx->status;
+#endif
+
+	SiTRACE("Si2168B SPI_PASSTHROUGH\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_SPI_PASSTHROUGH_CMD;
+	cmdByteBuffer[1] = (u8) ( ( subcode         & Si2168B_SPI_PASSTHROUGH_CMD_SUBCODE_MASK         ) << Si2168B_SPI_PASSTHROUGH_CMD_SUBCODE_LSB        );
+	cmdByteBuffer[2] = (u8) ( ( spi_passthr_clk & Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTHR_CLK_MASK ) << Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTHR_CLK_LSB);
+	cmdByteBuffer[3] = (u8) ( ( spi_passth_data & Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTH_DATA_MASK ) << Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTH_DATA_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 4, cmdByteBuffer) != 4) {
+		SiTRACE("Error writing SPI_PASSTHROUGH bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+	}
+
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+#endif
+
+#ifdef __EXTRA_COMMANDS__
+/*---------------------------------------------------*/
+/* Si2168B_DOWNLOAD_DATASET_CONTINUE COMMAND        */
+/*---------------------------------------------------*/
+static u8 si2168b_download_dataset_continue(si2168b_context *ctx,
+		u8 data0,
+		u8 data1,
+		u8 data2,
+		u8 data3,
+		u8 data4,
+		u8 data5,
+		u8 data6)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[8];
+	u8 rspByteBuffer[1];
+	u8 ret = NO_Si2168B_ERROR;
+#ifdef __COMMONREPLYOBJ__
+	ctx->rsp->download_dataset_continue.STATUS = ctx->status;
+#endif
+
+	SiTRACE("Si2168B DOWNLOAD_DATASET_CONTINUE\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD;
+	cmdByteBuffer[1] = (u8) ( ( data0 & Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_MASK ) << Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_LSB);
+	cmdByteBuffer[2] = (u8) ( ( data1 & Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_MASK ) << Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_LSB);
+	cmdByteBuffer[3] = (u8) ( ( data2 & Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_MASK ) << Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_LSB);
+	cmdByteBuffer[4] = (u8) ( ( data3 & Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_MASK ) << Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_LSB);
+	cmdByteBuffer[5] = (u8) ( ( data4 & Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_MASK ) << Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_LSB);
+	cmdByteBuffer[6] = (u8) ( ( data5 & Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_MASK ) << Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_LSB);
+	cmdByteBuffer[7] = (u8) ( ( data6 & Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_MASK ) << Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 8, cmdByteBuffer) != 8) {
+		SiTRACE("Error writing DOWNLOAD_DATASET_CONTINUE bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 1, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DOWNLOAD_DATASET_CONTINUE response\n");
+		ret = error_code;
+	}
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+#endif
+
+/*---------------------------------------------------*/
+/* Si2168B_DD_EXT_AGC_TER COMMAND                   */
+/*---------------------------------------------------*/
+static u8 si2168b_dd_ext_agc_ter(si2168b_context *ctx,
+		u8   agc_1_mode,
+		u8   agc_1_inv,
+		u8   agc_2_mode,
+		u8   agc_2_inv,
+		u8   agc_1_kloop,
+		u8   agc_2_kloop,
+		u8   agc_1_min,
+		u8   agc_2_min,
+		Si2168B_DD_EXT_AGC_TER_CMD_REPLY_struct *dd_ext_agc_ter)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[6];
+	u8 rspByteBuffer[3];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B DD_EXT_AGC_TER\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DD_EXT_AGC_TER_CMD;
+	cmdByteBuffer[1] = (u8) ( ( agc_1_mode  & Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MASK  ) << Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MODE_LSB |
+			( agc_1_inv   & Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_INV_MASK   ) << Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_INV_LSB  |
+			( agc_2_mode  & Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MASK  ) << Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MODE_LSB |
+			( agc_2_inv   & Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_INV_MASK   ) << Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_INV_LSB  );
+	cmdByteBuffer[2] = (u8) ( ( agc_1_kloop & Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_MASK ) << Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_LSB);
+	cmdByteBuffer[3] = (u8) ( ( agc_2_kloop & Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_MASK ) << Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_LSB);
+	cmdByteBuffer[4] = (u8) ( ( agc_1_min   & Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MIN_MASK   ) << Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MIN_LSB  );
+	cmdByteBuffer[5] = (u8) ( ( agc_2_min   & Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MIN_MASK   ) << Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MIN_LSB  );
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 6, cmdByteBuffer) != 6) {
+		SiTRACE("Error writing DD_EXT_AGC_TER bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 3, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DD_EXT_AGC_TER response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	dd_ext_agc_ter->agc_1_level = (( ( (rspByteBuffer[1]  )) >> Si2168B_DD_EXT_AGC_TER_RESPONSE_AGC_1_LEVEL_LSB ) & Si2168B_DD_EXT_AGC_TER_RESPONSE_AGC_1_LEVEL_MASK );
+	dd_ext_agc_ter->agc_2_level = (( ( (rspByteBuffer[2]  )) >> Si2168B_DD_EXT_AGC_TER_RESPONSE_AGC_2_LEVEL_LSB ) & Si2168B_DD_EXT_AGC_TER_RESPONSE_AGC_2_LEVEL_MASK );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+#ifdef __EXTRA_COMMANDS__
+/*---------------------------------------------------*/
+/* Si2168B_GET_PROPERTY COMMAND                     */
+/*---------------------------------------------------*/
+static u8 si2168b_get_property(si2168b_context *ctx,
+		u8   reserved,
+		unsigned int    prop)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[4];
+	u8 rspByteBuffer[4];
+	u8 ret = NO_Si2168B_ERROR;
+#ifdef __COMMONREPLYOBJ__
+	ctx->rsp->get_property.STATUS = ctx->status;
+#endif
+
+	SiTRACE("Si2168B GET_PROPERTY\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_GET_PROPERTY_CMD;
+	cmdByteBuffer[1] = (u8) ( ( reserved & Si2168B_GET_PROPERTY_CMD_RESERVED_MASK ) << Si2168B_GET_PROPERTY_CMD_RESERVED_LSB);
+	cmdByteBuffer[2] = (u8) ( ( prop     & Si2168B_GET_PROPERTY_CMD_PROP_MASK     ) << Si2168B_GET_PROPERTY_CMD_PROP_LSB    );
+	cmdByteBuffer[3] = (u8) ((( prop     & Si2168B_GET_PROPERTY_CMD_PROP_MASK     ) << Si2168B_GET_PROPERTY_CMD_PROP_LSB    )>>8);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 4, cmdByteBuffer) != 4) {
+		SiTRACE("Error writing GET_PROPERTY bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 4, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling GET_PROPERTY response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	ctx->rsp->get_property.reserved =   (( ( (rspByteBuffer[1]  )) >> Si2168B_GET_PROPERTY_RESPONSE_RESERVED_LSB ) & Si2168B_GET_PROPERTY_RESPONSE_RESERVED_MASK );
+	ctx->rsp->get_property.data     =   (( ( (rspByteBuffer[2]  ) | (rspByteBuffer[3]  << 8 )) >> Si2168B_GET_PROPERTY_RESPONSE_DATA_LSB     ) & Si2168B_GET_PROPERTY_RESPONSE_DATA_MASK     );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+#endif
+
+/*---------------------------------------------------*/
+/* Si2168B_DD_MP_DEFAULTS COMMAND                   */
+/*---------------------------------------------------*/
+static u8 si2168b_dd_mp_defaults(si2168b_context *ctx,
+		u8 mp_a_mode,
+		u8 mp_b_mode,
+		u8 mp_c_mode,
+		u8 mp_d_mode,
+		Si2168B_DD_MP_DEFAULTS_CMD_REPLY_struct *dd_mp_defaults)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[5];
+	u8 rspByteBuffer[5];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B DD_MP_DEFAULTS\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DD_MP_DEFAULTS_CMD;
+	cmdByteBuffer[1] = (u8) ( ( mp_a_mode & Si2168B_DD_MP_DEFAULTS_CMD_MP_A_MODE_MASK ) << Si2168B_DD_MP_DEFAULTS_CMD_MP_A_MODE_LSB);
+	cmdByteBuffer[2] = (u8) ( ( mp_b_mode & Si2168B_DD_MP_DEFAULTS_CMD_MP_B_MODE_MASK ) << Si2168B_DD_MP_DEFAULTS_CMD_MP_B_MODE_LSB);
+	cmdByteBuffer[3] = (u8) ( ( mp_c_mode & Si2168B_DD_MP_DEFAULTS_CMD_MP_C_MODE_MASK ) << Si2168B_DD_MP_DEFAULTS_CMD_MP_C_MODE_LSB);
+	cmdByteBuffer[4] = (u8) ( ( mp_d_mode & Si2168B_DD_MP_DEFAULTS_CMD_MP_D_MODE_MASK ) << Si2168B_DD_MP_DEFAULTS_CMD_MP_D_MODE_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 5, cmdByteBuffer) != 5) {
+		SiTRACE("Error writing DD_MP_DEFAULTS bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 5, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DD_MP_DEFAULTS response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	dd_mp_defaults->mp_a_mode = (( ( (rspByteBuffer[1]  )) >> Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_LSB ) & Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_MASK );
+	dd_mp_defaults->mp_b_mode = (( ( (rspByteBuffer[2]  )) >> Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_LSB ) & Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_MASK );
+	dd_mp_defaults->mp_c_mode = (( ( (rspByteBuffer[3]  )) >> Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_LSB ) & Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_MASK );
+	dd_mp_defaults->mp_d_mode = (( ( (rspByteBuffer[4]  )) >> Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_LSB ) & Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_MASK );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+#ifdef __EXTRA_COMMANDS__
+/*---------------------------------------------------*/
+/* Si2168B_DD_FER COMMAND                           */
+/*---------------------------------------------------*/
+static u8 Si2168B_L1_DD_FER(si2168b_context *ctx, u8 rst)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[3];
+	u8 ret = NO_Si2168B_ERROR;
+#ifdef __COMMONREPLYOBJ__
+	ctx->rsp->dd_fer.STATUS = ctx->status;
+#endif
+
+	SiTRACE("Si2168B DD_FER\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DD_FER_CMD;
+	cmdByteBuffer[1] = (u8) ( ( rst & Si2168B_DD_FER_CMD_RST_MASK ) << Si2168B_DD_FER_CMD_RST_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing DD_FER bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 3, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DD_FER response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	ctx->rsp->dd_fer.exp  =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DD_FER_RESPONSE_EXP_LSB  ) & Si2168B_DD_FER_RESPONSE_EXP_MASK  );
+	ctx->rsp->dd_fer.mant =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DD_FER_RESPONSE_MANT_LSB ) & Si2168B_DD_FER_RESPONSE_MANT_MASK );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+#endif
+
+#ifdef __EXTRA_COMMANDS__
+/*---------------------------------------------------*/
+/* Si2168B_SPI_LINK COMMAND                         */
+/*---------------------------------------------------*/
+static u8 Si2168B_L1_SPI_LINK(si2168b_context *ctx,
+		u8   subcode,
+		u8   spi_pbl_key,
+		u8   spi_pbl_num,
+		u8   spi_conf_clk,
+		u8   spi_clk_pola,
+		u8   spi_conf_data,
+		u8   spi_data_dir,
+		u8   spi_enable)
+{
+	u8 cmdByteBuffer[7];
+	u8 ret = NO_Si2168B_ERROR;
+#ifdef __COMMONREPLYOBJ__
+	ctx->rsp->spi_link.STATUS = ctx->status;
+#endif
+
+	SiTRACE("Si2168B SPI_LINK\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_SPI_LINK_CMD;
+	cmdByteBuffer[1] = (u8) ( ( subcode       & Si2168B_SPI_LINK_CMD_SUBCODE_MASK       ) << Si2168B_SPI_LINK_CMD_SUBCODE_LSB      );
+	cmdByteBuffer[2] = (u8) ( ( spi_pbl_key   & Si2168B_SPI_LINK_CMD_SPI_PBL_KEY_MASK   ) << Si2168B_SPI_LINK_CMD_SPI_PBL_KEY_LSB  );
+	cmdByteBuffer[3] = (u8) ( ( spi_pbl_num   & Si2168B_SPI_LINK_CMD_SPI_PBL_NUM_MASK   ) << Si2168B_SPI_LINK_CMD_SPI_PBL_NUM_LSB  );
+	cmdByteBuffer[4] = (u8) ( ( spi_conf_clk  & Si2168B_SPI_LINK_CMD_SPI_CONF_CLK_MASK  ) << Si2168B_SPI_LINK_CMD_SPI_CONF_CLK_LSB |
+			( spi_clk_pola  & Si2168B_SPI_LINK_CMD_SPI_CLK_POLA_MASK  ) << Si2168B_SPI_LINK_CMD_SPI_CLK_POLA_LSB );
+	cmdByteBuffer[5] = (u8) ( ( spi_conf_data & Si2168B_SPI_LINK_CMD_SPI_CONF_DATA_MASK ) << Si2168B_SPI_LINK_CMD_SPI_CONF_DATA_LSB|
+			( spi_data_dir  & Si2168B_SPI_LINK_CMD_SPI_DATA_DIR_MASK  ) << Si2168B_SPI_LINK_CMD_SPI_DATA_DIR_LSB );
+	cmdByteBuffer[6] = (u8) ( ( spi_enable    & Si2168B_SPI_LINK_CMD_SPI_ENABLE_MASK    ) << Si2168B_SPI_LINK_CMD_SPI_ENABLE_LSB   );
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 7, cmdByteBuffer) != 7) {
+		SiTRACE("Error writing SPI_LINK bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+	}
+
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+#endif
+
+#ifdef __EXTRA_COMMANDS__
+/*---------------------------------------------------*/
+/* Si2168B_DOWNLOAD_DATASET_START COMMAND           */
+/*---------------------------------------------------*/
+static u8 Si2168B_L1_DOWNLOAD_DATASET_START(si2168b_context *ctx,
+		u8   dataset_id,
+		u8   dataset_checksum,
+		u8   data0,
+		u8   data1,
+		u8   data2,
+		u8   data3,
+		u8   data4)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[8];
+	u8 rspByteBuffer[1];
+	u8 ret = NO_Si2168B_ERROR;
+#ifdef __COMMONREPLYOBJ__
+	ctx->rsp->download_dataset_start.STATUS = ctx->status;
+#endif
+
+	SiTRACE("Si2168B DOWNLOAD_DATASET_START\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DOWNLOAD_DATASET_START_CMD;
+	cmdByteBuffer[1] = (u8) ( ( dataset_id       & Si2168B_DOWNLOAD_DATASET_START_CMD_DATASET_ID_MASK       ) << Si2168B_DOWNLOAD_DATASET_START_CMD_DATASET_ID_LSB      );
+	cmdByteBuffer[2] = (u8) ( ( dataset_checksum & Si2168B_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_MASK ) << Si2168B_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_LSB);
+	cmdByteBuffer[3] = (u8) ( ( data0            & Si2168B_DOWNLOAD_DATASET_START_CMD_DATA0_MASK            ) << Si2168B_DOWNLOAD_DATASET_START_CMD_DATA0_LSB           );
+	cmdByteBuffer[4] = (u8) ( ( data1            & Si2168B_DOWNLOAD_DATASET_START_CMD_DATA1_MASK            ) << Si2168B_DOWNLOAD_DATASET_START_CMD_DATA1_LSB           );
+	cmdByteBuffer[5] = (u8) ( ( data2            & Si2168B_DOWNLOAD_DATASET_START_CMD_DATA2_MASK            ) << Si2168B_DOWNLOAD_DATASET_START_CMD_DATA2_LSB           );
+	cmdByteBuffer[6] = (u8) ( ( data3            & Si2168B_DOWNLOAD_DATASET_START_CMD_DATA3_MASK            ) << Si2168B_DOWNLOAD_DATASET_START_CMD_DATA3_LSB           );
+	cmdByteBuffer[7] = (u8) ( ( data4            & Si2168B_DOWNLOAD_DATASET_START_CMD_DATA4_MASK            ) << Si2168B_DOWNLOAD_DATASET_START_CMD_DATA4_LSB           );
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 8, cmdByteBuffer) != 8) {
+		SiTRACE("Error writing DOWNLOAD_DATASET_START bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 1, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DOWNLOAD_DATASET_START response\n");
+		ret = error_code;
+	}
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+#endif
+
+#ifdef __EXTRA_COMMANDS__
+/*---------------------------------------------------*/
+/* Si2168B_RSSI_ADC COMMAND                         */
+/*---------------------------------------------------*/
+static u8 Si2168B_L1_RSSI_ADC(si2168b_context *ctx, u8 on_off)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[2];
+	u8 ret = NO_Si2168B_ERROR;
+#ifdef __COMMONREPLYOBJ__
+	ctx->rsp->rssi_adc.STATUS = ctx->status;
+#endif
+
+	SiTRACE("Si2168B RSSI_ADC\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_RSSI_ADC_CMD;
+	cmdByteBuffer[1] = (u8) ( ( on_off & Si2168B_RSSI_ADC_CMD_ON_OFF_MASK ) << Si2168B_RSSI_ADC_CMD_ON_OFF_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing RSSI_ADC bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 2, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling RSSI_ADC response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	ctx->rsp->rssi_adc.level = (( ( (rspByteBuffer[1]  )) >> Si2168B_RSSI_ADC_RESPONSE_LEVEL_LSB ) & Si2168B_RSSI_ADC_RESPONSE_LEVEL_MASK );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+#endif
+
+#ifdef __EXTRA_COMMANDS__
+/*---------------------------------------------------*/
+/* Si2168B_DD_SET_REG COMMAND                       */
+/*---------------------------------------------------*/
+static u8 Si2168B_L1_DD_SET_REG(si2168b_context *ctx,
+		u8   reg_code_lsb,
+		u8   reg_code_mid,
+		u8   reg_code_msb,
+		unsigned long   value)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[8];
+	u8 rspByteBuffer[1];
+	u8 ret = NO_Si2168B_ERROR;
+#ifdef __COMMONREPLYOBJ__
+	ctx->rsp->dd_set_reg.STATUS = ctx->status;
+#endif
+
+	SiTRACE("Si2168B DD_SET_REG\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DD_SET_REG_CMD;
+	cmdByteBuffer[1] = (u8) ( ( reg_code_lsb & Si2168B_DD_SET_REG_CMD_REG_CODE_LSB_MASK ) << Si2168B_DD_SET_REG_CMD_REG_CODE_LSB_LSB);
+	cmdByteBuffer[2] = (u8) ( ( reg_code_mid & Si2168B_DD_SET_REG_CMD_REG_CODE_MID_MASK ) << Si2168B_DD_SET_REG_CMD_REG_CODE_MID_LSB);
+	cmdByteBuffer[3] = (u8) ( ( reg_code_msb & Si2168B_DD_SET_REG_CMD_REG_CODE_MSB_MASK ) << Si2168B_DD_SET_REG_CMD_REG_CODE_MSB_LSB);
+	cmdByteBuffer[4] = (u8) ( ( value        & Si2168B_DD_SET_REG_CMD_VALUE_MASK        ) << Si2168B_DD_SET_REG_CMD_VALUE_LSB       );
+	cmdByteBuffer[5] = (u8) ((( value        & Si2168B_DD_SET_REG_CMD_VALUE_MASK        ) << Si2168B_DD_SET_REG_CMD_VALUE_LSB       )>>8);
+	cmdByteBuffer[6] = (u8) ((( value        & Si2168B_DD_SET_REG_CMD_VALUE_MASK        ) << Si2168B_DD_SET_REG_CMD_VALUE_LSB       )>>16);
+	cmdByteBuffer[7] = (u8) ((( value        & Si2168B_DD_SET_REG_CMD_VALUE_MASK        ) << Si2168B_DD_SET_REG_CMD_VALUE_LSB       )>>24);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 8, cmdByteBuffer) != 8) {
+		SiTRACE("Error writing DD_SET_REG bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 1, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DD_SET_REG response\n");
+		ret = error_code;
+	}
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+#endif
+
+#ifdef __EXTRA_COMMANDS__
+/*---------------------------------------------------*/
+/* Si2168B_DD_GET_REG COMMAND                       */
+/*---------------------------------------------------*/
+static u8 Si2168B_L1_DD_GET_REG(si2168b_context *ctx,
+		u8   reg_code_lsb,
+		u8   reg_code_mid,
+		u8   reg_code_msb)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[4];
+	u8 rspByteBuffer[5];
+	u8 ret = NO_Si2168B_ERROR;
+#ifdef __COMMONREPLYOBJ__
+	ctx->rsp->dd_get_reg.STATUS = ctx->status;
+#endif
+
+	SiTRACE("Si2168B DD_GET_REG\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DD_GET_REG_CMD;
+	cmdByteBuffer[1] = (u8) ( ( reg_code_lsb & Si2168B_DD_GET_REG_CMD_REG_CODE_LSB_MASK ) << Si2168B_DD_GET_REG_CMD_REG_CODE_LSB_LSB);
+	cmdByteBuffer[2] = (u8) ( ( reg_code_mid & Si2168B_DD_GET_REG_CMD_REG_CODE_MID_MASK ) << Si2168B_DD_GET_REG_CMD_REG_CODE_MID_LSB);
+	cmdByteBuffer[3] = (u8) ( ( reg_code_msb & Si2168B_DD_GET_REG_CMD_REG_CODE_MSB_MASK ) << Si2168B_DD_GET_REG_CMD_REG_CODE_MSB_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 4, cmdByteBuffer) != 4) {
+		SiTRACE("Error writing DD_GET_REG bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 5, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DD_GET_REG response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	ctx->rsp->dd_get_reg.data1 =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DD_GET_REG_RESPONSE_DATA1_LSB ) & Si2168B_DD_GET_REG_RESPONSE_DATA1_MASK );
+	ctx->rsp->dd_get_reg.data2 =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DD_GET_REG_RESPONSE_DATA2_LSB ) & Si2168B_DD_GET_REG_RESPONSE_DATA2_MASK );
+	ctx->rsp->dd_get_reg.data3 =   (( ( (rspByteBuffer[3]  )) >> Si2168B_DD_GET_REG_RESPONSE_DATA3_LSB ) & Si2168B_DD_GET_REG_RESPONSE_DATA3_MASK );
+	ctx->rsp->dd_get_reg.data4 =   (( ( (rspByteBuffer[4]  )) >> Si2168B_DD_GET_REG_RESPONSE_DATA4_LSB ) & Si2168B_DD_GET_REG_RESPONSE_DATA4_MASK );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+#endif
+
+/*---------------------------------------------------*/
+/* Si2168B_DVBT2_PLP_INFO COMMAND                   */
+/*---------------------------------------------------*/
+static u8 si2168b_dvbt2_plp_info(si2168b_context *ctx, u8 plp_index, Si2168B_DVBT2_PLP_INFO_CMD_REPLY_struct *dvbt2_plp_info)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[13];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B DVBT2_PLP_INFO\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DVBT2_PLP_INFO_CMD;
+	cmdByteBuffer[1] = (u8) ( ( plp_index & Si2168B_DVBT2_PLP_INFO_CMD_PLP_INDEX_MASK ) << Si2168B_DVBT2_PLP_INFO_CMD_PLP_INDEX_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing DVBT2_PLP_INFO bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 13, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DVBT2_PLP_INFO response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	dvbt2_plp_info->plp_id                 =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_ID_LSB                 ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_ID_MASK                 );
+	dvbt2_plp_info->plp_payload_type       =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_PAYLOAD_TYPE_LSB       ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_PAYLOAD_TYPE_MASK       );
+	dvbt2_plp_info->plp_type               =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_TYPE_LSB               ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_TYPE_MASK               );
+	dvbt2_plp_info->first_frame_idx_msb    =   (( ( (rspByteBuffer[3]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_FIRST_FRAME_IDX_MSB_LSB    ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_FIRST_FRAME_IDX_MSB_MASK    );
+	dvbt2_plp_info->first_rf_idx           =   (( ( (rspByteBuffer[3]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_FIRST_RF_IDX_LSB           ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_FIRST_RF_IDX_MASK           );
+	dvbt2_plp_info->ff_flag                =   (( ( (rspByteBuffer[3]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_FF_FLAG_LSB                ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_FF_FLAG_MASK                );
+	dvbt2_plp_info->plp_group_id_msb       =   (( ( (rspByteBuffer[4]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_GROUP_ID_MSB_LSB       ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_GROUP_ID_MSB_MASK       );
+	dvbt2_plp_info->first_frame_idx_lsb    =   (( ( (rspByteBuffer[4]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_FIRST_FRAME_IDX_LSB_LSB    ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_FIRST_FRAME_IDX_LSB_MASK    );
+	dvbt2_plp_info->plp_mod_msb            =   (( ( (rspByteBuffer[5]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_MOD_MSB_LSB            ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_MOD_MSB_MASK            );
+	dvbt2_plp_info->plp_cod                =   (( ( (rspByteBuffer[5]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_COD_LSB                ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_COD_MASK                );
+	dvbt2_plp_info->plp_group_id_lsb       =   (( ( (rspByteBuffer[5]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_GROUP_ID_LSB_LSB       ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_GROUP_ID_LSB_MASK       );
+	dvbt2_plp_info->plp_num_blocks_max_msb =   (( ( (rspByteBuffer[6]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_NUM_BLOCKS_MAX_MSB_LSB ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_NUM_BLOCKS_MAX_MSB_MASK );
+	dvbt2_plp_info->plp_fec_type           =   (( ( (rspByteBuffer[6]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_FEC_TYPE_LSB           ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_FEC_TYPE_MASK           );
+	dvbt2_plp_info->plp_rot                =   (( ( (rspByteBuffer[6]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_ROT_LSB                ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_ROT_MASK                );
+	dvbt2_plp_info->plp_mod_lsb            =   (( ( (rspByteBuffer[6]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_MOD_LSB_LSB            ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_MOD_LSB_MASK            );
+	dvbt2_plp_info->frame_interval_msb     =   (( ( (rspByteBuffer[7]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_FRAME_INTERVAL_MSB_LSB     ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_FRAME_INTERVAL_MSB_MASK     );
+	dvbt2_plp_info->plp_num_blocks_max_lsb =   (( ( (rspByteBuffer[7]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_NUM_BLOCKS_MAX_LSB_LSB ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_NUM_BLOCKS_MAX_LSB_MASK );
+	dvbt2_plp_info->time_il_length_msb     =   (( ( (rspByteBuffer[8]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_TIME_IL_LENGTH_MSB_LSB     ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_TIME_IL_LENGTH_MSB_MASK     );
+	dvbt2_plp_info->frame_interval_lsb     =   (( ( (rspByteBuffer[8]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_FRAME_INTERVAL_LSB_LSB     ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_FRAME_INTERVAL_LSB_MASK     );
+	dvbt2_plp_info->time_il_type           =   (( ( (rspByteBuffer[9]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_TIME_IL_TYPE_LSB           ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_TIME_IL_TYPE_MASK           );
+	dvbt2_plp_info->time_il_length_lsb     =   (( ( (rspByteBuffer[9]  )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_TIME_IL_LENGTH_LSB_LSB     ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_TIME_IL_LENGTH_LSB_MASK     );
+	dvbt2_plp_info->reserved_1_1           =   (( ( (rspByteBuffer[10] )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_RESERVED_1_1_LSB           ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_RESERVED_1_1_MASK           );
+	dvbt2_plp_info->in_band_b_flag         =   (( ( (rspByteBuffer[10] )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_IN_BAND_B_FLAG_LSB         ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_IN_BAND_B_FLAG_MASK         );
+	dvbt2_plp_info->in_band_a_flag         =   (( ( (rspByteBuffer[10] )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_IN_BAND_A_FLAG_LSB         ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_IN_BAND_A_FLAG_MASK         );
+	dvbt2_plp_info->static_flag            =   (( ( (rspByteBuffer[11] )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_STATIC_FLAG_LSB            ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_STATIC_FLAG_MASK            );
+	dvbt2_plp_info->plp_mode               =   (( ( (rspByteBuffer[11] )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_MODE_LSB               ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_MODE_MASK               );
+	dvbt2_plp_info->reserved_1_2           =   (( ( (rspByteBuffer[11] )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_RESERVED_1_2_LSB           ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_RESERVED_1_2_MASK           );
+	dvbt2_plp_info->static_padding_flag    =   (( ( (rspByteBuffer[12] )) >> Si2168B_DVBT2_PLP_INFO_RESPONSE_STATIC_PADDING_FLAG_LSB    ) & Si2168B_DVBT2_PLP_INFO_RESPONSE_STATIC_PADDING_FLAG_MASK    );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+/*---------------------------------------------------*/
+/* Si2168B_DVBT2_FEF COMMAND                        */
+/*---------------------------------------------------*/
+static u8 si2168b_dvbt2_fef(si2168b_context *ctx,
+		u8   fef_tuner_flag,
+		u8   fef_tuner_flag_inv,
+		Si2168B_DVBT2_FEF_CMD_REPLY_struct *dvbt2_fef)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[12];
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("Si2168B DVBT2_FEF\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DVBT2_FEF_CMD;
+	cmdByteBuffer[1] = (u8) ( ( fef_tuner_flag     & Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MASK     ) << Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_LSB    |
+			( fef_tuner_flag_inv & Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_MASK ) << Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing DVBT2_FEF bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 12, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DVBT2_FEF response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	dvbt2_fef->fef_type       =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBT2_FEF_RESPONSE_FEF_TYPE_LSB       ) & Si2168B_DVBT2_FEF_RESPONSE_FEF_TYPE_MASK       );
+	dvbt2_fef->fef_length     =   (( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 ) | (rspByteBuffer[6]  << 16 ) | (rspByteBuffer[7]  << 24 )) >> Si2168B_DVBT2_FEF_RESPONSE_FEF_LENGTH_LSB     ) & Si2168B_DVBT2_FEF_RESPONSE_FEF_LENGTH_MASK     );
+	dvbt2_fef->fef_repetition =   (( ( (rspByteBuffer[8]  ) | (rspByteBuffer[9]  << 8 ) | (rspByteBuffer[10] << 16 ) | (rspByteBuffer[11] << 24 )) >> Si2168B_DVBT2_FEF_RESPONSE_FEF_REPETITION_LSB ) & Si2168B_DVBT2_FEF_RESPONSE_FEF_REPETITION_MASK );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+
+#ifdef __EXTRA_COMMANDS__
+/*---------------------------------------------------*/
+/* Si2168B_DD_CBER COMMAND                          */
+/*---------------------------------------------------*/
+static u8 Si2168B_L1_DD_CBER(si2168b_context *ctx, u8 rst)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[3];
+	u8 ret = NO_Si2168B_ERROR;
+#ifdef __COMMONREPLYOBJ__
+	ctx->rsp->dd_cber.STATUS = ctx->status;
+#endif
+
+	SiTRACE("Si2168B DD_CBER\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DD_CBER_CMD;
+	cmdByteBuffer[1] = (u8) ( ( rst & Si2168B_DD_CBER_CMD_RST_MASK ) << Si2168B_DD_CBER_CMD_RST_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing DD_CBER bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 3, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DD_CBER response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	ctx->rsp->dd_cber.exp  =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DD_CBER_RESPONSE_EXP_LSB  ) & Si2168B_DD_CBER_RESPONSE_EXP_MASK  );
+	ctx->rsp->dd_cber.mant =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DD_CBER_RESPONSE_MANT_LSB ) & Si2168B_DD_CBER_RESPONSE_MANT_MASK );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+#endif
+
+#ifdef __EXTRA_COMMANDS__
+/*---------------------------------------------------*/
+/* Si2168B_CONFIG_CLKIO COMMAND                     */
+/*---------------------------------------------------*/
+static u8 Si2168B_L1_CONFIG_CLKIO(si2168b_context *ctx,
+		u8   output,
+		u8   pre_driver_str,
+		u8   driver_str)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[4];
+	u8 ret = NO_Si2168B_ERROR;
+#ifdef __COMMONREPLYOBJ__
+	ctx->rsp->config_clkio.STATUS = ctx->status;
+#endif
+
+	SiTRACE("Si2168B CONFIG_CLKIO\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_CONFIG_CLKIO_CMD;
+	cmdByteBuffer[1] = (u8) ( ( output         & Si2168B_CONFIG_CLKIO_CMD_OUTPUT_MASK         ) << Si2168B_CONFIG_CLKIO_CMD_OUTPUT_LSB        |
+			( pre_driver_str & Si2168B_CONFIG_CLKIO_CMD_PRE_DRIVER_STR_MASK ) << Si2168B_CONFIG_CLKIO_CMD_PRE_DRIVER_STR_LSB|
+			( driver_str     & Si2168B_CONFIG_CLKIO_CMD_DRIVER_STR_MASK     ) << Si2168B_CONFIG_CLKIO_CMD_DRIVER_STR_LSB    );
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing CONFIG_CLKIO bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 4, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling CONFIG_CLKIO response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	ctx->rsp->config_clkio.mode           =   (( ( (rspByteBuffer[1]  )) >> Si2168B_CONFIG_CLKIO_RESPONSE_MODE_LSB           ) & Si2168B_CONFIG_CLKIO_RESPONSE_MODE_MASK           );
+	ctx->rsp->config_clkio.pre_driver_str =   (( ( (rspByteBuffer[2]  )) >> Si2168B_CONFIG_CLKIO_RESPONSE_PRE_DRIVER_STR_LSB ) & Si2168B_CONFIG_CLKIO_RESPONSE_PRE_DRIVER_STR_MASK );
+	ctx->rsp->config_clkio.driver_str     =   (( ( (rspByteBuffer[3]  )) >> Si2168B_CONFIG_CLKIO_RESPONSE_DRIVER_STR_LSB     ) & Si2168B_CONFIG_CLKIO_RESPONSE_DRIVER_STR_MASK     );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+#endif
+
+#ifdef __EXTRA_COMMANDS__
+/*---------------------------------------------------*/
+/* Si2168B_DVBT_TPS_EXTRA COMMAND                   */
+/*---------------------------------------------------*/
+static u8 Si2168B_L1_DVBT_TPS_EXTRA(si2168b_context *ctx)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[1];
+	u8 rspByteBuffer[6];
+	u8 ret = NO_Si2168B_ERROR;
+#ifdef __COMMONREPLYOBJ__
+	ctx->rsp->dvbt_tps_extra.STATUS = ctx->status;
+#endif
+
+	SiTRACE("Si2168B DVBT_TPS_EXTRA\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DVBT_TPS_EXTRA_CMD;
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 1, cmdByteBuffer) != 1) {
+		SiTRACE("Error writing DVBT_TPS_EXTRA bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 6, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DVBT_TPS_EXTRA response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	ctx->rsp->dvbt_tps_extra.lptimeslice =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBT_TPS_EXTRA_RESPONSE_LPTIMESLICE_LSB ) & Si2168B_DVBT_TPS_EXTRA_RESPONSE_LPTIMESLICE_MASK );
+	ctx->rsp->dvbt_tps_extra.hptimeslice =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBT_TPS_EXTRA_RESPONSE_HPTIMESLICE_LSB ) & Si2168B_DVBT_TPS_EXTRA_RESPONSE_HPTIMESLICE_MASK );
+	ctx->rsp->dvbt_tps_extra.lpmpefec    =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBT_TPS_EXTRA_RESPONSE_LPMPEFEC_LSB    ) & Si2168B_DVBT_TPS_EXTRA_RESPONSE_LPMPEFEC_MASK    );
+	ctx->rsp->dvbt_tps_extra.hpmpefec    =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBT_TPS_EXTRA_RESPONSE_HPMPEFEC_LSB    ) & Si2168B_DVBT_TPS_EXTRA_RESPONSE_HPMPEFEC_MASK    );
+	ctx->rsp->dvbt_tps_extra.dvbhinter   =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DVBT_TPS_EXTRA_RESPONSE_DVBHINTER_LSB   ) & Si2168B_DVBT_TPS_EXTRA_RESPONSE_DVBHINTER_MASK   );
+	ctx->rsp->dvbt_tps_extra.cell_id     = (((( ( (rspByteBuffer[2]  ) | (rspByteBuffer[3]  << 8 )) >> Si2168B_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_LSB     ) & Si2168B_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_MASK) <<Si2168B_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_SHIFT ) >>Si2168B_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_SHIFT     );
+	ctx->rsp->dvbt_tps_extra.tps_res1    =   (( ( (rspByteBuffer[4]  )) >> Si2168B_DVBT_TPS_EXTRA_RESPONSE_TPS_RES1_LSB    ) & Si2168B_DVBT_TPS_EXTRA_RESPONSE_TPS_RES1_MASK    );
+	ctx->rsp->dvbt_tps_extra.tps_res2    =   (( ( (rspByteBuffer[4]  )) >> Si2168B_DVBT_TPS_EXTRA_RESPONSE_TPS_RES2_LSB    ) & Si2168B_DVBT_TPS_EXTRA_RESPONSE_TPS_RES2_MASK    );
+	ctx->rsp->dvbt_tps_extra.tps_res3    =   (( ( (rspByteBuffer[5]  )) >> Si2168B_DVBT_TPS_EXTRA_RESPONSE_TPS_RES3_LSB    ) & Si2168B_DVBT_TPS_EXTRA_RESPONSE_TPS_RES3_MASK    );
+	ctx->rsp->dvbt_tps_extra.tps_res4    =   (( ( (rspByteBuffer[5]  )) >> Si2168B_DVBT_TPS_EXTRA_RESPONSE_TPS_RES4_LSB    ) & Si2168B_DVBT_TPS_EXTRA_RESPONSE_TPS_RES4_MASK    );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+#endif
+
+#ifdef __EXTRA_COMMANDS__
+/*---------------------------------------------------*/
+/* Si2168B_DD_PER COMMAND                           */
+/*---------------------------------------------------*/
+static u8 Si2168B_L1_DD_PER(si2168b_context *ctx, u8 rst)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[3];
+	u8 ret = NO_Si2168B_ERROR;
+#ifdef __COMMONREPLYOBJ__
+	ctx->rsp->dd_per.STATUS = ctx->status;
+#endif
+
+	SiTRACE("Si2168B DD_PER\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DD_PER_CMD;
+	cmdByteBuffer[1] = (u8) ( ( rst & Si2168B_DD_PER_CMD_RST_MASK ) << Si2168B_DD_PER_CMD_RST_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing DD_PER bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 3, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DD_PER response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	ctx->rsp->dd_per.exp  =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DD_PER_RESPONSE_EXP_LSB  ) & Si2168B_DD_PER_RESPONSE_EXP_MASK  );
+	ctx->rsp->dd_per.mant =   (( ( (rspByteBuffer[2]  )) >> Si2168B_DD_PER_RESPONSE_MANT_LSB ) & Si2168B_DD_PER_RESPONSE_MANT_MASK );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+#endif
+
+#ifdef __EXTRA_COMMANDS__
+/*---------------------------------------------------*/
+/* Si2168B_DD_SSI_SQI COMMAND                       */
+/*---------------------------------------------------*/
+static u8 Si2168B_L1_DD_SSI_SQI(si2168b_context *ctx, char tuner_rssi)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[3];
+	u8 ret = NO_Si2168B_ERROR;
+#ifdef __COMMONREPLYOBJ__
+	ctx->rsp->dd_ssi_sqi.STATUS = ctx->status;
+#endif
+
+	SiTRACE("Si2168B DD_SSI_SQI\n");
+
+	_mutex_lock(&ctx->lock);
+
+	cmdByteBuffer[0] = Si2168B_DD_SSI_SQI_CMD;
+	cmdByteBuffer[1] = (u8) ( ( tuner_rssi & Si2168B_DD_SSI_SQI_CMD_TUNER_RSSI_MASK ) << Si2168B_DD_SSI_SQI_CMD_TUNER_RSSI_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing DD_SSI_SQI bytes!\n");
+		ret = ERROR_Si2168B_SENDING_COMMAND;
+		goto unlock_mutex;
+	}
+
+	error_code = si2168b_poll_for_response(ctx, 3, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling DD_SSI_SQI response\n");
+		ret = error_code;
+		goto unlock_mutex;
+	}
+
+	ctx->rsp->dd_ssi_sqi.ssi =   (( ( (rspByteBuffer[1]  )) >> Si2168B_DD_SSI_SQI_RESPONSE_SSI_LSB ) & Si2168B_DD_SSI_SQI_RESPONSE_SSI_MASK );
+	ctx->rsp->dd_ssi_sqi.sqi = (((( ( (rspByteBuffer[2]  )) >> Si2168B_DD_SSI_SQI_RESPONSE_SQI_LSB ) & Si2168B_DD_SSI_SQI_RESPONSE_SQI_MASK) <<Si2168B_DD_SSI_SQI_RESPONSE_SQI_SHIFT ) >>Si2168B_DD_SSI_SQI_RESPONSE_SQI_SHIFT );
+
+unlock_mutex:
+	_mutex_unlock(&ctx->lock);
+
+	return ret;
+}
+#endif
+
+/*****************************************************************************************
+ NAME: si2168b_set_common_properties
+  DESCRIPTION: Setup Si2168B COMMON properties configuration
+  This function will download all the COMMON configuration properties.
+  The function Si2168B_storeUserProperties should be called before the first call to this function.
+  Parameter:  Pointer to Si2168B Context
+  Returns:    I2C transaction error code, NO_Si2168B_ERROR if successful
+  Programming Guide Reference:    COMMON setup flowchart
+******************************************************************************************/
+static int si2168b_set_common_properties(si2168b_context *ctx)
+{
+	const u8 master_ien_ddien   = Si2168B_MASTER_IEN_PROP_DDIEN_OFF   ; /* (default 'OFF') */
+	const u8 master_ien_scanien = Si2168B_MASTER_IEN_PROP_SCANIEN_OFF ; /* (default 'OFF') */
+	const u8 master_ien_errien  = Si2168B_MASTER_IEN_PROP_ERRIEN_OFF  ; /* (default 'OFF') */
+	const u8 master_ien_ctsien  = Si2168B_MASTER_IEN_PROP_CTSIEN_OFF  ; /* (default 'OFF') */
+
+	u8  ret;
+	u8  err = NO_Si2168B_ERROR;
+	u16 data;
+
+	SiTRACE("si2168b_set_common_properties\n");
+
+	data = (master_ien_ddien   & Si2168B_MASTER_IEN_PROP_DDIEN_MASK  ) << Si2168B_MASTER_IEN_PROP_DDIEN_LSB |
+           (master_ien_scanien & Si2168B_MASTER_IEN_PROP_SCANIEN_MASK) << Si2168B_MASTER_IEN_PROP_SCANIEN_LSB |
+           (master_ien_errien  & Si2168B_MASTER_IEN_PROP_ERRIEN_MASK ) << Si2168B_MASTER_IEN_PROP_ERRIEN_LSB |
+           (master_ien_ctsien  & Si2168B_MASTER_IEN_PROP_CTSIEN_MASK ) << Si2168B_MASTER_IEN_PROP_CTSIEN_LSB;
+
+	ret = si2168b_set_property(ctx, Si2168B_MASTER_IEN_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_MASTER_IEN_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+	return err;
+}
+
+/*****************************************************************************************
+ NAME: si2168b_set_dd_properties
+  DESCRIPTION: Setup Si2168B DD properties configuration
+  This function will download all the DD configuration properties.
+  The function Si2168B_storeUserProperties should be called before the first call to this function.
+  Parameter:  Pointer to Si2168B Context
+  Returns:    I2C transaction error code, NO_Si2168B_ERROR if successful
+  Programming Guide Reference:    DD setup flowchart
+******************************************************************************************/
+static int si2168b_set_dd_properties(si2168b_context *ctx)
+{
+	const u8  dd_ber_resol_exp                     = 7; /* (default     7) */
+	const u8  dd_ber_resol_mant                    = 1; /* (default     1) */
+	const u8  dd_cber_resol_exp                    = 5; /* (default     5) */
+	const u8  dd_cber_resol_mant                   = 1; /* (default     1) */
+	const u8  dd_fer_resol_exp                     = 3; /* (default     3) */
+	const u8  dd_fer_resol_mant                    = 1; /* (default     1) */
+    const u8  dd_ien_ien_bit0                      = Si2168B_DD_IEN_PROP_IEN_BIT0_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_ien_ien_bit1                      = Si2168B_DD_IEN_PROP_IEN_BIT1_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_ien_ien_bit2                      = Si2168B_DD_IEN_PROP_IEN_BIT2_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_ien_ien_bit3                      = Si2168B_DD_IEN_PROP_IEN_BIT3_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_ien_ien_bit4                      = Si2168B_DD_IEN_PROP_IEN_BIT4_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_ien_ien_bit5                      = Si2168B_DD_IEN_PROP_IEN_BIT5_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_ien_ien_bit6                      = Si2168B_DD_IEN_PROP_IEN_BIT6_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_ien_ien_bit7                      = Si2168B_DD_IEN_PROP_IEN_BIT7_DISABLE; /* (default 'DISABLE') */
+	const u16 dd_if_input_freq_offset              = 5000; /* (default  5000) */
+    const u8  dd_int_sense_neg_bit0                = Si2168B_DD_INT_SENSE_PROP_NEG_BIT0_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_int_sense_neg_bit1                = Si2168B_DD_INT_SENSE_PROP_NEG_BIT1_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_int_sense_neg_bit2                = Si2168B_DD_INT_SENSE_PROP_NEG_BIT2_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_int_sense_neg_bit3                = Si2168B_DD_INT_SENSE_PROP_NEG_BIT3_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_int_sense_neg_bit4                = Si2168B_DD_INT_SENSE_PROP_NEG_BIT4_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_int_sense_neg_bit5                = Si2168B_DD_INT_SENSE_PROP_NEG_BIT5_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_int_sense_neg_bit6                = Si2168B_DD_INT_SENSE_PROP_NEG_BIT6_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_int_sense_neg_bit7                = Si2168B_DD_INT_SENSE_PROP_NEG_BIT7_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_int_sense_pos_bit0                = Si2168B_DD_INT_SENSE_PROP_POS_BIT0_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_int_sense_pos_bit1                = Si2168B_DD_INT_SENSE_PROP_POS_BIT1_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_int_sense_pos_bit2                = Si2168B_DD_INT_SENSE_PROP_POS_BIT2_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_int_sense_pos_bit3                = Si2168B_DD_INT_SENSE_PROP_POS_BIT3_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_int_sense_pos_bit4                = Si2168B_DD_INT_SENSE_PROP_POS_BIT4_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_int_sense_pos_bit5                = Si2168B_DD_INT_SENSE_PROP_POS_BIT5_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_int_sense_pos_bit6                = Si2168B_DD_INT_SENSE_PROP_POS_BIT6_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_int_sense_pos_bit7                = Si2168B_DD_INT_SENSE_PROP_POS_BIT7_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_mode_bw                           = Si2168B_DD_MODE_PROP_BW_BW_8MHZ; /* (default 'BW_8MHZ') */
+    const u8  dd_mode_modulation                   = Si2168B_DD_MODE_PROP_MODULATION_DVBT; /* (default 'DVBT') */
+    const u8  dd_mode_invert_spectrum              = Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_NORMAL; /* (default 'NORMAL') */
+    const u8  dd_mode_auto_detect                  = Si2168B_DD_MODE_PROP_AUTO_DETECT_NONE; /* (default 'NONE') */
+    const u8  dd_per_resol_exp                     = 5; /* (default     5) */
+    const u8  dd_per_resol_mant                    = 1; /* (default     1) */
+    const u8  dd_rsq_ber_threshold_exp             = 1; /* (default     1) */
+    const u8  dd_rsq_ber_threshold_mant            = 10; /* (default    10) */
+    const u8  dd_ssi_sqi_param_sqi_average         = 1; /* (default     1) */
+	const u16 dd_ts_freq_req_freq_10khz            = 720; /* (default   720) */
+    const u8  dd_ts_mode_mode                      = Si2168B_DD_TS_MODE_PROP_MODE_TRISTATE; /* (default 'TRISTATE') */
+    const u8  dd_ts_mode_clock                     = Si2168B_DD_TS_MODE_PROP_CLOCK_AUTO_FIXED; /* (default 'AUTO_FIXED') */
+    const u8  dd_ts_mode_clk_gapped_en             = Si2168B_DD_TS_MODE_PROP_CLK_GAPPED_EN_DISABLED; /* (default 'DISABLED') */
+    const u8  dd_ts_mode_ts_err_polarity           = Si2168B_DD_TS_MODE_PROP_TS_ERR_POLARITY_NOT_INVERTED; /* (default 'NOT_INVERTED') */
+    const u8  dd_ts_mode_special                   = Si2168B_DD_TS_MODE_PROP_SPECIAL_FULL_TS; /* (default 'FULL_TS') */
+    const u8  dd_ts_mode_ts_freq_resolution        = Si2168B_DD_TS_MODE_PROP_TS_FREQ_RESOLUTION_NORMAL; /* (default 'NORMAL') */
+    const u8  dd_ts_serial_diff_ts_data1_strength  = 15; /* (default    15) */
+    const u8  dd_ts_serial_diff_ts_data1_shape     = 3; /* (default     3) */
+    const u8  dd_ts_serial_diff_ts_data2_strength  = 15; /* (default    15) */
+    const u8  dd_ts_serial_diff_ts_data2_shape     = 3; /* (default     3) */
+    const u8  dd_ts_serial_diff_ts_clkb_on_data1   = Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_CLKB_ON_DATA1_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_ts_serial_diff_ts_data0b_on_data2 = Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA0B_ON_DATA2_DISABLE; /* (default 'DISABLE') */
+    const u8  dd_ts_setup_par_ts_data_strength     = 3; /* (default     3) */
+    const u8  dd_ts_setup_par_ts_data_shape        = 1; /* (default     1) */
+    const u8  dd_ts_setup_par_ts_clk_strength      = 3; /* (default     3) */
+    const u8  dd_ts_setup_par_ts_clk_shape         = 1; /* (default     1) */
+    const u8  dd_ts_setup_par_ts_clk_invert        = Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_INVERTED; /* (default 'INVERTED') */
+    const u8  dd_ts_setup_par_ts_clk_shift         = 0; /* (default     0) */
+    const u8  dd_ts_setup_ser_ts_data_strength     = 15; /* (default    15) */
+    const u8  dd_ts_setup_ser_ts_data_shape        = 3; /* (default     3) */
+    const u8  dd_ts_setup_ser_ts_clk_strength      = 15; /* (default    15) */
+    const u8  dd_ts_setup_ser_ts_clk_shape         = 3; /* (default     3) */
+    const u8  dd_ts_setup_ser_ts_clk_invert        = Si2168B_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_INVERTED; /* (default 'INVERTED') */
+    const u8  dd_ts_setup_ser_ts_sync_duration     = Si2168B_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_FIRST_BYTE; /* (default 'FIRST_BYTE') */
+    const u8  dd_ts_setup_ser_ts_byte_order        = Si2168B_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_MSB_FIRST; /* (default 'MSB_FIRST') */
+
+#ifdef    Si2168B_DD_DISEQC_FREQ_PROP
+	dd_diseqc_freq.freq_hz                         = 22000; /* (default 22000) */
+#endif /* Si2168B_DD_DISEQC_FREQ_PROP */
+
+#ifdef    Si2168B_DD_DISEQC_PARAM_PROP
+	dd_diseqc_param.sequence_mode                  = Si2168B_DD_DISEQC_PARAM_PROP_SEQUENCE_MODE_GAP ; /* (default 'GAP') */
+#endif /* Si2168B_DD_DISEQC_PARAM_PROP */
+
+	u8  ret;
+	u8  err = NO_Si2168B_ERROR;
+	u16 data;
+
+	SiTRACE("si2168b_set_dd_properties\n");
+
+    data = (dd_ber_resol_exp  & Si2168B_DD_BER_RESOL_PROP_EXP_MASK ) << Si2168B_DD_BER_RESOL_PROP_EXP_LSB |
+           (dd_ber_resol_mant & Si2168B_DD_BER_RESOL_PROP_MANT_MASK) << Si2168B_DD_BER_RESOL_PROP_MANT_LSB;
+	ret = si2168b_set_property(ctx, Si2168B_DD_BER_RESOL_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DD_BER_RESOL_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dd_cber_resol_exp  & Si2168B_DD_CBER_RESOL_PROP_EXP_MASK ) << Si2168B_DD_CBER_RESOL_PROP_EXP_LSB |
+           (dd_cber_resol_mant & Si2168B_DD_CBER_RESOL_PROP_MANT_MASK) << Si2168B_DD_CBER_RESOL_PROP_MANT_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DD_CBER_RESOL_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DD_CBER_RESOL_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dd_fer_resol_exp  & Si2168B_DD_FER_RESOL_PROP_EXP_MASK ) << Si2168B_DD_FER_RESOL_PROP_EXP_LSB |
+           (dd_fer_resol_mant & Si2168B_DD_FER_RESOL_PROP_MANT_MASK) << Si2168B_DD_FER_RESOL_PROP_MANT_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DD_FER_RESOL_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DD_FER_RESOL_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dd_ien_ien_bit0 & Si2168B_DD_IEN_PROP_IEN_BIT0_MASK) << Si2168B_DD_IEN_PROP_IEN_BIT0_LSB |
+           (dd_ien_ien_bit1 & Si2168B_DD_IEN_PROP_IEN_BIT1_MASK) << Si2168B_DD_IEN_PROP_IEN_BIT1_LSB |
+           (dd_ien_ien_bit2 & Si2168B_DD_IEN_PROP_IEN_BIT2_MASK) << Si2168B_DD_IEN_PROP_IEN_BIT2_LSB |
+           (dd_ien_ien_bit3 & Si2168B_DD_IEN_PROP_IEN_BIT3_MASK) << Si2168B_DD_IEN_PROP_IEN_BIT3_LSB |
+           (dd_ien_ien_bit4 & Si2168B_DD_IEN_PROP_IEN_BIT4_MASK) << Si2168B_DD_IEN_PROP_IEN_BIT4_LSB |
+           (dd_ien_ien_bit5 & Si2168B_DD_IEN_PROP_IEN_BIT5_MASK) << Si2168B_DD_IEN_PROP_IEN_BIT5_LSB |
+           (dd_ien_ien_bit6 & Si2168B_DD_IEN_PROP_IEN_BIT6_MASK) << Si2168B_DD_IEN_PROP_IEN_BIT6_LSB |
+           (dd_ien_ien_bit7 & Si2168B_DD_IEN_PROP_IEN_BIT7_MASK) << Si2168B_DD_IEN_PROP_IEN_BIT7_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DD_IEN_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DD_IEN_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dd_if_input_freq_offset & Si2168B_DD_IF_INPUT_FREQ_PROP_OFFSET_MASK) << Si2168B_DD_IF_INPUT_FREQ_PROP_OFFSET_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DD_IF_INPUT_FREQ_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DD_IF_INPUT_FREQ_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dd_int_sense_neg_bit0 & Si2168B_DD_INT_SENSE_PROP_NEG_BIT0_MASK) << Si2168B_DD_INT_SENSE_PROP_NEG_BIT0_LSB |
+           (dd_int_sense_neg_bit1 & Si2168B_DD_INT_SENSE_PROP_NEG_BIT1_MASK) << Si2168B_DD_INT_SENSE_PROP_NEG_BIT1_LSB |
+           (dd_int_sense_neg_bit2 & Si2168B_DD_INT_SENSE_PROP_NEG_BIT2_MASK) << Si2168B_DD_INT_SENSE_PROP_NEG_BIT2_LSB |
+           (dd_int_sense_neg_bit3 & Si2168B_DD_INT_SENSE_PROP_NEG_BIT3_MASK) << Si2168B_DD_INT_SENSE_PROP_NEG_BIT3_LSB |
+           (dd_int_sense_neg_bit4 & Si2168B_DD_INT_SENSE_PROP_NEG_BIT4_MASK) << Si2168B_DD_INT_SENSE_PROP_NEG_BIT4_LSB |
+           (dd_int_sense_neg_bit5 & Si2168B_DD_INT_SENSE_PROP_NEG_BIT5_MASK) << Si2168B_DD_INT_SENSE_PROP_NEG_BIT5_LSB |
+           (dd_int_sense_neg_bit6 & Si2168B_DD_INT_SENSE_PROP_NEG_BIT6_MASK) << Si2168B_DD_INT_SENSE_PROP_NEG_BIT6_LSB |
+           (dd_int_sense_neg_bit7 & Si2168B_DD_INT_SENSE_PROP_NEG_BIT7_MASK) << Si2168B_DD_INT_SENSE_PROP_NEG_BIT7_LSB |
+           (dd_int_sense_pos_bit0 & Si2168B_DD_INT_SENSE_PROP_POS_BIT0_MASK) << Si2168B_DD_INT_SENSE_PROP_POS_BIT0_LSB |
+           (dd_int_sense_pos_bit1 & Si2168B_DD_INT_SENSE_PROP_POS_BIT1_MASK) << Si2168B_DD_INT_SENSE_PROP_POS_BIT1_LSB |
+           (dd_int_sense_pos_bit2 & Si2168B_DD_INT_SENSE_PROP_POS_BIT2_MASK) << Si2168B_DD_INT_SENSE_PROP_POS_BIT2_LSB |
+           (dd_int_sense_pos_bit3 & Si2168B_DD_INT_SENSE_PROP_POS_BIT3_MASK) << Si2168B_DD_INT_SENSE_PROP_POS_BIT3_LSB |
+           (dd_int_sense_pos_bit4 & Si2168B_DD_INT_SENSE_PROP_POS_BIT4_MASK) << Si2168B_DD_INT_SENSE_PROP_POS_BIT4_LSB |
+           (dd_int_sense_pos_bit5 & Si2168B_DD_INT_SENSE_PROP_POS_BIT5_MASK) << Si2168B_DD_INT_SENSE_PROP_POS_BIT5_LSB |
+           (dd_int_sense_pos_bit6 & Si2168B_DD_INT_SENSE_PROP_POS_BIT6_MASK) << Si2168B_DD_INT_SENSE_PROP_POS_BIT6_LSB |
+           (dd_int_sense_pos_bit7 & Si2168B_DD_INT_SENSE_PROP_POS_BIT7_MASK) << Si2168B_DD_INT_SENSE_PROP_POS_BIT7_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DD_INT_SENSE_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DD_INT_SENSE_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dd_mode_bw              & Si2168B_DD_MODE_PROP_BW_MASK             ) << Si2168B_DD_MODE_PROP_BW_LSB |
+           (dd_mode_modulation      & Si2168B_DD_MODE_PROP_MODULATION_MASK     ) << Si2168B_DD_MODE_PROP_MODULATION_LSB |
+           (dd_mode_invert_spectrum & Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_MASK) << Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_LSB |
+           (dd_mode_auto_detect     & Si2168B_DD_MODE_PROP_AUTO_DETECT_MASK    ) << Si2168B_DD_MODE_PROP_AUTO_DETECT_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DD_MODE_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DD_MODE_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dd_per_resol_exp  & Si2168B_DD_PER_RESOL_PROP_EXP_MASK ) << Si2168B_DD_PER_RESOL_PROP_EXP_LSB |
+           (dd_per_resol_mant & Si2168B_DD_PER_RESOL_PROP_MANT_MASK) << Si2168B_DD_PER_RESOL_PROP_MANT_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DD_PER_RESOL_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DD_PER_RESOL_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dd_rsq_ber_threshold_exp  & Si2168B_DD_RSQ_BER_THRESHOLD_PROP_EXP_MASK ) << Si2168B_DD_RSQ_BER_THRESHOLD_PROP_EXP_LSB |
+           (dd_rsq_ber_threshold_mant & Si2168B_DD_RSQ_BER_THRESHOLD_PROP_MANT_MASK) << Si2168B_DD_RSQ_BER_THRESHOLD_PROP_MANT_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DD_RSQ_BER_THRESHOLD_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DD_RSQ_BER_THRESHOLD_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dd_ssi_sqi_param_sqi_average & Si2168B_DD_SSI_SQI_PARAM_PROP_SQI_AVERAGE_MASK) << Si2168B_DD_SSI_SQI_PARAM_PROP_SQI_AVERAGE_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DD_SSI_SQI_PARAM_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DD_SSI_SQI_PARAM_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dd_ts_freq_req_freq_10khz & Si2168B_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_MASK) << Si2168B_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DD_TS_FREQ_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DD_TS_FREQ_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dd_ts_mode_mode            & Si2168B_DD_TS_MODE_PROP_MODE_MASK           ) << Si2168B_DD_TS_MODE_PROP_MODE_LSB |
+           (dd_ts_mode_clock           & Si2168B_DD_TS_MODE_PROP_CLOCK_MASK          ) << Si2168B_DD_TS_MODE_PROP_CLOCK_LSB |
+           (dd_ts_mode_clk_gapped_en   & Si2168B_DD_TS_MODE_PROP_CLK_GAPPED_EN_MASK  ) << Si2168B_DD_TS_MODE_PROP_CLK_GAPPED_EN_LSB |
+           (dd_ts_mode_ts_err_polarity & Si2168B_DD_TS_MODE_PROP_TS_ERR_POLARITY_MASK) << Si2168B_DD_TS_MODE_PROP_TS_ERR_POLARITY_LSB |
+           (dd_ts_mode_special            & Si2168B_DD_TS_MODE_PROP_SPECIAL_MASK     ) << Si2168B_DD_TS_MODE_PROP_SPECIAL_LSB |
+           (dd_ts_mode_ts_freq_resolution & Si2168B_DD_TS_MODE_PROP_TS_FREQ_RESOLUTION_MASK) << Si2168B_DD_TS_MODE_PROP_TS_FREQ_RESOLUTION_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DD_TS_MODE_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DD_TS_MODE_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dd_ts_serial_diff_ts_data1_strength  & Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA1_STRENGTH_MASK ) << Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA1_STRENGTH_LSB |
+           (dd_ts_serial_diff_ts_data1_shape     & Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA1_SHAPE_MASK    ) << Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA1_SHAPE_LSB |
+           (dd_ts_serial_diff_ts_data2_strength  & Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA2_STRENGTH_MASK ) << Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA2_STRENGTH_LSB |
+           (dd_ts_serial_diff_ts_data2_shape     & Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA2_SHAPE_MASK    ) << Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA2_SHAPE_LSB |
+           (dd_ts_serial_diff_ts_clkb_on_data1   & Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_CLKB_ON_DATA1_MASK  ) << Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_CLKB_ON_DATA1_LSB |
+           (dd_ts_serial_diff_ts_data0b_on_data2 & Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA0B_ON_DATA2_MASK) << Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA0B_ON_DATA2_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DD_TS_SERIAL_DIFF_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DD_TS_SERIAL_DIFF_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dd_ts_setup_par_ts_data_strength & Si2168B_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_MASK) << Si2168B_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_LSB |
+           (dd_ts_setup_par_ts_data_shape    & Si2168B_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_MASK   ) << Si2168B_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_LSB |
+           (dd_ts_setup_par_ts_clk_strength  & Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_MASK ) << Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_LSB |
+           (dd_ts_setup_par_ts_clk_shape     & Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_MASK    ) << Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_LSB |
+           (dd_ts_setup_par_ts_clk_invert    & Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_MASK   ) << Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_LSB |
+           (dd_ts_setup_par_ts_clk_shift     & Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_MASK    ) << Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DD_TS_SETUP_PAR_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DD_TS_SETUP_PAR_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dd_ts_setup_ser_ts_data_strength & Si2168B_DD_TS_SETUP_SER_PROP_TS_DATA_STRENGTH_MASK) << Si2168B_DD_TS_SETUP_SER_PROP_TS_DATA_STRENGTH_LSB  |
+           (dd_ts_setup_ser_ts_data_shape    & Si2168B_DD_TS_SETUP_SER_PROP_TS_DATA_SHAPE_MASK   ) << Si2168B_DD_TS_SETUP_SER_PROP_TS_DATA_SHAPE_LSB  |
+           (dd_ts_setup_ser_ts_clk_strength  & Si2168B_DD_TS_SETUP_SER_PROP_TS_CLK_STRENGTH_MASK ) << Si2168B_DD_TS_SETUP_SER_PROP_TS_CLK_STRENGTH_LSB  |
+           (dd_ts_setup_ser_ts_clk_shape     & Si2168B_DD_TS_SETUP_SER_PROP_TS_CLK_SHAPE_MASK    ) << Si2168B_DD_TS_SETUP_SER_PROP_TS_CLK_SHAPE_LSB  |
+           (dd_ts_setup_ser_ts_clk_invert    & Si2168B_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_MASK   ) << Si2168B_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_LSB  |
+           (dd_ts_setup_ser_ts_sync_duration & Si2168B_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_MASK) << Si2168B_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_LSB  |
+           (dd_ts_setup_ser_ts_byte_order    & Si2168B_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_MASK   ) << Si2168B_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_LSB ;
+    ret = si2168b_set_property(ctx, Si2168B_DD_TS_SETUP_SER_PROP, data);
+    pr_info("%s(): setting property Si2168B_DD_TS_SETUP_SER_PROP 0x%04X: data=0x%04X\n", __func__, Si2168B_DD_TS_SETUP_SER_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DD_TS_SETUP_SER_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    return err;
+}
+
+/*****************************************************************************************
+ NAME: si2168b_set_dvbc_properties
+  DESCRIPTION: Setup Si2168B DVBC properties configuration
+  This function will download all the DVBC configuration properties.
+  The function Si2168B_storeUserProperties should be called before the first call to this function.
+  Parameter:  Pointer to Si2168B Context
+  Returns:    I2C transaction error code, NO_Si2168B_ERROR if successful
+  Programming Guide Reference:    DVBC setup flowchart
+******************************************************************************************/
+static int si2168b_set_dvbc_properties(si2168b_context *ctx)
+{
+    const u8  dvbc_adc_crest_factor_crest_factor = 112; /* (default   112) */
+    const u16 dvbc_afc_range_range_khz           = 100; /* (default   100) */
+    const u8  dvbc_constellation_constellation   = Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_AUTO ; /* (default 'AUTO') */
+    const u16 dvbc_symbol_rate_rate              = 6900; /* (default  6900) */
+
+	u8  ret;
+	u8  err = NO_Si2168B_ERROR;
+	u16 data;
+
+	SiTRACE("si2168b_set_dvbc_properties\n");
+
+    data = (dvbc_adc_crest_factor_crest_factor & Si2168B_DVBC_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK) << Si2168B_DVBC_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DVBC_ADC_CREST_FACTOR_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DVBC_ADC_CREST_FACTOR_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dvbc_afc_range_range_khz & Si2168B_DVBC_AFC_RANGE_PROP_RANGE_KHZ_MASK) << Si2168B_DVBC_AFC_RANGE_PROP_RANGE_KHZ_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DVBC_AFC_RANGE_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DVBC_AFC_RANGE_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dvbc_constellation_constellation & Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_MASK) << Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DVBC_CONSTELLATION_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DVBC_CONSTELLATION_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dvbc_symbol_rate_rate & Si2168B_DVBC_SYMBOL_RATE_PROP_RATE_MASK) << Si2168B_DVBC_SYMBOL_RATE_PROP_RATE_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DVBC_SYMBOL_RATE_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DVBC_SYMBOL_RATE_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    return err;
+}
+
+/*****************************************************************************************
+ NAME: si2168b_set_dvbt_properties
+  DESCRIPTION: Setup Si2168B DVBT properties configuration
+  This function will download all the DVBT configuration properties.
+  The function Si2168B_storeUserProperties should be called before the first call to this function.
+  Parameter:  Pointer to Si2168B Context
+  Returns:    I2C transaction error code, NO_Si2168B_ERROR if successful
+  Programming Guide Reference:    DVBT setup flowchart
+******************************************************************************************/
+static int si2168b_set_dvbt_properties(si2168b_context *ctx)
+{
+    const u8  dvbt_adc_crest_factor_crest_factor = 130; /* (default   130) */
+    const u16 dvbt_afc_range_range_khz           = 550; /* (default   550) */
+    const u8  dvbt_hierarchy_stream              = Si2168B_DVBT_HIERARCHY_PROP_STREAM_HP; /* (default 'HP') */
+
+	u8  ret;
+	u8  err = NO_Si2168B_ERROR;
+	u16 data;
+
+	SiTRACE("si2168b_set_dvbt_properties\n");
+
+    data = (dvbt_adc_crest_factor_crest_factor & Si2168B_DVBT_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK) << Si2168B_DVBT_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DVBT_ADC_CREST_FACTOR_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DVBT_ADC_CREST_FACTOR_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dvbt_afc_range_range_khz & Si2168B_DVBT_AFC_RANGE_PROP_RANGE_KHZ_MASK) << Si2168B_DVBT_AFC_RANGE_PROP_RANGE_KHZ_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DVBT_AFC_RANGE_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DVBT_AFC_RANGE_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dvbt_hierarchy_stream & Si2168B_DVBT_HIERARCHY_PROP_STREAM_MASK) << Si2168B_DVBT_HIERARCHY_PROP_STREAM_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_DVBT_HIERARCHY_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DVBT_HIERARCHY_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+	return err;
+}
+
+/*****************************************************************************************
+ NAME: si2168b_set_dvbt2_properties
+  DESCRIPTION: Setup Si2168B DVBT2 properties configuration
+  This function will download all the DVBT2 configuration properties.
+  The function Si2168B_storeUserProperties should be called before the first call to this function.
+  Parameter:  Pointer to Si2168B Context
+  Returns:    I2C transaction error code, NO_Si2168B_ERROR if successful
+  Programming Guide Reference:    DVBT2 setup flowchart
+******************************************************************************************/
+static int si2168b_set_dvbt2_properties(si2168b_context *ctx)
+{
+    const u8  dvbt2_adc_crest_factor_crest_factor = 130; /* (default   130) */
+    const u16 dvbt2_afc_range_range_khz           = 550; /* (default   550) */
+    const u8  dvbt2_fef_tuner_tuner_delay         = 1; /* (default     1) */
+    const u8  dvbt2_fef_tuner_tuner_freeze_time   = 1; /* (default     1) */
+    const u8  dvbt2_fef_tuner_tuner_unfreeze_time = 1; /* (default     1) */
+    const u8  dvbt2_mode_lock_mode                = Si2168B_DVBT2_MODE_PROP_LOCK_MODE_ANY; /* (default 'ANY') */
+
+	u8  ret;
+	u8  err = NO_Si2168B_ERROR;
+	u16 data;
+
+    SiTRACE("si2168b_set_dvbt2_properties\n");
+
+    data = (dvbt2_adc_crest_factor_crest_factor & Si2168B_DVBT2_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK) << Si2168B_DVBT2_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB ;
+    ret = si2168b_set_property(ctx, Si2168B_DVBT2_ADC_CREST_FACTOR_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DVBT2_ADC_CREST_FACTOR_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dvbt2_afc_range_range_khz & Si2168B_DVBT2_AFC_RANGE_PROP_RANGE_KHZ_MASK) << Si2168B_DVBT2_AFC_RANGE_PROP_RANGE_KHZ_LSB ;
+    ret = si2168b_set_property(ctx, Si2168B_DVBT2_AFC_RANGE_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DVBT2_AFC_RANGE_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dvbt2_fef_tuner_tuner_delay         & Si2168B_DVBT2_FEF_TUNER_PROP_TUNER_DELAY_MASK        ) << Si2168B_DVBT2_FEF_TUNER_PROP_TUNER_DELAY_LSB  |
+            (dvbt2_fef_tuner_tuner_freeze_time   & Si2168B_DVBT2_FEF_TUNER_PROP_TUNER_FREEZE_TIME_MASK  ) << Si2168B_DVBT2_FEF_TUNER_PROP_TUNER_FREEZE_TIME_LSB  |
+            (dvbt2_fef_tuner_tuner_unfreeze_time & Si2168B_DVBT2_FEF_TUNER_PROP_TUNER_UNFREEZE_TIME_MASK) << Si2168B_DVBT2_FEF_TUNER_PROP_TUNER_UNFREEZE_TIME_LSB ;
+    ret = si2168b_set_property(ctx, Si2168B_DVBT2_FEF_TUNER_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DVBT2_FEF_TUNER_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (dvbt2_mode_lock_mode & Si2168B_DVBT2_MODE_PROP_LOCK_MODE_MASK) << Si2168B_DVBT2_MODE_PROP_LOCK_MODE_LSB ;
+    ret = si2168b_set_property(ctx, Si2168B_DVBT2_MODE_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_DVBT2_MODE_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    return err;
+}
+
+#ifdef __MCNS__
+/*****************************************************************************************
+ NAME: si2168b_set_mcns_properties
+  DESCRIPTION: Setup Si2168B MCNS properties configuration
+  This function will download all the MCNS configuration properties.
+  The function Si2168B_storeUserProperties should be called before the first call to this function.
+  Parameter:  Pointer to Si2168B Context
+  Returns:    I2C transaction error code, NO_Si2168B_ERROR if successful
+  Programming Guide Reference:    MCNS setup flowchart
+******************************************************************************************/
+static int si2168b_set_mcns_properties(si2168b_context *ctx)
+{
+#ifdef __MCNS__
+#ifdef    Si2168B_MCNS_ADC_CREST_FACTOR_PROP
+	mcns_adc_crest_factor_crest_factor                               =   112; /* (default   112) */
+#endif /* Si2168B_MCNS_ADC_CREST_FACTOR_PROP */
+
+#ifdef    Si2168B_MCNS_AFC_RANGE_PROP
+	mcns_afc_range_range_khz                                         =   100; /* (default   100) */
+#endif /* Si2168B_MCNS_AFC_RANGE_PROP */
+
+#ifdef    Si2168B_MCNS_CONSTELLATION_PROP
+	mcns_constellation_constellation                                 = Si2168B_MCNS_CONSTELLATION_PROP_CONSTELLATION_AUTO ; /* (default 'AUTO') */
+#endif /* Si2168B_MCNS_CONSTELLATION_PROP */
+
+#ifdef    Si2168B_MCNS_SYMBOL_RATE_PROP
+	mcns_symbol_rate_rate                                            =  6900; /* (default  6900) */
+#endif /* Si2168B_MCNS_SYMBOL_RATE_PROP */
+#endif /* __MCNS__ */
+
+	u8 ret = NO_Si2168B_ERROR;
+
+	SiTRACE("si2168b_set_mcns_properties\n");
+#ifdef    Si2168B_MCNS_ADC_CREST_FACTOR_PROP
+	ret = si2168b_set_property2(ctx, Si2168B_MCNS_ADC_CREST_FACTOR_PROP_CODE);
+	if (ret != NO_Si2168B_ERROR) {
+		return ERROR_Si2168B_SENDING_COMMAND;
+	}
+#endif /* Si2168B_MCNS_ADC_CREST_FACTOR_PROP */
+#ifdef    Si2168B_MCNS_AFC_RANGE_PROP
+	ret = si2168b_set_property2(ctx, Si2168B_MCNS_AFC_RANGE_PROP_CODE);
+	if (ret != NO_Si2168B_ERROR) {
+		return ERROR_Si2168B_SENDING_COMMAND;
+	}
+#endif /* Si2168B_MCNS_AFC_RANGE_PROP */
+#ifdef    Si2168B_MCNS_CONSTELLATION_PROP
+	ret = si2168b_set_property2(ctx, Si2168B_MCNS_CONSTELLATION_PROP_CODE);
+	if (ret != NO_Si2168B_ERROR) {
+		return ERROR_Si2168B_SENDING_COMMAND;
+	}
+#endif /* Si2168B_MCNS_CONSTELLATION_PROP */
+#ifdef    Si2168B_MCNS_SYMBOL_RATE_PROP
+	ret = si2168b_set_property2(ctx, Si2168B_MCNS_SYMBOL_RATE_PROP_CODE);
+	if (ret != NO_Si2168B_ERROR) {
+		return ERROR_Si2168B_SENDING_COMMAND;
+	}
+#endif /* Si2168B_MCNS_SYMBOL_RATE_PROP */
+	return NO_Si2168B_ERROR;
+}
+#endif /* __MCNS__ */
+
+/*****************************************************************************************
+ NAME: si2168b_set_scan_properties
+  DESCRIPTION: Setup Si2168B SCAN properties configuration
+  This function will download all the SCAN configuration properties.
+  The function Si2168B_storeUserProperties should be called before the first call to this function.
+  Parameter:  Pointer to Si2168B Context
+  Returns:    I2C transaction error code, NO_Si2168B_ERROR if successful
+  Programming Guide Reference:    SCAN setup flowchart
+******************************************************************************************/
+static int si2168b_set_scan_properties(si2168b_context *ctx)
+{
+	const u16 scan_fmax_scan_fmax                   = 0; /* (default     0) */
+    const u16 scan_fmin_scan_fmin                   = 0; /* (default     0) */
+    const u8  scan_ien_buzien                       = Si2168B_SCAN_IEN_PROP_BUZIEN_DISABLE; /* (default 'DISABLE') */
+    const u8  scan_ien_reqien                       = Si2168B_SCAN_IEN_PROP_REQIEN_DISABLE; /* (default 'DISABLE') */
+    const u8  scan_int_sense_buznegen               = Si2168B_SCAN_INT_SENSE_PROP_BUZNEGEN_ENABLE; /* (default 'ENABLE') */
+    const u8  scan_int_sense_reqnegen               = Si2168B_SCAN_INT_SENSE_PROP_REQNEGEN_DISABLE; /* (default 'DISABLE') */
+    const u8  scan_int_sense_buzposen               = Si2168B_SCAN_INT_SENSE_PROP_BUZPOSEN_DISABLE; /* (default 'DISABLE') */
+    const u8  scan_int_sense_reqposen               = Si2168B_SCAN_INT_SENSE_PROP_REQPOSEN_ENABLE; /* (default 'ENABLE') */
+	const u16 scan_symb_rate_max_scan_symb_rate_max = 0; /* (default     0) */
+    const u16 scan_symb_rate_min_scan_symb_rate_min = 0; /* (default     0) */
+    /* const u8  scan_ter_config_mode                  = Si2168B_SCAN_TER_CONFIG_PROP_MODE_MAPPING_SCAN; */ /* (default 'BLIND_SCAN') */
+    const u8  scan_ter_config_mode                  = Si2168B_SCAN_TER_CONFIG_PROP_MODE_BLIND_SCAN; /* (default 'BLIND_SCAN') */
+    const u8  scan_ter_config_analog_bw             = Si2168B_SCAN_TER_CONFIG_PROP_ANALOG_BW_8MHZ; /* (default '8MHZ') */
+    const u8  scan_ter_config_search_analog         = Si2168B_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_DISABLE; /* (default 'DISABLE') */
+    const u8  scan_ter_config_scan_debug            = 0;
+
+#ifdef Si2168B_SCAN_SAT_CONFIG_PROP
+	scan_sat_config_analog_detect                                    = Si2168B_SCAN_SAT_CONFIG_PROP_ANALOG_DETECT_DISABLED ; /* (default 'DISABLED') */
+	scan_sat_config_reserved1                                        =     0; /* (default     0) */
+	scan_sat_config_reserved2                                        =    12; /* (default    12) */
+#endif /* Si2168B_SCAN_SAT_CONFIG_PROP */
+#ifdef Si2168B_SCAN_SAT_UNICABLE_BW_PROP
+	scan_sat_unicable_bw_scan_sat_unicable_bw                        =     0; /* (default     0) */
+#endif /* Si2168B_SCAN_SAT_UNICABLE_BW_PROP */
+#ifdef Si2168B_SCAN_SAT_UNICABLE_MIN_TUNE_STEP_PROP
+	scan_sat_unicable_min_tune_step_scan_sat_unicable_min_tune_step  =    50; /* (default    50) */
+#endif /* Si2168B_SCAN_SAT_UNICABLE_MIN_TUNE_STEP_PROP */
+
+	u8  ret;
+	u8  err = NO_Si2168B_ERROR;
+	u16 data;
+
+	SiTRACE("si2168b_set_scan_properties\n");
+
+    data = (scan_fmax_scan_fmax & Si2168B_SCAN_FMAX_PROP_SCAN_FMAX_MASK) << Si2168B_SCAN_FMAX_PROP_SCAN_FMAX_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_SCAN_FMAX_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_SCAN_FMAX_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (scan_fmin_scan_fmin & Si2168B_SCAN_FMIN_PROP_SCAN_FMIN_MASK) << Si2168B_SCAN_FMIN_PROP_SCAN_FMIN_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_SCAN_FMIN_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_SCAN_FMIN_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (scan_ien_buzien & Si2168B_SCAN_IEN_PROP_BUZIEN_MASK) << Si2168B_SCAN_IEN_PROP_BUZIEN_LSB |
+           (scan_ien_reqien & Si2168B_SCAN_IEN_PROP_REQIEN_MASK) << Si2168B_SCAN_IEN_PROP_REQIEN_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_SCAN_IEN_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_SCAN_IEN_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (scan_int_sense_buznegen & Si2168B_SCAN_INT_SENSE_PROP_BUZNEGEN_MASK) << Si2168B_SCAN_INT_SENSE_PROP_BUZNEGEN_LSB |
+           (scan_int_sense_reqnegen & Si2168B_SCAN_INT_SENSE_PROP_REQNEGEN_MASK) << Si2168B_SCAN_INT_SENSE_PROP_REQNEGEN_LSB |
+           (scan_int_sense_buzposen & Si2168B_SCAN_INT_SENSE_PROP_BUZPOSEN_MASK) << Si2168B_SCAN_INT_SENSE_PROP_BUZPOSEN_LSB |
+           (scan_int_sense_reqposen & Si2168B_SCAN_INT_SENSE_PROP_REQPOSEN_MASK) << Si2168B_SCAN_INT_SENSE_PROP_REQPOSEN_LSB;
+    ret = si2168b_set_property(ctx, Si2168B_SCAN_INT_SENSE_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_SCAN_INT_SENSE_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (scan_symb_rate_max_scan_symb_rate_max & Si2168B_SCAN_SYMB_RATE_MAX_PROP_SCAN_SYMB_RATE_MAX_MASK) << Si2168B_SCAN_SYMB_RATE_MAX_PROP_SCAN_SYMB_RATE_MAX_LSB ;
+    ret = si2168b_set_property(ctx, Si2168B_SCAN_SYMB_RATE_MAX_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_SCAN_SYMB_RATE_MAX_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (scan_symb_rate_min_scan_symb_rate_min & Si2168B_SCAN_SYMB_RATE_MIN_PROP_SCAN_SYMB_RATE_MIN_MASK) << Si2168B_SCAN_SYMB_RATE_MIN_PROP_SCAN_SYMB_RATE_MIN_LSB ;
+    ret = si2168b_set_property(ctx, Si2168B_SCAN_SYMB_RATE_MIN_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_SCAN_SYMB_RATE_MIN_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    data = (scan_ter_config_mode          & Si2168B_SCAN_TER_CONFIG_PROP_MODE_MASK         ) << Si2168B_SCAN_TER_CONFIG_PROP_MODE_LSB  |
+           (scan_ter_config_analog_bw     & Si2168B_SCAN_TER_CONFIG_PROP_ANALOG_BW_MASK    ) << Si2168B_SCAN_TER_CONFIG_PROP_ANALOG_BW_LSB  |
+           (scan_ter_config_search_analog & Si2168B_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_MASK) << Si2168B_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_LSB |
+           (scan_ter_config_scan_debug    & Si2168B_SCAN_TER_CONFIG_PROP_SCAN_DEBUG_MASK   ) << Si2168B_SCAN_TER_CONFIG_PROP_SCAN_DEBUG_LSB ;
+    ret = si2168b_set_property(ctx, Si2168B_SCAN_TER_CONFIG_PROP, data);
+    if (ret != NO_Si2168B_ERROR) {
+		siprintk("%s(): setting property Si2168B_SCAN_TER_CONFIG_PROP failed.\n", __func__);
+		err = ERROR_Si2168B_SENDING_COMMAND;
+    }
+
+    return err;
+}
+
+static int si2168b_set_all_properties(si2168b_context *ctx)
+{
+	si2168b_set_common_properties(ctx);
+	si2168b_set_dd_properties(ctx);
+	si2168b_set_dvbc_properties(ctx);
+	si2168b_set_dvbt_properties(ctx);
+	si2168b_set_dvbt2_properties(ctx);
+#ifdef __MCNS__
+	si2168b_set_mcns_properties(ctx);
+#endif /* __MCNS__ */
+	si2168b_set_scan_properties(ctx);
+	return 0;
+}
+
+/************************************************************************************************************************
+  NAME: si2168b_configure
+  DESCRIPTION: Setup TER and SAT AGCs, Common Properties startup
+  Parameter:  Pointer to Si2168B Context
+  Returns:    I2C transaction error code, NO_Si2168B_ERROR if successful
+************************************************************************************************************************/
+static int si2168b_configure(si2168b_context *ctx)
+{
+	const u8 dd_ext_agc_ter_agc_1_mode = Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MODE_NO_CHANGE;
+	const u8 dd_ext_agc_ter_agc_1_inv  = Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_INV_NOT_INVERTED;
+	const u8 dd_ext_agc_ter_agc_2_mode = Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MODE_NO_CHANGE;
+	const u8 dd_ext_agc_ter_agc_2_inv  = Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_INV_NOT_INVERTED;
+
+	Si2168B_DD_MP_DEFAULTS_CMD_REPLY_struct dd_mp_defaults;
+	Si2168B_DD_EXT_AGC_TER_CMD_REPLY_struct dd_ext_agc_ter;
+	Si2168B_CONFIG_PINS_CMD_REPLY_struct config_pins;
+	Si2168B_DVBT2_FEF_CMD_REPLY_struct dvbt2_fef;
+	Si2168B_GET_REV_CMD_REPLY_struct get_rev;
+	u8 dd_mp_defaults_mp_a_mode;
+	u8 dd_mp_defaults_mp_b_mode;
+	u8 dd_mp_defaults_mp_c_mode;
+	u8 dd_mp_defaults_mp_d_mode;
+	u8 dd_ext_agc_ter_agc_1_kloop;
+	u8 dd_ext_agc_ter_agc_2_kloop;
+	u8 dd_ext_agc_ter_agc_1_min;
+	u8 dd_ext_agc_ter_agc_2_min;
+	u8 config_pins_gpio0_mode;
+	u8 config_pins_gpio0_read;
+	u8 config_pins_gpio1_mode;
+	u8 config_pins_gpio1_read;
+	u8 dvbt2_fef_tuner_flag     = Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_NOT_USED;
+	u8 dvbt2_fef_tuner_flag_inv = Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_FEF_HIGH;
+	u8 fef_pin   = 0;
+	u8 fef_level = 0;
+
+	int return_code = NO_Si2168B_ERROR;
+
+	SiTRACE("media %d\n", ctx->media);
+
+	return_code = si2168b_get_revision(ctx, &get_rev);
+	if (return_code != NO_Si2168B_ERROR) {
+		SiTRACE ("si2168b_get_revision error 0x%02x: %s\n", return_code, si2168b_error_text(return_code) );
+		return return_code;
+	}
+
+	/* AGC settings when not used */
+	if ( get_rev.mcm_die == Si2168B_GET_REV_RESPONSE_MCM_DIE_DIE_A) {
+		dd_mp_defaults_mp_a_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_A_MODE_DISABLE;
+		dd_mp_defaults_mp_b_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_B_MODE_NO_CHANGE;
+		dd_mp_defaults_mp_c_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_C_MODE_DISABLE;
+		dd_mp_defaults_mp_d_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_D_MODE_NO_CHANGE;
+	} else if ( get_rev.mcm_die == Si2168B_GET_REV_RESPONSE_MCM_DIE_DIE_B) {
+		dd_mp_defaults_mp_a_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_A_MODE_NO_CHANGE;
+		dd_mp_defaults_mp_b_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_B_MODE_DISABLE;
+		dd_mp_defaults_mp_c_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_C_MODE_NO_CHANGE;
+		dd_mp_defaults_mp_d_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_D_MODE_DISABLE;
+	} else {
+		dd_mp_defaults_mp_a_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_A_MODE_DISABLE;
+		dd_mp_defaults_mp_b_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_B_MODE_DISABLE;
+		dd_mp_defaults_mp_c_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_C_MODE_DISABLE;
+		dd_mp_defaults_mp_d_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_D_MODE_DISABLE;
+	}
+
+	/************************************************************************************************************************
+	  Si2168B_L2_TER_FEF_CONFIG function
+	  Use:        TER tuner FEF pin selection function
+	              Used to select the FEF pin connected to the terrestrial tuner
+	  Parameter:  *front_end, the front-end handle
+	  Parameter:  fef_mode, a flag controlling the FEF mode between SLOW_NORMAL_AGC(0), FREEZE_PIN(1)' and SLOW_INITIAL_AGC(2)
+	  Parameter:  fef_pin: where the FEF signal comes from.
+	              possible modes:
+	                0x0: Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_NOT_USED
+	                0xA: Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_A
+	                0xB: Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_B
+	                0xC: Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_C
+	                0xD: Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_D
+	  Parameter:  fef_level, a flag controlling the FEF signal level when active between 'low'(0) and 'high'(1)
+	  Returns:    1
+	************************************************************************************************************************/
+
+	switch (ctx->fef_mode) {
+	default:
+	case Si2168B_FEF_MODE_SLOW_NORMAL_AGC:
+	case Si2168B_FEF_MODE_SLOW_INITIAL_AGC:
+		fef_pin   = 0x0;
+		fef_level = 0;
+		break;
+	case Si2168B_FEF_MODE_FREEZE_PIN:
+		fef_pin   = ctx->fef_pin;
+		fef_level = ctx->fef_level;
+		break;
+	}
+
+	switch (fef_pin) {
+	default:
+	case 0x0: { dvbt2_fef_tuner_flag  = Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_NOT_USED; break; }
+	case 0xA: { dvbt2_fef_tuner_flag  = Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_A    ; break; }
+	case 0xB: { dvbt2_fef_tuner_flag  = Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_B    ; break; }
+	case 0xC: { dvbt2_fef_tuner_flag  = Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_C    ; break; }
+	case 0xD: { dvbt2_fef_tuner_flag  = Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_D    ; break; }
+	}
+
+	if (fef_level == 0) {
+		dvbt2_fef_tuner_flag_inv = Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_FEF_LOW ;
+	} else {
+		dvbt2_fef_tuner_flag_inv = Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_FEF_HIGH;
+	}
+
+	/*  For DVB_T2, if the TER tuner has a FEF freeze input pin, drive this pin to 0 or 1 when NOT in T2 */
+	/* if FEF is active high, set the pin to 0 when NOT in T2 */
+	/* if FEF is active low,  set the pin to 1 when NOT in T2 */
+	if (ctx->fef_mode == Si2168B_FEF_MODE_FREEZE_PIN) {
+		switch (fef_pin) {
+		case Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MP_A: {
+			dvbt2_fef_tuner_flag = Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_A;
+			if (fef_level == 1) {
+				dd_mp_defaults_mp_a_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_A_MODE_DRIVE_0;
+			} else {
+				dd_mp_defaults_mp_a_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_A_MODE_DRIVE_1;
+			}
+			break;
+		}
+		case Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MP_B: {
+			dvbt2_fef_tuner_flag = Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_B;
+			if (fef_level == 1) {
+				dd_mp_defaults_mp_b_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_B_MODE_DRIVE_0;
+			} else {
+				dd_mp_defaults_mp_b_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_B_MODE_DRIVE_1;
+			}
+			break;
+		}
+		case Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MP_C: {
+			dvbt2_fef_tuner_flag = Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_C;
+			if (fef_level == 1) {
+				dd_mp_defaults_mp_c_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_C_MODE_DRIVE_0;
+			} else {
+				dd_mp_defaults_mp_c_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_C_MODE_DRIVE_1;
+			}
+			break;
+		}
+		case Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MP_D: {
+			dvbt2_fef_tuner_flag = Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_D;
+			if (fef_level == 1) {
+				dd_mp_defaults_mp_d_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_D_MODE_DRIVE_0;
+			} else {
+				dd_mp_defaults_mp_d_mode = Si2168B_DD_MP_DEFAULTS_CMD_MP_D_MODE_DRIVE_1;
+			}
+			break;
+		}
+		default: break;
+		}
+	}
+	/* Si2168B_L1_SendCommand2(ctx, Si2168B_DVBT2_FEF_CMD_CODE); */
+	si2168b_dvbt2_fef(ctx, dvbt2_fef_tuner_flag, dvbt2_fef_tuner_flag_inv, &dvbt2_fef);
+	/* Si2168B_L1_SendCommand2(ctx, Si2168B_DD_MP_DEFAULTS_CMD_CODE); */
+	si2168b_dd_mp_defaults(ctx, dd_mp_defaults_mp_a_mode, dd_mp_defaults_mp_b_mode, dd_mp_defaults_mp_c_mode, dd_mp_defaults_mp_d_mode, &dd_mp_defaults);
+
+	if (ctx->media == Si2168B_TERRESTRIAL) {
+		/* TER AGC pins and inversion are previously selected using Si2168B_L2_TER_AGC */
+		dd_ext_agc_ter_agc_1_kloop = Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_MIN;
+		dd_ext_agc_ter_agc_1_min   = Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MIN_MIN;
+
+		dd_ext_agc_ter_agc_2_kloop = 18;
+		dd_ext_agc_ter_agc_2_min   = Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MIN_MIN;
+		/* Si2168B_L1_SendCommand2(ctx, Si2168B_DD_EXT_AGC_TER_CMD_CODE); */
+		si2168b_dd_ext_agc_ter(ctx,
+				dd_ext_agc_ter_agc_1_mode,
+				dd_ext_agc_ter_agc_1_inv,
+				dd_ext_agc_ter_agc_2_mode,
+				dd_ext_agc_ter_agc_2_inv,
+				dd_ext_agc_ter_agc_1_kloop,
+				dd_ext_agc_ter_agc_2_kloop,
+				dd_ext_agc_ter_agc_1_min,
+				dd_ext_agc_ter_agc_2_min,
+				&dd_ext_agc_ter);
+	}
+
+	/* LEDS MANAGEMENT */
+	/* set hardware lock on LED */
+	if ( get_rev.mcm_die == Si2168B_GET_REV_RESPONSE_MCM_DIE_DIE_A) {
+		config_pins_gpio0_mode = Si2168B_CONFIG_PINS_CMD_GPIO0_MODE_NO_CHANGE;
+		config_pins_gpio0_read = Si2168B_CONFIG_PINS_CMD_GPIO0_READ_DO_NOT_READ;
+		config_pins_gpio1_mode = Si2168B_CONFIG_PINS_CMD_GPIO1_MODE_HW_LOCK;
+		config_pins_gpio1_read = Si2168B_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ;
+	} else if ( get_rev.mcm_die == Si2168B_GET_REV_RESPONSE_MCM_DIE_DIE_B) {
+		config_pins_gpio0_mode = Si2168B_CONFIG_PINS_CMD_GPIO0_MODE_HW_LOCK;
+		config_pins_gpio0_read = Si2168B_CONFIG_PINS_CMD_GPIO0_READ_DO_NOT_READ;
+		config_pins_gpio1_mode = Si2168B_CONFIG_PINS_CMD_GPIO1_MODE_NO_CHANGE;
+		config_pins_gpio1_read = Si2168B_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ;
+	} else {
+		config_pins_gpio0_mode = Si2168B_CONFIG_PINS_CMD_GPIO0_MODE_HW_LOCK;
+		config_pins_gpio0_read = Si2168B_CONFIG_PINS_CMD_GPIO0_READ_DO_NOT_READ;
+		config_pins_gpio1_mode = Si2168B_CONFIG_PINS_CMD_GPIO1_MODE_TS_ERR;
+		config_pins_gpio1_read = Si2168B_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ;
+	}
+	/* Si2168B_L1_SendCommand2(ctx, Si2168B_CONFIG_PINS_CMD_CODE); */
+	si2168b_config_pins(ctx, config_pins_gpio0_mode, config_pins_gpio0_read, config_pins_gpio1_mode, config_pins_gpio1_read, &config_pins);
+
+	/* Download properties different from 'default' */
+	si2168b_set_all_properties(ctx);
+
+#ifdef    USB_Capability
+	if ( ctx->rsp->get_rev.mcm_die == Si2168B_GET_REV_RESPONSE_MCM_DIE_SINGLE) {
+		/* Setting GPIF clock to not_inverted to allow TS over USB transfer */
+		Si2168B_L1_DD_SET_REG(ctx, 0 , 35, 1, 0);
+	}
+#endif /* USB_Capability */
+
+	return return_code;
+}
+
+/************************************************************************************************************************
+  NAME: si2168b_first_init
+  DESCRIPTION:Reset and Initialize Si2168B
+  Parameter:  Si2168B Context (I2C address)
+  Returns:    I2C transaction error code, NO_Si2168B_ERROR if successful
+************************************************************************************************************************/
+static int si2168b_first_init(si2168b_context *ctx)
+{
+    int return_code;
+    SiTRACE("si2168b_first_init() starting...\n");
+
+    if ((return_code = si2168b_power_up_with_patch(ctx)) != NO_Si2168B_ERROR) {   /* PowerUp into bootloader */
+        SiTRACE ("si2168b_power_up_with_patch error 0x%02x: %s\n", return_code, si2168b_error_text(return_code) );
+        return return_code;
+    }
+    /* At this point, FW is loaded and started.  */
+    si2168b_configure(ctx);
+    SiTRACE("si2168b_first_init() complete...\n");
+    return NO_Si2168B_ERROR;
+}
+
+/************************************************************************************************************************
+  si2168b_ter_fef_setup function
+  Use:        TER tuner LPF setting function
+              Used to configure the FEF mode in the terrestrial tuner
+  Comments:   If the tuner is connected via the demodulator's I2C switch, enabling/disabling the i2c_passthru is required before/after tuning.
+  Behavior:   This function closes the Si2168B's I2C switch then sets the TER FEF mode and finally reopens the I2C switch
+  Parameter:  *front_end, the front-end handle
+  Parameter:  fef, a flag controlling the selection between FEF 'off'(0) and FEF 'on'(1)
+  Returns:    1
+************************************************************************************************************************/
+static int si2168b_ter_fef_setup(Si2168B_L2_Context *front_end, int fef)
+{
+	SiTRACE("si2168b_ter_fef_setup %d\n",fef);
+
+#ifdef L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN_SETUP
+	if (front_end->demod->fef_mode == Si2168B_FEF_MODE_FREEZE_PIN) {
+		SiTRACE("FEF mode Si2168B_FEF_MODE_FREEZE_PIN\n");
+		/* setup now in tuner module */
+	}
+#endif /* L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN_SETUP */
+
+#ifdef L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP
+	if (front_end->demod->fef_mode == Si2168B_FEF_MODE_SLOW_INITIAL_AGC) {
+		SiTRACE("FEF mode Si2168B_FEF_MODE_SLOW_INITIAL_AGC (AGC slowed down after tuning)\n");
+		/* setup now in tuner module */
+	}
+#endif /* L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP */
+
+#ifdef L1_RF_TER_TUNER_FEF_MODE_SLOW_NORMAL_AGC_SETUP
+	if (front_end->demod->fef_mode == Si2168B_FEF_MODE_SLOW_NORMAL_AGC) {
+		SiTRACE("FEF mode Si2168B_FEF_MODE_SLOW_NORMAL_AGC: AGC slowed down\n");
+		/* setup now in tuner module */
+	}
+#endif /* L1_RF_TER_TUNER_FEF_MODE_SLOW_NORMAL_AGC */
+
+	if ( front_end->tuner_indirect_i2c_connection ) {  /* INDIRECT_I2C_CONNECTION? */
+		front_end->f_TER_tuner_enable(front_end->callback);
+	} else {
+		si2168b_tuner_i2c_enable(front_end);
+	}
+
+	si2168b_ter_fef(front_end, fef);
+
+	if ( front_end->tuner_indirect_i2c_connection ) {  /* INDIRECT_I2C_CONNECTION? */
+		front_end->f_TER_tuner_disable(front_end->callback);
+	} else {
+		si2168b_tuner_i2c_disable(front_end);
+	}
+
+	SiTRACE("si2168b_ter_fef_setup done\n");
+	return 1;
+}
+
+/************************************************************************************************************************
+  si2168b_switch_to_standard function
+  Use:      Standard switching function selection
+            Used to switch nicely to the wanted standard, taking into account the previous state
+  Parameter: new_standard the wanted standard to switch to
+  Behavior: This function positions a set of flags to easily decide what needs to be done to
+              switch between standards.
+************************************************************************************************************************/
+static int si2168b_switch_to_standard(struct dvb_frontend *fe, u8 new_standard, u8 force_full_init)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+	Si2168B_L2_Context *front_end = priv->si_front_end;
+
+	/* previous state flags */
+	int dtv_demod_already_used = 0;
+	int i2c_connected          = 0;
+	int ter_tuner_already_used = 0;
+	int ter_clock_already_used = 0;
+	/* new state flags      */
+	int dtv_demod_needed       = 0;
+	int ter_tuner_needed       = 0;
+	int ter_clock_needed       = 0;
+	int dtv_demod_sleep_request= 0;
+	int res;
+
+	u8  dd_mode_bw = 8;
+	u8  dd_mode_modulation  = Si2168B_DD_MODE_PROP_MODULATION_DVBT;
+	u8  dd_mode_auto_detect = Si2168B_DD_MODE_PROP_AUTO_DETECT_NONE;
+	u8  dd_mode_invert_spectrum = Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_NORMAL;
+	u16 data;
+
+	SiTRACE("Si2168B_switch_to_standard %d starting... (full_init=%d)\n", new_standard, force_full_init);
+	SiTRACE("starting with Si2168B_init_done %d, first_init_done     %d\n", front_end->Si2168B_init_done, front_end->first_init_done);
+	SiTRACE("TER flags:    TER_init_done    %d\n", front_end->TER_init_done);
+
+	/* In this function is called for the first time, force a full init */
+	if (front_end->first_init_done == 0) {
+		force_full_init = 1;
+	}
+	/* ------------------------------------------------------------ */
+	/* Set Previous Flags                                           */
+	/* Setting flags representing the previous state                */
+	/* NB: Any value not matching a known standard will init as ATV */
+	/* Logic applied:                                               */
+	/*  dtv demod was used for TERRESTRIAL and SATELLITE reception  */
+	/*  ter tuner was used for TERRESTRIAL reception                */
+	/*   and for SATELLITE reception if it is the SAT clock source  */
+	/*  sat tuner was used for SATELLITE reception                  */
+	/*   and for TERRESTRIAL reception if it is the TER clock source*/
+	/* ------------------------------------------------------------ */
+	switch (front_end->previous_standard) {
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBT:
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBT2:
+#ifdef __MCNS__
+	case Si2168B_DD_MODE_PROP_MODULATION_MCNS:
+#endif /* __MCNS__ */
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBC: {
+		dtv_demod_already_used = 1;
+		ter_tuner_already_used = 1;
+		if ( front_end->demod->tuner_ter_clock_source == Si2168B_TER_Tuner_clock) {
+			ter_clock_already_used = 1;
+		}
+		break;
+	}
+	case Si2168B_DD_MODE_PROP_MODULATION_ANALOG: {
+		ter_tuner_already_used = 1;
+		break;
+	}
+	default : /* SLEEP */   {
+		siprintk("%s(): unknown previous standard %d.\n", __func__, front_end->previous_standard);
+		ter_tuner_already_used = 0;
+		break;
+	}
+	}
+	/* ------------------------------------------------------------ */
+	/* Set Needed Flags                                             */
+	/* Setting flags representing the new state                     */
+	/* Logic applied:                                               */
+	/*  dtv demod is needed for TERRESTRIAL and SATELLITE reception */
+	/*  ter tuner is needed for TERRESTRIAL reception               */
+	/*   and for SATELLITE reception if it is the SAT clock source  */
+	/*  sat tuner is needed for SATELLITE reception                 */
+	/*   and for TERRESTRIAL reception if it is the TER clock source*/
+	/* ------------------------------------------------------------ */
+	switch (new_standard) {
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBT:
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBT2:
+#ifdef __MCNS__
+	case Si2168B_DD_MODE_PROP_MODULATION_MCNS:
+#endif /* __MCNS__ */
+	case Si2168B_DD_MODE_PROP_MODULATION_DVBC: {
+		dtv_demod_needed = 1;
+		ter_tuner_needed = 1;
+		if ( front_end->demod->tuner_ter_clock_source == Si2168B_TER_Tuner_clock) {
+			ter_clock_needed = 1;
+		}
+		break;
+	}
+	case Si2168B_DD_MODE_PROP_MODULATION_ANALOG: {
+		ter_tuner_needed = 1;
+		break;
+	}
+	default : /* SLEEP */   {
+		siprintk("%s(): unknown modulation %d submitted. Entering SLEEP mode now...\n", __func__, new_standard);
+		ter_tuner_needed = 0;
+		break;
+	}
+	}
+	/* ------------------------------------------------------------ */
+	/* For multiple front-ends: override clock_needed flags         */
+	/*  to avoid switching shared clocks                            */
+	/* ------------------------------------------------------------ */
+	/* For multiple front-ends: overrride clock_needed flags to avoid switching shared clocks */
+	if (ter_clock_needed == 0) {
+		if ( front_end->demod->tuner_ter_clock_control == Si2168B_CLOCK_ALWAYS_ON ) {
+			SiTRACE("forcing ter_clock_needed = 1\n");
+			ter_clock_needed = 1;
+		}
+	} else {
+		if ( front_end->demod->tuner_ter_clock_control == Si2168B_CLOCK_ALWAYS_OFF) {
+			SiTRACE("forcing ter_clock_needed = 0\n");
+			ter_clock_needed = 0;
+		}
+	}
+
+	/* ------------------------------------------------------------ */
+	/* if 'force' flag is set, set flags to trigger a full init     */
+	/* This can be used to re-init the NIM after a power cycle      */
+	/*  or a HW reset                                               */
+	/* ------------------------------------------------------------ */
+	if (force_full_init) {
+		SiTRACE("Forcing full init\n");
+		/* set 'init_done' flags to force full init     */
+		front_end->first_init_done     = 0;
+		front_end->Si2168B_init_done    = 0;
+		front_end->TER_init_done       = 0;
+		/* set 'already used' flags to force full init  */
+		ter_tuner_already_used = 0;
+		dtv_demod_already_used = 0;
+	}
+
+	/* ------------------------------------------------------------ */
+	/* Request demodulator sleep if its clock will be stopped       */
+	/* ------------------------------------------------------------ */
+	if ((ter_tuner_already_used == 1) & (ter_tuner_needed == 0) ) {
+		SiTRACE("TER tuner 1->0 \n");
+	}
+	if ((ter_tuner_already_used == 0) & (ter_tuner_needed == 1) ) {
+		SiTRACE("TER tuner 0->1 \n");
+	}
+	if ((ter_clock_already_used == 1) & (ter_clock_needed == 0) ) {
+		SiTRACE("TER clock 1->0 \n");
+		dtv_demod_sleep_request = 1;
+	}
+	if ((ter_clock_already_used == 0) & (ter_clock_needed == 1) ) {
+		SiTRACE("TER clock 0->1 \n");
+		dtv_demod_sleep_request = 1;
+	}
+	/* ------------------------------------------------------------ */
+	/* Request demodulator sleep if transition from '1' to '0'      */
+	/* ------------------------------------------------------------ */
+	if ((dtv_demod_already_used == 1) & (dtv_demod_needed == 0) ) {
+		dtv_demod_sleep_request = 1;
+	}
+	SiTRACE("dtv_demod_already_used %d, dtv_demod_needed %d, dtv_demod_sleep_request %d\n", dtv_demod_already_used , dtv_demod_needed, dtv_demod_sleep_request);
+	/* ------------------------------------------------------------ */
+	/* Sleep dtv demodulator if requested                           */
+	/* ------------------------------------------------------------ */
+	if (dtv_demod_sleep_request == 1) {
+		SiTRACE("Sleep DTV demod\n");
+		/* To avoid issues with the FEF pin when switching from T2 to ANALOG, set the demodulator for DVB-T/non auto detect reception before POWER_DOWN */
+		if (new_standard == Si2168B_DD_MODE_PROP_MODULATION_ANALOG) {
+			if ( ( (front_end->previous_standard == Si2168B_DD_MODE_PROP_MODULATION_DVBT  )
+					& (front_end->demod->dd_mode_auto_detect == Si2168B_DD_MODE_PROP_AUTO_DETECT_AUTO_DVB_T_T2) )
+					| (front_end->previous_standard == Si2168B_DD_MODE_PROP_MODULATION_DVBT2 ) ) {
+				dd_mode_modulation  = Si2168B_DD_MODE_PROP_MODULATION_DVBT;
+				dd_mode_auto_detect = Si2168B_DD_MODE_PROP_AUTO_DETECT_NONE;
+			    data = (dd_mode_bw              & Si2168B_DD_MODE_PROP_BW_MASK             ) << Si2168B_DD_MODE_PROP_BW_LSB |
+			           (dd_mode_modulation      & Si2168B_DD_MODE_PROP_MODULATION_MASK     ) << Si2168B_DD_MODE_PROP_MODULATION_LSB |
+			           (dd_mode_invert_spectrum & Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_MASK) << Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_LSB |
+			           (dd_mode_auto_detect     & Si2168B_DD_MODE_PROP_AUTO_DETECT_MASK    ) << Si2168B_DD_MODE_PROP_AUTO_DETECT_LSB;
+				si2168b_set_property(front_end->demod, Si2168B_DD_MODE_PROP, data);
+				si2168b_dd_restart(front_end->demod);
+			}
+		}
+		si2168b_standby(front_end->demod);
+	}
+
+	/* ------------------------------------------------------------ */
+	/* Set media for new standard                                   */
+	/* ------------------------------------------------------------ */
+	front_end->demod->dd_mode_modulation = new_standard;
+	front_end->demod->media = si2168b_media(front_end->demod);
+
+	/* ------------------------------------------------------------ */
+	/* Allow i2c traffic to reach the tuners                        */
+	/* ------------------------------------------------------------ */
+	if ( front_end->tuner_indirect_i2c_connection ) { /* INDIRECT_I2C_CONNECTION? */
+		/* Connection will be done later on, depending on TER/SAT */
+	} else {
+		SiTRACE("Connect tuners i2c\n");
+		si2168b_tuner_i2c_enable(front_end);
+		i2c_connected = 1;
+	}
+	/* ------------------------------------------------------------ */
+	/* Sleep Ter Tuner                                              */
+	/* Sleep terrestrial tuner  if transition from '1' to '0'       */
+	/* ------------------------------------------------------------ */
+	if ((ter_tuner_already_used == 1) & (ter_tuner_needed == 0) ) {
+		if ( front_end->tuner_indirect_i2c_connection ) { /* INDIRECT_I2C_CONNECTION? */
+			if (i2c_connected==0) {
+				SiTRACE("-- I2C -- Connect TER tuner i2c to sleep it\n");
+				front_end->f_TER_tuner_enable(front_end->callback);
+				i2c_connected++;
+			}
+		}
+		SiTRACE("Sleep terrestrial tuner\n");
+		if (fe->ops.tuner_ops.sleep) {
+			res = fe->ops.tuner_ops.sleep(fe);
+			if (res) {
+				SiTRACE("Terrestrial tuner sleep error!\n");
+			}
+		} else {
+			SiTRACE("WARNING: sleep() not available\n");
+		}
+	}
+
+	/* ------------------------------------------------------------ */
+	/* Wakeup Ter Tuner                                             */
+	/* Wake up terrestrial tuner if transition from '0' to '1'      */
+	/* ------------------------------------------------------------ */
+	if ((ter_tuner_already_used == 0) & (ter_tuner_needed == 1)) {
+		if ( front_end->tuner_indirect_i2c_connection ) { /* INDIRECT_I2C_CONNECTION? */
+			if (i2c_connected==0) {
+				SiTRACE("-- I2C -- Connect TER tuner i2c to init/wakeup it\n");
+				front_end->f_TER_tuner_enable(front_end->callback);
+				i2c_connected++;
+			}
+		}
+		if (fe->ops.tuner_ops.init) {
+			res = fe->ops.tuner_ops.init(fe);
+			if (res) {
+				SiTRACE("Terrestrial tuner init error!\n");
+			}
+		} else {
+			SiTRACE("WARNING: init() not available\n");
+		}
+	}
+
+	if ((front_end->previous_standard != new_standard) & (dtv_demod_needed == 0) & (front_end->demod->media == Si2168B_TERRESTRIAL)) {
+		if (front_end->demod->media == Si2168B_TERRESTRIAL) {
+#ifdef    TER_TUNER_ATV_LO_INJECTION
+			TER_TUNER_ATV_LO_INJECTION(front_end->tuner_ter);
+#endif /* TER_TUNER_ATV_LO_INJECTION */
+
+		}
+	}
+	/* ------------------------------------------------------------ */
+	/* Change Dtv Demod standard if required                        */
+	/* ------------------------------------------------------------ */
+	if ((front_end->previous_standard != new_standard) & (dtv_demod_needed == 1)) {
+		SiTRACE("Store demod standard (%d)\n", new_standard);
+		front_end->standard = new_standard;
+		/* Set flag to trigger Si2168B init or re_init, to complete    */
+		/*  the standard change                                       */
+		dtv_demod_already_used = 0;
+		if (front_end->demod->media == Si2168B_TERRESTRIAL) {
+#ifdef    TER_TUNER_DTV_LO_INJECTION
+			TER_TUNER_DTV_LO_INJECTION(front_end->tuner_ter);
+#endif /* TER_TUNER_DTV_LO_INJECTION */
+#ifdef    TER_TUNER_DTV_LIF_OUT_AMP
+			/* Adjusting LIF signal for cable or terrestrial reception */
+			switch (new_standard) {
+			case Si2168B_DD_MODE_PROP_MODULATION_DVBT:
+			case Si2168B_DD_MODE_PROP_MODULATION_DVBT2:
+			{
+				TER_TUNER_DTV_LIF_OUT_AMP(front_end->tuner_ter, 0);
+				break;
+			}
+#ifdef __MCNS__
+			case Si2168B_DD_MODE_PROP_MODULATION_MCNS:
+#endif /* __MCNS__ */
+			case Si2168B_DD_MODE_PROP_MODULATION_DVBC: {
+				TER_TUNER_DTV_LIF_OUT_AMP(front_end->tuner_ter, 1);
+				break;
+			}
+			default: break;
+			}
+#endif /* TER_TUNER_DTV_LIF_OUT_AMP */
+		}
+	}
+	/* ------------------------------------------------------------ */
+	/* Wakeup Dtv Demod                                             */
+	/*  if it has been put in 'standby mode' and is needed          */
+	/* ------------------------------------------------------------ */
+	if (front_end->Si2168B_init_done) {
+		SiTRACE("dtv_demod_sleep_request %d\n",dtv_demod_sleep_request);
+		if ((dtv_demod_sleep_request == 1) & (dtv_demod_needed == 1) ) {
+			SiTRACE("Wake UP DTV demod\n");
+			if (si2168b_wakeup (front_end->demod) == NO_Si2168B_ERROR) {
+				SiTRACE("Wake UP DTV demod OK\n");
+				front_end->demod->Si2168B_in_standby = 0;
+			} else {
+				SiTRACE("Wake UP DTV demod failed!\n");
+				return 0;
+			}
+		}
+	}
+	/* ------------------------------------------------------------ */
+	/* Setup Dtv Demod                                              */
+	/* Setup dtv demodulator if transition from '0' to '1'          */
+	/* ------------------------------------------------------------ */
+	if ((dtv_demod_already_used == 0) & (dtv_demod_needed == 1)) {
+		/* Do the 'first init' only the first time, plus if requested  */
+		/* (when 'force' flag is 1, Si2168B_init_done is set to '0')   */
+		if (!front_end->Si2168B_init_done) {
+			SiTRACE("Init demod\n");
+			if (si2168b_first_init(front_end->demod) == NO_Si2168B_ERROR) {
+				front_end->Si2168B_init_done = 1;
+				SiTRACE("Demod init OK\n");
+			} else {
+				SiTRACE("Demod init failed!\n");
+				return 0;
+			}
+		}
+		if (front_end->demod->media == Si2168B_TERRESTRIAL) {
+			SiTRACE("front_end->demod->media Si2168B_TERRESTRIAL\n");
+			if (front_end->TER_init_done == 0) {
+				SiTRACE("Configure demod for TER\n");
+				if (si2168b_configure(front_end->demod) == NO_Si2168B_ERROR) {
+					/* set dd_mode.modulation again, as it is overwritten by si2168b_configure */
+					front_end->demod->dd_mode_modulation = new_standard;
+					front_end->TER_init_done = 1;
+				} else {
+					SiTRACE("Demod TER configuration failed !\n");
+					return 0;
+				}
+			}
+			/* ------------------------------------------------------------ */
+			/* Manage FEF mode in TER tuner                                 */
+			/* ------------------------------------------------------------ */
+			if (new_standard == Si2168B_DD_MODE_PROP_MODULATION_DVBT2) {
+				si2168b_ter_fef_setup(front_end, 1);
+			} else {
+				si2168b_ter_fef_setup(front_end, 0);
+			}
+		}
+		dd_mode_invert_spectrum = si2168b_set_invert_spectrum(front_end);
+	    data = (dd_mode_bw              & Si2168B_DD_MODE_PROP_BW_MASK             ) << Si2168B_DD_MODE_PROP_BW_LSB |
+	           (dd_mode_modulation      & Si2168B_DD_MODE_PROP_MODULATION_MASK     ) << Si2168B_DD_MODE_PROP_MODULATION_LSB |
+	           (dd_mode_invert_spectrum & Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_MASK) << Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_LSB |
+	           (dd_mode_auto_detect     & Si2168B_DD_MODE_PROP_AUTO_DETECT_MASK    ) << Si2168B_DD_MODE_PROP_AUTO_DETECT_LSB;
+		if (si2168b_set_property(front_end->demod, Si2168B_DD_MODE_PROP, data)==0) {
+			si2168b_dd_restart(front_end->demod);
+		} else {
+			SiTRACE("Demod restart failed !\n");
+			return 0;
+		}
+	}
+
+	/* ------------------------------------------------------------ */
+	/* Forbid i2c traffic to reach the tuners                       */
+	/* ------------------------------------------------------------ */
+	if ( front_end->tuner_indirect_i2c_connection ) { /* INDIRECT_I2C_CONNECTION? */
+		if (i2c_connected) {
+			SiTRACE("-- I2C -- Disconnect TER tuner i2c\n");
+			front_end->f_TER_tuner_disable(front_end->callback);
+		}
+	} else {
+		if (i2c_connected) {
+			SiTRACE("Disconnect tuners i2c\n");
+			si2168b_tuner_i2c_disable(front_end);
+		}
+	}
+	/* ------------------------------------------------------------ */
+	/* update value of previous_standard to prepare next call       */
+	/* ------------------------------------------------------------ */
+	front_end->previous_standard = new_standard;
+	front_end->standard          = new_standard;
+
+	front_end->first_init_done = 1;
+
+	SiTRACE("Si2168B_switch_to_standard complete\n");
+	return 1;
+}
+
+static int si2168b_initialize(struct dvb_frontend *fe)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+
+	siprintk("((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\n");
+	siprintk("(((                  %s()              )))\n", __func__);
+	siprintk("))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n");
+
+	if (!si2168b_switch_to_standard(fe, Si2168B_DD_MODE_PROP_MODULATION_DVBT, 1)) {
+		printk(KERN_ERR "%s(): si2168b_switch_to_standard() failed.\n", __func__);
+		goto err;
+	}
+
+	/* hardware related settings from base driver */
+	siprintk("%s(): ts_clk_invert=%d\n", __func__, priv->config->ts_par_clk_invert);
+	siprintk("%s(): ts_clk_shift=%d\n", __func__,  priv->config->ts_par_clk_shift);
+	siprintk("%s(): clock=%d\n", __func__,         priv->config->ts_clock_mode);
+	siprintk("%s(): clk_gapped_en=%d\n", __func__, priv->config->clk_gapped_en);
+	siprintk("%s(): fef_mode=%d\n", __func__,      priv->config->fef_mode);
+
+	if (si2168b_ts_bus_ctrl(fe, 1)) { /* set the bus mode */
+		printk(KERN_ERR "%s(): si2168b_ts_bus_ctrl(1) failed\n", __func__);
+		/* goto err; */
+	}
+	return 0;
+
+err:
+	printk(KERN_ERR "%s(): failed\n", __func__);
+	return -ENODEV;
+}
+
+static int si2168b_dvbc_auto_tune(struct dvb_frontend *fe, si2168b_context *demod, struct dtv_frontend_properties *p, u32 freq, int lock_start_ms)
+{
+	Si2168B_DVBC_STATUS_CMD_REPLY_struct dvbc_status;
+	Si2168B_CHANNEL_SEEK_PARAM_struct seek_param = {
+			.rangeMin     = freq,
+			.rangeMax     = freq,
+			.seekBWHz     = 8000000,
+			.seekStepHz   = 0,
+			.minSRbps     = 870000,
+			.maxSRbps     = 7500000,
+			/*.minRSSIdBm   = 0,*/
+			/*.maxRSSIdBm   = 0,*/
+			/*.minSNRHalfdB = 0,*/
+			/*.maxSNRHalfdB = 0,*/
+	};
+	Si2168B_CHANNEL_SEEK_NEXT_REPLY_struct channel_status;
+	int locked = 0;
+    int cnr = 0;
+
+	siprintk("%s(): +++ DVB-C AUTO TUNING (QAM AND SYMBOL RATE DETECTION) +++\n", __func__);
+
+	if (si2168b_channel_seek_init(fe, &seek_param)) {
+		pr_err("si2168b_channel_seek_init() failed.\n");
+	}
+	si2168b_set_tuner_params(fe, freq); /* tune first */
+
+    locked = si2168b_channel_seek_next(fe, &seek_param, &channel_status);
+
+    if (locked == 1) {
+		pr_info("%s(): Channel detected(standard %s, f=%d SR=%d constel=%d BW=%u)\n", __func__,
+				si2168b_standard_name(channel_status.standard),
+				channel_status.freq,
+				channel_status.symbol_rate_bps,
+				channel_status.constellation,
+				channel_status.bandwidth_Hz);
+		p->symbol_rate = channel_status.symbol_rate_bps;
+		switch (channel_status.constellation) {
+		case Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_AUTO:   p->modulation = QAM_AUTO; break;
+		case Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM128: p->modulation = QAM_128;  break;
+		case Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM16:  p->modulation = QAM_16;   break;
+		case Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM256: p->modulation = QAM_256;  break;
+		case Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM32:  p->modulation = QAM_32;   break;
+		case Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM64:  p->modulation = QAM_64;   break;
+		default:
+			/* invalid constellation returned */
+			break;
+		}
+		msleep(150);
+
+		if (si2168b_dvbc_status(demod, Si2168B_DVBC_STATUS_CMD_INTACK_OK, &dvbc_status) == NO_Si2168B_ERROR) {
+			cnr = dvbc_status.cnr / 4;
+		} else {
+			siprintk("%s(): si2168b_dvbc_status() failed\n", __func__);
+		}
+
+		while (cnr < 1) {
+			if (si2168b_dvbc_status(demod, Si2168B_DVBC_STATUS_CMD_INTACK_OK, &dvbc_status) == NO_Si2168B_ERROR) {
+				cnr = dvbc_status.cnr / 4;
+			} else {
+				siprintk("%s(): si2168b_dvbc_status() failed\n", __func__);
+			}
+			if (system_time() - lock_start_ms > 1000){
+				break;
+			}
+			msleep(150);
+		}
+		siprintk("%s(): C/N %u dB (%u ms)\n", __func__, cnr, (system_time() - lock_start_ms));
+	} else {
+		siprintk("%s(): Channel not locked (locked=%d)\n", __func__, locked);
+	}
+	si2168b_channel_seek_end(fe);
+	return locked;
+}
+
+static int si2168b_set_frontend(struct dvb_frontend *fe)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+    Si2168B_L2_Context *front_end = priv->si_front_end;
+	si2168b_context *demod = priv->si_front_end->demod;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	u8  standard = 0;
+	u32 freq = p->frequency;
+	u32 dvb_t_bandwidth_hz = p->bandwidth_hz;
+	u8  dvb_t_stream = 0;
+	u32 symbol_rate_bps = 0;
+	u8  dvb_c_constellation = 0;
+	int plp_id = (int)p->stream_id;
+	u8  T2_lock_mode = 0;
+	int locked = 0;
+	u8  force_full_init = 0;
+    int lock_start_ms;
+
+    if (plp_id == 0)
+    	plp_id = -1; /* set to auto detection */
+
+	siprintk("%s(): FE_SET_FRONTEND f=%u inv=%d mod=%d bw=%u plp_id=%d\n", __func__, p->frequency, p->inversion, p->modulation, p->bandwidth_hz, plp_id);
+
+	switch (p->delivery_system) {
+	case SYS_DVBT:         standard = Si2168B_DD_MODE_PROP_MODULATION_DVBT; break;
+	case SYS_DVBT2:	       standard = Si2168B_DD_MODE_PROP_MODULATION_DVBT2; break;
+	case SYS_DVBC_ANNEX_A: standard = Si2168B_DD_MODE_PROP_MODULATION_DVBC;
+		symbol_rate_bps = p->symbol_rate;
+		switch (p->modulation) {
+		case QAM_AUTO: dvb_c_constellation = Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_AUTO;   break;
+		case QAM_128:  dvb_c_constellation = Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM128; break;
+		case QAM_16:   dvb_c_constellation = Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM16;  break;
+		case QAM_256:  dvb_c_constellation = Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM256; break;
+		case QAM_32:   dvb_c_constellation = Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM32;  break;
+		case QAM_64:   dvb_c_constellation = Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM64;  break;
+		default:       dvb_c_constellation = Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_AUTO;   break;
+		}
+		break;
+	default:
+		siprintk("%s : ERROR: delivery system not supported\n", __func__);
+		return -EINVAL;
+	}
+
+	if (standard != front_end->demod->dd_mode_modulation) {
+		siprintk("%s(): switching from standard %s to %s\n", __func__, si2168b_standard_name(front_end->demod->dd_mode_modulation), si2168b_standard_name(standard));
+		if (!si2168b_switch_to_standard(fe, standard, force_full_init)) {
+			siprintk("%s(): si2168b_switch_to_standard() failed.\n", __func__);
+			return -ENODEV;
+		}
+		priv->delivery_system = p->delivery_system;
+	}
+
+	if (standard == Si2168B_DD_MODE_PROP_MODULATION_DVBC) {
+		demod->dvbc_symbol_rate = symbol_rate_bps / 1000;
+	} else {
+		demod->dvbc_symbol_rate = 0; /* clear old setting */
+	}
+
+	siprintk("%s(): delsys=%s  Si2168B_standard=%s  freq=%d  symbol_rate_bps=%d  dvb_c_constellation=%d\n",
+			__func__, delsys_name(p->delivery_system), si2168b_standard_name(front_end->demod->dd_mode_modulation),
+			freq, symbol_rate_bps, dvb_c_constellation);
+
+	lock_start_ms = system_time();
+
+	if (standard == Si2168B_DD_MODE_PROP_MODULATION_DVBC && symbol_rate_bps == 7501000) { /* 7501000 = AUTO */
+		locked = si2168b_dvbc_auto_tune(fe, demod, p, freq, lock_start_ms);
+	} else {
+		locked = si2168b_lock_to_carrier(fe, standard, freq,
+				dvb_t_bandwidth_hz, dvb_t_stream, symbol_rate_bps,
+				dvb_c_constellation, plp_id, T2_lock_mode);
+	}
+
+	if (locked == 1) {
+		siprintk("%s(): locked to carrier %dHz (duration=%dms)\n", __func__, freq, system_time()-lock_start_ms);
+		msleep(100);
+
+		if (priv->config->start_ctrl)
+			priv->config->start_ctrl(fe);
+	} else {
+		siprintk("%s(): not locked to carrier %dHz (duration=%dms)\n", __func__, freq, system_time()-lock_start_ms);
+	}
+
+	/* After set_frontend, stats aren't available */
+	p->strength.stat[0].scale = FE_SCALE_RELATIVE;
+	p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+
+	return 0;
+}
+
+static int si2168b_get_tune_settings(struct dvb_frontend *fe,
+		struct dvb_frontend_tune_settings
+		*fe_tune_settings)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+
+	fe_tune_settings->min_delay_ms = priv->config->min_delay_ms;
+	siprintk("%s(): min delay = %dms\n", __func__, fe_tune_settings->min_delay_ms);
+	return 0;
+}
+
+#if defined(FE_READ_STREAM_IDS) || defined(__MPLP_TEST__)
+static int si2168b_read_stream_ids(struct dvb_frontend *fe, struct dvb_stream_ids* ids)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+	si2168b_context *demod = priv->si_front_end->demod;
+	Si2168B_DD_STATUS_CMD_REPLY_struct      dd_status;
+	Si2168B_DVBT2_STATUS_CMD_REPLY_struct   dvbt2_status;
+	Si2168B_DVBT2_PLP_INFO_CMD_REPLY_struct dvbt2_plp_info;
+	int data_plp_count;
+	int num_plp;
+	int plp_index;
+	int plp_id;
+	int plp_type;
+	int ret = 0;
+
+	if (priv->delivery_system != SYS_DVBT2) {
+		siprintk("%s(): delivery system is not DVB-T2. Aborting...\n", __func__);
+	}
+
+	/* check demod */
+	if (si2168b_dd_status(demod, Si2168B_DD_STATUS_CMD_INTACK_OK, &dd_status) != NO_Si2168B_ERROR) {
+		siprintk("%s(): si2168b_dd_status() failed\n", __func__);
+		return -1;
+	}
+
+	if (dd_status.modulation != Si2168B_DD_STATUS_RESPONSE_MODULATION_DVBT2) {
+		siprintk("%s(): demod modulation is not DVB-T2. Aborting...\n", __func__);
+		return -1;
+	}
+
+	if (si2168b_dvbt2_status(demod, Si2168B_DVBT2_STATUS_CMD_INTACK_OK, &dvbt2_status) != NO_Si2168B_ERROR) {
+		siprintk("%s(): si2168b_dvbt2_status() failed\n", __func__);
+		return -1;
+	}
+
+	SiTRACE("dvbt2_status.pcl %d\n", dvbt2_status.pcl);
+
+	num_plp = dvbt2_status.num_plp;
+	plp_id  = dvbt2_status.plp_id;
+
+	SiTRACE("There are %d PLPs in this stream\n", num_plp);
+	SiTRACE("PLP ID = %d\n", plp_id);
+
+	/* hard limiter */
+	if (num_plp > 255) {
+		siprintk("%s(): WARNING: limiting found %d PLPs to 255\n", __func__, num_plp);
+		num_plp = 255;
+	}
+
+	ids->num = num_plp; /* number of valid stream ids in 'val' */
+	ids->cur = plp_id;  /* currently selected stream id */
+
+	data_plp_count = 0;
+	dvbt2_plp_info.plp_id = 0;
+	dvbt2_plp_info.plp_type = 3;
+
+	for (plp_index=0; plp_index<num_plp; plp_index++) {
+		if (si2168b_dvbt2_plp_info(demod, plp_index, &dvbt2_plp_info) ==  NO_Si2168B_ERROR) {
+			plp_id   = dvbt2_plp_info.plp_id;
+			plp_type = dvbt2_plp_info.plp_type;
+
+			ids->val[plp_index] = plp_id;
+
+			SiTRACE("PLP index %3d: PLP ID %3d, PLP TYPE %d : ", plp_index, plp_id, plp_type);
+			if (plp_type == Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_TYPE_COMMON) {
+				SiTRACE("COMMON PLP at index %3d: PLP ID %3d, PLP TYPE COMMON\n", plp_index, plp_id);
+			} else {
+				SiTRACE("DATA   PLP at index %3d: PLP ID %3d, PLP TYPE %d\n", plp_index, plp_id, plp_type);
+				data_plp_count++;
+			}
+		} else {
+			siprintk("%s(): si2168b_dvbt2_plp_info() index %d failed\n", __func__, plp_index);
+			ids->val[plp_index] = 0;
+			ret = -1;
+		}
+	}
+	SiTRACE("data_plp_count=%d\n", data_plp_count);
+	return ret;
+}
+#endif /* FE_READ_STREAM_IDS */
+
+static int si2168b_get_frontend(struct dvb_frontend *fe, struct dtv_frontend_properties *fe_params)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	si2168b_context *demod = priv->si_front_end->demod;
+	Si2168B_DD_STATUS_CMD_REPLY_struct    dd_status;
+	Si2168B_DVBT_STATUS_CMD_REPLY_struct  dvbt_status;
+	Si2168B_DVBT2_STATUS_CMD_REPLY_struct dvbt2_status;
+	Si2168B_DVBC_STATUS_CMD_REPLY_struct  dvbc_status;
+
+#if defined(FE_READ_STREAM_IDS) || defined(__MPLP_TEST__)
+	struct dvb_stream_ids ids;
+#endif
+
+	if (priv->delivery_system == SYS_UNDEFINED)
+		return -EINVAL;
+
+	if (si2168b_dd_status(demod, Si2168B_DD_STATUS_CMD_INTACK_OK, &dd_status) != NO_Si2168B_ERROR) {
+		siprintk("%s(): si2168b_dd_status() failed\n", __func__);
+		return -EFAULT;
+	}
+
+    if (dd_status.dl == Si2168B_DD_STATUS_RESPONSE_DL_LOCKED) {
+		siprintk("%s(): FE HAS LOCK\n", __func__);
+    }
+
+    switch (dd_status.modulation) {
+	case Si2168B_DD_STATUS_RESPONSE_MODULATION_DVBT:
+		siprintk("%s() delivery system SYS_DVBT\n", __func__);
+		if (si2168b_dvbt_status(demod, Si2168B_DVBT_STATUS_CMD_INTACK_OK, &dvbt_status) != NO_Si2168B_ERROR) {
+			siprintk("%s(): si2168b_dvbt_status() failed\n", __func__);
+			return -EFAULT;
+		}
+		switch (dvbt_status.constellation) {
+		case Si2168B_DVBT_STATUS_RESPONSE_CONSTELLATION_QAM16: p->modulation = QAM_16; break;
+		case Si2168B_DVBT_STATUS_RESPONSE_CONSTELLATION_QAM64: p->modulation = QAM_64; break;
+		case Si2168B_DVBT_STATUS_RESPONSE_CONSTELLATION_QPSK:  p->modulation = QPSK;   break;
+		default:
+			siprintk("%s(): invalid DVB-T constellation returned\n", __func__);
+		}
+		switch (dvbt_status.sp_inv) {
+		case Si2168B_DVBT_STATUS_RESPONSE_SP_INV_INVERTED: p->inversion = INVERSION_ON;	 break;
+		case Si2168B_DVBT_STATUS_RESPONSE_SP_INV_NORMAL:   p->inversion = INVERSION_OFF; break;
+		default:
+			siprintk("%s(): invalid DVB-T sp_inv returned\n", __func__);
+		}
+		switch (dvbt_status.rate_hp) {
+		case Si2168B_DVBT_STATUS_RESPONSE_RATE_HP_1_2: p->code_rate_HP = FEC_1_2; break;
+		case Si2168B_DVBT_STATUS_RESPONSE_RATE_HP_2_3: p->code_rate_HP = FEC_2_3; break;
+		case Si2168B_DVBT_STATUS_RESPONSE_RATE_HP_3_4: p->code_rate_HP = FEC_3_4; break;
+		case Si2168B_DVBT_STATUS_RESPONSE_RATE_HP_5_6: p->code_rate_HP = FEC_5_6; break;
+		case Si2168B_DVBT_STATUS_RESPONSE_RATE_HP_7_8: p->code_rate_HP = FEC_7_8; break;
+		default:
+			siprintk("%s(): invalid DVB-T rate_hp returned\n", __func__);
+		}
+		switch (dvbt_status.rate_lp) {
+		case Si2168B_DVBT_STATUS_RESPONSE_RATE_LP_1_2: p->code_rate_LP = FEC_1_2; break;
+		case Si2168B_DVBT_STATUS_RESPONSE_RATE_LP_2_3: p->code_rate_LP = FEC_2_3; break;
+		case Si2168B_DVBT_STATUS_RESPONSE_RATE_LP_3_4: p->code_rate_LP = FEC_3_4; break;
+		case Si2168B_DVBT_STATUS_RESPONSE_RATE_LP_5_6: p->code_rate_LP = FEC_5_6; break;
+		case Si2168B_DVBT_STATUS_RESPONSE_RATE_LP_7_8: p->code_rate_LP = FEC_7_8; break;
+		default:
+			siprintk("%s(): invalid DVB-T rate_lp returned\n", __func__);
+		}
+		switch (dvbt_status.fft_mode) {
+		case Si2168B_DVBT_STATUS_RESPONSE_FFT_MODE_2K: p->transmission_mode = TRANSMISSION_MODE_2K; break;
+		case Si2168B_DVBT_STATUS_RESPONSE_FFT_MODE_4K: p->transmission_mode = TRANSMISSION_MODE_4K; break;
+		case Si2168B_DVBT_STATUS_RESPONSE_FFT_MODE_8K: p->transmission_mode = TRANSMISSION_MODE_8K; break;
+		default:
+			siprintk("%s(): invalid DVB-T fft_mode returned\n", __func__);
+		}
+		switch (dvbt_status.guard_int) {
+		case Si2168B_DVBT_STATUS_RESPONSE_GUARD_INT_1_16: p->guard_interval = GUARD_INTERVAL_1_16; break;
+		case Si2168B_DVBT_STATUS_RESPONSE_GUARD_INT_1_32: p->guard_interval = GUARD_INTERVAL_1_32; break;
+		case Si2168B_DVBT_STATUS_RESPONSE_GUARD_INT_1_4:  p->guard_interval = GUARD_INTERVAL_1_4;  break;
+		case Si2168B_DVBT_STATUS_RESPONSE_GUARD_INT_1_8:  p->guard_interval = GUARD_INTERVAL_1_8;  break;
+		default:
+			siprintk("%s(): invalid DVB-T guard_int returned\n", __func__);
+		}
+		switch (dvbt_status.hierarchy) {
+		case Si2168B_DVBT_STATUS_RESPONSE_HIERARCHY_ALFA1: p->hierarchy = HIERARCHY_1;    break;
+		case Si2168B_DVBT_STATUS_RESPONSE_HIERARCHY_ALFA2: p->hierarchy = HIERARCHY_2;    break;
+		case Si2168B_DVBT_STATUS_RESPONSE_HIERARCHY_ALFA4: p->hierarchy = HIERARCHY_4;    break;
+		case Si2168B_DVBT_STATUS_RESPONSE_HIERARCHY_NONE:  p->hierarchy = HIERARCHY_NONE; break;
+		default:
+			siprintk("%s(): invalid DVB-T hierarchy returned\n", __func__);
+		}
+		p->fec_inner = FEC_NONE;
+		break;
+	case Si2168B_DD_STATUS_RESPONSE_MODULATION_DVBT2:
+		siprintk("%s() delivery system SYS_DVBT2\n", __func__);
+
+		if (priv->delivery_system != SYS_DVBT2) {
+			siprintk("%s(): delivery system changed from %s to SYS_DVBT2\n", __func__, delsys_name(p->delivery_system));
+			p->delivery_system = SYS_DVBT2;
+		}
+
+		if (si2168b_dvbt2_status(demod, Si2168B_DVBT2_STATUS_CMD_INTACK_OK, &dvbt2_status) != NO_Si2168B_ERROR) {
+			siprintk("%s(): si2168b_dvbt2_status() failed\n", __func__);
+			return -EFAULT;
+		}
+		switch (dvbt2_status.constellation) {
+		case Si2168B_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM128: p->modulation = QAM_128; break;
+		case Si2168B_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM16:  p->modulation = QAM_16;  break;
+		case Si2168B_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM256: p->modulation = QAM_256; break;
+		case Si2168B_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM32:  p->modulation = QAM_32;  break;
+		case Si2168B_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM64:  p->modulation = QAM_64;  break;
+		case Si2168B_DVBT2_STATUS_RESPONSE_CONSTELLATION_QPSK:   p->modulation = QPSK;    break;
+		default:
+			siprintk("%s(): invalid DVB-T2 constellation returned\n", __func__);
+		}
+		switch (dvbt2_status.sp_inv) {
+		case Si2168B_DVBT2_STATUS_RESPONSE_SP_INV_INVERTED: p->inversion = INVERSION_ON;  break;
+		case Si2168B_DVBT2_STATUS_RESPONSE_SP_INV_NORMAL:   p->inversion = INVERSION_OFF; break;
+		default:
+			siprintk("%s(): invalid DVB-T2 sp_inv returned\n", __func__);
+		}
+		switch (dvbt2_status.fft_mode) {
+		case Si2168B_DVBT2_STATUS_RESPONSE_FFT_MODE_16K: p->transmission_mode = TRANSMISSION_MODE_16K; break;
+		case Si2168B_DVBT2_STATUS_RESPONSE_FFT_MODE_1K:  p->transmission_mode = TRANSMISSION_MODE_1K;  break;
+		case Si2168B_DVBT2_STATUS_RESPONSE_FFT_MODE_2K:  p->transmission_mode = TRANSMISSION_MODE_2K;  break;
+		case Si2168B_DVBT2_STATUS_RESPONSE_FFT_MODE_32K: p->transmission_mode = TRANSMISSION_MODE_32K; break;
+		case Si2168B_DVBT2_STATUS_RESPONSE_FFT_MODE_4K:  p->transmission_mode = TRANSMISSION_MODE_4K;  break;
+		case Si2168B_DVBT2_STATUS_RESPONSE_FFT_MODE_8K:  p->transmission_mode = TRANSMISSION_MODE_8K;  break;
+		default:
+			siprintk("%s(): invalid DVB-T2 fft_mode returned\n", __func__);
+		}
+		switch (dvbt2_status.guard_int) {
+		case Si2168B_DVBT2_STATUS_RESPONSE_GUARD_INT_19_128: p->guard_interval = GUARD_INTERVAL_19_128; break;
+		case Si2168B_DVBT2_STATUS_RESPONSE_GUARD_INT_19_256: p->guard_interval = GUARD_INTERVAL_19_256; break;
+		case Si2168B_DVBT2_STATUS_RESPONSE_GUARD_INT_1_128:  p->guard_interval = GUARD_INTERVAL_1_128;  break;
+		case Si2168B_DVBT2_STATUS_RESPONSE_GUARD_INT_1_16:   p->guard_interval = GUARD_INTERVAL_1_16;   break;
+		case Si2168B_DVBT2_STATUS_RESPONSE_GUARD_INT_1_32:   p->guard_interval = GUARD_INTERVAL_1_32;   break;
+		case Si2168B_DVBT2_STATUS_RESPONSE_GUARD_INT_1_4:    p->guard_interval = GUARD_INTERVAL_1_4;    break;
+		case Si2168B_DVBT2_STATUS_RESPONSE_GUARD_INT_1_8:    p->guard_interval = GUARD_INTERVAL_1_8;    break;
+		default:
+			siprintk("%s(): invalid DVB-T2 guard_int returned\n", __func__);
+		}
+		p->fec_inner = FEC_NONE;
+		p->code_rate_HP = FEC_NONE;
+		p->code_rate_LP = FEC_NONE;
+		p->hierarchy = HIERARCHY_NONE;
+		p->stream_id = dvbt2_status.plp_id;
+
+#if defined(FE_READ_STREAM_IDS) || defined(__MPLP_TEST__)
+		si2168b_read_stream_ids(fe, &ids);
+#endif
+		break;
+	case Si2168B_DD_STATUS_RESPONSE_MODULATION_DVBC:
+		if (priv->delivery_system != SYS_DVBC_ANNEX_A) {
+			siprintk("%s(): delivery system changed from %s to SYS_DVBC_ANNEX_A\n", __func__, delsys_name(p->delivery_system));
+			p->delivery_system = SYS_DVBC_ANNEX_A;
+		} else {
+			siprintk("%s() delivery system SYS_DVBC_ANNEX_A\n", __func__);
+		}
+		if (si2168b_dvbc_status(demod, Si2168B_DVBC_STATUS_CMD_INTACK_OK, &dvbc_status) != NO_Si2168B_ERROR) {
+			siprintk("%s(): si2168b_dvbc_status() failed\n", __func__);
+			return -EFAULT;
+		}
+		switch (dvbc_status.constellation) {
+		case Si2168B_DVBC_STATUS_RESPONSE_CONSTELLATION_QAM128: p->modulation = QAM_128; break;
+		case Si2168B_DVBC_STATUS_RESPONSE_CONSTELLATION_QAM16:  p->modulation = QAM_16;  break;
+		case Si2168B_DVBC_STATUS_RESPONSE_CONSTELLATION_QAM256: p->modulation = QAM_256; break;
+		case Si2168B_DVBC_STATUS_RESPONSE_CONSTELLATION_QAM32:  p->modulation = QAM_32;  break;
+		case Si2168B_DVBC_STATUS_RESPONSE_CONSTELLATION_QAM64:  p->modulation = QAM_64;  break;
+		default:
+			siprintk("%s(): invalid DVB-C constellation returned\n", __func__);
+		}
+		switch (dvbc_status.sp_inv) {
+		case Si2168B_DVBC_STATUS_RESPONSE_SP_INV_INVERTED: p->inversion = INVERSION_ON;  break;
+		case Si2168B_DVBC_STATUS_RESPONSE_SP_INV_NORMAL:   p->inversion = INVERSION_OFF; break;
+		default:
+			siprintk("%s(): invalid DVB-C sp_inv returned\n", __func__);
+		}
+		p->symbol_rate = demod->dvbc_symbol_rate * 1000;
+		p->fec_inner = FEC_NONE;
+		break;
+	default:
+		siprintk("%s() delivery system not supported\n", __func__);
+		return -EINVAL;
+	}
+
+	memcpy(fe_params, p, sizeof(struct dtv_frontend_properties));
+
+	return 0;
+}
+
+static int si2168b_sleep(struct dvb_frontend *fe)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+	Si2168B_L2_Context *front_end = priv->si_front_end;
+
+#if 1 /* FGR - BUGBUG try alternate power down */
+	siprintk("%s()\n", __func__);
+
+	if (si2168b_ts_bus_ctrl(fe, 0)) { /* set the bus mode */
+		printk(KERN_ERR "%s(): si2168b_ts_bus_ctrl(0) failed\n", __func__);
+	}
+
+	if (!si2168b_switch_to_standard(fe, Si2168B_DD_MODE_PROP_MODULATION_SLEEP, 0)) {
+		printk(KERN_ERR "%s(): si2168b_switch_to_standard() failed.\n", __func__);
+		return -EIO;
+	}
+
+	front_end->demod->Si2168B_in_standby = 1;
+
+#else /* FGR */
+	si2168b_context *demod = priv->si_front_end->demod;
+
+	siprintk("%s()\n", __func__);
+
+	if (si2168b_ts_bus_ctrl(fe, 0)) { /* set the bus mode */
+		printk(KERN_ERR "%s(): si2168b_ts_bus_ctrl(0) failed\n", __func__);
+	}
+
+	if ( priv->config->indirect_i2c_connection ) { /* INDIRECT_I2C_CONNECTION? */
+		if (priv->si_front_end->f_TER_tuner_enable(priv->si_front_end->callback) != NO_Si2168B_ERROR) {
+			siprintk("%s(): f_TER_tuner_enable() failed\n", __func__);
+			return -EIO;
+		}
+	} else {
+		if (si2168b_tuner_i2c_enable(priv->si_front_end) != NO_Si2168B_ERROR) {
+			siprintk("%s(): si2168b_tuner_i2c_enable() failed\n", __func__);
+			return -EIO;
+		}
+	}
+
+	/* power down tuner */
+	/* ToDo */
+	/* ... */
+
+	if ( priv->config->indirect_i2c_connection ) { /* INDIRECT_I2C_CONNECTION? */
+		if (priv->si_front_end->f_TER_tuner_disable(priv->si_front_end->callback) != NO_Si2168B_ERROR) {
+			siprintk("%s(): f_TER_tuner_disable() failed\n", __func__);
+			return -EIO;
+		}
+	} else {
+		if (si2168b_tuner_i2c_disable(priv->si_front_end) != NO_Si2168B_ERROR) {
+			siprintk("%s(): si2168b_tuner_i2c_disable() failed\n", __func__);
+			return -EIO;
+		}
+	}
+
+	if (si2168b_power_down(demod) != NO_Si2168B_ERROR) {
+		siprintk("%s(): si2168b_power_down() failed\n", __func__);
+		return -EIO;
+	}
+	front_end->demod->Si2168B_in_standby = 1;
+#endif /* FGR */
+
+	return 0;
+}
+
+static void si2168b_release(struct dvb_frontend *fe)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+
+	siprintk("%s\n", __func__);
+
+	if (priv->si_front_end->demod)
+		kfree(priv->si_front_end->demod);
+
+	if (priv->si_front_end)
+		kfree(priv->si_front_end);
+
+	if (priv)
+		kfree(priv);
+}
+
+static enum dvbfe_algo si2168b_get_frontend_algo(struct dvb_frontend *fe)
+{
+#if 1
+	/*siprintk("%s(): DVBFE_ALGO_HW\n", __func__);*/
+	return DVBFE_ALGO_HW;      /* = si2168b_tune()          */
+#endif
+#if 0
+	siprintk("%s(): DVBFE_ALGO_SW\n", __func__);
+	return DVBFE_ALGO_SW;      /* = dvb_frontend_swzigzag() */
+#endif
+#if 0
+	siprintk("%s(): DVBFE_ALGO_CUSTOM\n", __func__);
+	return DVBFE_ALGO_CUSTOM;  /* = Si2168B_Search()        */
+#endif
+}
+
+static int si2168b_tune(struct dvb_frontend *fe, bool re_tune, unsigned int mode_flags, unsigned int *delay, enum fe_status *status)
+{
+	int rc = 0;
+
+	siprintk("%s(): re_tune=%d  mode_flags=%u\n", __func__, (int)re_tune, mode_flags);
+
+	if (re_tune)
+		rc = si2168b_set_frontend(fe);
+
+	if (!(mode_flags & FE_TUNE_MODE_ONESHOT))
+		si2168b_read_status(fe, status);
+
+	return rc;
+}
+
+static enum dvbfe_search si2168b_search(struct dvb_frontend *fe)
+{
+	struct Si2168B_Priv *priv = fe->demodulator_priv;
+	/*si2168b_context *demod = priv->si_front_end->demod;*/
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int ret, i;
+	enum fe_status status = 0;
+
+	siprintk("%s(): delsys=%d\n", __func__,	fe->dtv_property_cache.delivery_system);
+
+	/* switch between DVB-T and DVB-T2 when tune fails */
+	if (priv->last_tune_failed) {
+		if (priv->delivery_system == SYS_DVBT) {
+			c->delivery_system = SYS_DVBT2;
+		} else if (priv->delivery_system == SYS_DVBT2) {
+			c->delivery_system = SYS_DVBT;
+		}
+	}
+
+	/* set frontend */
+	ret = si2168b_set_frontend(fe);
+	if (ret)
+		goto error;
+
+
+	/* frontend lock wait loop count */
+	switch (priv->delivery_system) {
+	case SYS_DVBT:
+	case SYS_DVBC_ANNEX_A:
+		i = 2;
+		break;
+	case SYS_DVBT2:
+		i = 4;
+		break;
+	case SYS_UNDEFINED:
+	default:
+		i = 0;
+		break;
+	}
+
+	/* wait frontend lock */
+	for (; i > 0; i--) {
+		siprintk("%s(): loop=%d\n", __func__, i);
+		msleep(50);
+		ret = si2168b_read_status(fe, &status);
+		if (ret)
+			goto error;
+
+		if (status & FE_HAS_LOCK)
+			break;
+	}
+
+	/* check if we have a valid signal */
+	if (status & FE_HAS_LOCK) {
+		priv->last_tune_failed = 0;
+		return DVBFE_ALGO_SEARCH_SUCCESS;
+	} else {
+		priv->last_tune_failed = 1;
+		return DVBFE_ALGO_SEARCH_AGAIN;
+	}
+
+error:
+	siprintk("%s(): failed=%d\n", __func__, ret);
+	return DVBFE_ALGO_SEARCH_ERROR;
+}
+
+static const struct dvb_frontend_ops si2168b_ops = {
+		.delsys = { SYS_DVBT, SYS_DVBT2, SYS_DVBC_ANNEX_A },
+		.info = {
+				.name = "Si2168B DVB-T/T2/C",
+				.frequency_stepsize = 62500,
+				.frequency_min = 48000000,
+				.frequency_max = 870000000,
+				.symbol_rate_min = 870000,
+				.symbol_rate_max = 7501000,
+				.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3
+				| FE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8
+				| FE_CAN_FEC_AUTO | FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_32
+				| FE_CAN_QAM_64 | FE_CAN_QAM_128 | FE_CAN_QAM_256
+				| FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO
+				| FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO
+				| FE_CAN_MULTISTREAM | FE_CAN_2G_MODULATION | FE_CAN_MUTE_TS
+		},
+
+		.release = si2168b_release,
+		/*.release_sec,*/
+
+		.init = si2168b_initialize,
+		.sleep = si2168b_sleep,
+
+		/*.write,*/
+
+		/* if this is set, it overrides the default swzigzag */
+		.tune = si2168b_tune,
+		/* get frontend tuning algorithm from the module */
+		.get_frontend_algo = si2168b_get_frontend_algo,
+
+		/* these two are only used for the swzigzag code */
+		.set_frontend = si2168b_set_frontend,
+		.get_tune_settings = si2168b_get_tune_settings,
+		.get_frontend = si2168b_get_frontend,
+
+		.read_status = si2168b_read_status,
+		.read_ber = si2168b_read_ber,
+		.read_signal_strength = si2168b_read_rssi,
+		.read_snr = si2168b_read_cnr,
+		.read_ucblocks = si2168b_read_uncorrs,
+
+		/* Sat:
+		.diseqc_reset_overload,
+		.diseqc_send_master_cmd,
+		.diseqc_recv_slave_reply,
+		.diseqc_send_burst,
+		.set_tone,
+		.set_voltage,
+		.enable_high_lnb_voltage,
+		.dishnetwork_send_legacy_command,
+		*/
+
+		.i2c_gate_ctrl = si2168b_i2c_gate_ctrl,
+		.ts_bus_ctrl = si2168b_ts_bus_ctrl,
+		/* .set_lna set in em28xx-dvb.c */
+
+		/* These callbacks are for devices that implement their own
+		 * tuning algorithms, rather than a simple swzigzag
+		 */
+		.search = si2168b_search,
+
+		/* Allow the frontend to validate incoming properties */
+		/*.set_property,*/
+		/*.get_property,*/
+#ifdef FE_READ_STREAM_IDS
+		.read_stream_ids = si2168b_read_stream_ids,
+#endif
+};
+
+
+struct dvb_frontend *si2168b_attach(const struct si2168b_config *config, struct i2c_adapter *i2c)
+{
+	struct dtv_frontend_properties *p;
+	struct Si2168B_Priv *priv;
+
+	siprintk("%s()\n", __func__);
+
+	/* allocate memory */
+	priv = kzalloc(sizeof(struct Si2168B_Priv), GFP_KERNEL);
+	if (priv == NULL) {
+		siprintk("%s(): kzalloc() failed.\n", __func__);
+		goto error;
+	}
+
+	priv->si_front_end = kzalloc(sizeof(struct Si2168B_L2_Context), GFP_KERNEL);
+	if (priv->si_front_end == NULL) {
+		siprintk("%s(): kzalloc si_front_end failed.\n", __func__);
+		kfree(priv);
+		goto error;
+	}
+
+	priv->si_front_end->demod = kzalloc(sizeof(struct si2168b_context), GFP_KERNEL);
+	if (priv->si_front_end->demod == NULL) {
+		siprintk("%s(): kzalloc demod failed.\n", __func__);
+		kfree(priv->si_front_end);
+		kfree(priv);
+		goto error;
+	}
+
+	priv->config = config;
+	priv->i2c = i2c;
+	priv->delivery_system = SYS_UNDEFINED;
+
+	/* create dvb_frontend */
+	memcpy(&priv->frontend.ops, &si2168b_ops, sizeof(struct dvb_frontend_ops));
+	priv->frontend.demodulator_priv = priv;
+
+	if (!si2168b_sw_init(priv,
+			0,
+			enable_tuner_i2c,
+			disable_tuner_i2c,
+			i2c_callback)){
+		printk(KERN_ERR "%s(): si2168b_sw_init() failed.\n", __func__);
+	}
+	/* enable tuner i2c routing for tuner autodetection */
+	if ( priv->config->indirect_i2c_connection ) { /* INDIRECT_I2C_CONNECTION? */
+		if (priv->si_front_end->f_TER_tuner_enable(priv->si_front_end->callback) != NO_Si2168B_ERROR) {
+			siprintk("%s(): f_TER_tuner_enable() failed\n", __func__);
+		}
+	} else {
+		if (si2168b_tuner_i2c_enable(priv->si_front_end) != NO_Si2168B_ERROR) {
+			siprintk("%s(): si2168b_tuner_i2c_enable() failed\n", __func__);
+		}
+	}
+	/* tuner i2c routing is disabled automatically after first tuner access */
+
+	/* Initialize stats */
+	p = &priv->frontend.dtv_property_cache;
+	p->strength.len = 1;
+	p->cnr.len = 1;
+	p->block_error.len = 1;
+	p->block_count.len = 1;
+	p->pre_bit_error.len = 1;
+	p->pre_bit_count.len = 1;
+	p->post_bit_error.len = 1;
+	p->post_bit_count.len = 1;
+
+	p->strength.stat[0].scale = FE_SCALE_DECIBEL;
+	p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+
+	return &priv->frontend;
+
+error:
+	return NULL;
+}
+EXPORT_SYMBOL(si2168b_attach);
+
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
+MODULE_PARM_DESC(sitrace, "Turn on/off SiTRACE messages (default:off).");
+MODULE_PARM_DESC(mutex, "Turn on/off mutex (default:on).");
+
+MODULE_DESCRIPTION("SiLabs 2168B T/T2/C DVB driver");
+MODULE_AUTHOR("Source code provided by Silicon Laboratories Inc.");
+MODULE_AUTHOR("Henning Garbers <hgarbers@pctvsystems.com>");
+MODULE_LICENSE("PROPRIETARY AND CONFIDENTIAL");
+MODULE_VERSION("2015-03-09");
--- linux-4.15/drivers/media/dvb-frontends/si2168b.h.0140~	2018-02-12 11:32:52.764582151 +0100
+++ linux-4.15/drivers/media/dvb-frontends/si2168b.h	2018-02-12 11:32:52.764582151 +0100
@@ -0,0 +1,70 @@
+#ifndef SI2168B_H
+#define SI2168B_H
+
+#define DRIVER_BUILD
+#define TER_TUNER_SILABS
+#define HAUPPAUGE
+#define HCW_10BDA
+#define no_CHECK_CRC
+#define no_RANGE_CHECK
+#define __MPLP_TEST__
+#ifndef FE_READ_STREAM_IDS
+#ifdef __MPLP_TEST__
+struct dvb_stream_ids {
+	__u8	val[256];	/* stream ids seen on the transponder */
+	__u8    num;		/* number of valid stream ids in 'val' */
+	__u8    cur;		/* currently selected stream id */
+};
+#endif
+#endif
+
+#include <linux/kconfig.h>
+#include <linux/dvb/frontend.h>
+#include "dvb_frontend.h"
+
+extern int _sitrace; /* module parameter: SiTRACE on/off */
+
+struct si2168b_config {
+	/* the demodulator's i2c address */
+	u8 demod_address;
+
+	/* minimum delay before retuning */
+	int min_delay_ms;
+
+	u8 ts_bus_mode; /*1-serial, 2-parallel.*/
+	u8 ts_clock_mode; /*0-auto, 1-manual.*/
+	u8 clk_gapped_en; /*0-disabled, 1-enabled.*/
+	u8 ts_par_clk_invert; /* 0-not-invert, 1-invert */
+	u8 ts_par_clk_shift;
+
+	/* TER Tuner FEF management options
+	   FEF_MODE_SLOW_NORMAL_AGC  (=0)
+	   FEF_MODE_FREEZE_PIN       (=1)
+	   FEF_MODE_SLOW_INITIAL_AGC (=2) */
+    u8 fef_mode;
+    /* FEF pin connected to TER tuner AGC freeze input */
+	u8 fef_pin;
+	 /* GPIO state on FEF_pin when used (during FEF periods) */
+	u8 fef_level;
+
+    /* tuner i2c connection               */
+	/* 0-tuner connected through Si2168B  */
+	/* 1-tuner is direct accessible       */
+	u8 indirect_i2c_connection;
+
+	int (*start_ctrl)(struct dvb_frontend *fe);
+};
+
+#if IS_ENABLED(CONFIG_DVB_SI2168B)
+extern struct dvb_frontend *si2168b_attach(const struct si2168b_config *config,
+						struct i2c_adapter *i2c);
+#else
+static inline struct dvb_frontend *si2168b_attach(
+		const struct si2168b_config *config, struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif
--- linux-4.15/drivers/media/dvb-frontends/si2168b_priv.h.0140~	2018-02-12 11:32:52.766582165 +0100
+++ linux-4.15/drivers/media/dvb-frontends/si2168b_priv.h	2018-02-12 11:32:52.766582165 +0100
@@ -0,0 +1,4390 @@
+#ifndef __SI2168B_PRIV_H__
+#define __SI2168B_PRIV_H__
+
+#include "si2168b.h"
+
+/* Uncomment the following line to activate all traces in the code */
+#define SiTRACES
+
+#define Si2168B_A40_COMPATIBLE
+
+#define Si2168B_REF_FREQUENCY_TER 24
+#define Si2168B_CLOCK_MODE_TER    Si2168B_START_CLK_CMD_CLK_MODE_CLK_CLKIO
+
+#define TUNERTER_API
+#define L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN_SETUP
+#define L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP
+#define L1_RF_TER_TUNER_FEF_MODE_SLOW_NORMAL_AGC_SETUP
+
+#define Si2168B_DOWNLOAD_ON_CHANGE 1
+#define Si2168B_DOWNLOAD_ALWAYS    0
+
+#define Si2168B_TERRESTRIAL 1
+
+#define Si2168B_DVBT_MIN_LOCK_TIME    100
+#define Si2168B_DVBT_MAX_LOCK_TIME   2000
+
+#define Si2168B_CLOCK_ALWAYS_OFF 0
+#define Si2168B_CLOCK_ALWAYS_ON  1
+#define Si2168B_CLOCK_MANAGED    2
+
+#define Si2168B_DVBT2_MIN_LOCK_TIME   100
+#define Si2168B_DVBT2_MAX_LOCK_TIME  2000
+
+#define Si2168B_DVBC_MIN_LOCK_TIME     20
+#define Si2168B_DVBC_MAX_SEARCH_TIME 5000
+
+#define Si2168B_COMMAND_PROTOTYPES
+
+/* <porting> Replace  CUSTOM_PRINTF with your print-out function.*/
+/* #define CUSTOM_PRINTF printf */
+
+#define ERROR_MESSAGE_MAX_LENGH 1000
+#define CHECK_FOR_ERRORS  if (L0_ErrorMessage()) printf("\n\n**************\n%s**************\n\n\n", L0_error_message);
+
+#ifdef SiTRACES
+/* Porting: Select which of the following lines will allow you to display the function names */
+/* Porting: __FUNCTION__ is defined by GCC                                                   */
+/* Porting: __func__     is defined by C99 (it is not defined for VisualStudio 6)            */
+/* Porting: ""           will not display the function names, but will work on all platforms */
+#define SiTRACE(...)        sitrace_function(__FILE__, __LINE__, __FUNCTION__ ,__VA_ARGS__)
+/*#define SiTRACE(...)        SiTraceFunction(__FILE__, __LINE__, __func__     ,__VA_ARGS__)*/
+/*#define SiTRACE(...)        SiTraceFunction(__FILE__, __LINE__, ""           ,__VA_ARGS__)*/
+/*#define SiTRACE(...) */       /* nothing */
+
+/* Replace 'SiTRACES_FULL' by 'SiTRACES_MINIMAL' in the following line to de-activate full features mode */
+/* WARNING : the minimal features mode disables tracing functions in stdout and the extern file          */
+#define SiTRACES_FULL                  1
+#define SiTRACES_MINIMAL               0
+#define SiTRACES_FEATURES     SiTRACES_MINIMAL
+
+#else
+#define SiTRACE(...)               /* empty */
+#define SiTraceConfiguration(...)  /* empty */
+#define SiTracesSuspend()          /* empty */
+#define SiTracesResume()           /* empty */
+#endif /* SiTRACES */
+
+#define TRACES_PRINTF                SiTRACE
+#define ALLOCATION_ERROR_MESSAGE     SiTRACE
+#define TREAT_ERROR_MESSAGE          SiTRACE
+#define TRACES_ERR                   SiTRACE
+#define TRACES_TRACE                 SiTRACE
+#define TRACES_SHOW                  SiTRACE
+#define TRACES_USE                   SiTRACE
+
+#ifdef RWTRACES
+/*    #warning "register-level traces activated (RWTRACES defined)" */
+#define L1_READ(ptr,  register)     L0_ReadRegisterTrace  (ptr->i2c, #register,     register##_ADDRESS, register##_OFFSET, register##_NBBIT, register##_SIGNED)
+#define L1_WRITE(ptr, register, v ) L0_WriteRegisterTrace (ptr->i2c, #register, #v, register##_ADDRESS, register##_OFFSET, register##_NBBIT, register##_ALONE, v)
+#else
+#define L1_READ(ptr,  register)     L0_ReadRegister       (ptr->i2c,                register##_ADDRESS, register##_OFFSET, register##_NBBIT, register##_SIGNED)
+#define L1_WRITE(ptr, register, v ) L0_WriteRegister      (ptr->i2c,                register##_ADDRESS, register##_OFFSET, register##_NBBIT, register##_ALONE, v)
+#endif
+
+/******************************************************************************/
+/* TER Tuner FEF management options */
+/******************************************************************************/
+#define Si2168B_FEF_MODE_SLOW_NORMAL_AGC  0
+#define Si2168B_FEF_MODE_FREEZE_PIN       1
+#define Si2168B_FEF_MODE_SLOW_INITIAL_AGC 2
+
+/******************************************************************************/
+/* TER Tuner FEF management selection (possible values are defined above) */
+/* NB : This selection is the 'preferred' solution.                           */
+/* The code will use more compilation flags to slect the final mode based     */
+/*  on what the TER tuner can actually do.                                    */
+/******************************************************************************/
+/*#define Si2168B_FEF_MODE    Si2168B_FEF_MODE_FREEZE_PIN*/
+/*#define Si2168B_FEF_MODE    Si2168B_FEF_MODE_SLOW_NORMAL_AGC*/
+
+/******************************************************************************/
+/* Clock sources definition (allows using 'clear' names for clock sources)    */
+/******************************************************************************/
+typedef enum Si2168B_CLOCK_SOURCE {
+	Si2168B_Xtal_clock = 0,
+	Si2168B_TER_Tuner_clock,
+	Si2168B_SAT_Tuner_clock
+} Si2168B_CLOCK_SOURCE;
+
+#ifndef    Si2168B_A40_COMPATIBLE
+#ifndef    Si2168B_A3A_COMPATIBLE
+"If you get a compilation error on these lines, it means that no Si2168B version has been selected.";
+"Please define Si2168B_A40_COMPATIBLE or Si2168B_A3A_COMPATIBLE at project level!";
+"Once the flags will be defined, this code will not be visible to the compiler anymore";
+"Do NOT comment these lines, they are here to help, showing if there are missing project flags";
+#endif /* Si2168B_A3A_COMPATIBLE */
+#endif /* Si2168B_A40_COMPATIBLE */
+
+/* Si2168B DD_BER_RESOL property definition */
+#define Si2168B_DD_BER_RESOL_PROP 0x1003
+
+#ifdef Si2168B_DD_BER_RESOL_PROP
+#define Si2168B_DD_BER_RESOL_PROP_CODE 0x001003
+
+
+typedef struct { /* Si2168B_DD_BER_RESOL_PROP_struct */
+	u8  exp;
+	u8  mant;
+} Si2168B_DD_BER_RESOL_PROP_struct;
+
+/* DD_BER_RESOL property, EXP field definition (NO TITLE)*/
+#define Si2168B_DD_BER_RESOL_PROP_EXP_LSB         0
+#define Si2168B_DD_BER_RESOL_PROP_EXP_MASK        0x0f
+#define Si2168B_DD_BER_RESOL_PROP_EXP_DEFAULT    7
+#define Si2168B_DD_BER_RESOL_PROP_EXP_EXPLO_MIN  1
+#define Si2168B_DD_BER_RESOL_PROP_EXP_EXPLO_MAX  8
+
+/* DD_BER_RESOL property, MANT field definition (NO TITLE)*/
+#define Si2168B_DD_BER_RESOL_PROP_MANT_LSB         4
+#define Si2168B_DD_BER_RESOL_PROP_MANT_MASK        0x0f
+#define Si2168B_DD_BER_RESOL_PROP_MANT_DEFAULT    1
+#define Si2168B_DD_BER_RESOL_PROP_MANT_MANTLO_MIN  1
+#define Si2168B_DD_BER_RESOL_PROP_MANT_MANTLO_MAX  9
+
+#endif /* Si2168B_DD_BER_RESOL_PROP */
+
+/* Si2168B DD_CBER_RESOL property definition */
+#define Si2168B_DD_CBER_RESOL_PROP 0x1002
+
+#ifdef Si2168B_DD_CBER_RESOL_PROP
+#define Si2168B_DD_CBER_RESOL_PROP_CODE 0x001002
+
+
+typedef struct { /* Si2168B_DD_CBER_RESOL_PROP_struct */
+	u8  exp;
+	u8  mant;
+} Si2168B_DD_CBER_RESOL_PROP_struct;
+
+/* DD_CBER_RESOL property, EXP field definition (NO TITLE)*/
+#define Si2168B_DD_CBER_RESOL_PROP_EXP_LSB         0
+#define Si2168B_DD_CBER_RESOL_PROP_EXP_MASK        0x0f
+#define Si2168B_DD_CBER_RESOL_PROP_EXP_DEFAULT    5
+#define Si2168B_DD_CBER_RESOL_PROP_EXP_EXPLO_MIN  1
+#define Si2168B_DD_CBER_RESOL_PROP_EXP_EXPLO_MAX  8
+
+/* DD_CBER_RESOL property, MANT field definition (NO TITLE)*/
+#define Si2168B_DD_CBER_RESOL_PROP_MANT_LSB         4
+#define Si2168B_DD_CBER_RESOL_PROP_MANT_MASK        0x0f
+#define Si2168B_DD_CBER_RESOL_PROP_MANT_DEFAULT    1
+#define Si2168B_DD_CBER_RESOL_PROP_MANT_MANTLO_MIN  1
+#define Si2168B_DD_CBER_RESOL_PROP_MANT_MANTLO_MAX  9
+
+#endif /* Si2168B_DD_CBER_RESOL_PROP */
+
+/* Si2168B DD_FER_RESOL property definition */
+#define Si2168B_DD_FER_RESOL_PROP 0x100c
+
+#ifdef Si2168B_DD_FER_RESOL_PROP
+#define Si2168B_DD_FER_RESOL_PROP_CODE 0x00100c
+
+typedef struct { /* Si2168B_DD_FER_RESOL_PROP_struct */
+	u8  exp;
+	u8  mant;
+} Si2168B_DD_FER_RESOL_PROP_struct;
+
+/* DD_FER_RESOL property, EXP field definition (NO TITLE)*/
+#define Si2168B_DD_FER_RESOL_PROP_EXP_LSB         0
+#define Si2168B_DD_FER_RESOL_PROP_EXP_MASK        0x0f
+#define Si2168B_DD_FER_RESOL_PROP_EXP_DEFAULT    3
+#define Si2168B_DD_FER_RESOL_PROP_EXP_EXP_MIN  1
+#define Si2168B_DD_FER_RESOL_PROP_EXP_EXP_MAX  4
+
+/* DD_FER_RESOL property, MANT field definition (NO TITLE)*/
+#define Si2168B_DD_FER_RESOL_PROP_MANT_LSB         4
+#define Si2168B_DD_FER_RESOL_PROP_MANT_MASK        0x0f
+#define Si2168B_DD_FER_RESOL_PROP_MANT_DEFAULT    1
+#define Si2168B_DD_FER_RESOL_PROP_MANT_MANT_MIN  1
+#define Si2168B_DD_FER_RESOL_PROP_MANT_MANT_MAX  9
+
+#endif /* Si2168B_DD_FER_RESOL_PROP */
+
+/* Si2168B DD_IEN property definition */
+#define Si2168B_DD_IEN_PROP 0x1006
+
+#ifdef Si2168B_DD_IEN_PROP
+#define Si2168B_DD_IEN_PROP_CODE 0x001006
+
+typedef struct { /* Si2168B_DD_IEN_PROP_struct */
+	u8  ien_bit0;
+	u8  ien_bit1;
+	u8  ien_bit2;
+	u8  ien_bit3;
+	u8  ien_bit4;
+	u8  ien_bit5;
+	u8  ien_bit6;
+	u8  ien_bit7;
+} Si2168B_DD_IEN_PROP_struct;
+
+/* DD_IEN property, IEN_BIT0 field definition (NO TITLE)*/
+#define Si2168B_DD_IEN_PROP_IEN_BIT0_LSB         0
+#define Si2168B_DD_IEN_PROP_IEN_BIT0_MASK        0x01
+#define Si2168B_DD_IEN_PROP_IEN_BIT0_DEFAULT    0
+#define Si2168B_DD_IEN_PROP_IEN_BIT0_DISABLE  0
+#define Si2168B_DD_IEN_PROP_IEN_BIT0_ENABLE   1
+
+/* DD_IEN property, IEN_BIT1 field definition (NO TITLE)*/
+#define Si2168B_DD_IEN_PROP_IEN_BIT1_LSB         1
+#define Si2168B_DD_IEN_PROP_IEN_BIT1_MASK        0x01
+#define Si2168B_DD_IEN_PROP_IEN_BIT1_DEFAULT    0
+#define Si2168B_DD_IEN_PROP_IEN_BIT1_DISABLE  0
+#define Si2168B_DD_IEN_PROP_IEN_BIT1_ENABLE   1
+
+/* DD_IEN property, IEN_BIT2 field definition (NO TITLE)*/
+#define Si2168B_DD_IEN_PROP_IEN_BIT2_LSB         2
+#define Si2168B_DD_IEN_PROP_IEN_BIT2_MASK        0x01
+#define Si2168B_DD_IEN_PROP_IEN_BIT2_DEFAULT    0
+#define Si2168B_DD_IEN_PROP_IEN_BIT2_DISABLE  0
+#define Si2168B_DD_IEN_PROP_IEN_BIT2_ENABLE   1
+
+/* DD_IEN property, IEN_BIT3 field definition (NO TITLE)*/
+#define Si2168B_DD_IEN_PROP_IEN_BIT3_LSB         3
+#define Si2168B_DD_IEN_PROP_IEN_BIT3_MASK        0x01
+#define Si2168B_DD_IEN_PROP_IEN_BIT3_DEFAULT    0
+#define Si2168B_DD_IEN_PROP_IEN_BIT3_DISABLE  0
+#define Si2168B_DD_IEN_PROP_IEN_BIT3_ENABLE   1
+
+/* DD_IEN property, IEN_BIT4 field definition (NO TITLE)*/
+#define Si2168B_DD_IEN_PROP_IEN_BIT4_LSB         4
+#define Si2168B_DD_IEN_PROP_IEN_BIT4_MASK        0x01
+#define Si2168B_DD_IEN_PROP_IEN_BIT4_DEFAULT    0
+#define Si2168B_DD_IEN_PROP_IEN_BIT4_DISABLE  0
+#define Si2168B_DD_IEN_PROP_IEN_BIT4_ENABLE   1
+
+/* DD_IEN property, IEN_BIT5 field definition (NO TITLE)*/
+#define Si2168B_DD_IEN_PROP_IEN_BIT5_LSB         5
+#define Si2168B_DD_IEN_PROP_IEN_BIT5_MASK        0x01
+#define Si2168B_DD_IEN_PROP_IEN_BIT5_DEFAULT    0
+#define Si2168B_DD_IEN_PROP_IEN_BIT5_DISABLE  0
+#define Si2168B_DD_IEN_PROP_IEN_BIT5_ENABLE   1
+
+/* DD_IEN property, IEN_BIT6 field definition (NO TITLE)*/
+#define Si2168B_DD_IEN_PROP_IEN_BIT6_LSB         6
+#define Si2168B_DD_IEN_PROP_IEN_BIT6_MASK        0x01
+#define Si2168B_DD_IEN_PROP_IEN_BIT6_DEFAULT    0
+#define Si2168B_DD_IEN_PROP_IEN_BIT6_DISABLE  0
+#define Si2168B_DD_IEN_PROP_IEN_BIT6_ENABLE   1
+
+/* DD_IEN property, IEN_BIT7 field definition (NO TITLE)*/
+#define Si2168B_DD_IEN_PROP_IEN_BIT7_LSB         7
+#define Si2168B_DD_IEN_PROP_IEN_BIT7_MASK        0x01
+#define Si2168B_DD_IEN_PROP_IEN_BIT7_DEFAULT    0
+#define Si2168B_DD_IEN_PROP_IEN_BIT7_DISABLE  0
+#define Si2168B_DD_IEN_PROP_IEN_BIT7_ENABLE   1
+
+#endif /* Si2168B_DD_IEN_PROP */
+
+/* Si2168B DD_IF_INPUT_FREQ property definition */
+#define Si2168B_DD_IF_INPUT_FREQ_PROP 0x100b
+
+#ifdef Si2168B_DD_IF_INPUT_FREQ_PROP
+#define Si2168B_DD_IF_INPUT_FREQ_PROP_CODE 0x00100b
+
+
+typedef struct { /* Si2168B_DD_IF_INPUT_FREQ_PROP_struct */
+	u16 offset;
+} Si2168B_DD_IF_INPUT_FREQ_PROP_struct;
+
+/* DD_IF_INPUT_FREQ property, OFFSET field definition (NO TITLE)*/
+#define Si2168B_DD_IF_INPUT_FREQ_PROP_OFFSET_LSB         0
+#define Si2168B_DD_IF_INPUT_FREQ_PROP_OFFSET_MASK        0xffff
+#define Si2168B_DD_IF_INPUT_FREQ_PROP_OFFSET_DEFAULT    5000
+#define Si2168B_DD_IF_INPUT_FREQ_PROP_OFFSET_OFFSET_MIN  0
+#define Si2168B_DD_IF_INPUT_FREQ_PROP_OFFSET_OFFSET_MAX  36000
+
+#endif /* Si2168B_DD_IF_INPUT_FREQ_PROP */
+
+/* Si2168B DD_INT_SENSE property definition */
+#define Si2168B_DD_INT_SENSE_PROP 0x1007
+
+#ifdef Si2168B_DD_INT_SENSE_PROP
+#define Si2168B_DD_INT_SENSE_PROP_CODE 0x001007
+
+typedef struct { /* Si2168B_DD_INT_SENSE_PROP_struct */
+	u8  neg_bit0;
+	u8  neg_bit1;
+	u8  neg_bit2;
+	u8  neg_bit3;
+	u8  neg_bit4;
+	u8  neg_bit5;
+	u8  neg_bit6;
+	u8  neg_bit7;
+	u8  pos_bit0;
+	u8  pos_bit1;
+	u8  pos_bit2;
+	u8  pos_bit3;
+	u8  pos_bit4;
+	u8  pos_bit5;
+	u8  pos_bit6;
+	u8  pos_bit7;
+} Si2168B_DD_INT_SENSE_PROP_struct;
+
+/* DD_INT_SENSE property, NEG_BIT0 field definition (NO TITLE)*/
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT0_LSB         0
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT0_MASK        0x01
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT0_DEFAULT    0
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT0_DISABLE  0
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT0_ENABLE   1
+
+/* DD_INT_SENSE property, NEG_BIT1 field definition (NO TITLE)*/
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT1_LSB         1
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT1_MASK        0x01
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT1_DEFAULT    0
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT1_DISABLE  0
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT1_ENABLE   1
+
+/* DD_INT_SENSE property, NEG_BIT2 field definition (NO TITLE)*/
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT2_LSB         2
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT2_MASK        0x01
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT2_DEFAULT    0
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT2_DISABLE  0
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT2_ENABLE   1
+
+/* DD_INT_SENSE property, NEG_BIT3 field definition (NO TITLE)*/
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT3_LSB         3
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT3_MASK        0x01
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT3_DEFAULT    0
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT3_DISABLE  0
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT3_ENABLE   1
+
+/* DD_INT_SENSE property, NEG_BIT4 field definition (NO TITLE)*/
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT4_LSB         4
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT4_MASK        0x01
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT4_DEFAULT    0
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT4_DISABLE  0
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT4_ENABLE   1
+
+/* DD_INT_SENSE property, NEG_BIT5 field definition (NO TITLE)*/
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT5_LSB         5
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT5_MASK        0x01
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT5_DEFAULT    0
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT5_DISABLE  0
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT5_ENABLE   1
+
+/* DD_INT_SENSE property, NEG_BIT6 field definition (NO TITLE)*/
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT6_LSB         6
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT6_MASK        0x01
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT6_DEFAULT    0
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT6_DISABLE  0
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT6_ENABLE   1
+
+/* DD_INT_SENSE property, NEG_BIT7 field definition (NO TITLE)*/
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT7_LSB         7
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT7_MASK        0x01
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT7_DEFAULT    0
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT7_DISABLE  0
+#define Si2168B_DD_INT_SENSE_PROP_NEG_BIT7_ENABLE   1
+
+/* DD_INT_SENSE property, POS_BIT0 field definition (NO TITLE)*/
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT0_LSB         8
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT0_MASK        0x01
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT0_DEFAULT    0
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT0_DISABLE  0
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT0_ENABLE   1
+
+/* DD_INT_SENSE property, POS_BIT1 field definition (NO TITLE)*/
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT1_LSB         9
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT1_MASK        0x01
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT1_DEFAULT    0
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT1_DISABLE  0
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT1_ENABLE   1
+
+/* DD_INT_SENSE property, POS_BIT2 field definition (NO TITLE)*/
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT2_LSB         10
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT2_MASK        0x01
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT2_DEFAULT    0
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT2_DISABLE  0
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT2_ENABLE   1
+
+/* DD_INT_SENSE property, POS_BIT3 field definition (NO TITLE)*/
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT3_LSB         11
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT3_MASK        0x01
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT3_DEFAULT    0
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT3_DISABLE  0
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT3_ENABLE   1
+
+/* DD_INT_SENSE property, POS_BIT4 field definition (NO TITLE)*/
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT4_LSB         12
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT4_MASK        0x01
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT4_DEFAULT    0
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT4_DISABLE  0
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT4_ENABLE   1
+
+/* DD_INT_SENSE property, POS_BIT5 field definition (NO TITLE)*/
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT5_LSB         13
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT5_MASK        0x01
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT5_DEFAULT    0
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT5_DISABLE  0
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT5_ENABLE   1
+
+/* DD_INT_SENSE property, POS_BIT6 field definition (NO TITLE)*/
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT6_LSB         14
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT6_MASK        0x01
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT6_DEFAULT    0
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT6_DISABLE  0
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT6_ENABLE   1
+
+/* DD_INT_SENSE property, POS_BIT7 field definition (NO TITLE)*/
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT7_LSB         15
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT7_MASK        0x01
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT7_DEFAULT    0
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT7_DISABLE  0
+#define Si2168B_DD_INT_SENSE_PROP_POS_BIT7_ENABLE   1
+
+#endif /* Si2168B_DD_INT_SENSE_PROP */
+
+/* Si2168B DD_MODE property definition */
+#define Si2168B_DD_MODE_PROP 0x100a
+
+#ifdef Si2168B_DD_MODE_PROP
+#define Si2168B_DD_MODE_PROP_CODE 0x00100a
+
+typedef struct { /* Si2168B_DD_MODE_PROP_struct */
+	u8  auto_detect;
+	u8  bw;
+	u8  invert_spectrum;
+	u8  modulation;
+} Si2168B_DD_MODE_PROP_struct;
+
+/* DD_MODE property, AUTO_DETECT field definition (NO TITLE)*/
+#define Si2168B_DD_MODE_PROP_AUTO_DETECT_LSB         9
+#define Si2168B_DD_MODE_PROP_AUTO_DETECT_MASK        0x07
+#define Si2168B_DD_MODE_PROP_AUTO_DETECT_DEFAULT    0
+#define Si2168B_DD_MODE_PROP_AUTO_DETECT_NONE               0
+#define Si2168B_DD_MODE_PROP_AUTO_DETECT_AUTO_DVB_T_T2      1
+#define Si2168B_DD_MODE_PROP_AUTO_DETECT_AUTO_DVB_S_S2      2
+#define Si2168B_DD_MODE_PROP_AUTO_DETECT_AUTO_DVB_S_S2_DSS  3
+
+/* DD_MODE property, BW field definition (NO TITLE)*/
+#define Si2168B_DD_MODE_PROP_BW_LSB         0
+#define Si2168B_DD_MODE_PROP_BW_MASK        0x0f
+#define Si2168B_DD_MODE_PROP_BW_DEFAULT    8
+#define Si2168B_DD_MODE_PROP_BW_BW_5MHZ    5
+#define Si2168B_DD_MODE_PROP_BW_BW_6MHZ    6
+#define Si2168B_DD_MODE_PROP_BW_BW_7MHZ    7
+#define Si2168B_DD_MODE_PROP_BW_BW_8MHZ    8
+#define Si2168B_DD_MODE_PROP_BW_BW_1D7MHZ  2
+
+/* DD_MODE property, INVERT_SPECTRUM field definition (NO TITLE)*/
+#define Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_LSB         8
+#define Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_MASK        0x01
+#define Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_DEFAULT    0
+#define Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_NORMAL    0
+#define Si2168B_DD_MODE_PROP_INVERT_SPECTRUM_INVERTED  1
+
+/* DD_MODE property, MODULATION field definition (NO TITLE)*/
+#define Si2168B_DD_MODE_PROP_MODULATION_LSB         4
+#define Si2168B_DD_MODE_PROP_MODULATION_MASK        0x0f
+#define Si2168B_DD_MODE_PROP_MODULATION_DEFAULT    2
+#define Si2168B_DD_MODE_PROP_MODULATION_MCNS         1
+#define Si2168B_DD_MODE_PROP_MODULATION_DVBT         2
+#define Si2168B_DD_MODE_PROP_MODULATION_DVBC         3
+#define Si2168B_DD_MODE_PROP_MODULATION_DVBT2        7
+#define Si2168B_DD_MODE_PROP_MODULATION_DVBS         8
+#define Si2168B_DD_MODE_PROP_MODULATION_DVBS2        9
+#define Si2168B_DD_MODE_PROP_MODULATION_DSS          10
+#define Si2168B_DD_MODE_PROP_MODULATION_DVBC2        11
+#define Si2168B_DD_MODE_PROP_MODULATION_AUTO_DETECT  15
+#define Si2168B_DD_MODE_PROP_MODULATION_ANALOG     100
+/* new mode definition to set SLEEP mode */
+#define Si2168B_DD_MODE_PROP_MODULATION_SLEEP      0xFF
+
+#endif /* Si2168B_DD_MODE_PROP */
+
+/* Si2168B DD_PER_RESOL property definition */
+#define Si2168B_DD_PER_RESOL_PROP 0x1004
+
+#ifdef Si2168B_DD_PER_RESOL_PROP
+#define Si2168B_DD_PER_RESOL_PROP_CODE 0x001004
+
+typedef struct { /* Si2168B_DD_PER_RESOL_PROP_struct */
+	u8  exp;
+	u8  mant;
+} Si2168B_DD_PER_RESOL_PROP_struct;
+
+/* DD_PER_RESOL property, EXP field definition (NO TITLE)*/
+#define Si2168B_DD_PER_RESOL_PROP_EXP_LSB         0
+#define Si2168B_DD_PER_RESOL_PROP_EXP_MASK        0x0f
+#define Si2168B_DD_PER_RESOL_PROP_EXP_DEFAULT    5
+#define Si2168B_DD_PER_RESOL_PROP_EXP_EXPLO_MIN  1
+#define Si2168B_DD_PER_RESOL_PROP_EXP_EXPLO_MAX  9
+
+/* DD_PER_RESOL property, MANT field definition (NO TITLE)*/
+#define Si2168B_DD_PER_RESOL_PROP_MANT_LSB         4
+#define Si2168B_DD_PER_RESOL_PROP_MANT_MASK        0x0f
+#define Si2168B_DD_PER_RESOL_PROP_MANT_DEFAULT    1
+#define Si2168B_DD_PER_RESOL_PROP_MANT_MANTLO_MIN  1
+#define Si2168B_DD_PER_RESOL_PROP_MANT_MANTLO_MAX  9
+
+#endif /* Si2168B_DD_PER_RESOL_PROP */
+
+/* Si2168B DD_RSQ_BER_THRESHOLD property definition */
+#define Si2168B_DD_RSQ_BER_THRESHOLD_PROP 0x1005
+
+#ifdef Si2168B_DD_RSQ_BER_THRESHOLD_PROP
+#define Si2168B_DD_RSQ_BER_THRESHOLD_PROP_CODE 0x001005
+
+typedef struct { /* Si2168B_DD_RSQ_BER_THRESHOLD_PROP_struct */
+	u8  exp;
+	u8  mant;
+} Si2168B_DD_RSQ_BER_THRESHOLD_PROP_struct;
+
+/* DD_RSQ_BER_THRESHOLD property, EXP field definition (NO TITLE)*/
+#define Si2168B_DD_RSQ_BER_THRESHOLD_PROP_EXP_LSB         0
+#define Si2168B_DD_RSQ_BER_THRESHOLD_PROP_EXP_MASK        0x0f
+#define Si2168B_DD_RSQ_BER_THRESHOLD_PROP_EXP_DEFAULT    1
+#define Si2168B_DD_RSQ_BER_THRESHOLD_PROP_EXP_EXP_MIN  1
+#define Si2168B_DD_RSQ_BER_THRESHOLD_PROP_EXP_EXP_MAX  8
+
+/* DD_RSQ_BER_THRESHOLD property, MANT field definition (NO TITLE)*/
+#define Si2168B_DD_RSQ_BER_THRESHOLD_PROP_MANT_LSB         4
+#define Si2168B_DD_RSQ_BER_THRESHOLD_PROP_MANT_MASK        0x0f
+#define Si2168B_DD_RSQ_BER_THRESHOLD_PROP_MANT_DEFAULT    10
+#define Si2168B_DD_RSQ_BER_THRESHOLD_PROP_MANT_MANT_MIN  0
+#define Si2168B_DD_RSQ_BER_THRESHOLD_PROP_MANT_MANT_MAX  99
+
+#endif /* Si2168B_DD_RSQ_BER_THRESHOLD_PROP */
+
+/* Si2168B DD_SSI_SQI_PARAM property definition */
+#define Si2168B_DD_SSI_SQI_PARAM_PROP 0x100f
+
+#ifdef Si2168B_DD_SSI_SQI_PARAM_PROP
+#define Si2168B_DD_SSI_SQI_PARAM_PROP_CODE 0x00100f
+
+typedef struct { /* Si2168B_DD_SSI_SQI_PARAM_PROP_struct */
+	u8  sqi_average;
+} Si2168B_DD_SSI_SQI_PARAM_PROP_struct;
+
+/* DD_SSI_SQI_PARAM property, SQI_AVERAGE field definition (NO TITLE)*/
+#define Si2168B_DD_SSI_SQI_PARAM_PROP_SQI_AVERAGE_LSB         0
+#define Si2168B_DD_SSI_SQI_PARAM_PROP_SQI_AVERAGE_MASK        0x1f
+#define Si2168B_DD_SSI_SQI_PARAM_PROP_SQI_AVERAGE_DEFAULT    1
+#define Si2168B_DD_SSI_SQI_PARAM_PROP_SQI_AVERAGE_SQI_AVERAGE_MIN  1
+#define Si2168B_DD_SSI_SQI_PARAM_PROP_SQI_AVERAGE_SQI_AVERAGE_MAX  30
+
+#endif /* Si2168B_DD_SSI_SQI_PARAM_PROP */
+
+/* Si2168B DD_TS_FREQ property definition */
+#define Si2168B_DD_TS_FREQ_PROP 0x100d
+
+#ifdef Si2168B_DD_TS_FREQ_PROP
+#define Si2168B_DD_TS_FREQ_PROP_CODE 0x00100d
+
+typedef struct { /* Si2168B_DD_TS_FREQ_PROP_struct */
+	u16 req_freq_10khz;
+} Si2168B_DD_TS_FREQ_PROP_struct;
+
+/* DD_TS_FREQ property, REQ_FREQ_10KHZ field definition (NO TITLE)*/
+#define Si2168B_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_LSB         0
+#define Si2168B_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_MASK        0x3fff
+#define Si2168B_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_DEFAULT    720
+#define Si2168B_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_REQ_FREQ_10KHZ_MIN  0
+#define Si2168B_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_REQ_FREQ_10KHZ_MAX  14550
+
+#endif /* Si2168B_DD_TS_FREQ_PROP */
+
+/* Si2168B DD_TS_MODE property definition */
+#define Si2168B_DD_TS_MODE_PROP 0x1001
+
+#ifdef Si2168B_DD_TS_MODE_PROP
+#define Si2168B_DD_TS_MODE_PROP_CODE 0x001001
+
+typedef struct { /* Si2168B_DD_TS_MODE_PROP_struct */
+	u8  clk_gapped_en;
+	u8  clock;
+	u8  mode;
+	u8  special;
+	u8  ts_err_polarity;
+	u8  ts_freq_resolution;
+} Si2168B_DD_TS_MODE_PROP_struct;
+
+/* DD_TS_MODE property, CLK_GAPPED_EN field definition (NO TITLE)*/
+#define Si2168B_DD_TS_MODE_PROP_CLK_GAPPED_EN_LSB         6
+#define Si2168B_DD_TS_MODE_PROP_CLK_GAPPED_EN_MASK        0x01
+#define Si2168B_DD_TS_MODE_PROP_CLK_GAPPED_EN_DEFAULT    0
+#define Si2168B_DD_TS_MODE_PROP_CLK_GAPPED_EN_DISABLED  0
+#define Si2168B_DD_TS_MODE_PROP_CLK_GAPPED_EN_ENABLED   1
+
+/* DD_TS_MODE property, CLOCK field definition (NO TITLE)*/
+#define Si2168B_DD_TS_MODE_PROP_CLOCK_LSB         4
+#define Si2168B_DD_TS_MODE_PROP_CLOCK_MASK        0x03
+#define Si2168B_DD_TS_MODE_PROP_CLOCK_DEFAULT    0
+#define Si2168B_DD_TS_MODE_PROP_CLOCK_AUTO_FIXED  0
+#define Si2168B_DD_TS_MODE_PROP_CLOCK_AUTO_ADAPT  1
+#define Si2168B_DD_TS_MODE_PROP_CLOCK_MANUAL      2
+
+/* DD_TS_MODE property, MODE field definition (NO TITLE)*/
+#define Si2168B_DD_TS_MODE_PROP_MODE_LSB         0
+#define Si2168B_DD_TS_MODE_PROP_MODE_MASK        0x0f
+#define Si2168B_DD_TS_MODE_PROP_MODE_DEFAULT    0
+#define Si2168B_DD_TS_MODE_PROP_MODE_TRISTATE  0
+#define Si2168B_DD_TS_MODE_PROP_MODE_OFF       1
+#define Si2168B_DD_TS_MODE_PROP_MODE_SERIAL    3
+#define Si2168B_DD_TS_MODE_PROP_MODE_PARALLEL  6
+#define Si2168B_DD_TS_MODE_PROP_MODE_GPIF      7
+
+/* DD_TS_MODE property, SPECIAL field definition (NO TITLE)*/
+#define Si2168B_DD_TS_MODE_PROP_SPECIAL_LSB         8
+#define Si2168B_DD_TS_MODE_PROP_SPECIAL_MASK        0x03
+#define Si2168B_DD_TS_MODE_PROP_SPECIAL_DEFAULT    0
+#define Si2168B_DD_TS_MODE_PROP_SPECIAL_FULL_TS         0
+#define Si2168B_DD_TS_MODE_PROP_SPECIAL_DATAS_TRISTATE  1
+
+/* DD_TS_MODE property, TS_ERR_POLARITY field definition (NO TITLE)*/
+#define Si2168B_DD_TS_MODE_PROP_TS_ERR_POLARITY_LSB         7
+#define Si2168B_DD_TS_MODE_PROP_TS_ERR_POLARITY_MASK        0x01
+#define Si2168B_DD_TS_MODE_PROP_TS_ERR_POLARITY_DEFAULT    0
+#define Si2168B_DD_TS_MODE_PROP_TS_ERR_POLARITY_NOT_INVERTED  0
+#define Si2168B_DD_TS_MODE_PROP_TS_ERR_POLARITY_INVERTED      1
+
+/* DD_TS_MODE property, TS_FREQ_RESOLUTION field definition (NO TITLE)*/
+#define Si2168B_DD_TS_MODE_PROP_TS_FREQ_RESOLUTION_LSB         10
+#define Si2168B_DD_TS_MODE_PROP_TS_FREQ_RESOLUTION_MASK        0x01
+#define Si2168B_DD_TS_MODE_PROP_TS_FREQ_RESOLUTION_DEFAULT    0
+#define Si2168B_DD_TS_MODE_PROP_TS_FREQ_RESOLUTION_NORMAL  0
+#define Si2168B_DD_TS_MODE_PROP_TS_FREQ_RESOLUTION_FINE    1
+
+#endif /* Si2168B_DD_TS_MODE_PROP */
+
+/* Si2168B DD_TS_SERIAL_DIFF property definition */
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP 0x1012
+
+#ifdef Si2168B_DD_TS_SERIAL_DIFF_PROP
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_CODE 0x001012
+
+typedef struct { /* Si2168B_DD_TS_SERIAL_DIFF_PROP_struct */
+	u8  ts_clkb_on_data1;
+	u8  ts_data0b_on_data2;
+	u8  ts_data1_shape;
+	u8  ts_data1_strength;
+	u8  ts_data2_shape;
+	u8  ts_data2_strength;
+} Si2168B_DD_TS_SERIAL_DIFF_PROP_struct;
+
+/* DD_TS_SERIAL_DIFF property, TS_CLKB_ON_DATA1 field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_CLKB_ON_DATA1_LSB         12
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_CLKB_ON_DATA1_MASK        0x01
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_CLKB_ON_DATA1_DEFAULT    0
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_CLKB_ON_DATA1_DISABLE  0
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_CLKB_ON_DATA1_ENABLE   1
+
+/* DD_TS_SERIAL_DIFF property, TS_DATA0B_ON_DATA2 field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA0B_ON_DATA2_LSB         13
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA0B_ON_DATA2_MASK        0x01
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA0B_ON_DATA2_DEFAULT    0
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA0B_ON_DATA2_DISABLE  0
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA0B_ON_DATA2_ENABLE   1
+
+/* DD_TS_SERIAL_DIFF property, TS_DATA1_SHAPE field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA1_SHAPE_LSB         4
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA1_SHAPE_MASK        0x03
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA1_SHAPE_DEFAULT    3
+/* DD_TS_SERIAL_DIFF property, TS_DATA1_STRENGTH field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA1_STRENGTH_LSB         0
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA1_STRENGTH_MASK        0x0f
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA1_STRENGTH_DEFAULT    15
+/* DD_TS_SERIAL_DIFF property, TS_DATA2_SHAPE field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA2_SHAPE_LSB         10
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA2_SHAPE_MASK        0x03
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA2_SHAPE_DEFAULT    3
+/* DD_TS_SERIAL_DIFF property, TS_DATA2_STRENGTH field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA2_STRENGTH_LSB         6
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA2_STRENGTH_MASK        0x0f
+#define Si2168B_DD_TS_SERIAL_DIFF_PROP_TS_DATA2_STRENGTH_DEFAULT    15
+#endif /* Si2168B_DD_TS_SERIAL_DIFF_PROP */
+
+/* Si2168B DD_TS_SETUP_PAR property definition */
+#define Si2168B_DD_TS_SETUP_PAR_PROP 0x1009
+
+#ifdef Si2168B_DD_TS_SETUP_PAR_PROP
+#define Si2168B_DD_TS_SETUP_PAR_PROP_CODE 0x001009
+
+typedef struct { /* Si2168B_DD_TS_SETUP_PAR_PROP_struct */
+	u8  ts_clk_invert;
+	u8  ts_clk_shape;
+	u8  ts_clk_shift;
+	u8  ts_clk_strength;
+	u8  ts_data_shape;
+	u8  ts_data_strength;
+} Si2168B_DD_TS_SETUP_PAR_PROP_struct;
+
+/* DD_TS_SETUP_PAR property, TS_CLK_INVERT field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_LSB         12
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_MASK        0x01
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_DEFAULT    1
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_NOT_INVERTED  0
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_INVERTED      1
+
+/* DD_TS_SETUP_PAR property, TS_CLK_SHAPE field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_LSB         10
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_MASK        0x03
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_DEFAULT    1
+/* DD_TS_SETUP_PAR property, TS_CLK_SHIFT field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_LSB         13
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_MASK        0x07
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_DEFAULT    0
+/* DD_TS_SETUP_PAR property, TS_CLK_STRENGTH field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_LSB         6
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_MASK        0x0f
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_DEFAULT    3
+/* DD_TS_SETUP_PAR property, TS_DATA_SHAPE field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_LSB         4
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_MASK        0x03
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_DEFAULT    1
+/* DD_TS_SETUP_PAR property, TS_DATA_STRENGTH field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_LSB         0
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_MASK        0x0f
+#define Si2168B_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_DEFAULT    3
+#endif /* Si2168B_DD_TS_SETUP_PAR_PROP */
+
+/* Si2168B DD_TS_SETUP_SER property definition */
+#define Si2168B_DD_TS_SETUP_SER_PROP 0x1008
+
+#ifdef Si2168B_DD_TS_SETUP_SER_PROP
+#define Si2168B_DD_TS_SETUP_SER_PROP_CODE 0x001008
+
+typedef struct { /* Si2168B_DD_TS_SETUP_SER_PROP_struct */
+	u8  ts_byte_order;
+	u8  ts_clk_invert;
+	u8  ts_clk_shape;
+	u8  ts_clk_strength;
+	u8  ts_data_shape;
+	u8  ts_data_strength;
+	u8  ts_sync_duration;
+} Si2168B_DD_TS_SETUP_SER_PROP_struct;
+
+/* DD_TS_SETUP_SER property, TS_BYTE_ORDER field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_LSB         14
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_MASK        0x01
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_DEFAULT    0
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_MSB_FIRST  0
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_LSB_FIRST  1
+
+/* DD_TS_SETUP_SER property, TS_CLK_INVERT field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_LSB         12
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_MASK        0x01
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_DEFAULT    1
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_NOT_INVERTED  0
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_INVERTED      1
+
+/* DD_TS_SETUP_SER property, TS_CLK_SHAPE field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_CLK_SHAPE_LSB         10
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_CLK_SHAPE_MASK        0x03
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_CLK_SHAPE_DEFAULT    3
+/* DD_TS_SETUP_SER property, TS_CLK_STRENGTH field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_CLK_STRENGTH_LSB         6
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_CLK_STRENGTH_MASK        0x0f
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_CLK_STRENGTH_DEFAULT    15
+/* DD_TS_SETUP_SER property, TS_DATA_SHAPE field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_DATA_SHAPE_LSB         4
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_DATA_SHAPE_MASK        0x03
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_DATA_SHAPE_DEFAULT    3
+/* DD_TS_SETUP_SER property, TS_DATA_STRENGTH field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_DATA_STRENGTH_LSB         0
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_DATA_STRENGTH_MASK        0x0f
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_DATA_STRENGTH_DEFAULT    15
+/* DD_TS_SETUP_SER property, TS_SYNC_DURATION field definition (NO TITLE)*/
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_LSB         13
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_MASK        0x01
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_DEFAULT    0
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_FIRST_BYTE  0
+#define Si2168B_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_FIRST_BIT   1
+
+#endif /* Si2168B_DD_TS_SETUP_SER_PROP */
+
+/* Si2168B DVBC_ADC_CREST_FACTOR property definition */
+#define Si2168B_DVBC_ADC_CREST_FACTOR_PROP 0x1104
+
+#ifdef Si2168B_DVBC_ADC_CREST_FACTOR_PROP
+#define Si2168B_DVBC_ADC_CREST_FACTOR_PROP_CODE 0x001104
+
+typedef struct { /* Si2168B_DVBC_ADC_CREST_FACTOR_PROP_struct */
+	u8  crest_factor;
+} Si2168B_DVBC_ADC_CREST_FACTOR_PROP_struct;
+
+/* DVBC_ADC_CREST_FACTOR property, CREST_FACTOR field definition (NO TITLE)*/
+#define Si2168B_DVBC_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB         0
+#define Si2168B_DVBC_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK        0xff
+#define Si2168B_DVBC_ADC_CREST_FACTOR_PROP_CREST_FACTOR_DEFAULT    112
+#endif /* Si2168B_DVBC_ADC_CREST_FACTOR_PROP */
+
+/* Si2168B DVBC_AFC_RANGE property definition */
+#define Si2168B_DVBC_AFC_RANGE_PROP 0x1103
+
+#ifdef Si2168B_DVBC_AFC_RANGE_PROP
+#define Si2168B_DVBC_AFC_RANGE_PROP_CODE 0x001103
+
+typedef struct { /* Si2168B_DVBC_AFC_RANGE_PROP_struct */
+	u16 range_khz;
+} Si2168B_DVBC_AFC_RANGE_PROP_struct;
+
+/* DVBC_AFC_RANGE property, RANGE_KHZ field definition (NO TITLE)*/
+#define Si2168B_DVBC_AFC_RANGE_PROP_RANGE_KHZ_LSB         0
+#define Si2168B_DVBC_AFC_RANGE_PROP_RANGE_KHZ_MASK        0xffff
+#define Si2168B_DVBC_AFC_RANGE_PROP_RANGE_KHZ_DEFAULT    100
+#endif /* Si2168B_DVBC_AFC_RANGE_PROP */
+
+/* Si2168B DVBC_CONSTELLATION property definition */
+#define Si2168B_DVBC_CONSTELLATION_PROP 0x1101
+
+#ifdef Si2168B_DVBC_CONSTELLATION_PROP
+#define Si2168B_DVBC_CONSTELLATION_PROP_CODE 0x001101
+
+typedef struct { /* Si2168B_DVBC_CONSTELLATION_PROP_struct */
+	u8  constellation;
+} Si2168B_DVBC_CONSTELLATION_PROP_struct;
+
+/* DVBC_CONSTELLATION property, CONSTELLATION field definition (NO TITLE)*/
+#define Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_LSB         0
+#define Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_MASK        0x3f
+#define Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_DEFAULT    0
+#define Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_AUTO    0
+#define Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM16   7
+#define Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM32   8
+#define Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM64   9
+#define Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM128  10
+#define Si2168B_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM256  11
+
+#endif /* Si2168B_DVBC_CONSTELLATION_PROP */
+
+/* Si2168B DVBC_SYMBOL_RATE property definition */
+#define Si2168B_DVBC_SYMBOL_RATE_PROP 0x1102
+
+#ifdef Si2168B_DVBC_SYMBOL_RATE_PROP
+#define Si2168B_DVBC_SYMBOL_RATE_PROP_CODE 0x001102
+
+typedef struct { /* Si2168B_DVBC_SYMBOL_RATE_PROP_struct */
+	u16 rate;
+} Si2168B_DVBC_SYMBOL_RATE_PROP_struct;
+
+/* DVBC_SYMBOL_RATE property, RATE field definition (NO TITLE)*/
+#define Si2168B_DVBC_SYMBOL_RATE_PROP_RATE_LSB         0
+#define Si2168B_DVBC_SYMBOL_RATE_PROP_RATE_MASK        0xffff
+#define Si2168B_DVBC_SYMBOL_RATE_PROP_RATE_DEFAULT    6900
+#endif /* Si2168B_DVBC_SYMBOL_RATE_PROP */
+
+/* Si2168B DVBT2_ADC_CREST_FACTOR property definition */
+#define Si2168B_DVBT2_ADC_CREST_FACTOR_PROP 0x1303
+
+#ifdef Si2168B_DVBT2_ADC_CREST_FACTOR_PROP
+#define Si2168B_DVBT2_ADC_CREST_FACTOR_PROP_CODE 0x001303
+
+typedef struct { /* Si2168B_DVBT2_ADC_CREST_FACTOR_PROP_struct */
+	u8  crest_factor;
+} Si2168B_DVBT2_ADC_CREST_FACTOR_PROP_struct;
+
+/* DVBT2_ADC_CREST_FACTOR property, CREST_FACTOR field definition (NO TITLE)*/
+#define Si2168B_DVBT2_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB         0
+#define Si2168B_DVBT2_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK        0xff
+#define Si2168B_DVBT2_ADC_CREST_FACTOR_PROP_CREST_FACTOR_DEFAULT    130
+#endif /* Si2168B_DVBT2_ADC_CREST_FACTOR_PROP */
+
+/* Si2168B DVBT2_AFC_RANGE property definition */
+#define Si2168B_DVBT2_AFC_RANGE_PROP 0x1301
+
+#ifdef Si2168B_DVBT2_AFC_RANGE_PROP
+#define Si2168B_DVBT2_AFC_RANGE_PROP_CODE 0x001301
+
+typedef struct { /* Si2168B_DVBT2_AFC_RANGE_PROP_struct */
+	u16 range_khz;
+} Si2168B_DVBT2_AFC_RANGE_PROP_struct;
+
+/* DVBT2_AFC_RANGE property, RANGE_KHZ field definition (NO TITLE)*/
+#define Si2168B_DVBT2_AFC_RANGE_PROP_RANGE_KHZ_LSB         0
+#define Si2168B_DVBT2_AFC_RANGE_PROP_RANGE_KHZ_MASK        0xffff
+#define Si2168B_DVBT2_AFC_RANGE_PROP_RANGE_KHZ_DEFAULT    550
+#endif /* Si2168B_DVBT2_AFC_RANGE_PROP */
+
+/* Si2168B DVBT2_FEF_TUNER property definition */
+#define Si2168B_DVBT2_FEF_TUNER_PROP 0x1302
+
+#ifdef Si2168B_DVBT2_FEF_TUNER_PROP
+#define Si2168B_DVBT2_FEF_TUNER_PROP_CODE 0x001302
+
+typedef struct { /* Si2168B_DVBT2_FEF_TUNER_PROP_struct */
+	u8  tuner_delay;
+	u8  tuner_freeze_time;
+	u8  tuner_unfreeze_time;
+} Si2168B_DVBT2_FEF_TUNER_PROP_struct;
+
+/* DVBT2_FEF_TUNER property, TUNER_DELAY field definition (NO TITLE)*/
+#define Si2168B_DVBT2_FEF_TUNER_PROP_TUNER_DELAY_LSB         0
+#define Si2168B_DVBT2_FEF_TUNER_PROP_TUNER_DELAY_MASK        0xff
+#define Si2168B_DVBT2_FEF_TUNER_PROP_TUNER_DELAY_DEFAULT    1
+/* DVBT2_FEF_TUNER property, TUNER_FREEZE_TIME field definition (NO TITLE)*/
+#define Si2168B_DVBT2_FEF_TUNER_PROP_TUNER_FREEZE_TIME_LSB         8
+#define Si2168B_DVBT2_FEF_TUNER_PROP_TUNER_FREEZE_TIME_MASK        0x0f
+#define Si2168B_DVBT2_FEF_TUNER_PROP_TUNER_FREEZE_TIME_DEFAULT    1
+/* DVBT2_FEF_TUNER property, TUNER_UNFREEZE_TIME field definition (NO TITLE)*/
+#define Si2168B_DVBT2_FEF_TUNER_PROP_TUNER_UNFREEZE_TIME_LSB         12
+#define Si2168B_DVBT2_FEF_TUNER_PROP_TUNER_UNFREEZE_TIME_MASK        0x0f
+#define Si2168B_DVBT2_FEF_TUNER_PROP_TUNER_UNFREEZE_TIME_DEFAULT    1
+#endif /* Si2168B_DVBT2_FEF_TUNER_PROP */
+
+/* Si2168B DVBT2_MODE property definition */
+#define Si2168B_DVBT2_MODE_PROP 0x1304
+
+#ifdef Si2168B_DVBT2_MODE_PROP
+#define Si2168B_DVBT2_MODE_PROP_CODE 0x001304
+
+typedef struct { /* Si2168B_DVBT2_MODE_PROP_struct */
+	u8  lock_mode;
+} Si2168B_DVBT2_MODE_PROP_struct;
+
+/* DVBT2_MODE property, LOCK_MODE field definition (NO TITLE)*/
+#define Si2168B_DVBT2_MODE_PROP_LOCK_MODE_LSB         0
+#define Si2168B_DVBT2_MODE_PROP_LOCK_MODE_MASK        0x03
+#define Si2168B_DVBT2_MODE_PROP_LOCK_MODE_DEFAULT    0
+#define Si2168B_DVBT2_MODE_PROP_LOCK_MODE_ANY        0
+#define Si2168B_DVBT2_MODE_PROP_LOCK_MODE_BASE_ONLY  1
+#define Si2168B_DVBT2_MODE_PROP_LOCK_MODE_LITE_ONLY  2
+#define Si2168B_DVBT2_MODE_PROP_LOCK_MODE_RESERVED   3
+
+#endif /* Si2168B_DVBT2_MODE_PROP */
+
+/* Si2168B DVBT_ADC_CREST_FACTOR property definition */
+#define Si2168B_DVBT_ADC_CREST_FACTOR_PROP 0x1203
+
+#ifdef Si2168B_DVBT_ADC_CREST_FACTOR_PROP
+#define Si2168B_DVBT_ADC_CREST_FACTOR_PROP_CODE 0x001203
+
+typedef struct { /* Si2168B_DVBT_ADC_CREST_FACTOR_PROP_struct */
+	u8  crest_factor;
+} Si2168B_DVBT_ADC_CREST_FACTOR_PROP_struct;
+
+/* DVBT_ADC_CREST_FACTOR property, CREST_FACTOR field definition (NO TITLE)*/
+#define Si2168B_DVBT_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB         0
+#define Si2168B_DVBT_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK        0xff
+#define Si2168B_DVBT_ADC_CREST_FACTOR_PROP_CREST_FACTOR_DEFAULT    130
+#endif /* Si2168B_DVBT_ADC_CREST_FACTOR_PROP */
+
+/* Si2168B DVBT_AFC_RANGE property definition */
+#define Si2168B_DVBT_AFC_RANGE_PROP 0x1202
+
+#ifdef Si2168B_DVBT_AFC_RANGE_PROP
+#define Si2168B_DVBT_AFC_RANGE_PROP_CODE 0x001202
+
+typedef struct { /* Si2168B_DVBT_AFC_RANGE_PROP_struct */
+	u16 range_khz;
+} Si2168B_DVBT_AFC_RANGE_PROP_struct;
+
+/* DVBT_AFC_RANGE property, RANGE_KHZ field definition (NO TITLE)*/
+#define Si2168B_DVBT_AFC_RANGE_PROP_RANGE_KHZ_LSB         0
+#define Si2168B_DVBT_AFC_RANGE_PROP_RANGE_KHZ_MASK        0xffff
+#define Si2168B_DVBT_AFC_RANGE_PROP_RANGE_KHZ_DEFAULT    550
+#endif /* Si2168B_DVBT_AFC_RANGE_PROP */
+
+/* Si2168B DVBT_HIERARCHY property definition */
+#define Si2168B_DVBT_HIERARCHY_PROP 0x1201
+
+#ifdef Si2168B_DVBT_HIERARCHY_PROP
+#define Si2168B_DVBT_HIERARCHY_PROP_CODE 0x001201
+
+typedef struct { /* Si2168B_DVBT_HIERARCHY_PROP_struct */
+	u8  stream;
+} Si2168B_DVBT_HIERARCHY_PROP_struct;
+
+/* DVBT_HIERARCHY property, STREAM field definition (NO TITLE)*/
+#define Si2168B_DVBT_HIERARCHY_PROP_STREAM_LSB         0
+#define Si2168B_DVBT_HIERARCHY_PROP_STREAM_MASK        0x01
+#define Si2168B_DVBT_HIERARCHY_PROP_STREAM_DEFAULT    0
+#define Si2168B_DVBT_HIERARCHY_PROP_STREAM_HP  0
+#define Si2168B_DVBT_HIERARCHY_PROP_STREAM_LP  1
+
+#endif /* Si2168B_DVBT_HIERARCHY_PROP */
+
+/* Si2168B MASTER_IEN property definition */
+#define Si2168B_MASTER_IEN_PROP 0x0401
+
+#ifdef Si2168B_MASTER_IEN_PROP
+#define Si2168B_MASTER_IEN_PROP_CODE 0x000401
+
+typedef struct { /* Si2168B_MASTER_IEN_PROP_struct */
+	u8  ctsien;
+	u8  ddien;
+	u8  errien;
+	u8  scanien;
+} Si2168B_MASTER_IEN_PROP_struct;
+
+/* MASTER_IEN property, CTSIEN field definition (NO TITLE)*/
+#define Si2168B_MASTER_IEN_PROP_CTSIEN_LSB         7
+#define Si2168B_MASTER_IEN_PROP_CTSIEN_MASK        0x01
+#define Si2168B_MASTER_IEN_PROP_CTSIEN_DEFAULT    0
+#define Si2168B_MASTER_IEN_PROP_CTSIEN_OFF  0
+#define Si2168B_MASTER_IEN_PROP_CTSIEN_ON   1
+
+/* MASTER_IEN property, DDIEN field definition (NO TITLE)*/
+#define Si2168B_MASTER_IEN_PROP_DDIEN_LSB         0
+#define Si2168B_MASTER_IEN_PROP_DDIEN_MASK        0x01
+#define Si2168B_MASTER_IEN_PROP_DDIEN_DEFAULT    0
+#define Si2168B_MASTER_IEN_PROP_DDIEN_OFF  0
+#define Si2168B_MASTER_IEN_PROP_DDIEN_ON   1
+
+/* MASTER_IEN property, ERRIEN field definition (NO TITLE)*/
+#define Si2168B_MASTER_IEN_PROP_ERRIEN_LSB         6
+#define Si2168B_MASTER_IEN_PROP_ERRIEN_MASK        0x01
+#define Si2168B_MASTER_IEN_PROP_ERRIEN_DEFAULT    0
+#define Si2168B_MASTER_IEN_PROP_ERRIEN_OFF  0
+#define Si2168B_MASTER_IEN_PROP_ERRIEN_ON   1
+
+/* MASTER_IEN property, SCANIEN field definition (NO TITLE)*/
+#define Si2168B_MASTER_IEN_PROP_SCANIEN_LSB         1
+#define Si2168B_MASTER_IEN_PROP_SCANIEN_MASK        0x01
+#define Si2168B_MASTER_IEN_PROP_SCANIEN_DEFAULT    0
+#define Si2168B_MASTER_IEN_PROP_SCANIEN_OFF  0
+#define Si2168B_MASTER_IEN_PROP_SCANIEN_ON   1
+
+#endif /* Si2168B_MASTER_IEN_PROP */
+
+/* Si2168B MCNS_ADC_CREST_FACTOR property definition */
+#define Si2168B_MCNS_ADC_CREST_FACTOR_PROP 0x1604
+
+#ifdef Si2168B_MCNS_ADC_CREST_FACTOR_PROP
+#define Si2168B_MCNS_ADC_CREST_FACTOR_PROP_CODE 0x001604
+
+typedef struct { /* Si2168B_MCNS_ADC_CREST_FACTOR_PROP_struct */
+	u8  crest_factor;
+} Si2168B_MCNS_ADC_CREST_FACTOR_PROP_struct;
+
+/* MCNS_ADC_CREST_FACTOR property, CREST_FACTOR field definition (NO TITLE)*/
+#define Si2168B_MCNS_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB         0
+#define Si2168B_MCNS_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK        0xff
+#define Si2168B_MCNS_ADC_CREST_FACTOR_PROP_CREST_FACTOR_DEFAULT    112
+#endif /* Si2168B_MCNS_ADC_CREST_FACTOR_PROP */
+
+/* Si2168B MCNS_AFC_RANGE property definition */
+#define Si2168B_MCNS_AFC_RANGE_PROP 0x1603
+
+#ifdef Si2168B_MCNS_AFC_RANGE_PROP
+#define Si2168B_MCNS_AFC_RANGE_PROP_CODE 0x001603
+
+typedef struct { /* Si2168B_MCNS_AFC_RANGE_PROP_struct */
+	u16 range_khz;
+} Si2168B_MCNS_AFC_RANGE_PROP_struct;
+
+/* MCNS_AFC_RANGE property, RANGE_KHZ field definition (NO TITLE)*/
+#define Si2168B_MCNS_AFC_RANGE_PROP_RANGE_KHZ_LSB         0
+#define Si2168B_MCNS_AFC_RANGE_PROP_RANGE_KHZ_MASK        0xffff
+#define Si2168B_MCNS_AFC_RANGE_PROP_RANGE_KHZ_DEFAULT    100
+#endif /* Si2168B_MCNS_AFC_RANGE_PROP */
+
+/* Si2168B MCNS_CONSTELLATION property definition */
+#define Si2168B_MCNS_CONSTELLATION_PROP 0x1601
+
+#ifdef Si2168B_MCNS_CONSTELLATION_PROP
+#define Si2168B_MCNS_CONSTELLATION_PROP_CODE 0x001601
+
+typedef struct { /* Si2168B_MCNS_CONSTELLATION_PROP_struct */
+	u8  constellation;
+} Si2168B_MCNS_CONSTELLATION_PROP_struct;
+
+/* MCNS_CONSTELLATION property, CONSTELLATION field definition (NO TITLE)*/
+#define Si2168B_MCNS_CONSTELLATION_PROP_CONSTELLATION_LSB         0
+#define Si2168B_MCNS_CONSTELLATION_PROP_CONSTELLATION_MASK        0x3f
+#define Si2168B_MCNS_CONSTELLATION_PROP_CONSTELLATION_DEFAULT    0
+#define Si2168B_MCNS_CONSTELLATION_PROP_CONSTELLATION_AUTO    0
+#define Si2168B_MCNS_CONSTELLATION_PROP_CONSTELLATION_QAM64   9
+#define Si2168B_MCNS_CONSTELLATION_PROP_CONSTELLATION_QAM256  11
+
+#endif /* Si2168B_MCNS_CONSTELLATION_PROP */
+
+/* Si2168B MCNS_SYMBOL_RATE property definition */
+#define Si2168B_MCNS_SYMBOL_RATE_PROP 0x1602
+
+#ifdef Si2168B_MCNS_SYMBOL_RATE_PROP
+#define Si2168B_MCNS_SYMBOL_RATE_PROP_CODE 0x001602
+
+typedef struct { /* Si2168B_MCNS_SYMBOL_RATE_PROP_struct */
+	u16 rate;
+} Si2168B_MCNS_SYMBOL_RATE_PROP_struct;
+
+/* MCNS_SYMBOL_RATE property, RATE field definition (NO TITLE)*/
+#define Si2168B_MCNS_SYMBOL_RATE_PROP_RATE_LSB         0
+#define Si2168B_MCNS_SYMBOL_RATE_PROP_RATE_MASK        0xffff
+#define Si2168B_MCNS_SYMBOL_RATE_PROP_RATE_DEFAULT    6900
+#endif /* Si2168B_MCNS_SYMBOL_RATE_PROP */
+
+/* Si2168B SCAN_FMAX property definition */
+#define Si2168B_SCAN_FMAX_PROP 0x0304
+
+#ifdef Si2168B_SCAN_FMAX_PROP
+#define Si2168B_SCAN_FMAX_PROP_CODE 0x000304
+
+typedef struct { /* Si2168B_SCAN_FMAX_PROP_struct */
+	u16 scan_fmax;
+} Si2168B_SCAN_FMAX_PROP_struct;
+
+/* SCAN_FMAX property, SCAN_FMAX field definition (NO TITLE)*/
+#define Si2168B_SCAN_FMAX_PROP_SCAN_FMAX_LSB         0
+#define Si2168B_SCAN_FMAX_PROP_SCAN_FMAX_MASK        0xffff
+#define Si2168B_SCAN_FMAX_PROP_SCAN_FMAX_DEFAULT    0
+#endif /* Si2168B_SCAN_FMAX_PROP */
+
+/* Si2168B SCAN_FMIN property definition */
+#define Si2168B_SCAN_FMIN_PROP 0x0303
+
+#ifdef Si2168B_SCAN_FMIN_PROP
+#define Si2168B_SCAN_FMIN_PROP_CODE 0x000303
+
+typedef struct { /* Si2168B_SCAN_FMIN_PROP_struct */
+	u16 scan_fmin;
+} Si2168B_SCAN_FMIN_PROP_struct;
+
+/* SCAN_FMIN property, SCAN_FMIN field definition (NO TITLE)*/
+#define Si2168B_SCAN_FMIN_PROP_SCAN_FMIN_LSB         0
+#define Si2168B_SCAN_FMIN_PROP_SCAN_FMIN_MASK        0xffff
+#define Si2168B_SCAN_FMIN_PROP_SCAN_FMIN_DEFAULT    0
+#endif /* Si2168B_SCAN_FMIN_PROP */
+
+/* Si2168B SCAN_IEN property definition */
+#define Si2168B_SCAN_IEN_PROP 0x0308
+
+#ifdef Si2168B_SCAN_IEN_PROP
+#define Si2168B_SCAN_IEN_PROP_CODE 0x000308
+
+typedef struct { /* Si2168B_SCAN_IEN_PROP_struct */
+	u8  buzien;
+	u8  reqien;
+} Si2168B_SCAN_IEN_PROP_struct;
+
+/* SCAN_IEN property, BUZIEN field definition (NO TITLE)*/
+#define Si2168B_SCAN_IEN_PROP_BUZIEN_LSB         0
+#define Si2168B_SCAN_IEN_PROP_BUZIEN_MASK        0x01
+#define Si2168B_SCAN_IEN_PROP_BUZIEN_DEFAULT    0
+#define Si2168B_SCAN_IEN_PROP_BUZIEN_DISABLE  0
+#define Si2168B_SCAN_IEN_PROP_BUZIEN_ENABLE   1
+
+/* SCAN_IEN property, REQIEN field definition (NO TITLE)*/
+#define Si2168B_SCAN_IEN_PROP_REQIEN_LSB         1
+#define Si2168B_SCAN_IEN_PROP_REQIEN_MASK        0x01
+#define Si2168B_SCAN_IEN_PROP_REQIEN_DEFAULT    0
+#define Si2168B_SCAN_IEN_PROP_REQIEN_DISABLE  0
+#define Si2168B_SCAN_IEN_PROP_REQIEN_ENABLE   1
+
+#endif /* Si2168B_SCAN_IEN_PROP */
+
+/* Si2168B SCAN_INT_SENSE property definition */
+#define Si2168B_SCAN_INT_SENSE_PROP 0x0307
+
+#ifdef Si2168B_SCAN_INT_SENSE_PROP
+#define Si2168B_SCAN_INT_SENSE_PROP_CODE 0x000307
+
+typedef struct { /* Si2168B_SCAN_INT_SENSE_PROP_struct */
+	u8  buznegen;
+	u8  buzposen;
+	u8  reqnegen;
+	u8  reqposen;
+} Si2168B_SCAN_INT_SENSE_PROP_struct;
+
+/* SCAN_INT_SENSE property, BUZNEGEN field definition (NO TITLE)*/
+#define Si2168B_SCAN_INT_SENSE_PROP_BUZNEGEN_LSB         0
+#define Si2168B_SCAN_INT_SENSE_PROP_BUZNEGEN_MASK        0x01
+#define Si2168B_SCAN_INT_SENSE_PROP_BUZNEGEN_DEFAULT    1
+#define Si2168B_SCAN_INT_SENSE_PROP_BUZNEGEN_DISABLE  0
+#define Si2168B_SCAN_INT_SENSE_PROP_BUZNEGEN_ENABLE   1
+
+/* SCAN_INT_SENSE property, BUZPOSEN field definition (NO TITLE)*/
+#define Si2168B_SCAN_INT_SENSE_PROP_BUZPOSEN_LSB         8
+#define Si2168B_SCAN_INT_SENSE_PROP_BUZPOSEN_MASK        0x01
+#define Si2168B_SCAN_INT_SENSE_PROP_BUZPOSEN_DEFAULT    0
+#define Si2168B_SCAN_INT_SENSE_PROP_BUZPOSEN_DISABLE  0
+#define Si2168B_SCAN_INT_SENSE_PROP_BUZPOSEN_ENABLE   1
+
+/* SCAN_INT_SENSE property, REQNEGEN field definition (NO TITLE)*/
+#define Si2168B_SCAN_INT_SENSE_PROP_REQNEGEN_LSB         1
+#define Si2168B_SCAN_INT_SENSE_PROP_REQNEGEN_MASK        0x01
+#define Si2168B_SCAN_INT_SENSE_PROP_REQNEGEN_DEFAULT    0
+#define Si2168B_SCAN_INT_SENSE_PROP_REQNEGEN_DISABLE  0
+#define Si2168B_SCAN_INT_SENSE_PROP_REQNEGEN_ENABLE   1
+
+/* SCAN_INT_SENSE property, REQPOSEN field definition (NO TITLE)*/
+#define Si2168B_SCAN_INT_SENSE_PROP_REQPOSEN_LSB         9
+#define Si2168B_SCAN_INT_SENSE_PROP_REQPOSEN_MASK        0x01
+#define Si2168B_SCAN_INT_SENSE_PROP_REQPOSEN_DEFAULT    1
+#define Si2168B_SCAN_INT_SENSE_PROP_REQPOSEN_DISABLE  0
+#define Si2168B_SCAN_INT_SENSE_PROP_REQPOSEN_ENABLE   1
+
+#endif /* Si2168B_SCAN_INT_SENSE_PROP */
+
+/* Si2168B SCAN_SYMB_RATE_MAX property definition */
+#define Si2168B_SCAN_SYMB_RATE_MAX_PROP 0x0306
+
+#ifdef Si2168B_SCAN_SYMB_RATE_MAX_PROP
+#define Si2168B_SCAN_SYMB_RATE_MAX_PROP_CODE 0x000306
+
+typedef struct { /* Si2168B_SCAN_SYMB_RATE_MAX_PROP_struct */
+	u16 scan_symb_rate_max;
+} Si2168B_SCAN_SYMB_RATE_MAX_PROP_struct;
+
+/* SCAN_SYMB_RATE_MAX property, SCAN_SYMB_RATE_MAX field definition (NO TITLE)*/
+#define Si2168B_SCAN_SYMB_RATE_MAX_PROP_SCAN_SYMB_RATE_MAX_LSB         0
+#define Si2168B_SCAN_SYMB_RATE_MAX_PROP_SCAN_SYMB_RATE_MAX_MASK        0xffff
+#define Si2168B_SCAN_SYMB_RATE_MAX_PROP_SCAN_SYMB_RATE_MAX_DEFAULT    0
+#endif /* Si2168B_SCAN_SYMB_RATE_MAX_PROP */
+
+/* Si2168B SCAN_SYMB_RATE_MIN property definition */
+#define Si2168B_SCAN_SYMB_RATE_MIN_PROP 0x0305
+
+#ifdef Si2168B_SCAN_SYMB_RATE_MIN_PROP
+#define Si2168B_SCAN_SYMB_RATE_MIN_PROP_CODE 0x000305
+
+typedef struct { /* Si2168B_SCAN_SYMB_RATE_MIN_PROP_struct */
+	u16 scan_symb_rate_min;
+} Si2168B_SCAN_SYMB_RATE_MIN_PROP_struct;
+
+/* SCAN_SYMB_RATE_MIN property, SCAN_SYMB_RATE_MIN field definition (NO TITLE)*/
+#define Si2168B_SCAN_SYMB_RATE_MIN_PROP_SCAN_SYMB_RATE_MIN_LSB         0
+#define Si2168B_SCAN_SYMB_RATE_MIN_PROP_SCAN_SYMB_RATE_MIN_MASK        0xffff
+#define Si2168B_SCAN_SYMB_RATE_MIN_PROP_SCAN_SYMB_RATE_MIN_DEFAULT    0
+#endif /* Si2168B_SCAN_SYMB_RATE_MIN_PROP */
+
+/* Si2168B SCAN_TER_CONFIG property definition */
+#define Si2168B_SCAN_TER_CONFIG_PROP 0x0301
+
+#ifdef Si2168B_SCAN_TER_CONFIG_PROP
+#define Si2168B_SCAN_TER_CONFIG_PROP_CODE 0x000301
+
+typedef struct { /* Si2168B_SCAN_TER_CONFIG_PROP_struct */
+	u8  analog_bw;
+	u8  mode;
+	u8  scan_debug;
+	u8  search_analog;
+} Si2168B_SCAN_TER_CONFIG_PROP_struct;
+
+/* SCAN_TER_CONFIG property, ANALOG_BW field definition (NO TITLE)*/
+#define Si2168B_SCAN_TER_CONFIG_PROP_ANALOG_BW_LSB         2
+#define Si2168B_SCAN_TER_CONFIG_PROP_ANALOG_BW_MASK        0x03
+#define Si2168B_SCAN_TER_CONFIG_PROP_ANALOG_BW_DEFAULT    3
+#define Si2168B_SCAN_TER_CONFIG_PROP_ANALOG_BW_6MHZ  1
+#define Si2168B_SCAN_TER_CONFIG_PROP_ANALOG_BW_7MHZ  2
+#define Si2168B_SCAN_TER_CONFIG_PROP_ANALOG_BW_8MHZ  3
+
+/* SCAN_TER_CONFIG property, MODE field definition (NO TITLE)*/
+#define Si2168B_SCAN_TER_CONFIG_PROP_MODE_LSB         0
+#define Si2168B_SCAN_TER_CONFIG_PROP_MODE_MASK        0x03
+#define Si2168B_SCAN_TER_CONFIG_PROP_MODE_DEFAULT    0
+#define Si2168B_SCAN_TER_CONFIG_PROP_MODE_BLIND_SCAN    0
+#define Si2168B_SCAN_TER_CONFIG_PROP_MODE_MAPPING_SCAN  1
+#define Si2168B_SCAN_TER_CONFIG_PROP_MODE_BLIND_LOCK    2
+
+/* SCAN_TER_CONFIG property, SCAN_DEBUG field definition (NO TITLE)*/
+#define Si2168B_SCAN_TER_CONFIG_PROP_SCAN_DEBUG_LSB         12
+#define Si2168B_SCAN_TER_CONFIG_PROP_SCAN_DEBUG_MASK        0x0f
+#define Si2168B_SCAN_TER_CONFIG_PROP_SCAN_DEBUG_DEFAULT    0
+/* SCAN_TER_CONFIG property, SEARCH_ANALOG field definition (NO TITLE)*/
+#define Si2168B_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_LSB         4
+#define Si2168B_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_MASK        0x01
+#define Si2168B_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_DEFAULT    0
+#define Si2168B_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_DISABLE  0
+#define Si2168B_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_ENABLE   1
+
+#endif /* Si2168B_SCAN_TER_CONFIG_PROP */
+
+/* STATUS fields definition */
+/* STATUS, DDINT field definition (address 0, size 1, lsb 0, unsigned)*/
+#define Si2168B_STATUS_DDINT_LSB         0
+#define Si2168B_STATUS_DDINT_MASK        0x01
+#define Si2168B_STATUS_DDINT_NOT_TRIGGERED  0
+#define Si2168B_STATUS_DDINT_TRIGGERED      1
+/* STATUS, SCANINT field definition (address 0, size 1, lsb 1, unsigned)*/
+#define Si2168B_STATUS_SCANINT_LSB         1
+#define Si2168B_STATUS_SCANINT_MASK        0x01
+#define Si2168B_STATUS_SCANINT_NOT_TRIGGERED  0
+#define Si2168B_STATUS_SCANINT_TRIGGERED      1
+/* STATUS, ERR field definition (address 0, size 1, lsb 6, unsigned)*/
+#define Si2168B_STATUS_ERR_LSB         6
+#define Si2168B_STATUS_ERR_MASK        0x01
+#define Si2168B_STATUS_ERR_ERROR     1
+#define Si2168B_STATUS_ERR_NO_ERROR  0
+/* STATUS, CTS field definition (address 0, size 1, lsb 7, unsigned)*/
+#define Si2168B_STATUS_CTS_LSB         7
+#define Si2168B_STATUS_CTS_MASK        0x01
+#define Si2168B_STATUS_CTS_COMPLETED  1
+#define Si2168B_STATUS_CTS_WAIT       0
+
+/* Si2168B_CONFIG_CLKIO command definition */
+#define Si2168B_CONFIG_CLKIO_CMD 0x18
+
+#ifdef Si2168B_CONFIG_CLKIO_CMD
+#define Si2168B_CONFIG_CLKIO_CMD_CODE 0x010018
+
+typedef struct { /* Si2168B_CONFIG_CLKIO_CMD_struct */
+	u8  output;
+	u8  pre_driver_str;
+	u8  driver_str;
+} Si2168B_CONFIG_CLKIO_CMD_struct;
+
+typedef struct { /* Si2168B_CONFIG_CLKIO_CMD_REPLY_struct */
+	u8  mode;
+	u8  pre_driver_str;
+	u8  driver_str;
+} Si2168B_CONFIG_CLKIO_CMD_REPLY_struct;
+
+/* CONFIG_CLKIO command, OUTPUT field definition (address 1,size 2, lsb 0, unsigned) */
+#define Si2168B_CONFIG_CLKIO_CMD_OUTPUT_LSB         0
+#define Si2168B_CONFIG_CLKIO_CMD_OUTPUT_MASK        0x03
+#define Si2168B_CONFIG_CLKIO_CMD_OUTPUT_MIN         0
+#define Si2168B_CONFIG_CLKIO_CMD_OUTPUT_MAX         2
+#define Si2168B_CONFIG_CLKIO_CMD_OUTPUT_NO_CHANGE  0
+#define Si2168B_CONFIG_CLKIO_CMD_OUTPUT_OFF        2
+#define Si2168B_CONFIG_CLKIO_CMD_OUTPUT_ON         1
+/* CONFIG_CLKIO command, PRE_DRIVER_STR field definition (address 1,size 2, lsb 2, unsigned) */
+#define Si2168B_CONFIG_CLKIO_CMD_PRE_DRIVER_STR_LSB         2
+#define Si2168B_CONFIG_CLKIO_CMD_PRE_DRIVER_STR_MASK        0x03
+#define Si2168B_CONFIG_CLKIO_CMD_PRE_DRIVER_STR_MIN         0
+#define Si2168B_CONFIG_CLKIO_CMD_PRE_DRIVER_STR_MAX         3
+#define Si2168B_CONFIG_CLKIO_CMD_PRE_DRIVER_STR_PRE_DRIVER_MIN  0
+#define Si2168B_CONFIG_CLKIO_CMD_PRE_DRIVER_STR_PRE_DRIVER_MAX  3
+/* CONFIG_CLKIO command, DRIVER_STR field definition (address 1,size 4, lsb 4, unsigned) */
+#define Si2168B_CONFIG_CLKIO_CMD_DRIVER_STR_LSB         4
+#define Si2168B_CONFIG_CLKIO_CMD_DRIVER_STR_MASK        0x0f
+#define Si2168B_CONFIG_CLKIO_CMD_DRIVER_STR_MIN         0
+#define Si2168B_CONFIG_CLKIO_CMD_DRIVER_STR_MAX         15
+#define Si2168B_CONFIG_CLKIO_CMD_DRIVER_STR_DRIVER_MIN  0
+#define Si2168B_CONFIG_CLKIO_CMD_DRIVER_STR_DRIVER_MAX  15
+/* CONFIG_CLKIO command, MODE field definition (address 1, size 2, lsb 0, unsigned)*/
+#define Si2168B_CONFIG_CLKIO_RESPONSE_MODE_LSB         0
+#define Si2168B_CONFIG_CLKIO_RESPONSE_MODE_MASK        0x03
+#define Si2168B_CONFIG_CLKIO_RESPONSE_MODE_CLK_INPUT   2
+#define Si2168B_CONFIG_CLKIO_RESPONSE_MODE_CLK_OUTPUT  1
+#define Si2168B_CONFIG_CLKIO_RESPONSE_MODE_UNUSED      0
+/* CONFIG_CLKIO command, PRE_DRIVER_STR field definition (address 2, size 8, lsb 0, unsigned)*/
+#define Si2168B_CONFIG_CLKIO_RESPONSE_PRE_DRIVER_STR_LSB         0
+#define Si2168B_CONFIG_CLKIO_RESPONSE_PRE_DRIVER_STR_MASK        0xff
+/* CONFIG_CLKIO command, DRIVER_STR field definition (address 3, size 8, lsb 0, unsigned)*/
+#define Si2168B_CONFIG_CLKIO_RESPONSE_DRIVER_STR_LSB         0
+#define Si2168B_CONFIG_CLKIO_RESPONSE_DRIVER_STR_MASK        0xff
+
+#endif /* Si2168B_CONFIG_CLKIO_CMD */
+
+/* Si2168B_CONFIG_PINS command definition */
+#define Si2168B_CONFIG_PINS_CMD 0x12
+
+#ifdef Si2168B_CONFIG_PINS_CMD
+#define Si2168B_CONFIG_PINS_CMD_CODE 0x010012
+
+typedef struct { /* Si2168B_CONFIG_PINS_CMD_struct */
+	u8  gpio0_mode;
+	u8  gpio0_read;
+	u8  gpio1_mode;
+	u8  gpio1_read;
+} Si2168B_CONFIG_PINS_CMD_struct;
+
+typedef struct { /* Si2168B_CONFIG_PINS_CMD_REPLY_struct */
+	u8  gpio0_mode;
+	u8  gpio0_state;
+	u8  gpio1_mode;
+	u8  gpio1_state;
+}  Si2168B_CONFIG_PINS_CMD_REPLY_struct;
+
+/* CONFIG_PINS command, GPIO0_MODE field definition (address 1,size 7, lsb 0, unsigned) */
+#define Si2168B_CONFIG_PINS_CMD_GPIO0_MODE_LSB         0
+#define Si2168B_CONFIG_PINS_CMD_GPIO0_MODE_MASK        0x7f
+#define Si2168B_CONFIG_PINS_CMD_GPIO0_MODE_MIN         0
+#define Si2168B_CONFIG_PINS_CMD_GPIO0_MODE_MAX         8
+#define Si2168B_CONFIG_PINS_CMD_GPIO0_MODE_DISABLE    1
+#define Si2168B_CONFIG_PINS_CMD_GPIO0_MODE_DRIVE_0    2
+#define Si2168B_CONFIG_PINS_CMD_GPIO0_MODE_DRIVE_1    3
+#define Si2168B_CONFIG_PINS_CMD_GPIO0_MODE_HW_LOCK    8
+#define Si2168B_CONFIG_PINS_CMD_GPIO0_MODE_INT_FLAG   7
+#define Si2168B_CONFIG_PINS_CMD_GPIO0_MODE_NO_CHANGE  0
+#define Si2168B_CONFIG_PINS_CMD_GPIO0_MODE_TS_ERR     4
+/* CONFIG_PINS command, GPIO0_READ field definition (address 1,size 1, lsb 7, unsigned) */
+#define Si2168B_CONFIG_PINS_CMD_GPIO0_READ_LSB         7
+#define Si2168B_CONFIG_PINS_CMD_GPIO0_READ_MASK        0x01
+#define Si2168B_CONFIG_PINS_CMD_GPIO0_READ_MIN         0
+#define Si2168B_CONFIG_PINS_CMD_GPIO0_READ_MAX         1
+#define Si2168B_CONFIG_PINS_CMD_GPIO0_READ_DO_NOT_READ  0
+#define Si2168B_CONFIG_PINS_CMD_GPIO0_READ_READ         1
+/* CONFIG_PINS command, GPIO1_MODE field definition (address 2,size 7, lsb 0, unsigned) */
+#define Si2168B_CONFIG_PINS_CMD_GPIO1_MODE_LSB         0
+#define Si2168B_CONFIG_PINS_CMD_GPIO1_MODE_MASK        0x7f
+#define Si2168B_CONFIG_PINS_CMD_GPIO1_MODE_MIN         0
+#define Si2168B_CONFIG_PINS_CMD_GPIO1_MODE_MAX         8
+#define Si2168B_CONFIG_PINS_CMD_GPIO1_MODE_DISABLE    1
+#define Si2168B_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_0    2
+#define Si2168B_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_1    3
+#define Si2168B_CONFIG_PINS_CMD_GPIO1_MODE_HW_LOCK    8
+#define Si2168B_CONFIG_PINS_CMD_GPIO1_MODE_INT_FLAG   7
+#define Si2168B_CONFIG_PINS_CMD_GPIO1_MODE_NO_CHANGE  0
+#define Si2168B_CONFIG_PINS_CMD_GPIO1_MODE_TS_ERR     4
+/* CONFIG_PINS command, GPIO1_READ field definition (address 2,size 1, lsb 7, unsigned) */
+#define Si2168B_CONFIG_PINS_CMD_GPIO1_READ_LSB         7
+#define Si2168B_CONFIG_PINS_CMD_GPIO1_READ_MASK        0x01
+#define Si2168B_CONFIG_PINS_CMD_GPIO1_READ_MIN         0
+#define Si2168B_CONFIG_PINS_CMD_GPIO1_READ_MAX         1
+#define Si2168B_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ  0
+#define Si2168B_CONFIG_PINS_CMD_GPIO1_READ_READ         1
+/* CONFIG_PINS command, GPIO0_MODE field definition (address 1, size 7, lsb 0, unsigned)*/
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO0_MODE_LSB         0
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO0_MODE_MASK        0x7f
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO0_MODE_DISABLE   1
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO0_MODE_DRIVE_0   2
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO0_MODE_DRIVE_1   3
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO0_MODE_HW_LOCK   8
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO0_MODE_INT_FLAG  7
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO0_MODE_TS_ERR    4
+/* CONFIG_PINS command, GPIO0_STATE field definition (address 1, size 1, lsb 7, unsigned)*/
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO0_STATE_LSB         7
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO0_STATE_MASK        0x01
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO0_STATE_READ_0  0
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO0_STATE_READ_1  1
+/* CONFIG_PINS command, GPIO1_MODE field definition (address 2, size 7, lsb 0, unsigned)*/
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO1_MODE_LSB         0
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO1_MODE_MASK        0x7f
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO1_MODE_DISABLE   1
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO1_MODE_DRIVE_0   2
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO1_MODE_DRIVE_1   3
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO1_MODE_HW_LOCK   8
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO1_MODE_INT_FLAG  7
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO1_MODE_TS_ERR    4
+/* CONFIG_PINS command, GPIO1_STATE field definition (address 2, size 1, lsb 7, unsigned)*/
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO1_STATE_LSB         7
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO1_STATE_MASK        0x01
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO1_STATE_READ_0  0
+#define Si2168B_CONFIG_PINS_RESPONSE_GPIO1_STATE_READ_1  1
+
+#endif /* Si2168B_CONFIG_PINS_CMD */
+
+/* Si2168B_DD_BER command definition */
+#define Si2168B_DD_BER_CMD 0x82
+
+#ifdef Si2168B_DD_BER_CMD
+#define Si2168B_DD_BER_CMD_CODE 0x010082
+
+typedef struct { /* Si2168B_DD_BER_CMD_struct */
+	u8  rst;
+} Si2168B_DD_BER_CMD_struct;
+
+typedef struct { /* Si2168B_DD_BER_CMD_REPLY_struct */
+	u8  exp;
+	u8  mant;
+}  Si2168B_DD_BER_CMD_REPLY_struct;
+
+/* DD_BER command, RST field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2168B_DD_BER_CMD_RST_LSB         0
+#define Si2168B_DD_BER_CMD_RST_MASK        0x01
+#define Si2168B_DD_BER_CMD_RST_MIN         0
+#define Si2168B_DD_BER_CMD_RST_MAX         1
+#define Si2168B_DD_BER_CMD_RST_CLEAR  1
+#define Si2168B_DD_BER_CMD_RST_RUN    0
+/* DD_BER command, EXP field definition (address 1, size 4, lsb 0, unsigned)*/
+#define Si2168B_DD_BER_RESPONSE_EXP_LSB         0
+#define Si2168B_DD_BER_RESPONSE_EXP_MASK        0x0f
+#define Si2168B_DD_BER_RESPONSE_EXP_EXP_MIN  0
+#define Si2168B_DD_BER_RESPONSE_EXP_EXP_MAX  8
+/* DD_BER command, MANT field definition (address 2, size 8, lsb 0, unsigned)*/
+#define Si2168B_DD_BER_RESPONSE_MANT_LSB         0
+#define Si2168B_DD_BER_RESPONSE_MANT_MASK        0xff
+#define Si2168B_DD_BER_RESPONSE_MANT_MANT_MIN  0
+#define Si2168B_DD_BER_RESPONSE_MANT_MANT_MAX  99
+
+#endif /* Si2168B_DD_BER_CMD */
+
+/* Si2168B_DD_CBER command definition */
+#define Si2168B_DD_CBER_CMD 0x81
+
+#ifdef Si2168B_DD_CBER_CMD
+#define Si2168B_DD_CBER_CMD_CODE 0x010081
+
+typedef struct { /* Si2168B_DD_CBER_CMD_struct */
+	u8  rst;
+} Si2168B_DD_CBER_CMD_struct;
+
+typedef struct { /* Si2168B_DD_CBER_CMD_REPLY_struct */
+	u8  exp;
+	u8  mant;
+}  Si2168B_DD_CBER_CMD_REPLY_struct;
+
+/* DD_CBER command, RST field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2168B_DD_CBER_CMD_RST_LSB         0
+#define Si2168B_DD_CBER_CMD_RST_MASK        0x01
+#define Si2168B_DD_CBER_CMD_RST_MIN         0
+#define Si2168B_DD_CBER_CMD_RST_MAX         1
+#define Si2168B_DD_CBER_CMD_RST_CLEAR  1
+#define Si2168B_DD_CBER_CMD_RST_RUN    0
+/* DD_CBER command, EXP field definition (address 1, size 4, lsb 0, unsigned)*/
+#define Si2168B_DD_CBER_RESPONSE_EXP_LSB         0
+#define Si2168B_DD_CBER_RESPONSE_EXP_MASK        0x0f
+#define Si2168B_DD_CBER_RESPONSE_EXP_EXP_MIN  0
+#define Si2168B_DD_CBER_RESPONSE_EXP_EXP_MAX  8
+/* DD_CBER command, MANT field definition (address 2, size 8, lsb 0, unsigned)*/
+#define Si2168B_DD_CBER_RESPONSE_MANT_LSB         0
+#define Si2168B_DD_CBER_RESPONSE_MANT_MASK        0xff
+#define Si2168B_DD_CBER_RESPONSE_MANT_MANT_MIN  0
+#define Si2168B_DD_CBER_RESPONSE_MANT_MANT_MAX  99
+
+#endif /* Si2168B_DD_CBER_CMD */
+
+/* Si2168B_DD_EXT_AGC_TER command definition */
+#define Si2168B_DD_EXT_AGC_TER_CMD 0x89
+
+#ifdef Si2168B_DD_EXT_AGC_TER_CMD
+#define Si2168B_DD_EXT_AGC_TER_CMD_CODE 0x010089
+
+typedef struct { /* Si2168B_DD_EXT_AGC_TER_CMD_struct */
+	u8  agc_1_mode;
+	u8  agc_1_inv;
+	u8  agc_2_mode;
+	u8  agc_2_inv;
+	u8  agc_1_kloop;
+	u8  agc_2_kloop;
+	u8  agc_1_min;
+	u8  agc_2_min;
+} Si2168B_DD_EXT_AGC_TER_CMD_struct;
+
+typedef struct { /* Si2168B_DD_EXT_AGC_TER_CMD_REPLY_struct */
+	u8  agc_1_level;
+	u8  agc_2_level;
+}  Si2168B_DD_EXT_AGC_TER_CMD_REPLY_struct;
+
+/* DD_EXT_AGC_TER command, AGC_1_MODE field definition (address 1,size 3, lsb 0, unsigned) */
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MODE_LSB         0
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MASK        0x07
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MIN         0
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MAX         5
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MP_A       2
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MP_B       3
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MP_C       4
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MP_D       5
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MODE_NOT_USED   1
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MODE_NO_CHANGE  0
+/* DD_EXT_AGC_TER command, AGC_1_INV field definition (address 1,size 1, lsb 3, unsigned) */
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_INV_LSB         3
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_INV_MASK        0x01
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_INV_MIN         0
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_INV_MAX         1
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_INV_INVERTED      1
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_INV_NOT_INVERTED  0
+/* DD_EXT_AGC_TER command, AGC_2_MODE field definition (address 1,size 3, lsb 4, unsigned) */
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MODE_LSB         4
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MASK        0x07
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MIN         0
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MAX         5
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MP_A       2
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MP_B       3
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MP_C       4
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MP_D       5
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MODE_NOT_USED   1
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MODE_NO_CHANGE  0
+/* DD_EXT_AGC_TER command, AGC_2_INV field definition (address 1,size 1, lsb 7, unsigned) */
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_INV_LSB         7
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_INV_MASK        0x01
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_INV_MIN         0
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_INV_MAX         1
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_INV_INVERTED      1
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_INV_NOT_INVERTED  0
+/* DD_EXT_AGC_TER command, AGC_1_KLOOP field definition (address 2,size 5, lsb 0, unsigned) */
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_LSB         0
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_MASK        0x1f
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_MIN         6
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_MAX         20
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_AGC_1_KLOOP_MIN  6
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_AGC_1_KLOOP_MAX  20
+/* DD_EXT_AGC_TER command, AGC_2_KLOOP field definition (address 3,size 5, lsb 0, unsigned) */
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_LSB         0
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_MASK        0x1f
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_MIN         6
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_MAX         20
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_AGC_2_KLOOP_MIN  6
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_AGC_2_KLOOP_MAX  20
+/* DD_EXT_AGC_TER command, AGC_1_MIN field definition (address 4,size 8, lsb 0, unsigned) */
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MIN_LSB         0
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MIN_MASK        0xff
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MIN_MIN         0
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MIN_MAX         255
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MIN_AGC_1_MIN_MIN  0
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_1_MIN_AGC_1_MIN_MAX  255
+/* DD_EXT_AGC_TER command, AGC_2_MIN field definition (address 5,size 8, lsb 0, unsigned) */
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MIN_LSB         0
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MIN_MASK        0xff
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MIN_MIN         0
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MIN_MAX         255
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MIN_AGC_2_MIN_MIN  0
+#define Si2168B_DD_EXT_AGC_TER_CMD_AGC_2_MIN_AGC_2_MIN_MAX  255
+/* DD_EXT_AGC_TER command, AGC_1_LEVEL field definition (address 1, size 8, lsb 0, unsigned)*/
+#define Si2168B_DD_EXT_AGC_TER_RESPONSE_AGC_1_LEVEL_LSB         0
+#define Si2168B_DD_EXT_AGC_TER_RESPONSE_AGC_1_LEVEL_MASK        0xff
+/* DD_EXT_AGC_TER command, AGC_2_LEVEL field definition (address 2, size 8, lsb 0, unsigned)*/
+#define Si2168B_DD_EXT_AGC_TER_RESPONSE_AGC_2_LEVEL_LSB         0
+#define Si2168B_DD_EXT_AGC_TER_RESPONSE_AGC_2_LEVEL_MASK        0xff
+
+#endif /* Si2168B_DD_EXT_AGC_TER_CMD */
+
+/* Si2168B_DD_FER command definition */
+#define Si2168B_DD_FER_CMD 0x86
+
+#ifdef Si2168B_DD_FER_CMD
+#define Si2168B_DD_FER_CMD_CODE 0x010086
+
+typedef struct { /* Si2168B_DD_FER_CMD_struct */
+	u8  rst;
+} Si2168B_DD_FER_CMD_struct;
+
+typedef struct { /* Si2168B_DD_FER_CMD_REPLY_struct */
+	u8  exp;
+	u8  mant;
+}  Si2168B_DD_FER_CMD_REPLY_struct;
+
+/* DD_FER command, RST field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2168B_DD_FER_CMD_RST_LSB         0
+#define Si2168B_DD_FER_CMD_RST_MASK        0x01
+#define Si2168B_DD_FER_CMD_RST_MIN         0
+#define Si2168B_DD_FER_CMD_RST_MAX         1
+#define Si2168B_DD_FER_CMD_RST_CLEAR  1
+#define Si2168B_DD_FER_CMD_RST_RUN    0
+/* DD_FER command, EXP field definition (address 1, size 4, lsb 0, unsigned)*/
+#define Si2168B_DD_FER_RESPONSE_EXP_LSB         0
+#define Si2168B_DD_FER_RESPONSE_EXP_MASK        0x0f
+#define Si2168B_DD_FER_RESPONSE_EXP_EXP_MIN  0
+#define Si2168B_DD_FER_RESPONSE_EXP_EXP_MAX  8
+/* DD_FER command, MANT field definition (address 2, size 8, lsb 0, unsigned)*/
+#define Si2168B_DD_FER_RESPONSE_MANT_LSB         0
+#define Si2168B_DD_FER_RESPONSE_MANT_MASK        0xff
+#define Si2168B_DD_FER_RESPONSE_MANT_MANT_MIN  0
+#define Si2168B_DD_FER_RESPONSE_MANT_MANT_MAX  99
+
+#endif /* Si2168B_DD_FER_CMD */
+
+/* Si2168B_DD_GET_REG command definition */
+#define Si2168B_DD_GET_REG_CMD 0x8f
+
+#ifdef Si2168B_DD_GET_REG_CMD
+#define Si2168B_DD_GET_REG_CMD_CODE 0x01008f
+
+typedef struct { /* Si2168B_DD_GET_REG_CMD_struct */
+	u8  reg_code_lsb;
+	u8  reg_code_mid;
+	u8  reg_code_msb;
+} Si2168B_DD_GET_REG_CMD_struct;
+
+
+typedef struct { /* Si2168B_DD_GET_REG_CMD_REPLY_struct */
+	u8  data1;
+	u8  data2;
+	u8  data3;
+	u8  data4;
+}  Si2168B_DD_GET_REG_CMD_REPLY_struct;
+
+/* DD_GET_REG command, REG_CODE_LSB field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2168B_DD_GET_REG_CMD_REG_CODE_LSB_LSB         0
+#define Si2168B_DD_GET_REG_CMD_REG_CODE_LSB_MASK        0xff
+#define Si2168B_DD_GET_REG_CMD_REG_CODE_LSB_MIN         0
+#define Si2168B_DD_GET_REG_CMD_REG_CODE_LSB_MAX         255
+#define Si2168B_DD_GET_REG_CMD_REG_CODE_LSB_REG_CODE_LSB_MIN  0
+#define Si2168B_DD_GET_REG_CMD_REG_CODE_LSB_REG_CODE_LSB_MAX  255
+/* DD_GET_REG command, REG_CODE_MID field definition (address 2,size 8, lsb 0, unsigned) */
+#define Si2168B_DD_GET_REG_CMD_REG_CODE_MID_LSB         0
+#define Si2168B_DD_GET_REG_CMD_REG_CODE_MID_MASK        0xff
+#define Si2168B_DD_GET_REG_CMD_REG_CODE_MID_MIN         0
+#define Si2168B_DD_GET_REG_CMD_REG_CODE_MID_MAX         255
+#define Si2168B_DD_GET_REG_CMD_REG_CODE_MID_REG_CODE_MID_MIN  0
+#define Si2168B_DD_GET_REG_CMD_REG_CODE_MID_REG_CODE_MID_MAX  255
+/* DD_GET_REG command, REG_CODE_MSB field definition (address 3,size 8, lsb 0, unsigned) */
+#define Si2168B_DD_GET_REG_CMD_REG_CODE_MSB_LSB         0
+#define Si2168B_DD_GET_REG_CMD_REG_CODE_MSB_MASK        0xff
+#define Si2168B_DD_GET_REG_CMD_REG_CODE_MSB_MIN         0
+#define Si2168B_DD_GET_REG_CMD_REG_CODE_MSB_MAX         255
+#define Si2168B_DD_GET_REG_CMD_REG_CODE_MSB_REG_CODE_MSB_MIN  0
+#define Si2168B_DD_GET_REG_CMD_REG_CODE_MSB_REG_CODE_MSB_MAX  255
+/* DD_GET_REG command, DATA1 field definition (address 1, size 8, lsb 0, unsigned)*/
+#define Si2168B_DD_GET_REG_RESPONSE_DATA1_LSB         0
+#define Si2168B_DD_GET_REG_RESPONSE_DATA1_MASK        0xff
+#define Si2168B_DD_GET_REG_RESPONSE_DATA1_DATA1_MIN  0
+#define Si2168B_DD_GET_REG_RESPONSE_DATA1_DATA1_MAX  255
+/* DD_GET_REG command, DATA2 field definition (address 2, size 8, lsb 0, unsigned)*/
+#define Si2168B_DD_GET_REG_RESPONSE_DATA2_LSB         0
+#define Si2168B_DD_GET_REG_RESPONSE_DATA2_MASK        0xff
+#define Si2168B_DD_GET_REG_RESPONSE_DATA2_DATA2_MIN  0
+#define Si2168B_DD_GET_REG_RESPONSE_DATA2_DATA2_MAX  255
+/* DD_GET_REG command, DATA3 field definition (address 3, size 8, lsb 0, unsigned)*/
+#define Si2168B_DD_GET_REG_RESPONSE_DATA3_LSB         0
+#define Si2168B_DD_GET_REG_RESPONSE_DATA3_MASK        0xff
+#define Si2168B_DD_GET_REG_RESPONSE_DATA3_DATA3_MIN  0
+#define Si2168B_DD_GET_REG_RESPONSE_DATA3_DATA3_MAX  255
+/* DD_GET_REG command, DATA4 field definition (address 4, size 8, lsb 0, unsigned)*/
+#define Si2168B_DD_GET_REG_RESPONSE_DATA4_LSB         0
+#define Si2168B_DD_GET_REG_RESPONSE_DATA4_MASK        0xff
+#define Si2168B_DD_GET_REG_RESPONSE_DATA4_DATA4_MIN  0
+#define Si2168B_DD_GET_REG_RESPONSE_DATA4_DATA4_MAX  255
+
+#endif /* Si2168B_DD_GET_REG_CMD */
+
+/* Si2168B_DD_MP_DEFAULTS command definition */
+#define Si2168B_DD_MP_DEFAULTS_CMD 0x88
+
+#ifdef Si2168B_DD_MP_DEFAULTS_CMD
+#define Si2168B_DD_MP_DEFAULTS_CMD_CODE 0x010088
+
+typedef struct { /* Si2168B_DD_MP_DEFAULTS_CMD_struct */
+	u8  mp_a_mode;
+	u8  mp_b_mode;
+	u8  mp_c_mode;
+	u8  mp_d_mode;
+} Si2168B_DD_MP_DEFAULTS_CMD_struct;
+
+typedef struct { /* Si2168B_DD_MP_DEFAULTS_CMD_REPLY_struct */
+	u8  mp_a_mode;
+	u8  mp_b_mode;
+	u8  mp_c_mode;
+	u8  mp_d_mode;
+}  Si2168B_DD_MP_DEFAULTS_CMD_REPLY_struct;
+
+/* DD_MP_DEFAULTS command, MP_A_MODE field definition (address 1,size 7, lsb 0, unsigned) */
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_A_MODE_LSB         0
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_A_MODE_MASK        0x7f
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_A_MODE_MIN         0
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_A_MODE_MAX         3
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_A_MODE_DISABLE    1
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_A_MODE_DRIVE_0    2
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_A_MODE_DRIVE_1    3
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_A_MODE_NO_CHANGE  0
+/* DD_MP_DEFAULTS command, MP_B_MODE field definition (address 2,size 7, lsb 0, unsigned) */
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_B_MODE_LSB         0
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_B_MODE_MASK        0x7f
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_B_MODE_MIN         0
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_B_MODE_MAX         3
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_B_MODE_DISABLE    1
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_B_MODE_DRIVE_0    2
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_B_MODE_DRIVE_1    3
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_B_MODE_NO_CHANGE  0
+/* DD_MP_DEFAULTS command, MP_C_MODE field definition (address 3,size 7, lsb 0, unsigned) */
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_C_MODE_LSB         0
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_C_MODE_MASK        0x7f
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_C_MODE_MIN         0
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_C_MODE_MAX         3
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_C_MODE_DISABLE    1
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_C_MODE_DRIVE_0    2
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_C_MODE_DRIVE_1    3
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_C_MODE_NO_CHANGE  0
+/* DD_MP_DEFAULTS command, MP_D_MODE field definition (address 4,size 7, lsb 0, unsigned) */
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_D_MODE_LSB         0
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_D_MODE_MASK        0x7f
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_D_MODE_MIN         0
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_D_MODE_MAX         3
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_D_MODE_DISABLE    1
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_D_MODE_DRIVE_0    2
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_D_MODE_DRIVE_1    3
+#define Si2168B_DD_MP_DEFAULTS_CMD_MP_D_MODE_NO_CHANGE  0
+/* DD_MP_DEFAULTS command, MP_A_MODE field definition (address 1, size 7, lsb 0, unsigned)*/
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_LSB         0
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_MASK        0x7f
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_AGC_1           3
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_AGC_1_INVERTED  4
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_AGC_2           5
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_AGC_2_INVERTED  6
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_DISABLE         0
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_DRIVE_0         1
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_DRIVE_1         2
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_FEF             7
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_FEF_INVERTED    8
+/* DD_MP_DEFAULTS command, MP_B_MODE field definition (address 2, size 7, lsb 0, unsigned)*/
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_LSB         0
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_MASK        0x7f
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_AGC_1           3
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_AGC_1_INVERTED  4
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_AGC_2           5
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_AGC_2_INVERTED  6
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_DISABLE         0
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_DRIVE_0         1
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_DRIVE_1         2
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_FEF             7
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_FEF_INVERTED    8
+/* DD_MP_DEFAULTS command, MP_C_MODE field definition (address 3, size 7, lsb 0, unsigned)*/
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_LSB         0
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_MASK        0x7f
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_AGC_1           3
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_AGC_1_INVERTED  4
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_AGC_2           5
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_AGC_2_INVERTED  6
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_DISABLE         0
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_DRIVE_0         1
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_DRIVE_1         2
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_FEF             7
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_FEF_INVERTED    8
+/* DD_MP_DEFAULTS command, MP_D_MODE field definition (address 4, size 7, lsb 0, unsigned)*/
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_LSB         0
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_MASK        0x7f
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_AGC_1           3
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_AGC_1_INVERTED  4
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_AGC_2           5
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_AGC_2_INVERTED  6
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_DISABLE         0
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_DRIVE_0         1
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_DRIVE_1         2
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_FEF             7
+#define Si2168B_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_FEF_INVERTED    8
+
+#endif /* Si2168B_DD_MP_DEFAULTS_CMD */
+
+/* Si2168B_DD_PER command definition */
+#define Si2168B_DD_PER_CMD 0x83
+
+#ifdef Si2168B_DD_PER_CMD
+#define Si2168B_DD_PER_CMD_CODE 0x010083
+
+typedef struct { /* Si2168B_DD_PER_CMD_struct */
+	u8  rst;
+} Si2168B_DD_PER_CMD_struct;
+
+typedef struct { /* Si2168B_DD_PER_CMD_REPLY_struct */
+	u8  exp;
+	u8  mant;
+}  Si2168B_DD_PER_CMD_REPLY_struct;
+
+/* DD_PER command, RST field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2168B_DD_PER_CMD_RST_LSB         0
+#define Si2168B_DD_PER_CMD_RST_MASK        0x01
+#define Si2168B_DD_PER_CMD_RST_MIN         0
+#define Si2168B_DD_PER_CMD_RST_MAX         1
+#define Si2168B_DD_PER_CMD_RST_CLEAR  1
+#define Si2168B_DD_PER_CMD_RST_RUN    0
+/* DD_PER command, EXP field definition (address 1, size 4, lsb 0, unsigned)*/
+#define Si2168B_DD_PER_RESPONSE_EXP_LSB         0
+#define Si2168B_DD_PER_RESPONSE_EXP_MASK        0x0f
+#define Si2168B_DD_PER_RESPONSE_EXP_EXP_MIN  0
+#define Si2168B_DD_PER_RESPONSE_EXP_EXP_MAX  8
+/* DD_PER command, MANT field definition (address 2, size 8, lsb 0, unsigned)*/
+#define Si2168B_DD_PER_RESPONSE_MANT_LSB         0
+#define Si2168B_DD_PER_RESPONSE_MANT_MASK        0xff
+#define Si2168B_DD_PER_RESPONSE_MANT_MANT_MIN  0
+#define Si2168B_DD_PER_RESPONSE_MANT_MANT_MAX  99
+
+#endif /* Si2168B_DD_PER_CMD */
+
+/* Si2168B_DD_RESTART command definition */
+#define Si2168B_DD_RESTART_CMD 0x85
+
+#ifdef Si2168B_DD_RESTART_CMD
+#define Si2168B_DD_RESTART_CMD_CODE 0x010085
+
+typedef struct { /* Si2168B_DD_RESTART_CMD_struct */
+	u8  nothing;
+} Si2168B_DD_RESTART_CMD_struct;
+
+#endif /* Si2168B_DD_RESTART_CMD */
+
+/* Si2168B_DD_SET_REG command definition */
+#define Si2168B_DD_SET_REG_CMD 0x8e
+
+#ifdef Si2168B_DD_SET_REG_CMD
+#define Si2168B_DD_SET_REG_CMD_CODE 0x01008e
+
+typedef struct { /* Si2168B_DD_SET_REG_CMD_struct */
+	u8  reg_code_lsb;
+	u8  reg_code_mid;
+	u8  reg_code_msb;
+	u32 value;
+} Si2168B_DD_SET_REG_CMD_struct;
+
+/* DD_SET_REG command, REG_CODE_LSB field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2168B_DD_SET_REG_CMD_REG_CODE_LSB_LSB         0
+#define Si2168B_DD_SET_REG_CMD_REG_CODE_LSB_MASK        0xff
+#define Si2168B_DD_SET_REG_CMD_REG_CODE_LSB_MIN         0
+#define Si2168B_DD_SET_REG_CMD_REG_CODE_LSB_MAX         255
+#define Si2168B_DD_SET_REG_CMD_REG_CODE_LSB_REG_CODE_LSB_MIN  0
+#define Si2168B_DD_SET_REG_CMD_REG_CODE_LSB_REG_CODE_LSB_MAX  255
+/* DD_SET_REG command, REG_CODE_MID field definition (address 2,size 8, lsb 0, unsigned) */
+#define Si2168B_DD_SET_REG_CMD_REG_CODE_MID_LSB         0
+#define Si2168B_DD_SET_REG_CMD_REG_CODE_MID_MASK        0xff
+#define Si2168B_DD_SET_REG_CMD_REG_CODE_MID_MIN         0
+#define Si2168B_DD_SET_REG_CMD_REG_CODE_MID_MAX         255
+#define Si2168B_DD_SET_REG_CMD_REG_CODE_MID_REG_CODE_MID_MIN  0
+#define Si2168B_DD_SET_REG_CMD_REG_CODE_MID_REG_CODE_MID_MAX  255
+/* DD_SET_REG command, REG_CODE_MSB field definition (address 3,size 8, lsb 0, unsigned) */
+#define Si2168B_DD_SET_REG_CMD_REG_CODE_MSB_LSB         0
+#define Si2168B_DD_SET_REG_CMD_REG_CODE_MSB_MASK        0xff
+#define Si2168B_DD_SET_REG_CMD_REG_CODE_MSB_MIN         0
+#define Si2168B_DD_SET_REG_CMD_REG_CODE_MSB_MAX         255
+#define Si2168B_DD_SET_REG_CMD_REG_CODE_MSB_REG_CODE_MSB_MIN  0
+#define Si2168B_DD_SET_REG_CMD_REG_CODE_MSB_REG_CODE_MSB_MAX  255
+/* DD_SET_REG command, VALUE field definition (address 4,size 32, lsb 0, unsigned) */
+#define Si2168B_DD_SET_REG_CMD_VALUE_LSB         0
+#define Si2168B_DD_SET_REG_CMD_VALUE_MASK        0xffffffff
+#define Si2168B_DD_SET_REG_CMD_VALUE_MIN         0
+#define Si2168B_DD_SET_REG_CMD_VALUE_MAX         4294967295
+#define Si2168B_DD_SET_REG_CMD_VALUE_VALUE_MIN  0
+#define Si2168B_DD_SET_REG_CMD_VALUE_VALUE_MAX  4294967295
+#endif /* Si2168B_DD_SET_REG_CMD */
+
+/* Si2168B_DD_SSI_SQI command definition */
+#define Si2168B_DD_SSI_SQI_CMD 0x8b
+
+#ifdef Si2168B_DD_SSI_SQI_CMD
+#define Si2168B_DD_SSI_SQI_CMD_CODE 0x01008b
+
+typedef struct { /* Si2168B_DD_SSI_SQI_CMD_struct */
+	s8  tuner_rssi;
+} Si2168B_DD_SSI_SQI_CMD_struct;
+
+
+typedef struct { /* Si2168B_DD_SSI_SQI_CMD_REPLY_struct */
+	u8  ssi;
+	s8  sqi;
+}  Si2168B_DD_SSI_SQI_CMD_REPLY_struct;
+
+/* DD_SSI_SQI command, TUNER_RSSI field definition (address 1,size 8, lsb 0, signed) */
+#define Si2168B_DD_SSI_SQI_CMD_TUNER_RSSI_LSB         0
+#define Si2168B_DD_SSI_SQI_CMD_TUNER_RSSI_MASK        0xff
+#define Si2168B_DD_SSI_SQI_CMD_TUNER_RSSI_SHIFT       24
+#define Si2168B_DD_SSI_SQI_CMD_TUNER_RSSI_MIN         -128
+#define Si2168B_DD_SSI_SQI_CMD_TUNER_RSSI_MAX         127
+/* DD_SSI_SQI command, SSI field definition (address 1, size 8, lsb 0, unsigned)*/
+#define Si2168B_DD_SSI_SQI_RESPONSE_SSI_LSB         0
+#define Si2168B_DD_SSI_SQI_RESPONSE_SSI_MASK        0xff
+#define Si2168B_DD_SSI_SQI_RESPONSE_SSI_SSI_MIN  0
+#define Si2168B_DD_SSI_SQI_RESPONSE_SSI_SSI_MAX  100
+/* DD_SSI_SQI command, SQI field definition (address 2, size 8, lsb 0, signed)*/
+#define Si2168B_DD_SSI_SQI_RESPONSE_SQI_LSB         0
+#define Si2168B_DD_SSI_SQI_RESPONSE_SQI_MASK        0xff
+#define Si2168B_DD_SSI_SQI_RESPONSE_SQI_SHIFT       24
+#define Si2168B_DD_SSI_SQI_RESPONSE_SQI_SQI_MIN  -1
+#define Si2168B_DD_SSI_SQI_RESPONSE_SQI_SQI_MAX  100
+
+#endif /* Si2168B_DD_SSI_SQI_CMD */
+
+/* Si2168B_DD_STATUS command definition */
+#define Si2168B_DD_STATUS_CMD 0x87
+
+#ifdef Si2168B_DD_STATUS_CMD
+#define Si2168B_DD_STATUS_CMD_CODE 0x010087
+
+typedef struct { /* Si2168B_DD_STATUS_CMD_struct */
+	u8  intack;
+} Si2168B_DD_STATUS_CMD_struct;
+
+typedef struct { /* Si2168B_DD_STATUS_CMD_REPLY_struct */
+	u8  pclint;
+	u8  dlint;
+	u8  berint;
+	u8  uncorint;
+	u8  rsqint_bit5;
+	u8  rsqint_bit6;
+	u8  rsqint_bit7;
+	u8  pcl;
+	u8  dl;
+	u8  ber;
+	u8  uncor;
+	u8  rsqstat_bit5;
+	u8  rsqstat_bit6;
+	u8  rsqstat_bit7;
+	u8  modulation;
+	u16 ts_bit_rate;
+	u16 ts_clk_freq;
+}  Si2168B_DD_STATUS_CMD_REPLY_struct;
+
+/* DD_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2168B_DD_STATUS_CMD_INTACK_LSB         0
+#define Si2168B_DD_STATUS_CMD_INTACK_MASK        0x01
+#define Si2168B_DD_STATUS_CMD_INTACK_MIN         0
+#define Si2168B_DD_STATUS_CMD_INTACK_MAX         1
+#define Si2168B_DD_STATUS_CMD_INTACK_CLEAR  1
+#define Si2168B_DD_STATUS_CMD_INTACK_OK     0
+/* DD_STATUS command, PCLINT field definition (address 1, size 1, lsb 1, unsigned)*/
+#define Si2168B_DD_STATUS_RESPONSE_PCLINT_LSB         1
+#define Si2168B_DD_STATUS_RESPONSE_PCLINT_MASK        0x01
+#define Si2168B_DD_STATUS_RESPONSE_PCLINT_CHANGED    1
+#define Si2168B_DD_STATUS_RESPONSE_PCLINT_NO_CHANGE  0
+/* DD_STATUS command, DLINT field definition (address 1, size 1, lsb 2, unsigned)*/
+#define Si2168B_DD_STATUS_RESPONSE_DLINT_LSB         2
+#define Si2168B_DD_STATUS_RESPONSE_DLINT_MASK        0x01
+#define Si2168B_DD_STATUS_RESPONSE_DLINT_CHANGED    1
+#define Si2168B_DD_STATUS_RESPONSE_DLINT_NO_CHANGE  0
+/* DD_STATUS command, BERINT field definition (address 1, size 1, lsb 3, unsigned)*/
+#define Si2168B_DD_STATUS_RESPONSE_BERINT_LSB         3
+#define Si2168B_DD_STATUS_RESPONSE_BERINT_MASK        0x01
+#define Si2168B_DD_STATUS_RESPONSE_BERINT_CHANGED    1
+#define Si2168B_DD_STATUS_RESPONSE_BERINT_NO_CHANGE  0
+/* DD_STATUS command, UNCORINT field definition (address 1, size 1, lsb 4, unsigned)*/
+#define Si2168B_DD_STATUS_RESPONSE_UNCORINT_LSB         4
+#define Si2168B_DD_STATUS_RESPONSE_UNCORINT_MASK        0x01
+#define Si2168B_DD_STATUS_RESPONSE_UNCORINT_CHANGED    1
+#define Si2168B_DD_STATUS_RESPONSE_UNCORINT_NO_CHANGE  0
+/* DD_STATUS command, RSQINT_BIT5 field definition (address 1, size 1, lsb 5, unsigned)*/
+#define Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT5_LSB         5
+#define Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT5_MASK        0x01
+#define Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT5_CHANGED    1
+#define Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT5_NO_CHANGE  0
+/* DD_STATUS command, RSQINT_BIT6 field definition (address 1, size 1, lsb 6, unsigned)*/
+#define Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT6_LSB         6
+#define Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT6_MASK        0x01
+#define Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT6_CHANGED    1
+#define Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT6_NO_CHANGE  0
+/* DD_STATUS command, RSQINT_BIT7 field definition (address 1, size 1, lsb 7, unsigned)*/
+#define Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT7_LSB         7
+#define Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT7_MASK        0x01
+#define Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT7_CHANGED    1
+#define Si2168B_DD_STATUS_RESPONSE_RSQINT_BIT7_NO_CHANGE  0
+/* DD_STATUS command, PCL field definition (address 2, size 1, lsb 1, unsigned)*/
+#define Si2168B_DD_STATUS_RESPONSE_PCL_LSB         1
+#define Si2168B_DD_STATUS_RESPONSE_PCL_MASK        0x01
+#define Si2168B_DD_STATUS_RESPONSE_PCL_LOCKED   1
+#define Si2168B_DD_STATUS_RESPONSE_PCL_NO_LOCK  0
+/* DD_STATUS command, DL field definition (address 2, size 1, lsb 2, unsigned)*/
+#define Si2168B_DD_STATUS_RESPONSE_DL_LSB         2
+#define Si2168B_DD_STATUS_RESPONSE_DL_MASK        0x01
+#define Si2168B_DD_STATUS_RESPONSE_DL_LOCKED   1
+#define Si2168B_DD_STATUS_RESPONSE_DL_NO_LOCK  0
+/* DD_STATUS command, BER field definition (address 2, size 1, lsb 3, unsigned)*/
+#define Si2168B_DD_STATUS_RESPONSE_BER_LSB         3
+#define Si2168B_DD_STATUS_RESPONSE_BER_MASK        0x01
+#define Si2168B_DD_STATUS_RESPONSE_BER_BER_ABOVE  1
+#define Si2168B_DD_STATUS_RESPONSE_BER_BER_BELOW  0
+/* DD_STATUS command, UNCOR field definition (address 2, size 1, lsb 4, unsigned)*/
+#define Si2168B_DD_STATUS_RESPONSE_UNCOR_LSB         4
+#define Si2168B_DD_STATUS_RESPONSE_UNCOR_MASK        0x01
+#define Si2168B_DD_STATUS_RESPONSE_UNCOR_NO_UNCOR_FOUND  0
+#define Si2168B_DD_STATUS_RESPONSE_UNCOR_UNCOR_FOUND     1
+/* DD_STATUS command, RSQSTAT_BIT5 field definition (address 2, size 1, lsb 5, unsigned)*/
+#define Si2168B_DD_STATUS_RESPONSE_RSQSTAT_BIT5_LSB         5
+#define Si2168B_DD_STATUS_RESPONSE_RSQSTAT_BIT5_MASK        0x01
+#define Si2168B_DD_STATUS_RESPONSE_RSQSTAT_BIT5_NO_CHANGE 0
+#define Si2168B_DD_STATUS_RESPONSE_RSQSTAT_BIT5_CHANGE    1
+/* DD_STATUS command, RSQSTAT_BIT6 field definition (address 2, size 1, lsb 6, unsigned)*/
+#define Si2168B_DD_STATUS_RESPONSE_RSQSTAT_BIT6_LSB         6
+#define Si2168B_DD_STATUS_RESPONSE_RSQSTAT_BIT6_MASK        0x01
+/* DD_STATUS command, RSQSTAT_BIT7 field definition (address 2, size 1, lsb 7, unsigned)*/
+#define Si2168B_DD_STATUS_RESPONSE_RSQSTAT_BIT7_LSB         7
+#define Si2168B_DD_STATUS_RESPONSE_RSQSTAT_BIT7_MASK        0x01
+/* DD_STATUS command, MODULATION field definition (address 3, size 4, lsb 0, unsigned)*/
+#define Si2168B_DD_STATUS_RESPONSE_MODULATION_LSB         0
+#define Si2168B_DD_STATUS_RESPONSE_MODULATION_MASK        0x0f
+#define Si2168B_DD_STATUS_RESPONSE_MODULATION_DSS    10
+#define Si2168B_DD_STATUS_RESPONSE_MODULATION_DVBC   3
+#define Si2168B_DD_STATUS_RESPONSE_MODULATION_DVBC2  11
+#define Si2168B_DD_STATUS_RESPONSE_MODULATION_DVBS   8
+#define Si2168B_DD_STATUS_RESPONSE_MODULATION_DVBS2  9
+#define Si2168B_DD_STATUS_RESPONSE_MODULATION_DVBT   2
+#define Si2168B_DD_STATUS_RESPONSE_MODULATION_DVBT2  7
+#define Si2168B_DD_STATUS_RESPONSE_MODULATION_MCNS   1
+/* DD_STATUS command, TS_BIT_RATE field definition (address 4, size 16, lsb 0, unsigned)*/
+#define Si2168B_DD_STATUS_RESPONSE_TS_BIT_RATE_LSB         0
+#define Si2168B_DD_STATUS_RESPONSE_TS_BIT_RATE_MASK        0xffff
+/* DD_STATUS command, TS_CLK_FREQ field definition (address 6, size 16, lsb 0, unsigned)*/
+#define Si2168B_DD_STATUS_RESPONSE_TS_CLK_FREQ_LSB         0
+#define Si2168B_DD_STATUS_RESPONSE_TS_CLK_FREQ_MASK        0xffff
+
+#endif /* Si2168B_DD_STATUS_CMD */
+
+/* Si2168B_DD_UNCOR command definition */
+#define Si2168B_DD_UNCOR_CMD 0x84
+
+#ifdef Si2168B_DD_UNCOR_CMD
+#define Si2168B_DD_UNCOR_CMD_CODE 0x010084
+
+typedef struct { /* Si2168B_DD_UNCOR_CMD_struct */
+	u8  rst;
+} Si2168B_DD_UNCOR_CMD_struct;
+
+typedef struct { /* Si2168B_DD_UNCOR_CMD_REPLY_struct */
+	u8  uncor_lsb;
+	u8  uncor_msb;
+}  Si2168B_DD_UNCOR_CMD_REPLY_struct;
+
+/* DD_UNCOR command, RST field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2168B_DD_UNCOR_CMD_RST_LSB         0
+#define Si2168B_DD_UNCOR_CMD_RST_MASK        0x01
+#define Si2168B_DD_UNCOR_CMD_RST_MIN         0
+#define Si2168B_DD_UNCOR_CMD_RST_MAX         1
+#define Si2168B_DD_UNCOR_CMD_RST_CLEAR  1
+#define Si2168B_DD_UNCOR_CMD_RST_RUN    0
+/* DD_UNCOR command, UNCOR_LSB field definition (address 1, size 8, lsb 0, unsigned)*/
+#define Si2168B_DD_UNCOR_RESPONSE_UNCOR_LSB_LSB         0
+#define Si2168B_DD_UNCOR_RESPONSE_UNCOR_LSB_MASK        0xff
+/* DD_UNCOR command, UNCOR_MSB field definition (address 2, size 8, lsb 0, unsigned)*/
+#define Si2168B_DD_UNCOR_RESPONSE_UNCOR_MSB_LSB         0
+#define Si2168B_DD_UNCOR_RESPONSE_UNCOR_MSB_MASK        0xff
+
+#endif /* Si2168B_DD_UNCOR_CMD */
+
+/* Si2168B_DOWNLOAD_DATASET_CONTINUE command definition */
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD 0xb9
+
+#ifdef Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_CODE 0x0100b9
+
+typedef struct { /* Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_struct */
+	u8  data0;
+	u8  data1;
+	u8  data2;
+	u8  data3;
+	u8  data4;
+	u8  data5;
+	u8  data6;
+} Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_struct;
+
+typedef struct { /* Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_REPLY_struct */
+}  Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_REPLY_struct;
+
+/* DOWNLOAD_DATASET_CONTINUE command, DATA0 field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_LSB         0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_MASK        0xff
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_MIN         0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_MAX         255
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_DATA0_MIN  0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_DATA0_MAX  255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA1 field definition (address 2,size 8, lsb 0, unsigned) */
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_LSB         0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_MASK        0xff
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_MIN         0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_MAX         255
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_DATA1_MIN  0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_DATA1_MAX  255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA2 field definition (address 3,size 8, lsb 0, unsigned) */
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_LSB         0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_MASK        0xff
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_MIN         0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_MAX         255
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_DATA2_MIN  0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_DATA2_MAX  255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA3 field definition (address 4,size 8, lsb 0, unsigned) */
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_LSB         0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_MASK        0xff
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_MIN         0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_MAX         255
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_DATA3_MIN  0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_DATA3_MAX  255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA4 field definition (address 5,size 8, lsb 0, unsigned) */
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_LSB         0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_MASK        0xff
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_MIN         0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_MAX         255
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_DATA4_MIN  0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_DATA4_MAX  255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA5 field definition (address 6,size 8, lsb 0, unsigned) */
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_LSB         0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_MASK        0xff
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_MIN         0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_MAX         255
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_DATA5_MIN  0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_DATA5_MAX  255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA6 field definition (address 7,size 8, lsb 0, unsigned) */
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_LSB         0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_MASK        0xff
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_MIN         0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_MAX         255
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_DATA6_MIN  0
+#define Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_DATA6_MAX  255
+#endif /* Si2168B_DOWNLOAD_DATASET_CONTINUE_CMD */
+
+/* Si2168B_DOWNLOAD_DATASET_START command definition */
+#define Si2168B_DOWNLOAD_DATASET_START_CMD 0xb8
+
+#ifdef Si2168B_DOWNLOAD_DATASET_START_CMD
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_CODE 0x0100b8
+
+typedef struct { /* Si2168B_DOWNLOAD_DATASET_START_CMD_struct */
+	u8  dataset_id;
+	u8  dataset_checksum;
+	u8  data0;
+	u8  data1;
+	u8  data2;
+	u8  data3;
+	u8  data4;
+} Si2168B_DOWNLOAD_DATASET_START_CMD_struct;
+
+/* DOWNLOAD_DATASET_START command, DATASET_ID field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATASET_ID_LSB         0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATASET_ID_MASK        0xff
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATASET_ID_MIN         0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATASET_ID_MAX         0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATASET_ID_RFU  0
+/* DOWNLOAD_DATASET_START command, DATASET_CHECKSUM field definition (address 2,size 8, lsb 0, unsigned) */
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_LSB         0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_MASK        0xff
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_MIN         0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_MAX         255
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_DATASET_CHECKSUM_MIN  0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_DATASET_CHECKSUM_MAX  255
+/* DOWNLOAD_DATASET_START command, DATA0 field definition (address 3,size 8, lsb 0, unsigned) */
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA0_LSB         0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA0_MASK        0xff
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA0_MIN         0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA0_MAX         255
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA0_DATA0_MIN  0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA0_DATA0_MAX  255
+/* DOWNLOAD_DATASET_START command, DATA1 field definition (address 4,size 8, lsb 0, unsigned) */
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA1_LSB         0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA1_MASK        0xff
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA1_MIN         0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA1_MAX         255
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA1_DATA1_MIN  0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA1_DATA1_MAX  255
+/* DOWNLOAD_DATASET_START command, DATA2 field definition (address 5,size 8, lsb 0, unsigned) */
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA2_LSB         0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA2_MASK        0xff
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA2_MIN         0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA2_MAX         255
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA2_DATA2_MIN  0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA2_DATA2_MAX  255
+/* DOWNLOAD_DATASET_START command, DATA3 field definition (address 6,size 8, lsb 0, unsigned) */
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA3_LSB         0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA3_MASK        0xff
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA3_MIN         0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA3_MAX         255
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA3_DATA3_MIN  0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA3_DATA3_MAX  255
+/* DOWNLOAD_DATASET_START command, DATA4 field definition (address 7,size 8, lsb 0, unsigned) */
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA4_LSB         0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA4_MASK        0xff
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA4_MIN         0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA4_MAX         255
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA4_DATA4_MIN  0
+#define Si2168B_DOWNLOAD_DATASET_START_CMD_DATA4_DATA4_MAX  255
+#endif /* Si2168B_DOWNLOAD_DATASET_START_CMD */
+
+/* Si2168B_DVBC_STATUS command definition */
+#define Si2168B_DVBC_STATUS_CMD 0x90
+
+#ifdef Si2168B_DVBC_STATUS_CMD
+#define Si2168B_DVBC_STATUS_CMD_CODE 0x010090
+
+typedef struct { /* Si2168B_DVBC_STATUS_CMD_struct */
+	u8  intack;
+} Si2168B_DVBC_STATUS_CMD_struct;
+
+typedef struct { /* Si2168B_DVBC_STATUS_CMD_REPLY_struct */
+	u8  pclint;
+	u8  dlint;
+	u8  berint;
+	u8  uncorint;
+	u8  pcl;
+	u8  dl;
+	u8  ber;
+	u8  uncor;
+	u8  cnr;
+	s16 afc_freq;
+	s16 timing_offset;
+	u8  constellation;
+	u8  sp_inv;
+}  Si2168B_DVBC_STATUS_CMD_REPLY_struct;
+
+/* DVBC_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2168B_DVBC_STATUS_CMD_INTACK_LSB         0
+#define Si2168B_DVBC_STATUS_CMD_INTACK_MASK        0x01
+#define Si2168B_DVBC_STATUS_CMD_INTACK_MIN         0
+#define Si2168B_DVBC_STATUS_CMD_INTACK_MAX         1
+#define Si2168B_DVBC_STATUS_CMD_INTACK_CLEAR  1
+#define Si2168B_DVBC_STATUS_CMD_INTACK_OK     0
+/* DVBC_STATUS command, PCLINT field definition (address 1, size 1, lsb 1, unsigned)*/
+#define Si2168B_DVBC_STATUS_RESPONSE_PCLINT_LSB         1
+#define Si2168B_DVBC_STATUS_RESPONSE_PCLINT_MASK        0x01
+#define Si2168B_DVBC_STATUS_RESPONSE_PCLINT_CHANGED    1
+#define Si2168B_DVBC_STATUS_RESPONSE_PCLINT_NO_CHANGE  0
+/* DVBC_STATUS command, DLINT field definition (address 1, size 1, lsb 2, unsigned)*/
+#define Si2168B_DVBC_STATUS_RESPONSE_DLINT_LSB         2
+#define Si2168B_DVBC_STATUS_RESPONSE_DLINT_MASK        0x01
+#define Si2168B_DVBC_STATUS_RESPONSE_DLINT_CHANGED    1
+#define Si2168B_DVBC_STATUS_RESPONSE_DLINT_NO_CHANGE  0
+/* DVBC_STATUS command, BERINT field definition (address 1, size 1, lsb 3, unsigned)*/
+#define Si2168B_DVBC_STATUS_RESPONSE_BERINT_LSB         3
+#define Si2168B_DVBC_STATUS_RESPONSE_BERINT_MASK        0x01
+#define Si2168B_DVBC_STATUS_RESPONSE_BERINT_CHANGED    1
+#define Si2168B_DVBC_STATUS_RESPONSE_BERINT_NO_CHANGE  0
+/* DVBC_STATUS command, UNCORINT field definition (address 1, size 1, lsb 4, unsigned)*/
+#define Si2168B_DVBC_STATUS_RESPONSE_UNCORINT_LSB         4
+#define Si2168B_DVBC_STATUS_RESPONSE_UNCORINT_MASK        0x01
+#define Si2168B_DVBC_STATUS_RESPONSE_UNCORINT_CHANGED    1
+#define Si2168B_DVBC_STATUS_RESPONSE_UNCORINT_NO_CHANGE  0
+/* DVBC_STATUS command, PCL field definition (address 2, size 1, lsb 1, unsigned)*/
+#define Si2168B_DVBC_STATUS_RESPONSE_PCL_LSB         1
+#define Si2168B_DVBC_STATUS_RESPONSE_PCL_MASK        0x01
+#define Si2168B_DVBC_STATUS_RESPONSE_PCL_LOCKED   1
+#define Si2168B_DVBC_STATUS_RESPONSE_PCL_NO_LOCK  0
+/* DVBC_STATUS command, DL field definition (address 2, size 1, lsb 2, unsigned)*/
+#define Si2168B_DVBC_STATUS_RESPONSE_DL_LSB         2
+#define Si2168B_DVBC_STATUS_RESPONSE_DL_MASK        0x01
+#define Si2168B_DVBC_STATUS_RESPONSE_DL_LOCKED   1
+#define Si2168B_DVBC_STATUS_RESPONSE_DL_NO_LOCK  0
+/* DVBC_STATUS command, BER field definition (address 2, size 1, lsb 3, unsigned)*/
+#define Si2168B_DVBC_STATUS_RESPONSE_BER_LSB         3
+#define Si2168B_DVBC_STATUS_RESPONSE_BER_MASK        0x01
+#define Si2168B_DVBC_STATUS_RESPONSE_BER_BER_ABOVE  1
+#define Si2168B_DVBC_STATUS_RESPONSE_BER_BER_BELOW  0
+/* DVBC_STATUS command, UNCOR field definition (address 2, size 1, lsb 4, unsigned)*/
+#define Si2168B_DVBC_STATUS_RESPONSE_UNCOR_LSB         4
+#define Si2168B_DVBC_STATUS_RESPONSE_UNCOR_MASK        0x01
+#define Si2168B_DVBC_STATUS_RESPONSE_UNCOR_NO_UNCOR_FOUND  0
+#define Si2168B_DVBC_STATUS_RESPONSE_UNCOR_UNCOR_FOUND     1
+/* DVBC_STATUS command, CNR field definition (address 3, size 8, lsb 0, unsigned)*/
+#define Si2168B_DVBC_STATUS_RESPONSE_CNR_LSB         0
+#define Si2168B_DVBC_STATUS_RESPONSE_CNR_MASK        0xff
+/* DVBC_STATUS command, AFC_FREQ field definition (address 4, size 16, lsb 0, signed)*/
+#define Si2168B_DVBC_STATUS_RESPONSE_AFC_FREQ_LSB         0
+#define Si2168B_DVBC_STATUS_RESPONSE_AFC_FREQ_MASK        0xffff
+#define Si2168B_DVBC_STATUS_RESPONSE_AFC_FREQ_SHIFT       16
+/* DVBC_STATUS command, TIMING_OFFSET field definition (address 6, size 16, lsb 0, signed)*/
+#define Si2168B_DVBC_STATUS_RESPONSE_TIMING_OFFSET_LSB         0
+#define Si2168B_DVBC_STATUS_RESPONSE_TIMING_OFFSET_MASK        0xffff
+#define Si2168B_DVBC_STATUS_RESPONSE_TIMING_OFFSET_SHIFT       16
+/* DVBC_STATUS command, CONSTELLATION field definition (address 8, size 6, lsb 0, unsigned)*/
+#define Si2168B_DVBC_STATUS_RESPONSE_CONSTELLATION_LSB         0
+#define Si2168B_DVBC_STATUS_RESPONSE_CONSTELLATION_MASK        0x3f
+#define Si2168B_DVBC_STATUS_RESPONSE_CONSTELLATION_QAM128  10
+#define Si2168B_DVBC_STATUS_RESPONSE_CONSTELLATION_QAM16   7
+#define Si2168B_DVBC_STATUS_RESPONSE_CONSTELLATION_QAM256  11
+#define Si2168B_DVBC_STATUS_RESPONSE_CONSTELLATION_QAM32   8
+#define Si2168B_DVBC_STATUS_RESPONSE_CONSTELLATION_QAM64   9
+/* DVBC_STATUS command, SP_INV field definition (address 8, size 1, lsb 6, unsigned)*/
+#define Si2168B_DVBC_STATUS_RESPONSE_SP_INV_LSB         6
+#define Si2168B_DVBC_STATUS_RESPONSE_SP_INV_MASK        0x01
+#define Si2168B_DVBC_STATUS_RESPONSE_SP_INV_INVERTED  1
+#define Si2168B_DVBC_STATUS_RESPONSE_SP_INV_NORMAL    0
+
+#endif /* Si2168B_DVBC_STATUS_CMD */
+
+/* Si2168B_DVBT2_FEF command definition */
+#define Si2168B_DVBT2_FEF_CMD 0x51
+
+#ifdef Si2168B_DVBT2_FEF_CMD
+#define Si2168B_DVBT2_FEF_CMD_CODE 0x010051
+
+typedef struct { /* Si2168B_DVBT2_FEF_CMD_struct */
+	u8  fef_tuner_flag;
+	u8  fef_tuner_flag_inv;
+} Si2168B_DVBT2_FEF_CMD_struct;
+
+typedef struct { /* Si2168B_DVBT2_FEF_CMD_REPLY_struct */
+	u8  fef_type;
+	u32 fef_length;
+	u32 fef_repetition;
+}  Si2168B_DVBT2_FEF_CMD_REPLY_struct;
+
+/* DVBT2_FEF command, FEF_TUNER_FLAG field definition (address 1,size 3, lsb 0, unsigned) */
+#define Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_LSB         0
+#define Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MASK        0x07
+#define Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MIN         0
+#define Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MAX         5
+#define Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_A       2
+#define Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_B       3
+#define Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_C       4
+#define Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_D       5
+#define Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_NOT_USED   1
+#define Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_NO_CHANGE  0
+/* DVBT2_FEF command, FEF_TUNER_FLAG_INV field definition (address 1,size 1, lsb 3, unsigned) */
+#define Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_LSB         3
+#define Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_MASK        0x01
+#define Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_MIN         0
+#define Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_MAX         1
+#define Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_FEF_HIGH  0
+#define Si2168B_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_FEF_LOW   1
+/* DVBT2_FEF command, FEF_TYPE field definition (address 1, size 4, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_FEF_RESPONSE_FEF_TYPE_LSB         0
+#define Si2168B_DVBT2_FEF_RESPONSE_FEF_TYPE_MASK        0x0f
+/* DVBT2_FEF command, FEF_LENGTH field definition (address 4, size 32, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_FEF_RESPONSE_FEF_LENGTH_LSB         0
+#define Si2168B_DVBT2_FEF_RESPONSE_FEF_LENGTH_MASK        0xffffffff
+/* DVBT2_FEF command, FEF_REPETITION field definition (address 8, size 32, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_FEF_RESPONSE_FEF_REPETITION_LSB         0
+#define Si2168B_DVBT2_FEF_RESPONSE_FEF_REPETITION_MASK        0xffffffff
+
+#endif /* Si2168B_DVBT2_FEF_CMD */
+
+/* Si2168B_DVBT2_PLP_INFO command definition */
+#define Si2168B_DVBT2_PLP_INFO_CMD 0x53
+
+#ifdef Si2168B_DVBT2_PLP_INFO_CMD
+#define Si2168B_DVBT2_PLP_INFO_CMD_CODE 0x010053
+
+typedef struct { /* Si2168B_DVBT2_PLP_INFO_CMD_struct */
+	u8  plp_index;
+} Si2168B_DVBT2_PLP_INFO_CMD_struct;
+
+typedef struct { /* Si2168B_DVBT2_PLP_INFO_CMD_REPLY_struct */
+	u8  plp_id;
+	u8  reserved_1_1;
+	u8  in_band_b_flag;
+	u8  in_band_a_flag;
+	u8  static_flag;
+	u8  plp_mode;
+	u8  reserved_1_2;
+	u8  static_padding_flag;
+	u8  plp_payload_type;
+	u8  plp_type;
+	u8  first_frame_idx_msb;
+	u8  first_rf_idx;
+	u8  ff_flag;
+	u8  plp_group_id_msb;
+	u8  first_frame_idx_lsb;
+	u8  plp_mod_msb;
+	u8  plp_cod;
+	u8  plp_group_id_lsb;
+	u8  plp_num_blocks_max_msb;
+	u8  plp_fec_type;
+	u8  plp_rot;
+	u8  plp_mod_lsb;
+	u8  frame_interval_msb;
+	u8  plp_num_blocks_max_lsb;
+	u8  time_il_length_msb;
+	u8  frame_interval_lsb;
+	u8  time_il_type;
+	u8  time_il_length_lsb;
+}  Si2168B_DVBT2_PLP_INFO_CMD_REPLY_struct;
+
+/* DVBT2_PLP_INFO command, PLP_INDEX field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2168B_DVBT2_PLP_INFO_CMD_PLP_INDEX_LSB         0
+#define Si2168B_DVBT2_PLP_INFO_CMD_PLP_INDEX_MASK        0xff
+#define Si2168B_DVBT2_PLP_INFO_CMD_PLP_INDEX_MIN         0
+#define Si2168B_DVBT2_PLP_INFO_CMD_PLP_INDEX_MAX         255
+/* DVBT2_PLP_INFO command, PLP_ID field definition (address 1, size 8, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_ID_LSB         0
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_ID_MASK        0xff
+/* DVBT2_PLP_INFO command, RESERVED_1_1 field definition (address 10, size 6, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_RESERVED_1_1_LSB         0
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_RESERVED_1_1_MASK        0x3f
+/* DVBT2_PLP_INFO command, IN_BAND_B_FLAG field definition (address 10, size 1, lsb 6, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_IN_BAND_B_FLAG_LSB         6
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_IN_BAND_B_FLAG_MASK        0x01
+/* DVBT2_PLP_INFO command, IN_BAND_A_FLAG field definition (address 10, size 1, lsb 7, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_IN_BAND_A_FLAG_LSB         7
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_IN_BAND_A_FLAG_MASK        0x01
+/* DVBT2_PLP_INFO command, STATIC_FLAG field definition (address 11, size 1, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_STATIC_FLAG_LSB         0
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_STATIC_FLAG_MASK        0x01
+/* DVBT2_PLP_INFO command, PLP_MODE field definition (address 11, size 2, lsb 1, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_MODE_LSB         1
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_MODE_MASK        0x03
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_MODE_HIGH_EFFICIENCY_MODE  2
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_MODE_NORMAL_MODE           1
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_MODE_NOT_SPECIFIED         0
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_MODE_RESERVED              3
+/* DVBT2_PLP_INFO command, RESERVED_1_2 field definition (address 11, size 5, lsb 3, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_RESERVED_1_2_LSB         3
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_RESERVED_1_2_MASK        0x1f
+/* DVBT2_PLP_INFO command, STATIC_PADDING_FLAG field definition (address 12, size 1, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_STATIC_PADDING_FLAG_LSB         0
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_STATIC_PADDING_FLAG_MASK        0x01
+/* DVBT2_PLP_INFO command, PLP_PAYLOAD_TYPE field definition (address 2, size 5, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_PAYLOAD_TYPE_LSB         0
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_PAYLOAD_TYPE_MASK        0x1f
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_PAYLOAD_TYPE_GCS   1
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_PAYLOAD_TYPE_GFPS  0
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_PAYLOAD_TYPE_GSE   2
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_PAYLOAD_TYPE_TS    3
+/* DVBT2_PLP_INFO command, PLP_TYPE field definition (address 2, size 3, lsb 5, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_TYPE_LSB         5
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_TYPE_MASK        0x07
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_TYPE_COMMON      0
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_TYPE_DATA_TYPE1  1
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_TYPE_DATA_TYPE2  2
+/* DVBT2_PLP_INFO command, FIRST_FRAME_IDX_MSB field definition (address 3, size 4, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_FIRST_FRAME_IDX_MSB_LSB         0
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_FIRST_FRAME_IDX_MSB_MASK        0x0f
+/* DVBT2_PLP_INFO command, FIRST_RF_IDX field definition (address 3, size 3, lsb 4, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_FIRST_RF_IDX_LSB         4
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_FIRST_RF_IDX_MASK        0x07
+/* DVBT2_PLP_INFO command, FF_FLAG field definition (address 3, size 1, lsb 7, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_FF_FLAG_LSB         7
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_FF_FLAG_MASK        0x01
+/* DVBT2_PLP_INFO command, PLP_GROUP_ID_MSB field definition (address 4, size 4, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_GROUP_ID_MSB_LSB         0
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_GROUP_ID_MSB_MASK        0x0f
+/* DVBT2_PLP_INFO command, FIRST_FRAME_IDX_LSB field definition (address 4, size 4, lsb 4, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_FIRST_FRAME_IDX_LSB_LSB         4
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_FIRST_FRAME_IDX_LSB_MASK        0x0f
+/* DVBT2_PLP_INFO command, PLP_MOD_MSB field definition (address 5, size 1, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_MOD_MSB_LSB         0
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_MOD_MSB_MASK        0x01
+/* DVBT2_PLP_INFO command, PLP_COD field definition (address 5, size 3, lsb 1, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_COD_LSB         1
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_COD_MASK        0x07
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_COD_1_2  0
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_COD_2_3  2
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_COD_3_4  3
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_COD_3_5  1
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_COD_4_5  4
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_COD_5_6  5
+/* DVBT2_PLP_INFO command, PLP_GROUP_ID_LSB field definition (address 5, size 4, lsb 4, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_GROUP_ID_LSB_LSB         4
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_GROUP_ID_LSB_MASK        0x0f
+/* DVBT2_PLP_INFO command, PLP_NUM_BLOCKS_MAX_MSB field definition (address 6, size 3, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_NUM_BLOCKS_MAX_MSB_LSB         0
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_NUM_BLOCKS_MAX_MSB_MASK        0x07
+/* DVBT2_PLP_INFO command, PLP_FEC_TYPE field definition (address 6, size 2, lsb 3, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_FEC_TYPE_LSB         3
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_FEC_TYPE_MASK        0x03
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_FEC_TYPE_16K_LDPC  0
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_FEC_TYPE_64K_LDPC  1
+/* DVBT2_PLP_INFO command, PLP_ROT field definition (address 6, size 1, lsb 5, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_ROT_LSB         5
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_ROT_MASK        0x01
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_ROT_NOT_ROTATED  0
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_ROT_ROTATED      1
+/* DVBT2_PLP_INFO command, PLP_MOD_LSB field definition (address 6, size 2, lsb 6, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_MOD_LSB_LSB         6
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_MOD_LSB_MASK        0x03
+/* DVBT2_PLP_INFO command, FRAME_INTERVAL_MSB field definition (address 7, size 1, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_FRAME_INTERVAL_MSB_LSB         0
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_FRAME_INTERVAL_MSB_MASK        0x01
+/* DVBT2_PLP_INFO command, PLP_NUM_BLOCKS_MAX_LSB field definition (address 7, size 7, lsb 1, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_NUM_BLOCKS_MAX_LSB_LSB         1
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_PLP_NUM_BLOCKS_MAX_LSB_MASK        0x7f
+/* DVBT2_PLP_INFO command, TIME_IL_LENGTH_MSB field definition (address 8, size 1, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_TIME_IL_LENGTH_MSB_LSB         0
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_TIME_IL_LENGTH_MSB_MASK        0x01
+/* DVBT2_PLP_INFO command, FRAME_INTERVAL_LSB field definition (address 8, size 7, lsb 1, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_FRAME_INTERVAL_LSB_LSB         1
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_FRAME_INTERVAL_LSB_MASK        0x7f
+/* DVBT2_PLP_INFO command, TIME_IL_TYPE field definition (address 9, size 1, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_TIME_IL_TYPE_LSB         0
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_TIME_IL_TYPE_MASK        0x01
+/* DVBT2_PLP_INFO command, TIME_IL_LENGTH_LSB field definition (address 9, size 7, lsb 1, unsigned)*/
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_TIME_IL_LENGTH_LSB_LSB         1
+#define Si2168B_DVBT2_PLP_INFO_RESPONSE_TIME_IL_LENGTH_LSB_MASK        0x7f
+
+#endif /* Si2168B_DVBT2_PLP_INFO_CMD */
+
+/* Si2168B_DVBT2_PLP_SELECT command definition */
+#define Si2168B_DVBT2_PLP_SELECT_CMD 0x52
+
+#ifdef Si2168B_DVBT2_PLP_SELECT_CMD
+#define Si2168B_DVBT2_PLP_SELECT_CMD_CODE 0x010052
+
+typedef struct { /* Si2168B_DVBT2_PLP_SELECT_CMD_struct */
+	u8  plp_id;
+	u8  plp_id_sel_mode;
+} Si2168B_DVBT2_PLP_SELECT_CMD_struct;
+
+/* DVBT2_PLP_SELECT command, PLP_ID field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_LSB         0
+#define Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_MASK        0xff
+#define Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_MIN         0
+#define Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_MAX         255
+/* DVBT2_PLP_SELECT command, PLP_ID_SEL_MODE field definition (address 2,size 1, lsb 0, unsigned) */
+#define Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_LSB         0
+#define Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MASK        0x01
+#define Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MIN         0
+#define Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MAX         1
+#define Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_AUTO    0
+#define Si2168B_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MANUAL  1
+#endif /* Si2168B_DVBT2_PLP_SELECT_CMD */
+
+/* Si2168B_DVBT2_STATUS command definition */
+#define Si2168B_DVBT2_STATUS_CMD 0x50
+
+#ifdef Si2168B_DVBT2_STATUS_CMD
+#define Si2168B_DVBT2_STATUS_CMD_CODE 0x010050
+
+typedef struct { /* Si2168B_DVBT2_STATUS_CMD_struct */
+	u8  intack;
+} Si2168B_DVBT2_STATUS_CMD_struct;
+
+typedef struct { /* Si2168B_DVBT2_STATUS_CMD_REPLY_struct */
+	u8  pclint;
+	u8  dlint;
+	u8  berint;
+	u8  uncorint;
+	u8  notdvbt2int;
+	u8  num_plp;
+	u8  pilot_pattern;
+	u8  tx_mode;
+	u8  rotated;
+	u8  short_frame;
+	u8  t2_mode;
+	u8  code_rate;
+	u8  t2_version;
+	u8  plp_id;
+	u8  pcl;
+	u8  dl;
+	u8  ber;
+	u8  uncor;
+	u8  notdvbt2;
+	u8  cnr;
+	s16 afc_freq;
+	s16 timing_offset;
+	u8  constellation;
+	u8  sp_inv;
+	u8  fef;
+	u8  fft_mode;
+	u8  guard_int;
+	u8  bw_ext;
+}  Si2168B_DVBT2_STATUS_CMD_REPLY_struct;
+
+/* DVBT2_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2168B_DVBT2_STATUS_CMD_INTACK_LSB         0
+#define Si2168B_DVBT2_STATUS_CMD_INTACK_MASK        0x01
+#define Si2168B_DVBT2_STATUS_CMD_INTACK_MIN         0
+#define Si2168B_DVBT2_STATUS_CMD_INTACK_MAX         1
+#define Si2168B_DVBT2_STATUS_CMD_INTACK_CLEAR  1
+#define Si2168B_DVBT2_STATUS_CMD_INTACK_OK     0
+/* DVBT2_STATUS command, PCLINT field definition (address 1, size 1, lsb 1, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_PCLINT_LSB         1
+#define Si2168B_DVBT2_STATUS_RESPONSE_PCLINT_MASK        0x01
+#define Si2168B_DVBT2_STATUS_RESPONSE_PCLINT_CHANGED    1
+#define Si2168B_DVBT2_STATUS_RESPONSE_PCLINT_NO_CHANGE  0
+/* DVBT2_STATUS command, DLINT field definition (address 1, size 1, lsb 2, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_DLINT_LSB         2
+#define Si2168B_DVBT2_STATUS_RESPONSE_DLINT_MASK        0x01
+#define Si2168B_DVBT2_STATUS_RESPONSE_DLINT_CHANGED    1
+#define Si2168B_DVBT2_STATUS_RESPONSE_DLINT_NO_CHANGE  0
+/* DVBT2_STATUS command, BERINT field definition (address 1, size 1, lsb 3, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_BERINT_LSB         3
+#define Si2168B_DVBT2_STATUS_RESPONSE_BERINT_MASK        0x01
+#define Si2168B_DVBT2_STATUS_RESPONSE_BERINT_CHANGED    1
+#define Si2168B_DVBT2_STATUS_RESPONSE_BERINT_NO_CHANGE  0
+/* DVBT2_STATUS command, UNCORINT field definition (address 1, size 1, lsb 4, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_UNCORINT_LSB         4
+#define Si2168B_DVBT2_STATUS_RESPONSE_UNCORINT_MASK        0x01
+#define Si2168B_DVBT2_STATUS_RESPONSE_UNCORINT_CHANGED    1
+#define Si2168B_DVBT2_STATUS_RESPONSE_UNCORINT_NO_CHANGE  0
+/* DVBT2_STATUS command, NOTDVBT2INT field definition (address 1, size 1, lsb 5, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_NOTDVBT2INT_LSB         5
+#define Si2168B_DVBT2_STATUS_RESPONSE_NOTDVBT2INT_MASK        0x01
+#define Si2168B_DVBT2_STATUS_RESPONSE_NOTDVBT2INT_CHANGED    1
+#define Si2168B_DVBT2_STATUS_RESPONSE_NOTDVBT2INT_NO_CHANGE  0
+/* DVBT2_STATUS command, NUM_PLP field definition (address 10, size 8, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_NUM_PLP_LSB         0
+#define Si2168B_DVBT2_STATUS_RESPONSE_NUM_PLP_MASK        0xff
+/* DVBT2_STATUS command, PILOT_PATTERN field definition (address 11, size 4, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_LSB         0
+#define Si2168B_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_MASK        0x0f
+#define Si2168B_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP1  0
+#define Si2168B_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP2  1
+#define Si2168B_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP3  2
+#define Si2168B_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP4  3
+#define Si2168B_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP5  4
+#define Si2168B_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP6  5
+#define Si2168B_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP7  6
+#define Si2168B_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP8  7
+/* DVBT2_STATUS command, TX_MODE field definition (address 11, size 1, lsb 4, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_TX_MODE_LSB         4
+#define Si2168B_DVBT2_STATUS_RESPONSE_TX_MODE_MASK        0x01
+#define Si2168B_DVBT2_STATUS_RESPONSE_TX_MODE_MISO  1
+#define Si2168B_DVBT2_STATUS_RESPONSE_TX_MODE_SISO  0
+/* DVBT2_STATUS command, ROTATED field definition (address 11, size 1, lsb 5, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_ROTATED_LSB         5
+#define Si2168B_DVBT2_STATUS_RESPONSE_ROTATED_MASK        0x01
+#define Si2168B_DVBT2_STATUS_RESPONSE_ROTATED_NORMAL   0
+#define Si2168B_DVBT2_STATUS_RESPONSE_ROTATED_ROTATED  1
+/* DVBT2_STATUS command, SHORT_FRAME field definition (address 11, size 1, lsb 6, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_SHORT_FRAME_LSB         6
+#define Si2168B_DVBT2_STATUS_RESPONSE_SHORT_FRAME_MASK        0x01
+#define Si2168B_DVBT2_STATUS_RESPONSE_SHORT_FRAME_16K_LDPC  0
+#define Si2168B_DVBT2_STATUS_RESPONSE_SHORT_FRAME_64K_LDPC  1
+/* DVBT2_STATUS command, T2_MODE field definition (address 11, size 1, lsb 7, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_T2_MODE_LSB         7
+#define Si2168B_DVBT2_STATUS_RESPONSE_T2_MODE_MASK        0x01
+#define Si2168B_DVBT2_STATUS_RESPONSE_T2_MODE_BASE  0
+#define Si2168B_DVBT2_STATUS_RESPONSE_T2_MODE_LITE  1
+/* DVBT2_STATUS command, CODE_RATE field definition (address 12, size 4, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_CODE_RATE_LSB         0
+#define Si2168B_DVBT2_STATUS_RESPONSE_CODE_RATE_MASK        0x0f
+#define Si2168B_DVBT2_STATUS_RESPONSE_CODE_RATE_1_2  1
+#define Si2168B_DVBT2_STATUS_RESPONSE_CODE_RATE_1_3  10
+#define Si2168B_DVBT2_STATUS_RESPONSE_CODE_RATE_2_3  2
+#define Si2168B_DVBT2_STATUS_RESPONSE_CODE_RATE_2_5  12
+#define Si2168B_DVBT2_STATUS_RESPONSE_CODE_RATE_3_4  3
+#define Si2168B_DVBT2_STATUS_RESPONSE_CODE_RATE_3_5  13
+#define Si2168B_DVBT2_STATUS_RESPONSE_CODE_RATE_4_5  4
+#define Si2168B_DVBT2_STATUS_RESPONSE_CODE_RATE_5_6  5
+/* DVBT2_STATUS command, T2_VERSION field definition (address 12, size 4, lsb 4, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_T2_VERSION_LSB         4
+#define Si2168B_DVBT2_STATUS_RESPONSE_T2_VERSION_MASK        0x0f
+#define Si2168B_DVBT2_STATUS_RESPONSE_T2_VERSION_1_1_1  0
+#define Si2168B_DVBT2_STATUS_RESPONSE_T2_VERSION_1_2_1  1
+#define Si2168B_DVBT2_STATUS_RESPONSE_T2_VERSION_1_3_1  2
+/* DVBT2_STATUS command, PLP_ID field definition (address 13, size 8, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_PLP_ID_LSB         0
+#define Si2168B_DVBT2_STATUS_RESPONSE_PLP_ID_MASK        0xff
+/* DVBT2_STATUS command, PCL field definition (address 2, size 1, lsb 1, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_PCL_LSB         1
+#define Si2168B_DVBT2_STATUS_RESPONSE_PCL_MASK        0x01
+#define Si2168B_DVBT2_STATUS_RESPONSE_PCL_LOCKED   1
+#define Si2168B_DVBT2_STATUS_RESPONSE_PCL_NO_LOCK  0
+/* DVBT2_STATUS command, DL field definition (address 2, size 1, lsb 2, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_DL_LSB         2
+#define Si2168B_DVBT2_STATUS_RESPONSE_DL_MASK        0x01
+#define Si2168B_DVBT2_STATUS_RESPONSE_DL_LOCKED   1
+#define Si2168B_DVBT2_STATUS_RESPONSE_DL_NO_LOCK  0
+/* DVBT2_STATUS command, BER field definition (address 2, size 1, lsb 3, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_BER_LSB         3
+#define Si2168B_DVBT2_STATUS_RESPONSE_BER_MASK        0x01
+#define Si2168B_DVBT2_STATUS_RESPONSE_BER_BER_ABOVE  1
+#define Si2168B_DVBT2_STATUS_RESPONSE_BER_BER_BELOW  0
+/* DVBT2_STATUS command, UNCOR field definition (address 2, size 1, lsb 4, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_UNCOR_LSB         4
+#define Si2168B_DVBT2_STATUS_RESPONSE_UNCOR_MASK        0x01
+#define Si2168B_DVBT2_STATUS_RESPONSE_UNCOR_NO_UNCOR_FOUND  0
+#define Si2168B_DVBT2_STATUS_RESPONSE_UNCOR_UNCOR_FOUND     1
+/* DVBT2_STATUS command, NOTDVBT2 field definition (address 2, size 1, lsb 5, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_NOTDVBT2_LSB         5
+#define Si2168B_DVBT2_STATUS_RESPONSE_NOTDVBT2_MASK        0x01
+#define Si2168B_DVBT2_STATUS_RESPONSE_NOTDVBT2_DVBT2      0
+#define Si2168B_DVBT2_STATUS_RESPONSE_NOTDVBT2_NOT_DVBT2  1
+/* DVBT2_STATUS command, CNR field definition (address 3, size 8, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_CNR_LSB         0
+#define Si2168B_DVBT2_STATUS_RESPONSE_CNR_MASK        0xff
+/* DVBT2_STATUS command, AFC_FREQ field definition (address 4, size 16, lsb 0, signed)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_AFC_FREQ_LSB         0
+#define Si2168B_DVBT2_STATUS_RESPONSE_AFC_FREQ_MASK        0xffff
+#define Si2168B_DVBT2_STATUS_RESPONSE_AFC_FREQ_SHIFT       16
+/* DVBT2_STATUS command, TIMING_OFFSET field definition (address 6, size 16, lsb 0, signed)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_LSB         0
+#define Si2168B_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_MASK        0xffff
+#define Si2168B_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_SHIFT       16
+/* DVBT2_STATUS command, CONSTELLATION field definition (address 8, size 6, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_CONSTELLATION_LSB         0
+#define Si2168B_DVBT2_STATUS_RESPONSE_CONSTELLATION_MASK        0x3f
+#define Si2168B_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM128  10
+#define Si2168B_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM16   7
+#define Si2168B_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM256  11
+#define Si2168B_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM32   8
+#define Si2168B_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM64   9
+#define Si2168B_DVBT2_STATUS_RESPONSE_CONSTELLATION_QPSK    3
+/* DVBT2_STATUS command, SP_INV field definition (address 8, size 1, lsb 6, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_SP_INV_LSB         6
+#define Si2168B_DVBT2_STATUS_RESPONSE_SP_INV_MASK        0x01
+#define Si2168B_DVBT2_STATUS_RESPONSE_SP_INV_INVERTED  1
+#define Si2168B_DVBT2_STATUS_RESPONSE_SP_INV_NORMAL    0
+/* DVBT2_STATUS command, FEF field definition (address 8, size 1, lsb 7, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_FEF_LSB         7
+#define Si2168B_DVBT2_STATUS_RESPONSE_FEF_MASK        0x01
+#define Si2168B_DVBT2_STATUS_RESPONSE_FEF_FEF     1
+#define Si2168B_DVBT2_STATUS_RESPONSE_FEF_NO_FEF  0
+/* DVBT2_STATUS command, FFT_MODE field definition (address 9, size 4, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_FFT_MODE_LSB         0
+#define Si2168B_DVBT2_STATUS_RESPONSE_FFT_MODE_MASK        0x0f
+#define Si2168B_DVBT2_STATUS_RESPONSE_FFT_MODE_16K  14
+#define Si2168B_DVBT2_STATUS_RESPONSE_FFT_MODE_1K   10
+#define Si2168B_DVBT2_STATUS_RESPONSE_FFT_MODE_2K   11
+#define Si2168B_DVBT2_STATUS_RESPONSE_FFT_MODE_32K  15
+#define Si2168B_DVBT2_STATUS_RESPONSE_FFT_MODE_4K   12
+#define Si2168B_DVBT2_STATUS_RESPONSE_FFT_MODE_8K   13
+/* DVBT2_STATUS command, GUARD_INT field definition (address 9, size 3, lsb 4, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_GUARD_INT_LSB         4
+#define Si2168B_DVBT2_STATUS_RESPONSE_GUARD_INT_MASK        0x07
+#define Si2168B_DVBT2_STATUS_RESPONSE_GUARD_INT_19_128  6
+#define Si2168B_DVBT2_STATUS_RESPONSE_GUARD_INT_19_256  7
+#define Si2168B_DVBT2_STATUS_RESPONSE_GUARD_INT_1_128   5
+#define Si2168B_DVBT2_STATUS_RESPONSE_GUARD_INT_1_16    2
+#define Si2168B_DVBT2_STATUS_RESPONSE_GUARD_INT_1_32    1
+#define Si2168B_DVBT2_STATUS_RESPONSE_GUARD_INT_1_4     4
+#define Si2168B_DVBT2_STATUS_RESPONSE_GUARD_INT_1_8     3
+/* DVBT2_STATUS command, BW_EXT field definition (address 9, size 1, lsb 7, unsigned)*/
+#define Si2168B_DVBT2_STATUS_RESPONSE_BW_EXT_LSB         7
+#define Si2168B_DVBT2_STATUS_RESPONSE_BW_EXT_MASK        0x01
+#define Si2168B_DVBT2_STATUS_RESPONSE_BW_EXT_EXTENDED  1
+#define Si2168B_DVBT2_STATUS_RESPONSE_BW_EXT_NORMAL    0
+
+#endif /* Si2168B_DVBT2_STATUS_CMD */
+
+/* Si2168B_DVBT2_TX_ID command definition */
+#define Si2168B_DVBT2_TX_ID_CMD 0x54
+
+#ifdef Si2168B_DVBT2_TX_ID_CMD
+#define Si2168B_DVBT2_TX_ID_CMD_CODE 0x010054
+
+typedef struct { /* Si2168B_DVBT2_TX_ID_CMD_struct */
+	u8  nothing;
+} Si2168B_DVBT2_TX_ID_CMD_struct;
+
+typedef struct { /* Si2168B_DVBT2_TX_ID_CMD_REPLY_struct */
+	u8  tx_id_availability;
+	u16 cell_id;
+	u16 network_id;
+	u16 t2_system_id;
+}  Si2168B_DVBT2_TX_ID_CMD_REPLY_struct;
+
+/* DVBT2_TX_ID command, TX_ID_AVAILABILITY field definition (address 1, size 8, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_TX_ID_RESPONSE_TX_ID_AVAILABILITY_LSB         0
+#define Si2168B_DVBT2_TX_ID_RESPONSE_TX_ID_AVAILABILITY_MASK        0xff
+/* DVBT2_TX_ID command, CELL_ID field definition (address 2, size 16, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_TX_ID_RESPONSE_CELL_ID_LSB         0
+#define Si2168B_DVBT2_TX_ID_RESPONSE_CELL_ID_MASK        0xffff
+/* DVBT2_TX_ID command, NETWORK_ID field definition (address 4, size 16, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_TX_ID_RESPONSE_NETWORK_ID_LSB         0
+#define Si2168B_DVBT2_TX_ID_RESPONSE_NETWORK_ID_MASK        0xffff
+/* DVBT2_TX_ID command, T2_SYSTEM_ID field definition (address 6, size 16, lsb 0, unsigned)*/
+#define Si2168B_DVBT2_TX_ID_RESPONSE_T2_SYSTEM_ID_LSB         0
+#define Si2168B_DVBT2_TX_ID_RESPONSE_T2_SYSTEM_ID_MASK        0xffff
+
+#endif /* Si2168B_DVBT2_TX_ID_CMD */
+
+/* Si2168B_DVBT_STATUS command definition */
+#define Si2168B_DVBT_STATUS_CMD 0xa0
+
+#ifdef Si2168B_DVBT_STATUS_CMD
+#define Si2168B_DVBT_STATUS_CMD_CODE 0x0100a0
+
+typedef struct { /* Si2168B_DVBT_STATUS_CMD_struct */
+	u8  intack;
+} Si2168B_DVBT_STATUS_CMD_struct;
+
+typedef struct { /* Si2168B_DVBT_STATUS_CMD_REPLY_struct */
+	u8  pclint;
+	u8  dlint;
+	u8  berint;
+	u8  uncorint;
+	u8  notdvbtint;
+	u8  fft_mode;
+	u8  guard_int;
+	u8  hierarchy;
+	s8  tps_length;
+	u8  pcl;
+	u8  dl;
+	u8  ber;
+	u8  uncor;
+	u8  notdvbt;
+	u8  cnr;
+	s16 afc_freq;
+	s16 timing_offset;
+	u8  constellation;
+	u8  sp_inv;
+	u8  rate_hp;
+	u8  rate_lp;
+}  Si2168B_DVBT_STATUS_CMD_REPLY_struct;
+
+/* DVBT_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2168B_DVBT_STATUS_CMD_INTACK_LSB         0
+#define Si2168B_DVBT_STATUS_CMD_INTACK_MASK        0x01
+#define Si2168B_DVBT_STATUS_CMD_INTACK_MIN         0
+#define Si2168B_DVBT_STATUS_CMD_INTACK_MAX         1
+#define Si2168B_DVBT_STATUS_CMD_INTACK_CLEAR  1
+#define Si2168B_DVBT_STATUS_CMD_INTACK_OK     0
+/* DVBT_STATUS command, PCLINT field definition (address 1, size 1, lsb 1, unsigned)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_PCLINT_LSB         1
+#define Si2168B_DVBT_STATUS_RESPONSE_PCLINT_MASK        0x01
+#define Si2168B_DVBT_STATUS_RESPONSE_PCLINT_CHANGED    1
+#define Si2168B_DVBT_STATUS_RESPONSE_PCLINT_NO_CHANGE  0
+/* DVBT_STATUS command, DLINT field definition (address 1, size 1, lsb 2, unsigned)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_DLINT_LSB         2
+#define Si2168B_DVBT_STATUS_RESPONSE_DLINT_MASK        0x01
+#define Si2168B_DVBT_STATUS_RESPONSE_DLINT_CHANGED    1
+#define Si2168B_DVBT_STATUS_RESPONSE_DLINT_NO_CHANGE  0
+/* DVBT_STATUS command, BERINT field definition (address 1, size 1, lsb 3, unsigned)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_BERINT_LSB         3
+#define Si2168B_DVBT_STATUS_RESPONSE_BERINT_MASK        0x01
+#define Si2168B_DVBT_STATUS_RESPONSE_BERINT_CHANGED    1
+#define Si2168B_DVBT_STATUS_RESPONSE_BERINT_NO_CHANGE  0
+/* DVBT_STATUS command, UNCORINT field definition (address 1, size 1, lsb 4, unsigned)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_UNCORINT_LSB         4
+#define Si2168B_DVBT_STATUS_RESPONSE_UNCORINT_MASK        0x01
+#define Si2168B_DVBT_STATUS_RESPONSE_UNCORINT_CHANGED    1
+#define Si2168B_DVBT_STATUS_RESPONSE_UNCORINT_NO_CHANGE  0
+/* DVBT_STATUS command, NOTDVBTINT field definition (address 1, size 1, lsb 5, unsigned)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_NOTDVBTINT_LSB         5
+#define Si2168B_DVBT_STATUS_RESPONSE_NOTDVBTINT_MASK        0x01
+#define Si2168B_DVBT_STATUS_RESPONSE_NOTDVBTINT_CHANGED    1
+#define Si2168B_DVBT_STATUS_RESPONSE_NOTDVBTINT_NO_CHANGE  0
+/* DVBT_STATUS command, FFT_MODE field definition (address 10, size 4, lsb 0, unsigned)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_FFT_MODE_LSB         0
+#define Si2168B_DVBT_STATUS_RESPONSE_FFT_MODE_MASK        0x0f
+#define Si2168B_DVBT_STATUS_RESPONSE_FFT_MODE_2K  11
+#define Si2168B_DVBT_STATUS_RESPONSE_FFT_MODE_4K  12
+#define Si2168B_DVBT_STATUS_RESPONSE_FFT_MODE_8K  13
+/* DVBT_STATUS command, GUARD_INT field definition (address 10, size 3, lsb 4, unsigned)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_GUARD_INT_LSB         4
+#define Si2168B_DVBT_STATUS_RESPONSE_GUARD_INT_MASK        0x07
+#define Si2168B_DVBT_STATUS_RESPONSE_GUARD_INT_1_16  2
+#define Si2168B_DVBT_STATUS_RESPONSE_GUARD_INT_1_32  1
+#define Si2168B_DVBT_STATUS_RESPONSE_GUARD_INT_1_4   4
+#define Si2168B_DVBT_STATUS_RESPONSE_GUARD_INT_1_8   3
+/* DVBT_STATUS command, HIERARCHY field definition (address 11, size 3, lsb 0, unsigned)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_HIERARCHY_LSB         0
+#define Si2168B_DVBT_STATUS_RESPONSE_HIERARCHY_MASK        0x07
+#define Si2168B_DVBT_STATUS_RESPONSE_HIERARCHY_ALFA1  2
+#define Si2168B_DVBT_STATUS_RESPONSE_HIERARCHY_ALFA2  3
+#define Si2168B_DVBT_STATUS_RESPONSE_HIERARCHY_ALFA4  5
+#define Si2168B_DVBT_STATUS_RESPONSE_HIERARCHY_NONE   1
+/* DVBT_STATUS command, TPS_LENGTH field definition (address 12, size 7, lsb 0, signed)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_TPS_LENGTH_LSB         0
+#define Si2168B_DVBT_STATUS_RESPONSE_TPS_LENGTH_MASK        0x7f
+#define Si2168B_DVBT_STATUS_RESPONSE_TPS_LENGTH_SHIFT       25
+/* DVBT_STATUS command, PCL field definition (address 2, size 1, lsb 1, unsigned)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_PCL_LSB         1
+#define Si2168B_DVBT_STATUS_RESPONSE_PCL_MASK        0x01
+#define Si2168B_DVBT_STATUS_RESPONSE_PCL_LOCKED   1
+#define Si2168B_DVBT_STATUS_RESPONSE_PCL_NO_LOCK  0
+/* DVBT_STATUS command, DL field definition (address 2, size 1, lsb 2, unsigned)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_DL_LSB         2
+#define Si2168B_DVBT_STATUS_RESPONSE_DL_MASK        0x01
+#define Si2168B_DVBT_STATUS_RESPONSE_DL_LOCKED   1
+#define Si2168B_DVBT_STATUS_RESPONSE_DL_NO_LOCK  0
+/* DVBT_STATUS command, BER field definition (address 2, size 1, lsb 3, unsigned)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_BER_LSB         3
+#define Si2168B_DVBT_STATUS_RESPONSE_BER_MASK        0x01
+#define Si2168B_DVBT_STATUS_RESPONSE_BER_BER_ABOVE  1
+#define Si2168B_DVBT_STATUS_RESPONSE_BER_BER_BELOW  0
+/* DVBT_STATUS command, UNCOR field definition (address 2, size 1, lsb 4, unsigned)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_UNCOR_LSB         4
+#define Si2168B_DVBT_STATUS_RESPONSE_UNCOR_MASK        0x01
+#define Si2168B_DVBT_STATUS_RESPONSE_UNCOR_NO_UNCOR_FOUND  0
+#define Si2168B_DVBT_STATUS_RESPONSE_UNCOR_UNCOR_FOUND     1
+/* DVBT_STATUS command, NOTDVBT field definition (address 2, size 1, lsb 5, unsigned)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_NOTDVBT_LSB         5
+#define Si2168B_DVBT_STATUS_RESPONSE_NOTDVBT_MASK        0x01
+#define Si2168B_DVBT_STATUS_RESPONSE_NOTDVBT_DVBT      0
+#define Si2168B_DVBT_STATUS_RESPONSE_NOTDVBT_NOT_DVBT  1
+/* DVBT_STATUS command, CNR field definition (address 3, size 8, lsb 0, unsigned)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_CNR_LSB         0
+#define Si2168B_DVBT_STATUS_RESPONSE_CNR_MASK        0xff
+/* DVBT_STATUS command, AFC_FREQ field definition (address 4, size 16, lsb 0, signed)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_AFC_FREQ_LSB         0
+#define Si2168B_DVBT_STATUS_RESPONSE_AFC_FREQ_MASK        0xffff
+#define Si2168B_DVBT_STATUS_RESPONSE_AFC_FREQ_SHIFT       16
+/* DVBT_STATUS command, TIMING_OFFSET field definition (address 6, size 16, lsb 0, signed)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_TIMING_OFFSET_LSB         0
+#define Si2168B_DVBT_STATUS_RESPONSE_TIMING_OFFSET_MASK        0xffff
+#define Si2168B_DVBT_STATUS_RESPONSE_TIMING_OFFSET_SHIFT       16
+/* DVBT_STATUS command, CONSTELLATION field definition (address 8, size 6, lsb 0, unsigned)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_CONSTELLATION_LSB         0
+#define Si2168B_DVBT_STATUS_RESPONSE_CONSTELLATION_MASK        0x3f
+#define Si2168B_DVBT_STATUS_RESPONSE_CONSTELLATION_QAM16  7
+#define Si2168B_DVBT_STATUS_RESPONSE_CONSTELLATION_QAM64  9
+#define Si2168B_DVBT_STATUS_RESPONSE_CONSTELLATION_QPSK   3
+/* DVBT_STATUS command, SP_INV field definition (address 8, size 1, lsb 6, unsigned)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_SP_INV_LSB         6
+#define Si2168B_DVBT_STATUS_RESPONSE_SP_INV_MASK        0x01
+#define Si2168B_DVBT_STATUS_RESPONSE_SP_INV_INVERTED  1
+#define Si2168B_DVBT_STATUS_RESPONSE_SP_INV_NORMAL    0
+/* DVBT_STATUS command, RATE_HP field definition (address 9, size 4, lsb 0, unsigned)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_RATE_HP_LSB         0
+#define Si2168B_DVBT_STATUS_RESPONSE_RATE_HP_MASK        0x0f
+#define Si2168B_DVBT_STATUS_RESPONSE_RATE_HP_1_2  1
+#define Si2168B_DVBT_STATUS_RESPONSE_RATE_HP_2_3  2
+#define Si2168B_DVBT_STATUS_RESPONSE_RATE_HP_3_4  3
+#define Si2168B_DVBT_STATUS_RESPONSE_RATE_HP_5_6  5
+#define Si2168B_DVBT_STATUS_RESPONSE_RATE_HP_7_8  7
+/* DVBT_STATUS command, RATE_LP field definition (address 9, size 4, lsb 4, unsigned)*/
+#define Si2168B_DVBT_STATUS_RESPONSE_RATE_LP_LSB         4
+#define Si2168B_DVBT_STATUS_RESPONSE_RATE_LP_MASK        0x0f
+#define Si2168B_DVBT_STATUS_RESPONSE_RATE_LP_1_2  1
+#define Si2168B_DVBT_STATUS_RESPONSE_RATE_LP_2_3  2
+#define Si2168B_DVBT_STATUS_RESPONSE_RATE_LP_3_4  3
+#define Si2168B_DVBT_STATUS_RESPONSE_RATE_LP_5_6  5
+#define Si2168B_DVBT_STATUS_RESPONSE_RATE_LP_7_8  7
+
+#endif /* Si2168B_DVBT_STATUS_CMD */
+
+/* Si2168B_DVBT_TPS_EXTRA command definition */
+#define Si2168B_DVBT_TPS_EXTRA_CMD 0xa1
+
+#ifdef Si2168B_DVBT_TPS_EXTRA_CMD
+#define Si2168B_DVBT_TPS_EXTRA_CMD_CODE 0x0100a1
+
+typedef struct { /* Si2168B_DVBT_TPS_EXTRA_CMD_struct */
+	u8  nothing;
+} Si2168B_DVBT_TPS_EXTRA_CMD_struct;
+
+typedef struct { /* Si2168B_DVBT_TPS_EXTRA_CMD_REPLY_struct */
+	u8  lptimeslice;
+	u8  hptimeslice;
+	u8  lpmpefec;
+	u8  hpmpefec;
+	u8  dvbhinter;
+	s16 cell_id;
+	u8  tps_res1;
+	u8  tps_res2;
+	u8  tps_res3;
+	u8  tps_res4;
+}  Si2168B_DVBT_TPS_EXTRA_CMD_REPLY_struct;
+
+/* DVBT_TPS_EXTRA command, LPTIMESLICE field definition (address 1, size 1, lsb 0, unsigned)*/
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_LPTIMESLICE_LSB         0
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_LPTIMESLICE_MASK        0x01
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_LPTIMESLICE_OFF  0
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_LPTIMESLICE_ON   1
+/* DVBT_TPS_EXTRA command, HPTIMESLICE field definition (address 1, size 1, lsb 1, unsigned)*/
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_HPTIMESLICE_LSB         1
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_HPTIMESLICE_MASK        0x01
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_HPTIMESLICE_OFF  0
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_HPTIMESLICE_ON   1
+/* DVBT_TPS_EXTRA command, LPMPEFEC field definition (address 1, size 1, lsb 2, unsigned)*/
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_LPMPEFEC_LSB         2
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_LPMPEFEC_MASK        0x01
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_LPMPEFEC_OFF  0
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_LPMPEFEC_ON   1
+/* DVBT_TPS_EXTRA command, HPMPEFEC field definition (address 1, size 1, lsb 3, unsigned)*/
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_HPMPEFEC_LSB         3
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_HPMPEFEC_MASK        0x01
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_HPMPEFEC_OFF  0
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_HPMPEFEC_ON   1
+/* DVBT_TPS_EXTRA command, DVBHINTER field definition (address 1, size 1, lsb 4, unsigned)*/
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_DVBHINTER_LSB         4
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_DVBHINTER_MASK        0x01
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_DVBHINTER_IN_DEPTH  1
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_DVBHINTER_NATIVE    0
+/* DVBT_TPS_EXTRA command, CELL_ID field definition (address 2, size 16, lsb 0, signed)*/
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_LSB         0
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_MASK        0xffff
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_SHIFT       16
+/* DVBT_TPS_EXTRA command, TPS_RES1 field definition (address 4, size 4, lsb 0, unsigned)*/
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_TPS_RES1_LSB         0
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_TPS_RES1_MASK        0x0f
+/* DVBT_TPS_EXTRA command, TPS_RES2 field definition (address 4, size 4, lsb 4, unsigned)*/
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_TPS_RES2_LSB         4
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_TPS_RES2_MASK        0x0f
+/* DVBT_TPS_EXTRA command, TPS_RES3 field definition (address 5, size 4, lsb 0, unsigned)*/
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_TPS_RES3_LSB         0
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_TPS_RES3_MASK        0x0f
+/* DVBT_TPS_EXTRA command, TPS_RES4 field definition (address 5, size 4, lsb 4, unsigned)*/
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_TPS_RES4_LSB         4
+#define Si2168B_DVBT_TPS_EXTRA_RESPONSE_TPS_RES4_MASK        0x0f
+
+#endif /* Si2168B_DVBT_TPS_EXTRA_CMD */
+
+/* Si2168B_EXIT_BOOTLOADER command definition */
+#define Si2168B_EXIT_BOOTLOADER_CMD 0x01
+
+#ifdef Si2168B_EXIT_BOOTLOADER_CMD
+#define Si2168B_EXIT_BOOTLOADER_CMD_CODE 0x010001
+
+typedef struct { /* Si2168B_EXIT_BOOTLOADER_CMD_struct */
+	u8  func;
+	u8  ctsien;
+} Si2168B_EXIT_BOOTLOADER_CMD_struct;
+
+/* EXIT_BOOTLOADER command, FUNC field definition (address 1,size 4, lsb 0, unsigned) */
+#define Si2168B_EXIT_BOOTLOADER_CMD_FUNC_LSB         0
+#define Si2168B_EXIT_BOOTLOADER_CMD_FUNC_MASK        0x0f
+#define Si2168B_EXIT_BOOTLOADER_CMD_FUNC_MIN         0
+#define Si2168B_EXIT_BOOTLOADER_CMD_FUNC_MAX         1
+#define Si2168B_EXIT_BOOTLOADER_CMD_FUNC_BOOTLOADER  0
+#define Si2168B_EXIT_BOOTLOADER_CMD_FUNC_NORMAL      1
+/* EXIT_BOOTLOADER command, CTSIEN field definition (address 1,size 1, lsb 7, unsigned) */
+#define Si2168B_EXIT_BOOTLOADER_CMD_CTSIEN_LSB         7
+#define Si2168B_EXIT_BOOTLOADER_CMD_CTSIEN_MASK        0x01
+#define Si2168B_EXIT_BOOTLOADER_CMD_CTSIEN_MIN         0
+#define Si2168B_EXIT_BOOTLOADER_CMD_CTSIEN_MAX         1
+#define Si2168B_EXIT_BOOTLOADER_CMD_CTSIEN_OFF  0
+#define Si2168B_EXIT_BOOTLOADER_CMD_CTSIEN_ON   1
+#endif /* Si2168B_EXIT_BOOTLOADER_CMD */
+
+/* Si2168B_GET_PROPERTY command definition */
+#define Si2168B_GET_PROPERTY_CMD 0x15
+
+#ifdef Si2168B_GET_PROPERTY_CMD
+#define Si2168B_GET_PROPERTY_CMD_CODE 0x010015
+
+typedef struct { /* Si2168B_GET_PROPERTY_CMD_struct */
+	u8  reserved;
+	u16 prop;
+} Si2168B_GET_PROPERTY_CMD_struct;
+
+typedef struct { /* Si2168B_GET_PROPERTY_CMD_REPLY_struct */
+	u8  reserved;
+	u16 data;
+}  Si2168B_GET_PROPERTY_CMD_REPLY_struct;
+
+/* GET_PROPERTY command, RESERVED field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2168B_GET_PROPERTY_CMD_RESERVED_LSB         0
+#define Si2168B_GET_PROPERTY_CMD_RESERVED_MASK        0xff
+#define Si2168B_GET_PROPERTY_CMD_RESERVED_MIN         0
+#define Si2168B_GET_PROPERTY_CMD_RESERVED_MAX         0
+#define Si2168B_GET_PROPERTY_CMD_RESERVED_RESERVED_MIN  0
+#define Si2168B_GET_PROPERTY_CMD_RESERVED_RESERVED_MAX  0
+/* GET_PROPERTY command, PROP field definition (address 2,size 16, lsb 0, unsigned) */
+#define Si2168B_GET_PROPERTY_CMD_PROP_LSB         0
+#define Si2168B_GET_PROPERTY_CMD_PROP_MASK        0xffff
+#define Si2168B_GET_PROPERTY_CMD_PROP_MIN         0
+#define Si2168B_GET_PROPERTY_CMD_PROP_MAX         65535
+#define Si2168B_GET_PROPERTY_CMD_PROP_PROP_MIN  0
+#define Si2168B_GET_PROPERTY_CMD_PROP_PROP_MAX  65535
+/* GET_PROPERTY command, RESERVED field definition (address 1, size 8, lsb 0, unsigned)*/
+#define Si2168B_GET_PROPERTY_RESPONSE_RESERVED_LSB         0
+#define Si2168B_GET_PROPERTY_RESPONSE_RESERVED_MASK        0xff
+/* GET_PROPERTY command, DATA field definition (address 2, size 16, lsb 0, unsigned)*/
+#define Si2168B_GET_PROPERTY_RESPONSE_DATA_LSB         0
+#define Si2168B_GET_PROPERTY_RESPONSE_DATA_MASK        0xffff
+
+#endif /* Si2168B_GET_PROPERTY_CMD */
+
+/* Si2168B_GET_REV command definition */
+#define Si2168B_GET_REV_CMD 0x11
+
+#ifdef Si2168B_GET_REV_CMD
+#define Si2168B_GET_REV_CMD_CODE 0x010011
+
+typedef struct { /* Si2168B_GET_REV_CMD_struct */
+	u8  nothing;
+} Si2168B_GET_REV_CMD_struct;
+
+typedef struct { /* Si2168B_GET_REV_CMD_REPLY_struct */
+	u8  pn;
+	u8  fwmajor;
+	u8  fwminor;
+	u16 patch;
+	u8  cmpmajor;
+	u8  cmpminor;
+	u8  cmpbuild;
+	u8  chiprev;
+	u8  mcm_die;
+}  Si2168B_GET_REV_CMD_REPLY_struct;
+
+/* GET_REV command, PN field definition (address 1, size 8, lsb 0, unsigned)*/
+#define Si2168B_GET_REV_RESPONSE_PN_LSB         0
+#define Si2168B_GET_REV_RESPONSE_PN_MASK        0xff
+/* GET_REV command, FWMAJOR field definition (address 2, size 8, lsb 0, unsigned)*/
+#define Si2168B_GET_REV_RESPONSE_FWMAJOR_LSB         0
+#define Si2168B_GET_REV_RESPONSE_FWMAJOR_MASK        0xff
+/* GET_REV command, FWMINOR field definition (address 3, size 8, lsb 0, unsigned)*/
+#define Si2168B_GET_REV_RESPONSE_FWMINOR_LSB         0
+#define Si2168B_GET_REV_RESPONSE_FWMINOR_MASK        0xff
+/* GET_REV command, PATCH field definition (address 4, size 16, lsb 0, unsigned)*/
+#define Si2168B_GET_REV_RESPONSE_PATCH_LSB         0
+#define Si2168B_GET_REV_RESPONSE_PATCH_MASK        0xffff
+/* GET_REV command, CMPMAJOR field definition (address 6, size 8, lsb 0, unsigned)*/
+#define Si2168B_GET_REV_RESPONSE_CMPMAJOR_LSB         0
+#define Si2168B_GET_REV_RESPONSE_CMPMAJOR_MASK        0xff
+/* GET_REV command, CMPMINOR field definition (address 7, size 8, lsb 0, unsigned)*/
+#define Si2168B_GET_REV_RESPONSE_CMPMINOR_LSB         0
+#define Si2168B_GET_REV_RESPONSE_CMPMINOR_MASK        0xff
+/* GET_REV command, CMPBUILD field definition (address 8, size 8, lsb 0, unsigned)*/
+#define Si2168B_GET_REV_RESPONSE_CMPBUILD_LSB         0
+#define Si2168B_GET_REV_RESPONSE_CMPBUILD_MASK        0xff
+#define Si2168B_GET_REV_RESPONSE_CMPBUILD_CMPBUILD_MIN  0
+#define Si2168B_GET_REV_RESPONSE_CMPBUILD_CMPBUILD_MAX  255
+/* GET_REV command, CHIPREV field definition (address 9, size 4, lsb 0, unsigned)*/
+#define Si2168B_GET_REV_RESPONSE_CHIPREV_LSB         0
+#define Si2168B_GET_REV_RESPONSE_CHIPREV_MASK        0x0f
+#define Si2168B_GET_REV_RESPONSE_CHIPREV_A  1
+#define Si2168B_GET_REV_RESPONSE_CHIPREV_B  2
+#define Si2168B_GET_REV_RESPONSE_CHIPREV_C  2
+/* GET_REV command, MCM_DIE field definition (address 9, size 4, lsb 4, unsigned)*/
+#define Si2168B_GET_REV_RESPONSE_MCM_DIE_LSB         4
+#define Si2168B_GET_REV_RESPONSE_MCM_DIE_MASK        0x0f
+#define Si2168B_GET_REV_RESPONSE_MCM_DIE_DIE_A   1
+#define Si2168B_GET_REV_RESPONSE_MCM_DIE_DIE_B   2
+#define Si2168B_GET_REV_RESPONSE_MCM_DIE_SINGLE  0
+
+#endif /* Si2168B_GET_REV_CMD */
+
+/* Si2168B_I2C_PASSTHROUGH command definition */
+#define Si2168B_I2C_PASSTHROUGH_CMD 0xc0
+
+#ifdef Si2168B_I2C_PASSTHROUGH_CMD
+#define Si2168B_I2C_PASSTHROUGH_CMD_CODE 0x0100c0
+
+typedef struct { /* Si2168B_I2C_PASSTHROUGH_CMD_struct */
+	u8  subcode;
+	u8  i2c_passthru;
+	u8  reserved;
+} Si2168B_I2C_PASSTHROUGH_CMD_struct;
+
+/* I2C_PASSTHROUGH command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2168B_I2C_PASSTHROUGH_CMD_SUBCODE_LSB         0
+#define Si2168B_I2C_PASSTHROUGH_CMD_SUBCODE_MASK        0xff
+#define Si2168B_I2C_PASSTHROUGH_CMD_SUBCODE_MIN         13
+#define Si2168B_I2C_PASSTHROUGH_CMD_SUBCODE_MAX         13
+#define Si2168B_I2C_PASSTHROUGH_CMD_SUBCODE_CODE  13
+/* I2C_PASSTHROUGH command, I2C_PASSTHRU field definition (address 2,size 1, lsb 0, unsigned) */
+#define Si2168B_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_LSB         0
+#define Si2168B_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_MASK        0x01
+#define Si2168B_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_MIN         0
+#define Si2168B_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_MAX         1
+#define Si2168B_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_CLOSE  1
+#define Si2168B_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_OPEN   0
+/* I2C_PASSTHROUGH command, RESERVED field definition (address 2,size 7, lsb 1, unsigned) */
+#define Si2168B_I2C_PASSTHROUGH_CMD_RESERVED_LSB         1
+#define Si2168B_I2C_PASSTHROUGH_CMD_RESERVED_MASK        0x7f
+#define Si2168B_I2C_PASSTHROUGH_CMD_RESERVED_MIN         0
+#define Si2168B_I2C_PASSTHROUGH_CMD_RESERVED_MAX         0
+#define Si2168B_I2C_PASSTHROUGH_CMD_RESERVED_RESERVED  0
+#endif /* Si2168B_I2C_PASSTHROUGH_CMD */
+
+/* Si2168B_MCNS_STATUS command definition */
+#define Si2168B_MCNS_STATUS_CMD 0x98
+
+#ifdef Si2168B_MCNS_STATUS_CMD
+#define Si2168B_MCNS_STATUS_CMD_CODE 0x010098
+
+typedef struct { /* Si2168B_MCNS_STATUS_CMD_struct */
+	u8  intack;
+} Si2168B_MCNS_STATUS_CMD_struct;
+
+typedef struct { /* Si2168B_MCNS_STATUS_CMD_REPLY_struct */
+	u8  pclint;
+	u8  dlint;
+	u8  berint;
+	u8  uncorint;
+	u8  pcl;
+	u8  dl;
+	u8  ber;
+	u8  uncor;
+	u8  cnr;
+	s16 afc_freq;
+	s16 timing_offset;
+	u8  constellation;
+	u8  sp_inv;
+	u8  interleaving;
+}  Si2168B_MCNS_STATUS_CMD_REPLY_struct;
+
+/* MCNS_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2168B_MCNS_STATUS_CMD_INTACK_LSB         0
+#define Si2168B_MCNS_STATUS_CMD_INTACK_MASK        0x01
+#define Si2168B_MCNS_STATUS_CMD_INTACK_MIN         0
+#define Si2168B_MCNS_STATUS_CMD_INTACK_MAX         1
+#define Si2168B_MCNS_STATUS_CMD_INTACK_CLEAR  1
+#define Si2168B_MCNS_STATUS_CMD_INTACK_OK     0
+/* MCNS_STATUS command, PCLINT field definition (address 1, size 1, lsb 1, unsigned)*/
+#define Si2168B_MCNS_STATUS_RESPONSE_PCLINT_LSB         1
+#define Si2168B_MCNS_STATUS_RESPONSE_PCLINT_MASK        0x01
+#define Si2168B_MCNS_STATUS_RESPONSE_PCLINT_CHANGED    1
+#define Si2168B_MCNS_STATUS_RESPONSE_PCLINT_NO_CHANGE  0
+/* MCNS_STATUS command, DLINT field definition (address 1, size 1, lsb 2, unsigned)*/
+#define Si2168B_MCNS_STATUS_RESPONSE_DLINT_LSB         2
+#define Si2168B_MCNS_STATUS_RESPONSE_DLINT_MASK        0x01
+#define Si2168B_MCNS_STATUS_RESPONSE_DLINT_CHANGED    1
+#define Si2168B_MCNS_STATUS_RESPONSE_DLINT_NO_CHANGE  0
+/* MCNS_STATUS command, BERINT field definition (address 1, size 1, lsb 3, unsigned)*/
+#define Si2168B_MCNS_STATUS_RESPONSE_BERINT_LSB         3
+#define Si2168B_MCNS_STATUS_RESPONSE_BERINT_MASK        0x01
+#define Si2168B_MCNS_STATUS_RESPONSE_BERINT_CHANGED    1
+#define Si2168B_MCNS_STATUS_RESPONSE_BERINT_NO_CHANGE  0
+/* MCNS_STATUS command, UNCORINT field definition (address 1, size 1, lsb 4, unsigned)*/
+#define Si2168B_MCNS_STATUS_RESPONSE_UNCORINT_LSB         4
+#define Si2168B_MCNS_STATUS_RESPONSE_UNCORINT_MASK        0x01
+#define Si2168B_MCNS_STATUS_RESPONSE_UNCORINT_CHANGED    1
+#define Si2168B_MCNS_STATUS_RESPONSE_UNCORINT_NO_CHANGE  0
+/* MCNS_STATUS command, PCL field definition (address 2, size 1, lsb 1, unsigned)*/
+#define Si2168B_MCNS_STATUS_RESPONSE_PCL_LSB         1
+#define Si2168B_MCNS_STATUS_RESPONSE_PCL_MASK        0x01
+#define Si2168B_MCNS_STATUS_RESPONSE_PCL_LOCKED   1
+#define Si2168B_MCNS_STATUS_RESPONSE_PCL_NO_LOCK  0
+/* MCNS_STATUS command, DL field definition (address 2, size 1, lsb 2, unsigned)*/
+#define Si2168B_MCNS_STATUS_RESPONSE_DL_LSB         2
+#define Si2168B_MCNS_STATUS_RESPONSE_DL_MASK        0x01
+#define Si2168B_MCNS_STATUS_RESPONSE_DL_LOCKED   1
+#define Si2168B_MCNS_STATUS_RESPONSE_DL_NO_LOCK  0
+/* MCNS_STATUS command, BER field definition (address 2, size 1, lsb 3, unsigned)*/
+#define Si2168B_MCNS_STATUS_RESPONSE_BER_LSB         3
+#define Si2168B_MCNS_STATUS_RESPONSE_BER_MASK        0x01
+#define Si2168B_MCNS_STATUS_RESPONSE_BER_BER_ABOVE  1
+#define Si2168B_MCNS_STATUS_RESPONSE_BER_BER_BELOW  0
+/* MCNS_STATUS command, UNCOR field definition (address 2, size 1, lsb 4, unsigned)*/
+#define Si2168B_MCNS_STATUS_RESPONSE_UNCOR_LSB         4
+#define Si2168B_MCNS_STATUS_RESPONSE_UNCOR_MASK        0x01
+#define Si2168B_MCNS_STATUS_RESPONSE_UNCOR_NO_UNCOR_FOUND  0
+#define Si2168B_MCNS_STATUS_RESPONSE_UNCOR_UNCOR_FOUND     1
+/* MCNS_STATUS command, CNR field definition (address 3, size 8, lsb 0, unsigned)*/
+#define Si2168B_MCNS_STATUS_RESPONSE_CNR_LSB         0
+#define Si2168B_MCNS_STATUS_RESPONSE_CNR_MASK        0xff
+/* MCNS_STATUS command, AFC_FREQ field definition (address 4, size 16, lsb 0, signed)*/
+#define Si2168B_MCNS_STATUS_RESPONSE_AFC_FREQ_LSB         0
+#define Si2168B_MCNS_STATUS_RESPONSE_AFC_FREQ_MASK        0xffff
+#define Si2168B_MCNS_STATUS_RESPONSE_AFC_FREQ_SHIFT       16
+/* MCNS_STATUS command, TIMING_OFFSET field definition (address 6, size 16, lsb 0, signed)*/
+#define Si2168B_MCNS_STATUS_RESPONSE_TIMING_OFFSET_LSB         0
+#define Si2168B_MCNS_STATUS_RESPONSE_TIMING_OFFSET_MASK        0xffff
+#define Si2168B_MCNS_STATUS_RESPONSE_TIMING_OFFSET_SHIFT       16
+/* MCNS_STATUS command, CONSTELLATION field definition (address 8, size 6, lsb 0, unsigned)*/
+#define Si2168B_MCNS_STATUS_RESPONSE_CONSTELLATION_LSB         0
+#define Si2168B_MCNS_STATUS_RESPONSE_CONSTELLATION_MASK        0x3f
+#define Si2168B_MCNS_STATUS_RESPONSE_CONSTELLATION_QAM256  11
+#define Si2168B_MCNS_STATUS_RESPONSE_CONSTELLATION_QAM64   9
+/* MCNS_STATUS command, SP_INV field definition (address 8, size 1, lsb 6, unsigned)*/
+#define Si2168B_MCNS_STATUS_RESPONSE_SP_INV_LSB         6
+#define Si2168B_MCNS_STATUS_RESPONSE_SP_INV_MASK        0x01
+#define Si2168B_MCNS_STATUS_RESPONSE_SP_INV_INVERTED  1
+#define Si2168B_MCNS_STATUS_RESPONSE_SP_INV_NORMAL    0
+/* MCNS_STATUS command, INTERLEAVING field definition (address 9, size 4, lsb 0, unsigned)*/
+#define Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_LSB         0
+#define Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_MASK        0x0f
+#define Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_0__128_1      0
+#define Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_10__128_6     10
+#define Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_11__RESERVED  11
+#define Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_12__128_7     12
+#define Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_13__RESERVED  13
+#define Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_14__128_8     14
+#define Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_15__RESERVED  15
+#define Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_1__128_1      1
+#define Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_2__128_2      2
+#define Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_3__64_2       3
+#define Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_4__128_3      4
+#define Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_5__32_4       5
+#define Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_6__128_4      6
+#define Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_7__16_8       7
+#define Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_8__128_5      8
+#define Si2168B_MCNS_STATUS_RESPONSE_INTERLEAVING_9__8_16       9
+
+#endif /* Si2168B_MCNS_STATUS_CMD */
+
+/* Si2168B_PART_INFO command definition */
+#define Si2168B_PART_INFO_CMD 0x02
+
+#ifdef Si2168B_PART_INFO_CMD
+#define Si2168B_PART_INFO_CMD_CODE 0x010002
+
+typedef struct { /* Si2168B_PART_INFO_CMD_struct */
+	u8  nothing;
+} Si2168B_PART_INFO_CMD_struct;
+
+typedef struct { /* Si2168B_PART_INFO_CMD_REPLY_struct */
+	u8  chiprev;
+	u8  romid;
+	u8  part;
+	u8  pmajor;
+	u8  pminor;
+	u8  pbuild;
+	u16 reserved;
+	u32 serial;
+}  Si2168B_PART_INFO_CMD_REPLY_struct;
+
+/* PART_INFO command, CHIPREV field definition (address 1, size 4, lsb 0, unsigned)*/
+#define Si2168B_PART_INFO_RESPONSE_CHIPREV_LSB         0
+#define Si2168B_PART_INFO_RESPONSE_CHIPREV_MASK        0x0f
+#define Si2168B_PART_INFO_RESPONSE_CHIPREV_A  1
+#define Si2168B_PART_INFO_RESPONSE_CHIPREV_B  2
+/* PART_INFO command, ROMID field definition (address 12, size 8, lsb 0, unsigned)*/
+#define Si2168B_PART_INFO_RESPONSE_ROMID_LSB         0
+#define Si2168B_PART_INFO_RESPONSE_ROMID_MASK        0xff
+/* PART_INFO command, PART field definition (address 2, size 8, lsb 0, unsigned)*/
+#define Si2168B_PART_INFO_RESPONSE_PART_LSB         0
+#define Si2168B_PART_INFO_RESPONSE_PART_MASK        0xff
+/* PART_INFO command, PMAJOR field definition (address 3, size 8, lsb 0, unsigned)*/
+#define Si2168B_PART_INFO_RESPONSE_PMAJOR_LSB         0
+#define Si2168B_PART_INFO_RESPONSE_PMAJOR_MASK        0xff
+/* PART_INFO command, PMINOR field definition (address 4, size 8, lsb 0, unsigned)*/
+#define Si2168B_PART_INFO_RESPONSE_PMINOR_LSB         0
+#define Si2168B_PART_INFO_RESPONSE_PMINOR_MASK        0xff
+/* PART_INFO command, PBUILD field definition (address 5, size 8, lsb 0, unsigned)*/
+#define Si2168B_PART_INFO_RESPONSE_PBUILD_LSB         0
+#define Si2168B_PART_INFO_RESPONSE_PBUILD_MASK        0xff
+/* PART_INFO command, RESERVED field definition (address 6, size 16, lsb 0, unsigned)*/
+#define Si2168B_PART_INFO_RESPONSE_RESERVED_LSB         0
+#define Si2168B_PART_INFO_RESPONSE_RESERVED_MASK        0xffff
+/* PART_INFO command, SERIAL field definition (address 8, size 32, lsb 0, unsigned)*/
+#define Si2168B_PART_INFO_RESPONSE_SERIAL_LSB         0
+#define Si2168B_PART_INFO_RESPONSE_SERIAL_MASK        0xffffffff
+
+#endif /* Si2168B_PART_INFO_CMD */
+
+/* Si2168B_POWER_DOWN command definition */
+#define Si2168B_POWER_DOWN_CMD 0x13
+
+#ifdef Si2168B_POWER_DOWN_CMD
+#define Si2168B_POWER_DOWN_CMD_CODE 0x010013
+
+typedef struct { /* Si2168B_POWER_DOWN_CMD_struct */
+	u8  nothing;
+} Si2168B_POWER_DOWN_CMD_struct;
+
+#endif /* Si2168B_POWER_DOWN_CMD */
+
+/* Si2168B_POWER_UP command definition */
+#define Si2168B_POWER_UP_CMD 0xc0
+
+#ifdef Si2168B_POWER_UP_CMD
+#define Si2168B_POWER_UP_CMD_CODE 0x0200c0
+
+typedef struct { /* Si2168B_POWER_UP_CMD_struct */
+	u8  subcode;
+	u8  reset;
+	u8  reserved2;
+	u8  reserved4;
+	u8  reserved1;
+	u8  addr_mode;
+	u8  reserved5;
+	u8  func;
+	u8  clock_freq;
+	u8  ctsien;
+	u8  wake_up;
+} Si2168B_POWER_UP_CMD_struct;
+
+/* POWER_UP command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2168B_POWER_UP_CMD_SUBCODE_LSB         0
+#define Si2168B_POWER_UP_CMD_SUBCODE_MASK        0xff
+#define Si2168B_POWER_UP_CMD_SUBCODE_MIN         6
+#define Si2168B_POWER_UP_CMD_SUBCODE_MAX         6
+#define Si2168B_POWER_UP_CMD_SUBCODE_CODE  6
+/* POWER_UP command, RESET field definition (address 2,size 8, lsb 0, unsigned) */
+#define Si2168B_POWER_UP_CMD_RESET_LSB         0
+#define Si2168B_POWER_UP_CMD_RESET_MASK        0xff
+#define Si2168B_POWER_UP_CMD_RESET_MIN         1
+#define Si2168B_POWER_UP_CMD_RESET_MAX         8
+#define Si2168B_POWER_UP_CMD_RESET_RESET   1
+#define Si2168B_POWER_UP_CMD_RESET_RESUME  8
+/* POWER_UP command, RESERVED2 field definition (address 3,size 8, lsb 0, unsigned) */
+#define Si2168B_POWER_UP_CMD_RESERVED2_LSB         0
+#define Si2168B_POWER_UP_CMD_RESERVED2_MASK        0xff
+#define Si2168B_POWER_UP_CMD_RESERVED2_MIN         15
+#define Si2168B_POWER_UP_CMD_RESERVED2_MAX         15
+#define Si2168B_POWER_UP_CMD_RESERVED2_RESERVED  15
+/* POWER_UP command, RESERVED4 field definition (address 4,size 8, lsb 0, unsigned) */
+#define Si2168B_POWER_UP_CMD_RESERVED4_LSB         0
+#define Si2168B_POWER_UP_CMD_RESERVED4_MASK        0xff
+#define Si2168B_POWER_UP_CMD_RESERVED4_MIN         0
+#define Si2168B_POWER_UP_CMD_RESERVED4_MAX         0
+#define Si2168B_POWER_UP_CMD_RESERVED4_RESERVED  0
+/* POWER_UP command, RESERVED1 field definition (address 5,size 4, lsb 0, unsigned) */
+#define Si2168B_POWER_UP_CMD_RESERVED1_LSB         0
+#define Si2168B_POWER_UP_CMD_RESERVED1_MASK        0x0f
+#define Si2168B_POWER_UP_CMD_RESERVED1_MIN         0
+#define Si2168B_POWER_UP_CMD_RESERVED1_MAX         0
+#define Si2168B_POWER_UP_CMD_RESERVED1_RESERVED  0
+/* POWER_UP command, ADDR_MODE field definition (address 5,size 1, lsb 4, unsigned) */
+#define Si2168B_POWER_UP_CMD_ADDR_MODE_LSB         4
+#define Si2168B_POWER_UP_CMD_ADDR_MODE_MASK        0x01
+#define Si2168B_POWER_UP_CMD_ADDR_MODE_MIN         0
+#define Si2168B_POWER_UP_CMD_ADDR_MODE_MAX         1
+#define Si2168B_POWER_UP_CMD_ADDR_MODE_CAPTURE  1
+#define Si2168B_POWER_UP_CMD_ADDR_MODE_CURRENT  0
+/* POWER_UP command, RESERVED5 field definition (address 5,size 1, lsb 5, unsigned) */
+#define Si2168B_POWER_UP_CMD_RESERVED5_LSB         5
+#define Si2168B_POWER_UP_CMD_RESERVED5_MASK        0x01
+#define Si2168B_POWER_UP_CMD_RESERVED5_MIN         1
+#define Si2168B_POWER_UP_CMD_RESERVED5_MAX         1
+#define Si2168B_POWER_UP_CMD_RESERVED5_RESERVED  1
+/* POWER_UP command, FUNC field definition (address 6,size 4, lsb 0, unsigned) */
+#define Si2168B_POWER_UP_CMD_FUNC_LSB         0
+#define Si2168B_POWER_UP_CMD_FUNC_MASK        0x0f
+#define Si2168B_POWER_UP_CMD_FUNC_MIN         0
+#define Si2168B_POWER_UP_CMD_FUNC_MAX         1
+#define Si2168B_POWER_UP_CMD_FUNC_BOOTLOADER  0
+#define Si2168B_POWER_UP_CMD_FUNC_NORMAL      1
+/* POWER_UP command, CLOCK_FREQ field definition (address 6,size 3, lsb 4, unsigned) */
+#define Si2168B_POWER_UP_CMD_CLOCK_FREQ_LSB         4
+#define Si2168B_POWER_UP_CMD_CLOCK_FREQ_MASK        0x07
+#define Si2168B_POWER_UP_CMD_CLOCK_FREQ_MIN         0
+#define Si2168B_POWER_UP_CMD_CLOCK_FREQ_MAX         4
+#define Si2168B_POWER_UP_CMD_CLOCK_FREQ_CLK_16MHZ  0
+#define Si2168B_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ  2
+#define Si2168B_POWER_UP_CMD_CLOCK_FREQ_CLK_27MHZ  3
+/* POWER_UP command, CTSIEN field definition (address 6,size 1, lsb 7, unsigned) */
+#define Si2168B_POWER_UP_CMD_CTSIEN_LSB         7
+#define Si2168B_POWER_UP_CMD_CTSIEN_MASK        0x01
+#define Si2168B_POWER_UP_CMD_CTSIEN_MIN         0
+#define Si2168B_POWER_UP_CMD_CTSIEN_MAX         1
+#define Si2168B_POWER_UP_CMD_CTSIEN_DISABLE  0
+#define Si2168B_POWER_UP_CMD_CTSIEN_ENABLE   1
+/* POWER_UP command, WAKE_UP field definition (address 7,size 1, lsb 0, unsigned) */
+#define Si2168B_POWER_UP_CMD_WAKE_UP_LSB         0
+#define Si2168B_POWER_UP_CMD_WAKE_UP_MASK        0x01
+#define Si2168B_POWER_UP_CMD_WAKE_UP_MIN         1
+#define Si2168B_POWER_UP_CMD_WAKE_UP_MAX         1
+#define Si2168B_POWER_UP_CMD_WAKE_UP_WAKE_UP  1
+#endif /* Si2168B_POWER_UP_CMD */
+
+/* Si2168B_RSSI_ADC command definition */
+#define Si2168B_RSSI_ADC_CMD 0x17
+
+#ifdef Si2168B_RSSI_ADC_CMD
+#define Si2168B_RSSI_ADC_CMD_CODE 0x010017
+
+typedef struct { /* Si2168B_RSSI_ADC_CMD_struct */
+	u8  on_off;
+} Si2168B_RSSI_ADC_CMD_struct;
+
+typedef struct { /* Si2168B_RSSI_ADC_CMD_REPLY_struct */
+	u8  level;
+}  Si2168B_RSSI_ADC_CMD_REPLY_struct;
+
+/* RSSI_ADC command, ON_OFF field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2168B_RSSI_ADC_CMD_ON_OFF_LSB         0
+#define Si2168B_RSSI_ADC_CMD_ON_OFF_MASK        0x01
+#define Si2168B_RSSI_ADC_CMD_ON_OFF_MIN         0
+#define Si2168B_RSSI_ADC_CMD_ON_OFF_MAX         1
+#define Si2168B_RSSI_ADC_CMD_ON_OFF_OFF  0
+#define Si2168B_RSSI_ADC_CMD_ON_OFF_ON   1
+/* RSSI_ADC command, LEVEL field definition (address 1, size 8, lsb 0, unsigned)*/
+#define Si2168B_RSSI_ADC_RESPONSE_LEVEL_LSB         0
+#define Si2168B_RSSI_ADC_RESPONSE_LEVEL_MASK        0xff
+
+#endif /* Si2168B_RSSI_ADC_CMD */
+
+/* Si2168B_SCAN_CTRL command definition */
+#define Si2168B_SCAN_CTRL_CMD 0x31
+
+#ifdef Si2168B_SCAN_CTRL_CMD
+#define Si2168B_SCAN_CTRL_CMD_CODE 0x010031
+
+typedef struct { /* Si2168B_SCAN_CTRL_CMD_struct */
+	u8  action;
+	u32 tuned_rf_freq;
+} Si2168B_SCAN_CTRL_CMD_struct;
+
+/* SCAN_CTRL command, ACTION field definition (address 1,size 4, lsb 0, unsigned) */
+#define Si2168B_SCAN_CTRL_CMD_ACTION_LSB         0
+#define Si2168B_SCAN_CTRL_CMD_ACTION_MASK        0x0f
+#define Si2168B_SCAN_CTRL_CMD_ACTION_MIN         1
+#define Si2168B_SCAN_CTRL_CMD_ACTION_MAX         3
+#define Si2168B_SCAN_CTRL_CMD_ACTION_ABORT   3
+#define Si2168B_SCAN_CTRL_CMD_ACTION_RESUME  2
+#define Si2168B_SCAN_CTRL_CMD_ACTION_START   1
+/* SCAN_CTRL command, TUNED_RF_FREQ field definition (address 4,size 32, lsb 0, unsigned) */
+#define Si2168B_SCAN_CTRL_CMD_TUNED_RF_FREQ_LSB         0
+#define Si2168B_SCAN_CTRL_CMD_TUNED_RF_FREQ_MASK        0xffffffff
+#define Si2168B_SCAN_CTRL_CMD_TUNED_RF_FREQ_MIN         0
+#define Si2168B_SCAN_CTRL_CMD_TUNED_RF_FREQ_MAX         4294967
+#define Si2168B_SCAN_CTRL_CMD_TUNED_RF_FREQ_TUNED_RF_FREQ_MIN  0
+#define Si2168B_SCAN_CTRL_CMD_TUNED_RF_FREQ_TUNED_RF_FREQ_MAX  4294967
+#endif /* Si2168B_SCAN_CTRL_CMD */
+
+/* Si2168B_SCAN_STATUS command definition */
+#define Si2168B_SCAN_STATUS_CMD 0x30
+
+#ifdef Si2168B_SCAN_STATUS_CMD
+#define Si2168B_SCAN_STATUS_CMD_CODE 0x010030
+
+typedef struct { /* Si2168B_SCAN_STATUS_CMD_struct */
+	u8  intack;
+} Si2168B_SCAN_STATUS_CMD_struct;
+
+typedef struct { /* Si2168B_SCAN_STATUS_CMD_REPLY_struct */
+	u8  buzint;
+	u8  reqint;
+	u8  modulation;
+	u8  buz;
+	u8  req;
+	u8  scan_status;
+	u32 rf_freq;
+	u16 symb_rate;
+}  Si2168B_SCAN_STATUS_CMD_REPLY_struct;
+
+/* SCAN_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2168B_SCAN_STATUS_CMD_INTACK_LSB         0
+#define Si2168B_SCAN_STATUS_CMD_INTACK_MASK        0x01
+#define Si2168B_SCAN_STATUS_CMD_INTACK_MIN         0
+#define Si2168B_SCAN_STATUS_CMD_INTACK_MAX         1
+#define Si2168B_SCAN_STATUS_CMD_INTACK_CLEAR  1
+#define Si2168B_SCAN_STATUS_CMD_INTACK_OK     0
+/* SCAN_STATUS command, BUZINT field definition (address 1, size 1, lsb 0, unsigned)*/
+#define Si2168B_SCAN_STATUS_RESPONSE_BUZINT_LSB         0
+#define Si2168B_SCAN_STATUS_RESPONSE_BUZINT_MASK        0x01
+#define Si2168B_SCAN_STATUS_RESPONSE_BUZINT_CHANGED    1
+#define Si2168B_SCAN_STATUS_RESPONSE_BUZINT_NO_CHANGE  0
+/* SCAN_STATUS command, REQINT field definition (address 1, size 1, lsb 1, unsigned)*/
+#define Si2168B_SCAN_STATUS_RESPONSE_REQINT_LSB         1
+#define Si2168B_SCAN_STATUS_RESPONSE_REQINT_MASK        0x01
+#define Si2168B_SCAN_STATUS_RESPONSE_REQINT_CHANGED    1
+#define Si2168B_SCAN_STATUS_RESPONSE_REQINT_NO_CHANGE  0
+/* SCAN_STATUS command, MODULATION field definition (address 10, size 4, lsb 0, unsigned)*/
+#define Si2168B_SCAN_STATUS_RESPONSE_MODULATION_LSB         0
+#define Si2168B_SCAN_STATUS_RESPONSE_MODULATION_MASK        0x0f
+#define Si2168B_SCAN_STATUS_RESPONSE_MODULATION_DSS    10
+#define Si2168B_SCAN_STATUS_RESPONSE_MODULATION_DVBC   3
+#define Si2168B_SCAN_STATUS_RESPONSE_MODULATION_DVBC2  11
+#define Si2168B_SCAN_STATUS_RESPONSE_MODULATION_DVBS   8
+#define Si2168B_SCAN_STATUS_RESPONSE_MODULATION_DVBS2  9
+#define Si2168B_SCAN_STATUS_RESPONSE_MODULATION_DVBT   2
+#define Si2168B_SCAN_STATUS_RESPONSE_MODULATION_DVBT2  7
+#define Si2168B_SCAN_STATUS_RESPONSE_MODULATION_MCNS   1
+/* SCAN_STATUS command, BUZ field definition (address 2, size 1, lsb 0, unsigned)*/
+#define Si2168B_SCAN_STATUS_RESPONSE_BUZ_LSB         0
+#define Si2168B_SCAN_STATUS_RESPONSE_BUZ_MASK        0x01
+#define Si2168B_SCAN_STATUS_RESPONSE_BUZ_BUSY  1
+#define Si2168B_SCAN_STATUS_RESPONSE_BUZ_CTS   0
+/* SCAN_STATUS command, REQ field definition (address 2, size 1, lsb 1, unsigned)*/
+#define Si2168B_SCAN_STATUS_RESPONSE_REQ_LSB         1
+#define Si2168B_SCAN_STATUS_RESPONSE_REQ_MASK        0x01
+#define Si2168B_SCAN_STATUS_RESPONSE_REQ_NO_REQUEST  0
+#define Si2168B_SCAN_STATUS_RESPONSE_REQ_REQUEST     1
+/* SCAN_STATUS command, SCAN_STATUS field definition (address 3, size 6, lsb 0, unsigned)*/
+#define Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_LSB         0
+#define Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_MASK        0x3f
+#define Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_ANALOG_CHANNEL_FOUND   6
+#define Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_DEBUG                  63
+#define Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_DIGITAL_CHANNEL_FOUND  5
+#define Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_ENDED                  2
+#define Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_ERROR                  3
+#define Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_IDLE                   0
+#define Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_SEARCHING              1
+#define Si2168B_SCAN_STATUS_RESPONSE_SCAN_STATUS_TUNE_REQUEST           4
+/* SCAN_STATUS command, RF_FREQ field definition (address 4, size 32, lsb 0, unsigned)*/
+#define Si2168B_SCAN_STATUS_RESPONSE_RF_FREQ_LSB         0
+#define Si2168B_SCAN_STATUS_RESPONSE_RF_FREQ_MASK        0xffffffff
+/* SCAN_STATUS command, SYMB_RATE field definition (address 8, size 16, lsb 0, unsigned)*/
+#define Si2168B_SCAN_STATUS_RESPONSE_SYMB_RATE_LSB         0
+#define Si2168B_SCAN_STATUS_RESPONSE_SYMB_RATE_MASK        0xffff
+
+#endif /* Si2168B_SCAN_STATUS_CMD */
+
+/* Si2168B_SET_PROPERTY command definition */
+#define Si2168B_SET_PROPERTY_CMD 0x14
+
+#ifdef Si2168B_SET_PROPERTY_CMD
+#define Si2168B_SET_PROPERTY_CMD_CODE 0x010014
+
+typedef struct { /* Si2168B_SET_PROPERTY_CMD_struct */
+	u8  reserved;
+	u16 prop;
+	u16 data;
+} Si2168B_SET_PROPERTY_CMD_struct;
+
+typedef struct { /* Si2168B_SET_PROPERTY_CMD_REPLY_struct */
+	u8  reserved;
+	u16 data;
+} Si2168B_SET_PROPERTY_CMD_REPLY_struct;
+
+/* SET_PROPERTY command, RESERVED field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2168B_SET_PROPERTY_CMD_RESERVED_LSB         0
+#define Si2168B_SET_PROPERTY_CMD_RESERVED_MASK        0xff
+#define Si2168B_SET_PROPERTY_CMD_RESERVED_MIN         0
+#define Si2168B_SET_PROPERTY_CMD_RESERVED_MAX         255
+/* SET_PROPERTY command, PROP field definition (address 2,size 16, lsb 0, unsigned) */
+#define Si2168B_SET_PROPERTY_CMD_PROP_LSB         0
+#define Si2168B_SET_PROPERTY_CMD_PROP_MASK        0xffff
+#define Si2168B_SET_PROPERTY_CMD_PROP_MIN         0
+#define Si2168B_SET_PROPERTY_CMD_PROP_MAX         65535
+#define Si2168B_SET_PROPERTY_CMD_PROP_PROP_MIN  0
+#define Si2168B_SET_PROPERTY_CMD_PROP_PROP_MAX  65535
+/* SET_PROPERTY command, DATA field definition (address 4,size 16, lsb 0, unsigned) */
+#define Si2168B_SET_PROPERTY_CMD_DATA_LSB         0
+#define Si2168B_SET_PROPERTY_CMD_DATA_MASK        0xffff
+#define Si2168B_SET_PROPERTY_CMD_DATA_MIN         0
+#define Si2168B_SET_PROPERTY_CMD_DATA_MAX         65535
+#define Si2168B_SET_PROPERTY_CMD_DATA_DATA_MIN  0
+#define Si2168B_SET_PROPERTY_CMD_DATA_DATA_MAX  65535
+/* SET_PROPERTY command, RESERVED field definition (address 1, size 8, lsb 0, unsigned)*/
+#define Si2168B_SET_PROPERTY_RESPONSE_RESERVED_LSB         0
+#define Si2168B_SET_PROPERTY_RESPONSE_RESERVED_MASK        0xff
+#define Si2168B_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MIN  0
+#define Si2168B_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MAX  0
+/* SET_PROPERTY command, DATA field definition (address 2, size 16, lsb 0, unsigned)*/
+#define Si2168B_SET_PROPERTY_RESPONSE_DATA_LSB         0
+#define Si2168B_SET_PROPERTY_RESPONSE_DATA_MASK        0xffff
+
+#endif /* Si2168B_SET_PROPERTY_CMD */
+
+/* Si2168B_SPI_LINK command definition */
+#define Si2168B_SPI_LINK_CMD 0xc0
+
+#ifdef Si2168B_SPI_LINK_CMD
+#define Si2168B_SPI_LINK_CMD_CODE 0x0400c0
+
+typedef struct { /* Si2168B_SPI_LINK_CMD_struct */
+	u8  subcode;
+	u8  spi_pbl_key;
+	u8  spi_pbl_num;
+	u8  spi_conf_clk;
+	u8  spi_clk_pola;
+	u8  spi_conf_data;
+	u8  spi_data_dir;
+	u8  spi_enable;
+} Si2168B_SPI_LINK_CMD_struct;
+
+/* SPI_LINK command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2168B_SPI_LINK_CMD_SUBCODE_LSB         0
+#define Si2168B_SPI_LINK_CMD_SUBCODE_MASK        0xff
+#define Si2168B_SPI_LINK_CMD_SUBCODE_MIN         56
+#define Si2168B_SPI_LINK_CMD_SUBCODE_MAX         56
+#define Si2168B_SPI_LINK_CMD_SUBCODE_CODE  56
+/* SPI_LINK command, SPI_PBL_KEY field definition (address 2,size 8, lsb 0, unsigned) */
+#define Si2168B_SPI_LINK_CMD_SPI_PBL_KEY_LSB         0
+#define Si2168B_SPI_LINK_CMD_SPI_PBL_KEY_MASK        0xff
+#define Si2168B_SPI_LINK_CMD_SPI_PBL_KEY_MIN         0
+#define Si2168B_SPI_LINK_CMD_SPI_PBL_KEY_MAX         255
+/* SPI_LINK command, SPI_PBL_NUM field definition (address 3,size 4, lsb 0, unsigned) */
+#define Si2168B_SPI_LINK_CMD_SPI_PBL_NUM_LSB         0
+#define Si2168B_SPI_LINK_CMD_SPI_PBL_NUM_MASK        0x0f
+#define Si2168B_SPI_LINK_CMD_SPI_PBL_NUM_MIN         0
+#define Si2168B_SPI_LINK_CMD_SPI_PBL_NUM_MAX         15
+/* SPI_LINK command, SPI_CONF_CLK field definition (address 4,size 4, lsb 0, unsigned) */
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_CLK_LSB         0
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_CLK_MASK        0x0f
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_CLK_MIN         0
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_CLK_MAX         9
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_CLK_DISABLE     0
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_CLK_DISEQC_CMD  9
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_CLK_DISEQC_IN   7
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_CLK_DISEQC_OUT  8
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_CLK_GPIO0       5
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_CLK_GPIO1       6
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_CLK_MP_A        1
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_CLK_MP_B        2
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_CLK_MP_C        3
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_CLK_MP_D        4
+/* SPI_LINK command, SPI_CLK_POLA field definition (address 4,size 1, lsb 4, unsigned) */
+#define Si2168B_SPI_LINK_CMD_SPI_CLK_POLA_LSB         4
+#define Si2168B_SPI_LINK_CMD_SPI_CLK_POLA_MASK        0x01
+#define Si2168B_SPI_LINK_CMD_SPI_CLK_POLA_MIN         0
+#define Si2168B_SPI_LINK_CMD_SPI_CLK_POLA_MAX         1
+#define Si2168B_SPI_LINK_CMD_SPI_CLK_POLA_FALLING  1
+#define Si2168B_SPI_LINK_CMD_SPI_CLK_POLA_RISING   0
+/* SPI_LINK command, SPI_CONF_DATA field definition (address 5,size 4, lsb 0, unsigned) */
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_DATA_LSB         0
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_DATA_MASK        0x0f
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_DATA_MIN         0
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_DATA_MAX         9
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_DATA_DISABLE     0
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_DATA_DISEQC_CMD  9
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_DATA_DISEQC_IN   7
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_DATA_DISEQC_OUT  8
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_DATA_GPIO0       5
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_DATA_GPIO1       6
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_DATA_MP_A        1
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_DATA_MP_B        2
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_DATA_MP_C        3
+#define Si2168B_SPI_LINK_CMD_SPI_CONF_DATA_MP_D        4
+/* SPI_LINK command, SPI_DATA_DIR field definition (address 5,size 1, lsb 4, unsigned) */
+#define Si2168B_SPI_LINK_CMD_SPI_DATA_DIR_LSB         4
+#define Si2168B_SPI_LINK_CMD_SPI_DATA_DIR_MASK        0x01
+#define Si2168B_SPI_LINK_CMD_SPI_DATA_DIR_MIN         0
+#define Si2168B_SPI_LINK_CMD_SPI_DATA_DIR_MAX         1
+#define Si2168B_SPI_LINK_CMD_SPI_DATA_DIR_LSB_FIRST  1
+#define Si2168B_SPI_LINK_CMD_SPI_DATA_DIR_MSB_FIRST  0
+/* SPI_LINK command, SPI_ENABLE field definition (address 6,size 1, lsb 0, unsigned) */
+#define Si2168B_SPI_LINK_CMD_SPI_ENABLE_LSB         0
+#define Si2168B_SPI_LINK_CMD_SPI_ENABLE_MASK        0x01
+#define Si2168B_SPI_LINK_CMD_SPI_ENABLE_MIN         0
+#define Si2168B_SPI_LINK_CMD_SPI_ENABLE_MAX         1
+#define Si2168B_SPI_LINK_CMD_SPI_ENABLE_DISABLE  0
+#define Si2168B_SPI_LINK_CMD_SPI_ENABLE_ENABLE   1
+#endif /* Si2168B_SPI_LINK_CMD */
+
+/* Si2168B_SPI_PASSTHROUGH command definition */
+#define Si2168B_SPI_PASSTHROUGH_CMD 0xc0
+
+#ifdef Si2168B_SPI_PASSTHROUGH_CMD
+#define Si2168B_SPI_PASSTHROUGH_CMD_CODE 0x0500c0
+
+typedef struct { /* Si2168B_SPI_PASSTHROUGH_CMD_struct */
+	u8  subcode;
+	u8  spi_passthr_clk;
+	u8  spi_passth_data;
+} Si2168B_SPI_PASSTHROUGH_CMD_struct;
+
+/* SPI_PASSTHROUGH command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2168B_SPI_PASSTHROUGH_CMD_SUBCODE_LSB         0
+#define Si2168B_SPI_PASSTHROUGH_CMD_SUBCODE_MASK        0xff
+#define Si2168B_SPI_PASSTHROUGH_CMD_SUBCODE_MIN         64
+#define Si2168B_SPI_PASSTHROUGH_CMD_SUBCODE_MAX         64
+#define Si2168B_SPI_PASSTHROUGH_CMD_SUBCODE_CODE  64
+/* SPI_PASSTHROUGH command, SPI_PASSTHR_CLK field definition (address 2,size 4, lsb 0, unsigned) */
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTHR_CLK_LSB         0
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTHR_CLK_MASK        0x0f
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTHR_CLK_MIN         0
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTHR_CLK_MAX         10
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTHR_CLK_DISABLE     0
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTHR_CLK_DISEQC_CMD  9
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTHR_CLK_DISEQC_IN   7
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTHR_CLK_DISEQC_OUT  8
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTHR_CLK_GPIO0       5
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTHR_CLK_GPIO1       6
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTHR_CLK_MP_A        1
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTHR_CLK_MP_B        2
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTHR_CLK_MP_C        3
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTHR_CLK_MP_D        4
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTHR_CLK_SCL_MAST    10
+/* SPI_PASSTHROUGH command, SPI_PASSTH_DATA field definition (address 3,size 4, lsb 0, unsigned) */
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTH_DATA_LSB         0
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTH_DATA_MASK        0x0f
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTH_DATA_MIN         0
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTH_DATA_MAX         10
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTH_DATA_DISABLE     0
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTH_DATA_DISEQC_CMD  9
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTH_DATA_DISEQC_IN   7
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTH_DATA_DISEQC_OUT  8
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTH_DATA_GPIO0       5
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTH_DATA_GPIO1       6
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTH_DATA_MP_A        1
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTH_DATA_MP_B        2
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTH_DATA_MP_C        3
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTH_DATA_MP_D        4
+#define Si2168B_SPI_PASSTHROUGH_CMD_SPI_PASSTH_DATA_SDA_MAST    10
+#endif /* Si2168B_SPI_PASSTHROUGH_CMD */
+
+/* Si2168B_START_CLK command definition */
+#define Si2168B_START_CLK_CMD 0xc0
+
+#ifdef Si2168B_START_CLK_CMD
+#define Si2168B_START_CLK_CMD_CODE 0x0300c0
+
+typedef struct { /* Si2168B_START_CLK_CMD_struct */
+	u8  subcode;
+	u8  reserved1;
+	u8  tune_cap;
+	u8  reserved2;
+	u16 clk_mode;
+	u8  reserved3;
+	u8  reserved4;
+	u8  start_clk;
+} Si2168B_START_CLK_CMD_struct;
+
+/* START_CLK command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2168B_START_CLK_CMD_SUBCODE_LSB         0
+#define Si2168B_START_CLK_CMD_SUBCODE_MASK        0xff
+#define Si2168B_START_CLK_CMD_SUBCODE_MIN         18
+#define Si2168B_START_CLK_CMD_SUBCODE_MAX         18
+#define Si2168B_START_CLK_CMD_SUBCODE_CODE  18
+/* START_CLK command, RESERVED1 field definition (address 2,size 8, lsb 0, unsigned) */
+#define Si2168B_START_CLK_CMD_RESERVED1_LSB         0
+#define Si2168B_START_CLK_CMD_RESERVED1_MASK        0xff
+#define Si2168B_START_CLK_CMD_RESERVED1_MIN         0
+#define Si2168B_START_CLK_CMD_RESERVED1_MAX         0
+#define Si2168B_START_CLK_CMD_RESERVED1_RESERVED  0
+/* START_CLK command, TUNE_CAP field definition (address 3,size 4, lsb 0, unsigned) */
+#define Si2168B_START_CLK_CMD_TUNE_CAP_LSB         0
+#define Si2168B_START_CLK_CMD_TUNE_CAP_MASK        0x0f
+#define Si2168B_START_CLK_CMD_TUNE_CAP_MIN         0
+#define Si2168B_START_CLK_CMD_TUNE_CAP_MAX         15
+#define Si2168B_START_CLK_CMD_TUNE_CAP_10P4     8
+#define Si2168B_START_CLK_CMD_TUNE_CAP_11P7     9
+#define Si2168B_START_CLK_CMD_TUNE_CAP_13P0     10
+#define Si2168B_START_CLK_CMD_TUNE_CAP_14P3     11
+#define Si2168B_START_CLK_CMD_TUNE_CAP_15P6     12
+#define Si2168B_START_CLK_CMD_TUNE_CAP_16P9     13
+#define Si2168B_START_CLK_CMD_TUNE_CAP_18P2     14
+#define Si2168B_START_CLK_CMD_TUNE_CAP_19P5     15
+#define Si2168B_START_CLK_CMD_TUNE_CAP_1P3      1
+#define Si2168B_START_CLK_CMD_TUNE_CAP_2P6      2
+#define Si2168B_START_CLK_CMD_TUNE_CAP_3P9      3
+#define Si2168B_START_CLK_CMD_TUNE_CAP_5P2      4
+#define Si2168B_START_CLK_CMD_TUNE_CAP_6P5      5
+#define Si2168B_START_CLK_CMD_TUNE_CAP_7P8      6
+#define Si2168B_START_CLK_CMD_TUNE_CAP_9P1      7
+#define Si2168B_START_CLK_CMD_TUNE_CAP_EXT_CLK  0
+/* START_CLK command, RESERVED2 field definition (address 3,size 4, lsb 4, unsigned) */
+#define Si2168B_START_CLK_CMD_RESERVED2_LSB         4
+#define Si2168B_START_CLK_CMD_RESERVED2_MASK        0x0f
+#define Si2168B_START_CLK_CMD_RESERVED2_MIN         0
+#define Si2168B_START_CLK_CMD_RESERVED2_MAX         0
+#define Si2168B_START_CLK_CMD_RESERVED2_RESERVED  0
+/* START_CLK command, CLK_MODE field definition (address 4,size 12, lsb 0, unsigned) */
+#define Si2168B_START_CLK_CMD_CLK_MODE_LSB         0
+#define Si2168B_START_CLK_CMD_CLK_MODE_MASK        0xfff
+#define Si2168B_START_CLK_CMD_CLK_MODE_MIN         575
+#define Si2168B_START_CLK_CMD_CLK_MODE_MAX         3328
+#define Si2168B_START_CLK_CMD_CLK_MODE_CLK_CLKIO    3328
+#define Si2168B_START_CLK_CMD_CLK_MODE_CLK_XTAL_IN  1536
+#define Si2168B_START_CLK_CMD_CLK_MODE_XTAL         575
+/* START_CLK command, RESERVED3 field definition (address 6,size 8, lsb 0, unsigned) */
+#define Si2168B_START_CLK_CMD_RESERVED3_LSB         0
+#define Si2168B_START_CLK_CMD_RESERVED3_MASK        0xff
+#define Si2168B_START_CLK_CMD_RESERVED3_MIN         22
+#define Si2168B_START_CLK_CMD_RESERVED3_MAX         22
+#define Si2168B_START_CLK_CMD_RESERVED3_RESERVED  22
+/* START_CLK command, RESERVED4 field definition (address 7,size 1, lsb 0, unsigned) */
+#define Si2168B_START_CLK_CMD_RESERVED4_LSB         0
+#define Si2168B_START_CLK_CMD_RESERVED4_MASK        0x01
+#define Si2168B_START_CLK_CMD_RESERVED4_MIN         0
+#define Si2168B_START_CLK_CMD_RESERVED4_MAX         0
+#define Si2168B_START_CLK_CMD_RESERVED4_RESERVED  0
+/* START_CLK command, START_CLK field definition (address 12,size 1, lsb 0, unsigned) */
+#define Si2168B_START_CLK_CMD_START_CLK_LSB         0
+#define Si2168B_START_CLK_CMD_START_CLK_MASK        0x01
+#define Si2168B_START_CLK_CMD_START_CLK_MIN         0
+#define Si2168B_START_CLK_CMD_START_CLK_MAX         0
+#define Si2168B_START_CLK_CMD_START_CLK_START_CLK  0
+#endif /* Si2168B_START_CLK_CMD */
+
+/* readback values (detected channel properties) */
+typedef struct { /* Si2168B_CHANNEL_SEEK_NEXT_REPLY_struct */
+    s32 freq;
+    u32 bandwidth_Hz;
+    u32 symbol_rate_bps;
+    u8  stream;
+	u8  standard;
+    u8  constellation;
+    u8  num_plp;
+    u8  T2_base_lite;
+} Si2168B_CHANNEL_SEEK_NEXT_REPLY_struct;
+
+typedef struct {
+	u32  rangeMin;
+	u32  rangeMax;
+	u32  seekBWHz;
+	u32  seekStepHz;
+	u32  minSRbps;
+	u32  maxSRbps;
+	/*int  minRSSIdBm;*/
+	/*int  maxRSSIdBm;*/
+	/*int  minSNRHalfdB;*/
+	/*int  maxSNRHalfdB;*/
+} Si2168B_CHANNEL_SEEK_PARAM_struct;
+
+#define Si2168B_GET_COMMAND_STRINGS
+
+#define NO_Si2168B_ERROR                     0x00
+#define ERROR_Si2168B_PARAMETER_OUT_OF_RANGE 0x01
+#define ERROR_Si2168B_ALLOCATING_CONTEXT     0x02
+#define ERROR_Si2168B_SENDING_COMMAND        0x03
+#define ERROR_Si2168B_CTS_TIMEOUT            0x04
+#define ERROR_Si2168B_ERR                    0x05
+#define ERROR_Si2168B_POLLING_CTS            0x06
+#define ERROR_Si2168B_POLLING_RESPONSE       0x07
+#define ERROR_Si2168B_LOADING_FIRMWARE       0x08
+#define ERROR_Si2168B_LOADING_BOOTBLOCK      0x09
+#define ERROR_Si2168B_STARTING_FIRMWARE      0x0a
+#define ERROR_Si2168B_SW_RESET               0x0b
+#define ERROR_Si2168B_INCOMPATIBLE_PART      0x0c
+#define ERROR_Si2168B_DISEQC_BUS_NOT_READY   0x0d
+#define ERROR_Si2168B_UNKNOWN_COMMAND        0xf0
+#define ERROR_Si2168B_UNKNOWN_PROPERTY       0xf1
+
+typedef int  (*Si2168B_INDIRECT_I2C_FUNC)  (void*);
+
+typedef struct si2168b_context {
+	struct i2c_adapter *i2c_adap;
+	u8  address;
+	u8  i2c_addr;
+	u8  power_up_reset;
+	u8  power_up_func;
+	u8  scan_ctrl_action;
+	u8  dd_mode_modulation;
+	u8  dd_mode_auto_detect;
+	u8  dd_mode_invert_spectrum;
+	u8  dd_mode_bw;
+	u8  dvbt_hierarchy_stream;
+	u16 dvbc_symbol_rate;
+	u16 scan_fmin;
+	u16 scan_fmax;
+	u16 scan_symb_rate_min;
+	u16 scan_symb_rate_max;
+	u8  status_ddint;
+	u8  status_scanint;
+	u8  status_err;
+	u8  status_cts;
+	u8  media;
+
+	/* _additional_struct_members_point */
+	Si2168B_CLOCK_SOURCE tuner_ter_clock_source;
+	u8  tuner_ter_clock_freq;
+	u16 tuner_ter_clock_input;
+	u8  tuner_ter_clock_control;
+	u8  fef_selection;
+	u8  fef_mode;
+	u8  fef_pin;   /* FEF pin connected to TER tuner AGC freeze input      */
+	u8  fef_level; /* GPIO state on FEF_pin when used (during FEF periods) */
+	u8  Si2168B_in_standby;
+	struct mutex lock;
+	struct mutex ts_bus_ctrl_lock;
+} si2168b_context;
+
+typedef struct Si2168B_L2_Context {
+	si2168b_context *demod;
+	Si2168B_INDIRECT_I2C_FUNC  f_TER_tuner_enable;
+	Si2168B_INDIRECT_I2C_FUNC  f_TER_tuner_disable;
+	void *callback;
+	u8  standard;
+	u8  previous_standard;
+	u8  first_init_done;
+	u8  Si2168B_init_done;
+	u8  TER_init_done;
+	u8  tuner_indirect_i2c_connection;
+	u8  auto_detect_TER;
+	u8  tuneUnitHz;
+	u8  seekAbort;
+	u8  handshakeUsed;
+	u32 handshakeStart_ms;
+	u32 handshakePeriod_ms;
+	u8  handshakeOn;
+} Si2168B_L2_Context;
+
+/* firmware_struct needs to be declared to allow loading the FW in 16 bytes mode */
+#ifndef __FIRMWARE_STRUCT__
+#define __FIRMWARE_STRUCT__
+typedef struct firmware_struct {
+	u8 firmware_len;
+	u8 firmware_table[16];
+} firmware_struct;
+#endif /* __FIRMWARE_STRUCT__ */
+
+struct Si2168B_Priv {
+	struct i2c_adapter *i2c;
+	const struct si2168b_config *config;
+	struct dvb_frontend frontend;
+	Si2168B_L2_Context *si_front_end;
+	enum fe_delivery_system delivery_system;
+	bool last_tune_failed; /* for switch between T and T2 tune */
+};
+
+#if defined(SiTRACES)
+static void sitrace_default_configuration(void);
+static void sitrace_function(const char *name, int trace_linenumber, const char *func, const char *fmt, ...);
+#ifdef DRIVER_BUILD
+#define SiTraceConfiguration(...) /* empty */
+#else
+char * SiTraceConfiguration(const char *config);
+#endif
+static void sitraces_suspend(void);
+static void sitraces_resume(void);
+#else
+#define SiTraceDefaultConfiguration(...) /* empty */
+#define SiTracesSuspend()                /* empty */
+#define SiTracesResume()                 /* empty */
+#define sitraces_suspend()               /* empty */
+#define sitraces_resume()                /* empty */
+#endif /* SiTRACES */
+
+#ifndef __FIRMWARE_STRUCT__
+#define __FIRMWARE_STRUCT__
+typedef struct  {
+	u8 firmware_len;
+	u8 firmware_table[16];
+} firmware_struct;
+#endif /* __FIRMWARE_STRUCT__ */
+
+#define _Si2168B_PATCH16_4_0b9_TABLE_H_
+
+#define Si2168B_PATCH16_4_0b9_PART    68
+#define Si2168B_PATCH16_4_0b9_ROM      1
+#define Si2168B_PATCH16_4_0b9_PMAJOR  '4'
+#define Si2168B_PATCH16_4_0b9_PMINOR  '0'
+#define Si2168B_PATCH16_4_0b9_PBUILD   2
+
+#ifndef __FIRMWARE_STRUCT__
+#define __FIRMWARE_STRUCT__
+typedef struct firmware_struct {
+	u8 firmware_len;
+	u8 firmware_table[16];
+} firmware_struct;
+#endif /* __FIRMWARE_STRUCT__ */
+
+firmware_struct Si2168B_PATCH16_4_0b9[] = {
+		{  8 , { 0x05,0x00,0xF6,0x30,0x56,0x40,0x00,0x00 } },
+		{  8 , { 0x0C,0x58,0x70,0xA0,0x93,0x5E,0x38,0x95 } },
+		{  3 , { 0x4A,0x4F,0xFA } },
+		{  8 , { 0x0C,0xD2,0xAA,0x09,0x35,0xDD,0xF3,0x87 } },
+		{  6 , { 0x4D,0x8E,0x5B,0xAC,0x28,0xB5 } },
+		{  8 , { 0x0C,0x53,0x6F,0x17,0xD9,0x7C,0x82,0xBD } },
+		{  3 , { 0x4A,0x55,0xF4 } },
+		{  8 , { 0x0C,0xC4,0x62,0x78,0x18,0x46,0x92,0xCF } },
+		{ 12 , { 0x3B,0xC5,0x82,0xE0,0xD9,0x60,0x03,0xDC,0x4C,0x1B,0xA0,0xC7 } },
+		{  8 , { 0x08,0xEE,0x78,0xEE,0xD4,0xCF,0x22,0xAA } },
+		{  8 , { 0x0C,0x03,0xCD,0x8E,0x92,0xD6,0x73,0xA6 } },
+		{  3 , { 0x42,0x10,0xAA } },
+		{  8 , { 0x0C,0x16,0xB2,0xD3,0x2D,0xC0,0xBB,0xF5 } },
+		{  3 , { 0x4A,0x95,0x66 } },
+		{  8 , { 0x0C,0xEC,0xA1,0x54,0xC2,0xA2,0x1E,0xCD } },
+		{ 16 , { 0x3F,0x4F,0xF5,0x82,0x11,0x5D,0xD9,0x99,0x0D,0xD1,0xE7,0xBC,0xCA,0x9C,0x50,0x52 } },
+		{  3 , { 0x4A,0x2A,0xBC } },
+		{  8 , { 0x09,0x65,0x97,0x63,0x35,0xFB,0xDC,0xEF } },
+		{  8 , { 0x09,0x2E,0xC0,0x2B,0xC4,0xBF,0x17,0x6E } },
+		{  8 , { 0x08,0x27,0x3D,0x6F,0x7A,0x38,0x99,0x91 } },
+		{  9 , { 0x38,0xE2,0xAC,0x75,0xDC,0x28,0x6A,0x7D,0x63 } },
+		{  8 , { 0x08,0xEA,0xA3,0xAF,0xC6,0x01,0xE7,0x58 } },
+		{  5 , { 0x44,0x97,0x01,0x98,0xBC } },
+		{  8 , { 0x09,0x50,0x28,0x28,0xFA,0x1E,0x0B,0xC5 } },
+		{ 13 , { 0x34,0x30,0xA5,0x54,0x05,0x07,0xE4,0x44,0x1C,0xEE,0x15,0xD4,0x87 } },
+		{  8 , { 0x08,0xC2,0xF6,0x3D,0x59,0xF4,0x0D,0xC0 } },
+		{  4 , { 0x43,0xD5,0x47,0x3C } },
+		{  8 , { 0x09,0x40,0xC7,0xBF,0x5E,0x22,0x74,0x99 } },
+		{ 16 , { 0x3F,0xFC,0xF1,0x57,0x95,0x67,0x26,0xA7,0x38,0x7A,0xB4,0x9B,0xFD,0xA5,0x29,0xB9 } },
+		{ 16 , { 0x3F,0x71,0x73,0x43,0xB4,0x27,0x6D,0xAB,0x98,0xC9,0x95,0xD6,0x8F,0x77,0xE6,0xDF } },
+		{ 12 , { 0x3B,0x84,0xC5,0x5B,0x75,0x7F,0x80,0x6C,0xED,0x09,0x65,0xE8 } },
+		{  8 , { 0x09,0x32,0xE6,0x0D,0x2D,0x20,0x13,0x94 } },
+		{ 16 , { 0x3F,0x4B,0xC8,0xAC,0x22,0x45,0x44,0x2F,0x99,0xA7,0x2E,0x1F,0xD9,0xDE,0xF4,0x76 } },
+		{ 16 , { 0x37,0x9B,0x3F,0xAA,0x3A,0x33,0x16,0xA4,0xD5,0xDF,0xD9,0xBA,0x5C,0x3A,0x39,0x2B } },
+		{  8 , { 0x09,0xE0,0xAD,0xDE,0x8A,0x6B,0x2F,0xDB } },
+		{ 16 , { 0x37,0xC5,0xE2,0xAC,0x74,0x5D,0x77,0xAC,0x2E,0x79,0x2B,0x65,0x66,0xCA,0xDE,0xB2 } },
+		{ 16 , { 0x37,0xEF,0x9C,0x99,0x03,0x34,0xF7,0xEF,0xEE,0x71,0xD1,0x71,0xCE,0x0B,0xF3,0x23 } },
+		{ 16 , { 0x3F,0xCE,0xAC,0xF4,0x52,0x29,0x1D,0xFD,0xA8,0xF9,0xDC,0xCA,0x5B,0x71,0xF8,0x7B } },
+		{ 16 , { 0x3F,0x20,0xB1,0xB9,0xA8,0xBA,0x4E,0xC3,0x43,0xBF,0xD4,0x37,0xE1,0x21,0xED,0x4E } },
+		{ 16 , { 0x37,0x02,0xE2,0x06,0x37,0x01,0x19,0x03,0x46,0x9E,0x25,0xC2,0xAF,0xA5,0x0C,0x05 } },
+		{ 16 , { 0x3F,0x24,0xFB,0x02,0x2F,0x87,0x72,0x72,0x78,0x33,0x20,0x06,0xC4,0x92,0x11,0x52 } },
+		{ 16 , { 0x3F,0x12,0x59,0xDB,0xB6,0xA0,0xF6,0x5F,0x8D,0xF5,0x5D,0x42,0x6F,0x0B,0x85,0xFF } },
+		{ 16 , { 0x37,0x9D,0x7F,0xC0,0x52,0xA4,0xB1,0xA7,0xC6,0x15,0x78,0xDF,0xFA,0x1D,0x25,0xEA } },
+		{ 13 , { 0x3C,0x4C,0xFA,0x1F,0x73,0x44,0x7B,0xEA,0x30,0xBD,0xD6,0xB6,0xCF } },
+		{  8 , { 0x0C,0x64,0x3E,0xB6,0x62,0xE2,0x4F,0x90 } },
+		{ 16 , { 0x3F,0x04,0xA9,0xCF,0xC3,0x9C,0x93,0xFE,0x68,0x91,0xD3,0x30,0x5F,0x5C,0x34,0x4A } },
+		{ 10 , { 0x39,0xDB,0xD8,0x30,0x2F,0xB5,0x7A,0xFE,0x1A,0x37 } },
+		{  8 , { 0x0C,0x5A,0x55,0x79,0xD2,0x70,0xCC,0x14 } },
+		{  3 , { 0x4A,0x61,0xD8 } },
+		{  8 , { 0x08,0xBF,0x36,0xE1,0x0F,0x76,0x0E,0x97 } },
+		{  8 , { 0x09,0xBF,0x03,0x26,0xB6,0x79,0x25,0x4C } },
+		{  8 , { 0x09,0x23,0xE6,0x93,0x4E,0xC1,0x1D,0xE6 } },
+		{  8 , { 0x0C,0x65,0x84,0xE0,0x20,0xAB,0x9A,0xA7 } },
+		{  5 , { 0x44,0xF2,0xCE,0x5B,0x51 } },
+		{  8 , { 0x0C,0xF6,0x12,0xDA,0x80,0x37,0x21,0x29 } },
+		{  5 , { 0x44,0x4F,0x25,0x61,0xA1 } },
+		{  8 , { 0x0C,0x98,0xC3,0x69,0x6C,0x0A,0xBD,0x02 } },
+		{  9 , { 0x30,0x6D,0xA6,0x9C,0xE7,0x35,0xE1,0xF8,0xB2 } },
+		{  8 , { 0x0C,0x74,0xA9,0x08,0x36,0xAC,0x71,0xD7 } },
+		{  5 , { 0x44,0x3E,0x84,0x38,0x27 } },
+		{  8 , { 0x0C,0x1A,0x98,0xB0,0x3D,0x03,0x53,0xD6 } },
+		{  5 , { 0x44,0xE6,0x56,0xFF,0x61 } },
+		{  8 , { 0x0C,0x8F,0xCC,0xCA,0xB6,0x41,0x85,0xDE } },
+		{  5 , { 0x4C,0xB1,0x93,0xE7,0x2A } },
+		{  8 , { 0x0C,0x0A,0xBD,0xB6,0xED,0xD5,0xC0,0x5B } },
+		{  5 , { 0x4C,0x2B,0x36,0x8D,0xA2 } },
+		{  8 , { 0x0C,0x7A,0x22,0x9D,0x40,0x0F,0x83,0xE9 } },
+		{  5 , { 0x4C,0xE0,0x9D,0xC6,0xE1 } },
+		{  8 , { 0x0C,0xFA,0x6E,0x54,0x74,0x21,0xBF,0x33 } },
+		{  5 , { 0x44,0xB1,0xE5,0xC4,0xCC } },
+		{  8 , { 0x0C,0xEF,0xFB,0xE5,0x37,0x7E,0xB8,0xC0 } },
+		{ 16 , { 0x3F,0xF5,0x51,0x23,0xE2,0x63,0x8A,0x44,0xF2,0xD1,0x48,0xAA,0x8E,0x32,0x3F,0x24 } },
+		{  2 , { 0x49,0x54 } },
+		{  8 , { 0x0C,0xBF,0x04,0xB0,0xDA,0xEF,0xD3,0x63 } },
+		{  5 , { 0x4C,0xEF,0xE1,0x6F,0xD0 } },
+		{  8 , { 0x0C,0x23,0xC4,0xF2,0xB0,0x9F,0x5D,0xF8 } },
+		{  5 , { 0x44,0x76,0x8F,0x57,0x79 } },
+		{  8 , { 0x0C,0x11,0xE4,0xE8,0x77,0x54,0x91,0x24 } },
+		{  5 , { 0x4C,0x94,0x2F,0x21,0xF6 } },
+		{  8 , { 0x0C,0x4A,0xBE,0xCC,0xE2,0xC5,0x58,0xCF } },
+		{  5 , { 0x4C,0x79,0xEE,0x3E,0xE6 } },
+		{  8 , { 0x0C,0xE0,0xD0,0x42,0xAA,0xFB,0xBB,0xAC } },
+		{  5 , { 0x44,0xC4,0x86,0x6D,0x84 } },
+		{  8 , { 0x0C,0x04,0x16,0x66,0x22,0xDA,0x5E,0x1C } },
+		{  5 , { 0x44,0xE2,0xE2,0x56,0x4D } },
+		{  8 , { 0x0C,0x2D,0x68,0x26,0xE7,0xAA,0x22,0x0A } },
+		{  5 , { 0x44,0x10,0x7F,0x20,0xF6 } },
+		{  8 , { 0x0C,0x60,0x61,0xD4,0xE4,0xD1,0xBF,0x01 } },
+		{  5 , { 0x4C,0x58,0x91,0xA2,0xF2 } },
+		{  8 , { 0x0C,0xA9,0xD1,0x46,0x0A,0x23,0xBB,0xB8 } },
+		{  9 , { 0x38,0x84,0xBF,0x5A,0xAB,0x0D,0x95,0x87,0x60 } },
+		{  8 , { 0x0C,0x75,0xE8,0x5D,0x32,0x86,0x20,0x8D } },
+		{  5 , { 0x4C,0xD0,0x18,0xDA,0x26 } },
+		{  8 , { 0x0C,0xF1,0xE0,0x5E,0xF7,0x77,0xCE,0xFF } },
+		{  5 , { 0x4C,0x78,0x75,0x06,0xBF } },
+		{  8 , { 0x0C,0x18,0x5A,0x27,0xE7,0x2A,0x50,0x94 } },
+		{  5 , { 0x4C,0xD0,0xAC,0x59,0xDD } },
+		{  8 , { 0x0C,0x92,0xB2,0xFD,0xB9,0xE0,0x7A,0x15 } },
+		{  5 , { 0x4C,0x6A,0x3C,0x2B,0xD3 } },
+		{  8 , { 0x0C,0x2D,0xF3,0x5C,0x73,0xD2,0x3C,0x0F } },
+		{  5 , { 0x4C,0xFA,0xE2,0xA5,0x9D } },
+		{  8 , { 0x0C,0xFE,0xCD,0x58,0x12,0x14,0xA9,0x19 } },
+		{  5 , { 0x4C,0x97,0x9A,0xF9,0xA9 } },
+		{  8 , { 0x0C,0x4F,0x48,0xAC,0xF1,0x7B,0x52,0xE6 } },
+		{ 13 , { 0x3C,0x1B,0x90,0xB6,0xD1,0x38,0x35,0xE8,0x29,0x04,0x18,0xD3,0x16 } },
+		{  8 , { 0x0C,0xBD,0x2C,0x0F,0xFC,0x2B,0xFF,0xD9 } },
+		{  5 , { 0x4C,0xEE,0x32,0x98,0x52 } },
+		{  8 , { 0x0C,0xF5,0x9E,0x18,0x04,0xBE,0x0E,0xCD } },
+		{ 13 , { 0x3C,0x29,0xC5,0x08,0x14,0x7B,0x01,0x05,0xAB,0x1C,0xE1,0x07,0xF6 } },
+		{  8 , { 0x0C,0x97,0xA0,0xE5,0x29,0x15,0xD1,0x32 } },
+		{  5 , { 0x44,0x30,0x41,0x18,0xA3 } },
+		{  8 , { 0x0C,0xAC,0x97,0xBE,0xAE,0x5F,0xFE,0x0B } },
+		{  5 , { 0x4C,0x60,0x20,0xB8,0x04 } },
+		{  8 , { 0x0C,0xA9,0x9F,0x96,0x2E,0xF7,0x11,0x05 } },
+		{  5 , { 0x44,0x1B,0x00,0x99,0xE5 } },
+		{  8 , { 0x0C,0x92,0x29,0x74,0x3B,0x1C,0x50,0x7C } },
+		{ 16 , { 0x37,0x0F,0xE9,0x22,0x33,0x2A,0x96,0x93,0x9E,0x99,0x71,0xA4,0x5D,0xA2,0xC5,0x4A } },
+		{  2 , { 0x49,0xB4 } },
+		{  8 , { 0x08,0x95,0x6D,0x10,0x64,0x62,0xF2,0x68 } },
+		{ 16 , { 0x3F,0x1F,0xE6,0x74,0x05,0x4E,0x58,0xE0,0x8E,0x17,0x31,0x18,0x3F,0xB7,0xEC,0x68 } },
+		{  2 , { 0x49,0x96 } },
+		{  8 , { 0x09,0x61,0xC0,0x9C,0x35,0x49,0x44,0x82 } },
+		{  8 , { 0x08,0x1C,0x39,0x93,0xC8,0xBD,0xF1,0x87 } },
+		{ 16 , { 0x3F,0x3A,0x78,0xF2,0x62,0x23,0x18,0x11,0x13,0xEB,0xDF,0x66,0x9A,0x2D,0x40,0x5E } },
+		{ 16 , { 0x37,0x91,0x61,0x2B,0x76,0xF7,0x15,0xF9,0xCD,0x82,0xB7,0x97,0xB4,0xF5,0x5D,0x7A } },
+		{ 16 , { 0x37,0xED,0x0A,0x9F,0xF1,0x60,0xAA,0xF4,0x30,0x65,0xC0,0xDF,0x73,0x56,0x9D,0xE2 } },
+		{  4 , { 0x4B,0x6B,0xB3,0x23 } },
+		{  8 , { 0x09,0xFB,0x68,0xD7,0x90,0x6D,0x20,0xA2 } },
+		{  5 , { 0x44,0x7C,0x22,0xF3,0x48 } },
+		{  8 , { 0x09,0x47,0x06,0x1B,0x86,0x03,0xAC,0x02 } },
+		{ 16 , { 0x37,0x06,0xF1,0xB0,0xF6,0xC1,0x21,0x94,0xB7,0xA4,0xDB,0x07,0x70,0x65,0x70,0xB7 } },
+		{ 16 , { 0x37,0xFE,0x60,0x67,0x04,0x50,0x0D,0xC4,0x4D,0x1F,0x3F,0xCD,0xE2,0x0D,0x2A,0xF4 } },
+		{ 11 , { 0x3A,0x98,0x70,0x26,0x0F,0x02,0x44,0xD9,0x5B,0x7A,0x25 } },
+		{  8 , { 0x09,0x70,0x85,0x33,0x5C,0xB0,0x38,0x76 } },
+		{ 16 , { 0x37,0xB4,0x46,0x17,0xC8,0x3B,0x40,0x06,0xF6,0x09,0xC1,0x50,0xFC,0x88,0xF8,0x78 } },
+		{  6 , { 0x45,0x58,0x72,0x01,0x68,0x55 } },
+		{  8 , { 0x08,0xC3,0x6B,0x35,0x0B,0x23,0x96,0x68 } },
+		{ 13 , { 0x34,0xFE,0x7E,0xC9,0x63,0xAE,0x53,0xDB,0x84,0x39,0xE5,0x49,0xC4 } },
+		{  8 , { 0x09,0x78,0xD6,0x0A,0x49,0x2E,0xA9,0x12 } },
+		{ 16 , { 0x3F,0x52,0x76,0xCD,0x56,0x9C,0xB5,0xD1,0x28,0xA0,0x76,0x38,0x86,0x0E,0x6F,0xEE } },
+		{ 16 , { 0x3F,0x27,0xFF,0x9D,0xD2,0xAF,0xAB,0x85,0xAB,0x99,0x66,0x59,0x4E,0x65,0x22,0xDF } },
+		{ 16 , { 0x3F,0x6A,0x5F,0x3F,0x88,0xB1,0x12,0x3B,0x98,0x87,0xCD,0x33,0x17,0x58,0xAA,0x94 } },
+		{  4 , { 0x43,0xC3,0xD6,0xE6 } },
+		{  8 , { 0x08,0x66,0x32,0xC6,0xE7,0x19,0x82,0x94 } },
+		{  5 , { 0x44,0x13,0x97,0x1A,0x8C } },
+		{ 16 , { 0x37,0x7B,0x0A,0xC5,0x48,0xA8,0xAF,0x6C,0xA1,0x85,0x76,0x54,0x67,0xE8,0x36,0xDE } },
+		{ 16 , { 0x3F,0x45,0x8A,0xE8,0x61,0xB7,0xEE,0xB9,0xD1,0x45,0x51,0x79,0xDF,0x92,0xD9,0x9E } },
+		{ 15 , { 0x3E,0xF5,0x2B,0x36,0xF7,0xF6,0xD7,0x19,0x01,0xAF,0x24,0x2F,0xBA,0xCD,0xA7 } },
+		{  9 , { 0x30,0x91,0xE3,0x38,0x34,0xF6,0x6E,0xF0,0x92 } },
+		{  8 , { 0x09,0x7A,0xD7,0x88,0x59,0x78,0xF9,0x59 } },
+		{  5 , { 0x4C,0x57,0xFB,0xBF,0xAC } },
+		{  8 , { 0x09,0x4B,0x26,0xCE,0x3B,0x4B,0xEE,0x40 } },
+		{ 16 , { 0x3F,0xF0,0xB2,0x05,0xAC,0x79,0x46,0xE6,0x7D,0xBA,0xB1,0x03,0xCF,0x1E,0x9B,0x64 } },
+		{ 16 , { 0x3F,0x78,0x48,0xC1,0xE6,0xB1,0xD6,0x82,0x74,0x76,0x42,0x58,0x60,0xE5,0x8B,0x88 } },
+		{ 16 , { 0x37,0x11,0x9D,0xE5,0x9C,0xEE,0x0D,0xC3,0x67,0x6F,0x5D,0x3D,0x1F,0x23,0x13,0x7D } },
+		{  8 , { 0x4F,0x87,0x20,0x35,0xEF,0xA2,0x48,0xCA } },
+		{  8 , { 0x09,0xA6,0x14,0x0A,0xF5,0xD2,0xFE,0xAE } },
+		{ 13 , { 0x3C,0x5A,0x4D,0xCE,0x7B,0x72,0x54,0x2D,0xF5,0x6A,0xC6,0xC7,0x2B } },
+		{  8 , { 0x08,0xF3,0xD9,0xF6,0x53,0x35,0xDE,0xA5 } },
+		{  5 , { 0x44,0xED,0xD5,0x5C,0x8C } },
+		{  8 , { 0x09,0xDB,0xB8,0x6B,0x17,0x9A,0xC1,0x11 } },
+		{  9 , { 0x38,0x5C,0x74,0x5A,0x22,0x89,0x60,0x5B,0xAA } },
+		{  8 , { 0x08,0x5E,0x13,0x0B,0x04,0xD3,0xFC,0xFF } },
+		{ 13 , { 0x34,0x68,0x58,0xCC,0x67,0x2B,0x87,0xE3,0x8D,0xEF,0x87,0x1F,0x32 } },
+		{  8 , { 0x09,0x21,0x6F,0xBD,0x66,0x70,0xD8,0xC1 } },
+		{ 16 , { 0x3F,0x7E,0xC0,0xEF,0x53,0x59,0x30,0x8C,0xE3,0x18,0x28,0x80,0x21,0x7F,0x60,0x64 } },
+		{ 16 , { 0x3F,0xFC,0x48,0x57,0x25,0x34,0xD4,0xA8,0xA1,0x43,0x24,0x27,0x2D,0x56,0xFE,0x01 } },
+		{  3 , { 0x4A,0x57,0x84 } },
+		{  8 , { 0x08,0xAF,0x8D,0xAF,0x3F,0xB1,0x32,0x44 } },
+		{ 13 , { 0x34,0xA6,0x91,0xDE,0x72,0x1D,0xA2,0x93,0x46,0xC3,0x4E,0x17,0x38 } },
+		{  8 , { 0x09,0x26,0x42,0x44,0x9D,0x31,0x64,0xB1 } },
+		{ 16 , { 0x37,0xA9,0x53,0x9E,0x8D,0x66,0xD6,0x00,0xAC,0xEF,0x05,0x82,0xE8,0x8E,0xD7,0x2E } },
+		{ 16 , { 0x3F,0xCF,0xD3,0x4D,0xFA,0x81,0x57,0xC2,0xF3,0x50,0x24,0x18,0x94,0xED,0xE6,0x6C } },
+		{ 16 , { 0x3F,0x80,0xE7,0x7C,0x16,0xE1,0x26,0xB7,0x33,0x5F,0x4B,0x9E,0xF4,0x05,0x48,0x44 } },
+		{ 16 , { 0x3F,0x44,0xEF,0x9D,0xF9,0x40,0xE5,0xA6,0x73,0xA5,0x76,0xF3,0x0E,0x15,0x66,0x2A } },
+		{ 16 , { 0x37,0xF0,0xF9,0x7C,0xE2,0x35,0x47,0x57,0xB5,0x0C,0xE5,0x0D,0x4B,0xE0,0x4F,0x1B } },
+		{ 14 , { 0x3D,0x24,0x58,0x97,0x02,0x2F,0xA2,0x4A,0x59,0xA9,0xD7,0xDE,0x9C,0x9E } },
+		{  8 , { 0x08,0x9A,0xCD,0xEF,0x62,0xCF,0xB6,0x61 } },
+		{ 16 , { 0x37,0xFE,0x79,0xFB,0x0A,0x3E,0x19,0x70,0x03,0x94,0x5E,0x6E,0x63,0x71,0xE3,0x06 } },
+		{ 14 , { 0x35,0x54,0x2D,0x0F,0x07,0xBB,0x46,0x9E,0x34,0xF8,0xBA,0x87,0x0B,0xA6 } },
+		{  8 , { 0x09,0x47,0x0B,0x2F,0x06,0xF3,0x6E,0x1D } },
+		{ 16 , { 0x37,0x9F,0x27,0xCA,0x16,0xAC,0x24,0x71,0x8E,0xB2,0xD2,0x35,0x09,0x8C,0xAD,0x81 } },
+		{ 16 , { 0x3F,0x82,0xF9,0xDA,0x35,0xEF,0x0C,0x7C,0x2C,0x11,0xE1,0x43,0x8A,0x29,0x42,0x05 } },
+		{ 11 , { 0x32,0xA5,0x72,0x9C,0x34,0x7F,0x0D,0xC6,0xCF,0xF2,0x1D } },
+		{  8 , { 0x08,0xED,0x1F,0x44,0x44,0x2C,0x17,0x10 } },
+		{  8 , { 0x08,0xBD,0x19,0x2E,0xC6,0x50,0x2F,0xEE } },
+		{  8 , { 0x09,0x1F,0x38,0x17,0x95,0x2C,0xE6,0x27 } },
+		{ 16 , { 0x37,0x4F,0x69,0x25,0x5E,0xC9,0xC0,0xF4,0xAB,0xA2,0x22,0xCB,0x6F,0xEA,0xE0,0x5A } },
+		{ 16 , { 0x37,0x2D,0xCD,0x85,0xCE,0x41,0x68,0xD9,0x0D,0x5C,0x7A,0x6A,0x02,0x56,0xAF,0xEB } },
+		{ 16 , { 0x37,0xF4,0x10,0x4F,0x26,0x9C,0x8B,0x60,0x9F,0x68,0x3F,0xD6,0x93,0x6D,0x44,0xC6 } },
+		{ 12 , { 0x33,0x00,0xAC,0x78,0xE9,0xFA,0xC3,0x23,0x0E,0x08,0x9B,0xC9 } },
+		{  8 , { 0x09,0x35,0x6A,0x8B,0xB1,0xC4,0xFD,0x82 } },
+		{  5 , { 0x4C,0x56,0x39,0x5C,0x71 } },
+		{  8 , { 0x08,0x4C,0x31,0xB8,0x3C,0x35,0x55,0x0E } },
+		{  8 , { 0x08,0x52,0xB6,0x48,0xCA,0x40,0xF8,0xBA } },
+		{ 16 , { 0x37,0x85,0x77,0x83,0x57,0x26,0x9E,0xEC,0x2D,0x81,0x3A,0x47,0x64,0x49,0x4E,0x47 } },
+		{ 16 , { 0x37,0x70,0xB5,0x66,0x86,0xC6,0x4C,0x24,0x6A,0x68,0x08,0x8F,0xBE,0xAE,0x4E,0xC4 } },
+		{ 16 , { 0x3F,0x98,0xD2,0x93,0xA9,0x12,0x4D,0x50,0x0B,0x81,0x66,0x76,0xA8,0x52,0x06,0xC6 } },
+		{  4 , { 0x43,0x85,0xDC,0x56 } },
+		{  8 , { 0x09,0xD7,0x87,0x39,0x2E,0xDD,0xB5,0xB6 } },
+		{  5 , { 0x44,0x93,0x97,0x06,0x9C } },
+		{  8 , { 0x09,0x73,0x13,0x82,0xF4,0x86,0x61,0xBF } },
+		{ 16 , { 0x37,0xEE,0xAB,0xB5,0x6D,0x7E,0x15,0x5E,0x8F,0x08,0xBB,0xA5,0x8F,0x02,0xBA,0xDF } },
+		{ 16 , { 0x37,0x9F,0xA6,0x5E,0x6D,0x3B,0x07,0xA1,0x0B,0x00,0xE4,0x59,0xCF,0x95,0x02,0x17 } },
+		{ 16 , { 0x3F,0x4A,0x51,0xF9,0xE5,0xC7,0xEA,0xCA,0x17,0xBB,0xEC,0xE3,0x72,0xB8,0x38,0xD3 } },
+		{ 16 , { 0x3F,0x3C,0x5F,0x81,0xAD,0xA7,0xC2,0x6B,0x9E,0x58,0x64,0xB5,0x1E,0xDF,0xBC,0x9D } },
+		{ 16 , { 0x3F,0x1A,0x62,0x2B,0x7E,0x4E,0xD0,0x13,0x2A,0xEE,0xFA,0xBD,0x65,0xF6,0x66,0x61 } },
+		{ 16 , { 0x37,0x98,0xBE,0xD4,0xEA,0xED,0x1B,0x7B,0x04,0xC4,0x32,0x52,0x4E,0x33,0x1A,0x8A } },
+		{ 16 , { 0x3F,0x3E,0x8C,0x16,0xDE,0xC6,0x6E,0xBE,0x50,0x36,0x72,0xF6,0x26,0xE6,0x51,0xDE } },
+		{ 16 , { 0x37,0xE5,0x60,0x86,0xC3,0xBE,0xC0,0x0F,0xBF,0x05,0x1F,0xED,0x23,0xC3,0x1D,0x13 } },
+		{ 16 , { 0x3F,0x91,0xFF,0xB3,0x9A,0x12,0x8F,0x04,0x4D,0x23,0x48,0xAD,0x0E,0x46,0xA4,0xBB } },
+		{ 16 , { 0x37,0x87,0xF1,0x65,0xE2,0xE8,0x29,0xDA,0x4B,0x1B,0x06,0x7C,0xF6,0xCF,0x14,0xD9 } },
+		{ 16 , { 0x37,0x9D,0x62,0x38,0x13,0xFD,0x8D,0x8D,0xA7,0xB9,0xDE,0x06,0xCE,0xFF,0xE1,0xB5 } },
+		{ 16 , { 0x37,0x23,0xFB,0x05,0xD1,0x48,0x3C,0x22,0x92,0x48,0x4F,0x08,0x0B,0x5D,0x0C,0x1B } },
+		{  9 , { 0x38,0x49,0xC0,0x76,0x17,0xEB,0x3C,0x04,0xDC } },
+		{  8 , { 0x08,0x29,0xB6,0x14,0xBF,0x69,0x79,0x13 } },
+		{ 16 , { 0x3F,0xB8,0x0A,0x0A,0x97,0xCC,0xD5,0x0C,0x82,0x49,0x3A,0x81,0x5A,0x3E,0x25,0x84 } },
+		{  6 , { 0x45,0x96,0x0B,0xA8,0x89,0xE6 } },
+		{  8 , { 0x08,0x6F,0x77,0xA1,0xD4,0x50,0x7F,0xDB } },
+		{  9 , { 0x38,0xAA,0xE7,0x85,0xFF,0x84,0x56,0xF4,0x3E } },
+		{  8 , { 0x08,0x2A,0x70,0xD6,0x03,0x5C,0x4B,0xA5 } },
+		{ 16 , { 0x3F,0x82,0xBC,0x35,0xA6,0xF7,0x6A,0x91,0x47,0x93,0x11,0x28,0xE4,0xE8,0x9E,0xA3 } },
+		{  2 , { 0x49,0x07 } },
+		{  8 , { 0x09,0xAD,0x07,0x5A,0xF2,0xAF,0x56,0x37 } },
+		{ 16 , { 0x37,0xAF,0xE4,0x5E,0x58,0xF8,0x0A,0xDE,0x26,0x03,0x1B,0x5C,0x1C,0x81,0xF3,0xB0 } },
+		{ 16 , { 0x3F,0xD7,0x45,0xCE,0xB0,0xBF,0xC2,0x55,0x28,0xA2,0xF8,0xB2,0x35,0x6E,0xE1,0x35 } },
+		{ 15 , { 0x3E,0x17,0x2C,0x12,0x65,0x14,0x35,0xA6,0xA6,0x7A,0x8A,0xC3,0x9E,0x87,0x3C } },
+		{  8 , { 0x08,0xC8,0x85,0x2D,0xC7,0xCC,0xF3,0xED } },
+		{ 13 , { 0x34,0xC4,0xC3,0x32,0x18,0xA5,0x53,0x6B,0xD3,0x75,0x40,0x3D,0x44 } },
+		{  8 , { 0x09,0xA7,0xDC,0xA4,0x12,0xEE,0xE3,0x8A } },
+		{  9 , { 0x30,0x8E,0x7D,0x3B,0x11,0x55,0x02,0x49,0xC0 } },
+		{  8 , { 0x08,0xE9,0x20,0xCC,0xB1,0x89,0xA2,0xF4 } },
+		{ 16 , { 0x3F,0x8C,0x8E,0xCC,0xA2,0x89,0x74,0x0D,0x43,0x07,0x3E,0x3A,0xD4,0x9E,0xFF,0x92 } },
+		{  6 , { 0x4D,0xAB,0x50,0x1C,0xEF,0x26 } },
+		{  8 , { 0x09,0xA1,0xF6,0x31,0xB1,0x21,0x5B,0x18 } },
+		{  8 , { 0x08,0x82,0xAF,0xF6,0x75,0x9E,0xF5,0xE5 } },
+		{  5 , { 0x44,0xB0,0x28,0xA9,0x5A } },
+		{  8 , { 0x08,0xF9,0xE1,0xBF,0x17,0x87,0x46,0x52 } },
+		{  9 , { 0x38,0x92,0x8E,0x4C,0x3A,0x62,0x95,0x43,0xB6 } },
+		{  8 , { 0x09,0x73,0xCC,0x09,0xEC,0x39,0x6B,0xF1 } },
+		{ 16 , { 0x37,0x30,0x72,0x00,0x70,0x8D,0x5A,0x92,0x0B,0x60,0x73,0xFC,0x1D,0xCE,0xB9,0x44 } },
+		{ 16 , { 0x3F,0x1D,0x5E,0x80,0x26,0x5C,0x3E,0x96,0xCF,0x07,0x8F,0x82,0x80,0xDF,0x25,0xD1 } },
+		{ 16 , { 0x3F,0xCC,0x57,0xB9,0x5F,0xCA,0xAB,0x45,0xB1,0x0E,0xC7,0x3B,0x62,0x3A,0x30,0x01 } },
+		{ 12 , { 0x33,0x32,0x0A,0xA4,0xBE,0xBE,0x99,0xD7,0xDC,0x95,0x88,0xFB } },
+		{  8 , { 0x09,0xED,0x55,0xE1,0x3C,0x18,0x46,0x38 } },
+		{ 16 , { 0x37,0x05,0xC4,0x09,0x1F,0xFA,0x8C,0x16,0xB1,0x7A,0x9F,0x89,0x0C,0x83,0x60,0xC1 } },
+		{ 16 , { 0x3F,0xCA,0xCD,0x6E,0xEB,0xBD,0x49,0x97,0x1E,0x35,0x12,0x88,0x5C,0xE6,0xF7,0x98 } },
+		{ 16 , { 0x3F,0xE8,0x2B,0x09,0x4D,0x20,0xFC,0x5D,0xE2,0xCA,0xF2,0x49,0xA5,0x9D,0x31,0x8A } },
+		{ 16 , { 0x37,0x8A,0xFA,0x1F,0x45,0x41,0xD7,0x58,0x12,0x19,0x85,0x00,0x44,0xB2,0x25,0x65 } },
+		{ 16 , { 0x37,0xEA,0xCE,0xAE,0x51,0xAB,0xC9,0x70,0x4D,0x62,0x90,0x29,0xDC,0x1D,0x09,0xCB } },
+		{ 16 , { 0x37,0xF9,0x1F,0x54,0x3F,0x6D,0x3F,0x22,0x31,0x72,0x0C,0xC8,0x5E,0x4E,0x91,0x34 } },
+		{ 16 , { 0x37,0x4E,0x62,0xC7,0x66,0xBB,0xD0,0xE2,0xB9,0x78,0x61,0x91,0x8C,0xA8,0x5E,0x17 } },
+		{  8 , { 0x4F,0xC4,0xC9,0x92,0x59,0xEE,0x5D,0x5B } },
+		{  8 , { 0x09,0xCA,0xF6,0xD7,0xCD,0xD5,0x3D,0x43 } },
+		{ 16 , { 0x37,0x52,0xF3,0xD4,0x4E,0x2D,0xE6,0xB0,0xBD,0xDC,0x4C,0x35,0x68,0x16,0x03,0x93 } },
+		{ 16 , { 0x3F,0xDD,0xA8,0x12,0xD5,0x79,0x45,0x67,0x26,0x0C,0x51,0x79,0x0B,0xA2,0x54,0x2F } },
+		{ 16 , { 0x3F,0xA7,0x56,0x10,0x6F,0x24,0x28,0xE4,0x00,0x5A,0x49,0xD0,0xB9,0x2A,0x06,0x1F } },
+		{ 16 , { 0x3F,0x79,0x0E,0x2E,0x83,0x73,0xA0,0x83,0xDA,0xD0,0x10,0x7B,0x83,0xFC,0x67,0x6F } },
+		{  5 , { 0x44,0xCF,0xA9,0x50,0x91 } },
+		{  8 , { 0x09,0xA6,0xFB,0x86,0xC8,0x29,0x89,0x28 } },
+		{ 13 , { 0x34,0xDC,0x56,0x07,0x57,0x9F,0xC3,0xFB,0x41,0xEB,0xE6,0x4D,0x34 } },
+		{  8 , { 0x09,0x9D,0x4C,0xA5,0x30,0x55,0x5D,0xD9 } },
+		{ 13 , { 0x3C,0x4B,0x6F,0x76,0x77,0xC0,0xF8,0x43,0xCF,0x4D,0x1A,0x2E,0x30 } },
+		{  8 , { 0x08,0xE3,0x0A,0x9D,0x98,0xE8,0x25,0xCF } },
+		{ 13 , { 0x3C,0xB9,0x8E,0x93,0xFD,0x5C,0xF3,0xB9,0xB9,0xD9,0x0E,0x17,0xC8 } },
+		{  8 , { 0x08,0xE5,0xDC,0xB4,0xB5,0x0F,0x98,0x17 } },
+		{ 16 , { 0x3F,0xBB,0x57,0x3C,0x39,0xBD,0x08,0x95,0x38,0x50,0xEE,0x51,0xB5,0xC1,0xB7,0xC7 } },
+		{ 16 , { 0x3F,0xF7,0x40,0xEC,0x32,0x6A,0xDA,0x10,0x53,0xFE,0x61,0x7F,0x83,0xC7,0xE8,0xC1 } },
+		{ 16 , { 0x3F,0xEB,0xB3,0x78,0x08,0xDC,0xA8,0x60,0x81,0xC0,0x8C,0xDF,0xD8,0x5A,0xC8,0xF7 } },
+		{ 12 , { 0x33,0xC8,0xFD,0x05,0xEB,0x76,0xEC,0x8E,0x5F,0x25,0xF7,0x6D } },
+		{  8 , { 0x08,0x70,0x26,0xB9,0x7F,0xFA,0x22,0xEB } },
+		{  9 , { 0x30,0x6C,0xDA,0xCD,0xA7,0x86,0x50,0xFD,0x26 } },
+		{  8 , { 0x08,0x08,0xE0,0xE6,0x21,0xE8,0xCC,0x8C } },
+		{ 16 , { 0x37,0x90,0x95,0x4A,0x38,0x84,0x29,0x10,0xF5,0x0C,0x08,0xD3,0xD8,0x2F,0x82,0xE9 } },
+		{ 16 , { 0x3F,0x1D,0x05,0x60,0xBD,0x0F,0x8C,0x27,0xD9,0xB6,0xC6,0x8B,0x6F,0x28,0x1C,0x13 } },
+		{ 15 , { 0x3E,0x37,0xB5,0x9C,0x38,0xD3,0xA1,0x12,0xEC,0xBA,0xF8,0x70,0x53,0xCF,0x16 } },
+		{  8 , { 0x09,0x48,0x57,0x7A,0x00,0xE5,0x9C,0xDA } },
+		{ 13 , { 0x34,0x9D,0xDC,0xEE,0x29,0x17,0x13,0x9D,0xE8,0x9E,0xBB,0x00,0xB0 } },
+		{  8 , { 0x08,0xA7,0x36,0xE1,0x6B,0x48,0xD0,0x34 } },
+		{ 13 , { 0x34,0xE7,0xDA,0x19,0xD3,0x7E,0x72,0xFE,0x90,0xAE,0xFD,0xEB,0x10 } },
+		{  9 , { 0x38,0x70,0x17,0xCB,0x60,0xD3,0x2D,0x8C,0xEE } },
+		{ 13 , { 0x3C,0x9F,0xEF,0xD3,0x42,0x6D,0x9A,0x4C,0x2E,0x5F,0x71,0x5C,0xDB } },
+		{  8 , { 0x09,0x9F,0xA6,0x25,0x1A,0xF9,0x8E,0x5C } },
+		{ 16 , { 0x37,0x86,0x9D,0xE9,0xB0,0x5B,0xFF,0xED,0x54,0x35,0x35,0xD6,0x53,0x83,0xE5,0x27 } },
+		{ 16 , { 0x3F,0x49,0x92,0x79,0x9A,0xFB,0x31,0x3D,0x52,0x27,0xE4,0x03,0x82,0x29,0x2F,0xAE } },
+		{ 11 , { 0x3A,0x67,0xBE,0x11,0x4D,0xD7,0x54,0x69,0x39,0x4C,0xA5 } },
+		{  8 , { 0x08,0x23,0x53,0xF8,0xAD,0x1A,0x16,0x32 } },
+		{ 16 , { 0x37,0xF1,0x60,0x33,0x96,0x65,0x9C,0xFA,0x0D,0xFE,0xB2,0x8B,0x23,0xC1,0x8E,0x71 } },
+		{ 16 , { 0x37,0xD9,0x47,0xF3,0x29,0x7D,0x5F,0x45,0xDF,0x1C,0x06,0x48,0x9F,0x46,0x0E,0x92 } },
+		{ 15 , { 0x3E,0xCF,0x0C,0xA9,0xEC,0xC7,0x04,0x32,0xE1,0x45,0xC6,0x4D,0x41,0xF8,0x4A } },
+		{  8 , { 0x09,0x07,0x12,0x20,0x49,0x55,0x4D,0x7F } },
+		{  8 , { 0x09,0xBE,0xB6,0x6E,0x4F,0x4B,0x6C,0x81 } },
+		{ 16 , { 0x37,0xCD,0x51,0x38,0x9B,0x79,0x7C,0x51,0x03,0x5A,0x36,0xDF,0x82,0x19,0x26,0x72 } },
+		{ 16 , { 0x37,0x33,0x0E,0xC1,0xE0,0xDD,0xE4,0x55,0x2A,0xD2,0xDE,0x6E,0x80,0x61,0x61,0x23 } },
+		{  3 , { 0x42,0x6B,0x73 } },
+		{  8 , { 0x08,0x46,0x0D,0x86,0x64,0xF1,0x19,0x6B } },
+		{  5 , { 0x44,0xC1,0x08,0xE4,0x0C } },
+		{  8 , { 0x09,0x01,0x11,0x85,0x50,0xA6,0x93,0xFA } },
+		{  9 , { 0x30,0xDB,0xA2,0xC0,0x32,0x71,0x01,0x0E,0x74 } },
+		{  8 , { 0x08,0x88,0x1D,0x53,0x31,0x2D,0xC7,0xDB } },
+		{  5 , { 0x44,0xB7,0x51,0x3C,0xA1 } },
+		{  8 , { 0x08,0xA6,0x93,0xF0,0xCD,0x5C,0x3B,0x7B } },
+		{ 16 , { 0x3F,0x17,0x48,0x96,0x2D,0x0A,0xC3,0x14,0x70,0xD6,0xEC,0x24,0x71,0xDB,0xDB,0x82 } },
+		{  2 , { 0x49,0x21 } },
+		{  8 , { 0x09,0x57,0xDB,0xE1,0x20,0xFB,0x35,0x57 } },
+		{  9 , { 0x30,0x5C,0xA6,0xAD,0x48,0xB4,0x01,0xBB,0xAA } },
+		{  8 , { 0x08,0x24,0xC6,0xCA,0x88,0x05,0xEB,0x0D } },
+		{  8 , { 0x09,0xFB,0x99,0x0D,0x52,0xC8,0x71,0x4B } },
+		{  8 , { 0x09,0x98,0x83,0x4B,0x9C,0x41,0x93,0x5C } },
+		{  8 , { 0x09,0xC0,0xA7,0x87,0xA8,0x67,0x51,0x2E } },
+		{  8 , { 0x09,0x94,0x08,0xC0,0x40,0x10,0x05,0xF7 } },
+		{ 16 , { 0x37,0xE7,0x85,0xBC,0x24,0xF5,0x61,0x3C,0xBE,0x31,0xC1,0x83,0xB7,0x79,0x7B,0x43 } },
+		{ 14 , { 0x3D,0x23,0xB3,0x28,0x54,0x4C,0x71,0x5C,0x0C,0x0D,0x21,0x54,0x8D,0x0C } },
+		{  8 , { 0x08,0xD2,0x3A,0x3D,0x3E,0xC0,0xF8,0xB9 } },
+		{  5 , { 0x4C,0x67,0x23,0xFD,0x70 } },
+		{  8 , { 0x08,0xC5,0x5F,0x78,0xAD,0x9A,0xF8,0x67 } },
+		{ 13 , { 0x34,0x4F,0x69,0x06,0x88,0x5D,0x7C,0xDA,0x73,0xA6,0x17,0xEA,0x2C } },
+		{  8 , { 0x08,0xDF,0xB2,0x29,0x5C,0x3B,0x23,0x37 } },
+		{ 16 , { 0x3F,0x4C,0x6B,0xB5,0x32,0xB7,0x53,0x99,0xA8,0x80,0x84,0xE8,0xE9,0x71,0x64,0x53 } },
+		{ 16 , { 0x3F,0x71,0xDB,0x81,0xBE,0x53,0xA7,0xF2,0x57,0xF1,0x54,0xBA,0x14,0x1C,0x42,0x10 } },
+		{ 16 , { 0x3F,0x59,0x82,0xFE,0xCE,0xBE,0x25,0x1E,0x29,0x28,0x99,0x74,0x42,0xBA,0x9D,0x14 } },
+		{ 12 , { 0x33,0x06,0xB7,0x70,0xF5,0x3A,0x89,0x4F,0x9C,0x0B,0xAE,0xA8 } },
+		{  8 , { 0x08,0xD9,0x9A,0x8A,0x8C,0x3C,0x6A,0xB5 } },
+		{  8 , { 0x09,0x34,0x15,0x18,0xBE,0xC4,0x27,0x0A } },
+		{  9 , { 0x38,0x7A,0x10,0x24,0x6F,0x03,0x1C,0xB8,0xF2 } },
+		{  8 , { 0x09,0x49,0x91,0xB8,0x48,0x5E,0x8D,0xEF } },
+		{ 16 , { 0x37,0xDB,0xB7,0x21,0xA1,0x45,0x9A,0xC3,0x91,0x09,0xE5,0xD4,0xC4,0x67,0x81,0xE9 } },
+		{ 16 , { 0x37,0x54,0xE4,0x9E,0x5E,0x2D,0x85,0xF0,0x89,0x6C,0xFC,0xBF,0x26,0x4E,0xC1,0xD2 } },
+		{  7 , { 0x46,0x94,0xC0,0x9A,0xCC,0x58,0x8D } },
+		{  8 , { 0x09,0x2F,0x2B,0xD6,0xC3,0xCC,0x48,0x83 } },
+		{  9 , { 0x38,0x96,0x61,0xE9,0x98,0xB3,0x44,0x12,0xE6 } },
+		{  8 , { 0x08,0x82,0xE4,0x8D,0x30,0xDA,0xDE,0x5B } },
+		{  9 , { 0x30,0x4F,0xE9,0x03,0xFF,0x9B,0x20,0x0B,0xD8 } },
+		{  8 , { 0x09,0x81,0x4B,0x22,0xD3,0xE2,0xA5,0x2E } },
+		{ 16 , { 0x37,0xDC,0xF7,0x8D,0xFA,0xC8,0xBE,0x3D,0x7D,0xBC,0x2E,0x62,0x20,0x17,0x87,0x1B } },
+		{  2 , { 0x41,0x64 } },
+		{  8 , { 0x08,0xE8,0x9F,0xDE,0x19,0xCD,0x78,0xEE } },
+		{  9 , { 0x38,0x42,0xAA,0xBE,0x44,0xAC,0xFA,0x33,0x78 } },
+		{  8 , { 0x08,0xD7,0x97,0x0C,0x6C,0xF2,0xEC,0xE7 } },
+		{  5 , { 0x44,0x3E,0x3D,0x8F,0x96 } },
+		{  8 , { 0x09,0x36,0x0E,0xA2,0xB8,0xF8,0x01,0x1C } },
+		{  8 , { 0x09,0xA3,0xA3,0xD2,0x53,0x5F,0xD4,0xD0 } },
+		{ 16 , { 0x3F,0xFA,0xD0,0xBF,0xD6,0x21,0xB4,0x67,0xA0,0xCC,0x51,0xDC,0xB5,0x7D,0xFD,0xBE } },
+		{  2 , { 0x49,0x20 } },
+		{  8 , { 0x08,0xC1,0xE2,0x4D,0xF4,0x56,0xAD,0xAD } },
+		{  8 , { 0x08,0x12,0xDF,0x04,0xA3,0x1B,0xC2,0x81 } },
+		{ 16 , { 0x3F,0x83,0xD3,0x97,0x48,0xDA,0xE9,0x2C,0x2C,0xE4,0x24,0x5B,0x95,0x4F,0x9E,0x12 } },
+		{  6 , { 0x45,0x39,0x9F,0x86,0xF8,0x31 } },
+		{  8 , { 0x09,0x23,0x5A,0xF5,0xB1,0x91,0x9D,0x82 } },
+		{  9 , { 0x38,0x3D,0xBD,0xED,0x9C,0xC7,0x98,0x22,0x0E } },
+		{  8 , { 0x08,0xE1,0x7B,0x7B,0xB5,0x9B,0xFA,0xFC } },
+		{  5 , { 0x4C,0x01,0x2D,0x76,0x1C } },
+		{  8 , { 0x08,0xFC,0x48,0x5D,0x0A,0x61,0x17,0xD7 } },
+		{  8 , { 0x08,0x6E,0xB0,0x81,0x3C,0xC9,0x2D,0x77 } },
+		{  5 , { 0x44,0xDA,0x56,0x75,0xB0 } },
+		{  8 , { 0x08,0x4F,0xDF,0x0C,0xC0,0x6F,0x32,0xBA } },
+		{  5 , { 0x4C,0xB5,0x3F,0xB7,0xDC } },
+		{  8 , { 0x08,0x06,0xF3,0xAD,0x9A,0x4B,0x73,0x1F } },
+		{  8 , { 0x0C,0x8E,0x0E,0x1C,0x6A,0x87,0x89,0x05 } },
+		{  9 , { 0x38,0xF4,0x5C,0x97,0x8B,0x78,0x77,0x75,0xAD } },
+		{  8 , { 0x0C,0xB1,0x6E,0x1E,0x67,0x04,0x01,0x6E } },
+};
+
+#define Si2168B_PATCH16_4_0b9_LINES (sizeof(Si2168B_PATCH16_4_0b9)/(sizeof(firmware_struct)))
+
+#endif /* __SI2168B_PRIV_H__ */
--- linux-4.15/drivers/media/dvb-frontends/silg.c.0140~	2018-02-12 11:32:52.766582165 +0100
+++ linux-4.15/drivers/media/dvb-frontends/silg.c	2018-02-12 11:32:52.766582165 +0100
@@ -0,0 +1,709 @@
+/* DVB compliant Linux driver for dual demodulator system with
+*  a Silicon Labs Si2168B DVB-T/T2/C demodulator
+*  and a LG 3306A ATSC demodulator
+*
+* Copyright (C) 2014 PCTV Systems S.Ã  r.l & Silicon Laboratories Inc.
+*
+*/
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+
+#include "dvb_frontend.h"
+#include "silg.h"
+
+static int debug = 0;
+module_param_named(debug, debug, int, 0644);
+
+#define _SI_ 0 /* index referencing Silicon Labs Si2168B demodulator */
+#define _LG_ 1 /* index referencing LG3306A demodulator */
+
+#define silg_printk(args...) \
+	do { \
+		if (debug) \
+			printk(KERN_DEBUG "silg: " args); \
+	} while (0)
+
+struct silg_priv {
+	int si_demod_enable:1;
+	int lg_demod_enable:1;
+	struct si2168b_config si2168b_cfg;
+	struct lgdt3306a_config lgdt3306a_cfg;
+	struct dvb_frontend *demod[2];
+	int demod_bus_state[2]; /* flag to avoid unnecessary calls */
+	struct dvb_frontend frontend;
+	enum fe_delivery_system delivery_system;
+	u32 dmid; /* demod id used as index */
+};
+
+/* names of the delivery systems for debugging purposes only */
+static char *delsys_name(enum fe_delivery_system delsys)
+{
+	switch (delsys)	{
+	case SYS_UNDEFINED    : {return (char*)"SYS_UNDEFINED"   ;}
+	case SYS_DVBC_ANNEX_A : {return (char*)"SYS_DVBC_ANNEX_A";}
+	case SYS_DVBC_ANNEX_B : {return (char*)"SYS_DVBC_ANNEX_B";}
+	case SYS_DVBT         : {return (char*)"SYS_DVBT"        ;}
+	case SYS_DSS          : {return (char*)"SYS_DSS"         ;}
+	case SYS_DVBS         : {return (char*)"SYS_DVBS"        ;}
+	case SYS_DVBS2        : {return (char*)"SYS_DVBS2"       ;}
+	case SYS_DVBH         : {return (char*)"SYS_DVBH"        ;}
+	case SYS_ISDBT        : {return (char*)"SYS_ISDBT"       ;}
+	case SYS_ISDBS        : {return (char*)"SYS_ISDBS"       ;}
+	case SYS_ISDBC        : {return (char*)"SYS_ISDBC"       ;}
+	case SYS_ATSC         : {return (char*)"SYS_ATSC"        ;}
+	case SYS_ATSCMH       : {return (char*)"SYS_ATSCMH"      ;}
+	case SYS_DTMB         : {return (char*)"SYS_DTMB"        ;}
+	case SYS_CMMB         : {return (char*)"SYS_CMMB"        ;}
+	case SYS_DAB          : {return (char*)"SYS_DAB"         ;}
+	case SYS_DVBT2        : {return (char*)"SYS_DVBT2"       ;}
+	case SYS_TURBO        : {return (char*)"SYS_TURBO"       ;}
+	case SYS_DVBC_ANNEX_C : {return (char*)"SYS_DVBC_ANNEX_C";}
+    default:
+    	break;
+	}
+	return (char*)"* UNKNOWN *";
+}
+
+static int silg_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)
+{
+	struct silg_priv *priv = fe->demodulator_priv;
+	struct dvb_frontend *demod = priv->demod[priv->dmid];
+
+	return demod ? demod->ops.i2c_gate_ctrl(demod, enable) : -ENODEV;
+}
+
+/* control both demodulator ts busses to avoid bus conflicts
+   modes:
+   Si2168B ON,        LG3306A tri-state
+   Si2168B tri-state, LG3306A ON
+   Si2168B tri-state, LG3306A tri-state
+ */
+static int silg_ts_bus_ctrl(struct dvb_frontend* fe, int acquire)
+{
+	struct silg_priv *priv = fe->demodulator_priv;
+	struct dvb_frontend *demod;
+	int ret = 0;
+
+	silg_printk("%s() acquire=%d\n", __func__, acquire);
+
+	if (acquire) {
+		if (priv->dmid == _SI_) {
+			/* turn off demod[_LG_] */
+			if (priv->lg_demod_enable && priv->demod_bus_state[_LG_] != 0 ) {
+				demod = priv->demod[_LG_];
+				silg_printk("%s() disabling LG3306A output bus\n", __func__);
+				ret = demod->ops.ts_bus_ctrl(demod, 0);
+				if (ret==0) priv->demod_bus_state[_LG_] = 0;
+			}
+			/* turn on demod[_SI_] */
+			if (priv->si_demod_enable && priv->demod_bus_state[_SI_] != 1 ) {
+				demod = priv->demod[_SI_];
+				silg_printk("%s() enabling Si2168B output bus\n", __func__);
+				ret = demod->ops.ts_bus_ctrl(demod, 1);
+				if (ret==0) priv->demod_bus_state[_SI_] = 1;
+			}
+		} else { /* priv->dmid != _SI_ */
+			/* turn off demod[_SI_] */
+			if (priv->si_demod_enable && priv->demod_bus_state[_SI_] != 0 ) {
+				demod = priv->demod[_SI_];
+				silg_printk("%s() disabling Si2168B output bus\n", __func__);
+				ret = demod->ops.ts_bus_ctrl(demod, 0);
+				if (ret==0) priv->demod_bus_state[_SI_] = 0;
+			}
+			/* turn on demod[_LG_] */
+			if (priv->lg_demod_enable && priv->demod_bus_state[_LG_] != 1 ) {
+				demod = priv->demod[_LG_];
+				silg_printk("%s() enabling LG3306A output bus\n", __func__);
+				ret = demod->ops.ts_bus_ctrl(demod, 1);
+				if (ret==0) priv->demod_bus_state[_LG_] = 1;
+			}
+		}
+	} else { /* !acquire */
+		silg_printk("%s() setting all demod output buses to tri-state\n", __func__);
+		if (priv->si_demod_enable && priv->demod_bus_state[_SI_] != 0) {
+			demod = priv->demod[_SI_];
+			ret = demod->ops.ts_bus_ctrl(demod, 0);
+			if (ret==0) priv->demod_bus_state[_SI_] = 0;
+		}
+		if (ret == 0 && priv->lg_demod_enable && priv->demod_bus_state[_LG_] != 0) {
+			demod = priv->demod[_LG_];
+			ret = demod->ops.ts_bus_ctrl(demod, 0);
+			if (ret==0) priv->demod_bus_state[_LG_] = 0;
+		}
+	}
+
+	return ret;
+}
+
+static int silg_init(struct dvb_frontend *fe)
+{
+	struct silg_priv *priv = fe->demodulator_priv;
+	struct dvb_frontend *demod;
+
+	silg_printk("((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\n");
+	silg_printk("(((                       %s()                  )))\n", __func__);
+	silg_printk("))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n");
+
+	if (priv->si_demod_enable) {
+		demod = priv->demod[_SI_];
+		if (!demod) {
+			silg_printk("%s(): Silicon Labs demod configured but not available\n", __func__);
+			goto err;
+		}
+		if (fe->tuner_priv) {
+			demod->tuner_priv = fe->tuner_priv;
+			memcpy(&demod->ops.tuner_ops, &fe->ops.tuner_ops, sizeof(struct dvb_tuner_ops));
+		}
+		if (demod->ops.init(demod)) {
+			silg_printk("%s(): initializing Silicon Labs demod failed\n", __func__);
+			goto err;
+		}
+		/* reconfigure the ts bus tri-state control after init */
+		switch (priv->demod_bus_state[_SI_]) {
+		case 0: demod->ops.ts_bus_ctrl(demod, 0); break;
+		case 1: demod->ops.ts_bus_ctrl(demod, 1); break;
+		}
+	}
+	silg_printk("%s(): initializing Silicon Labs demod succeeded\n", __func__);
+
+	if (priv->lg_demod_enable) {
+		demod = priv->demod[_LG_];
+		if (!demod) {
+			silg_printk("%s(): LG demod configured but not available\n", __func__);
+			goto err;
+		}
+		if (fe->tuner_priv) {
+			demod->tuner_priv = fe->tuner_priv;
+			memcpy(&demod->ops.tuner_ops, &fe->ops.tuner_ops, sizeof(struct dvb_tuner_ops));
+		}
+		if (demod->ops.init(demod)) {
+			silg_printk("%s(): initializing LG demod failed\n", __func__);
+			goto err;
+		}
+		/* reconfigure the ts bus tri-state control after init */
+		switch (priv->demod_bus_state[_LG_]) {
+		case 0: demod->ops.ts_bus_ctrl(demod, 0); break;
+		case 1: demod->ops.ts_bus_ctrl(demod, 1); break;
+		default:
+			silg_printk("%s(): lg demod not reconfigured (demod_bus_state=%d)\n", __func__, priv->demod_bus_state[_LG_]);
+			break;
+		}
+	}
+	silg_printk("%s(): initializing LG demod succeeded\n", __func__);
+
+	return 0;
+
+err:
+	printk(KERN_ERR "%s(): failed\n", __func__);
+	return -ENODEV;
+}
+
+static int silg_read_status(struct dvb_frontend *fe, enum fe_status *status)
+{
+	struct silg_priv *priv = fe->demodulator_priv;
+	struct dvb_frontend *demod = priv->demod[priv->dmid];
+
+	return demod ? demod->ops.read_status(demod, status) : -ENODEV;
+}
+
+static int silg_read_signal_strength(struct dvb_frontend *fe, u16 *rssi)
+{
+	struct silg_priv *priv = fe->demodulator_priv;
+	struct dvb_frontend *demod = priv->demod[priv->dmid];
+
+	return demod ? demod->ops.read_signal_strength(demod, rssi) : -ENODEV;
+}
+
+static int silg_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct silg_priv *priv = fe->demodulator_priv;
+	struct dvb_frontend *demod = priv->demod[priv->dmid];
+
+	return demod ? demod->ops.read_ber(demod, ber) : -ENODEV;
+}
+
+static int silg_read_snr(struct dvb_frontend *fe, u16 *cnr)
+{
+	struct silg_priv *priv = fe->demodulator_priv;
+	struct dvb_frontend *demod = priv->demod[priv->dmid];
+
+	return demod ? demod->ops.read_snr(demod, cnr) : -ENODEV;
+}
+
+static int silg_read_ucblocks(struct dvb_frontend *fe, u32 *uncorrs)
+{
+	struct silg_priv *priv = fe->demodulator_priv;
+	struct dvb_frontend *demod = priv->demod[priv->dmid];
+
+	return demod ? demod->ops.read_ucblocks(demod, uncorrs) : -ENODEV;
+}
+
+static int select_demod(struct dvb_frontend *fe, enum fe_delivery_system delsys)
+{
+	struct silg_priv *priv = fe->demodulator_priv;
+	u32    dmid = priv->dmid;
+
+	switch (delsys) {
+	case SYS_ATSC:
+	case SYS_DVBC_ANNEX_B:
+		dmid = _LG_; /* LG demod */
+		break;
+	case SYS_DVBT:
+	case SYS_DVBT2:
+	case SYS_DVBC_ANNEX_A:
+		dmid = _SI_; /* SiLabs demod */
+		break;
+	default:
+		silg_printk("%s : ERROR: delivery system %s not supported\n", __func__, delsys_name(delsys));
+		return -EINVAL;
+	}
+	silg_printk("%s(): changing delivery system from %s to %s\n", __func__,
+			delsys_name(priv->delivery_system), delsys_name(delsys));
+
+	priv->delivery_system = delsys;
+
+	if (dmid != priv->dmid) {
+		silg_printk("%s(): changing demod from %s to %s\n", __func__,
+				priv->dmid ? "LG" : "SI", dmid ? "LG" : "SI");
+		priv->dmid = dmid;
+	}
+	return 0;
+}
+
+static int silg_set_frontend(struct dvb_frontend *fe)
+{
+	struct silg_priv *priv = fe->demodulator_priv;
+	struct dvb_frontend *demod;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	int ret = 0;
+
+	silg_printk("%s(): FE_SET_FRONTEND delsys=%s\n", __func__, delsys_name(p->delivery_system));
+
+	if (p->delivery_system != priv->delivery_system) {
+		ret = select_demod(fe, p->delivery_system);
+		if (ret) {
+			return ret;
+		}
+	}
+
+	demod = priv->demod[priv->dmid];
+	if (!demod) {
+		silg_printk("%s(): ERROR: no demod for index=%u\n", __func__, priv->dmid);
+		return -ENODEV;
+	}
+
+	if (priv->demod_bus_state[priv->dmid] != 1) { /* ts bus of the demod already enabled? */
+		ret = silg_ts_bus_ctrl(fe, 1); /* enable ts bus of the selected demod */
+		if (ret) {
+			return ret;
+		}
+	}
+
+	memcpy(&demod->dtv_property_cache, &fe->dtv_property_cache, sizeof(struct dtv_frontend_properties));
+	return demod->ops.set_frontend(demod);
+}
+
+static int silg_get_frontend(struct dvb_frontend *fe, struct dtv_frontend_properties *fe_params)
+{
+	struct silg_priv *priv = fe->demodulator_priv;
+	struct dvb_frontend *demod = priv->demod[priv->dmid];
+	int ret = 0;
+
+	if (!demod)
+		return -ENODEV;
+
+	ret = demod->ops.get_frontend(demod, fe_params);
+	if (ret) {
+		return ret;
+	}
+	memcpy(&fe->dtv_property_cache, &demod->dtv_property_cache, sizeof(struct dtv_frontend_properties));
+	memcpy(fe_params, &demod->dtv_property_cache, sizeof(struct dtv_frontend_properties));
+	return ret;
+}
+
+static int silg_sleep(struct dvb_frontend *fe)
+{
+	struct silg_priv *priv = fe->demodulator_priv;
+	struct dvb_frontend *demod;
+	int ret = 0;
+
+	if (priv->si_demod_enable) {
+		demod = priv->demod[_SI_];
+		if(!demod){
+			silg_printk("%s : ERROR: no demod for index=%d\n", __func__, _SI_);
+			return -ENODEV;
+		}
+		ret = demod->ops.sleep(demod);
+	}
+	if (priv->lg_demod_enable) {
+		demod = priv->demod[_LG_];
+		if(!demod){
+			silg_printk("%s : ERROR: no demod for index=%d\n", __func__, _LG_);
+			return -ENODEV;
+		}
+		ret |= demod->ops.sleep(demod);
+	}
+	return ret;
+}
+
+static void silg_release(struct dvb_frontend *fe)
+{
+	struct silg_priv *priv = fe->demodulator_priv;
+	struct dvb_frontend *demod;
+
+	silg_printk("%s\n", __func__);
+
+	if (priv->si_demod_enable) {
+		demod = priv->demod[_SI_];
+		if(demod){
+			demod->ops.release(demod);
+			symbol_put_addr((void*)demod->ops.release);
+		} else {
+			silg_printk("%s : ERROR: no demod for index=%d\n", __func__, _SI_);
+		}
+	}
+	if (priv->lg_demod_enable) {
+		demod = priv->demod[_LG_];
+		if(demod){
+			demod->ops.release(demod);
+			symbol_put_addr((void*)demod->ops.release);
+		} else {
+			silg_printk("%s : ERROR: no demod for index=%d\n", __func__, _LG_);
+		}
+	}
+	if (priv)
+		kfree(priv);
+}
+
+static int silg_get_tune_settings(struct dvb_frontend *fe,
+				      struct dvb_frontend_tune_settings
+					*fe_tune_settings)
+{
+	struct silg_priv *priv = fe->demodulator_priv;
+	struct dvb_frontend *demod = priv->demod[priv->dmid];
+
+	return demod ? demod->ops.get_tune_settings(demod, fe_tune_settings) : -ENODEV;
+}
+
+#ifdef CUSTOM_TUNING_ALGO
+static int silg_tune(struct dvb_frontend *fe, bool re_tune, unsigned int mode_flags, unsigned int *delay, enum fe_status *status)
+{
+	struct silg_priv *priv = fe->demodulator_priv;
+	struct dvb_frontend *demod;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	int ret = 0;
+
+	silg_printk("%s(): delsys=%s\n", __func__, delsys_name(p->delivery_system));
+
+	if (p->delivery_system != priv->delivery_system) {
+		ret = select_demod(fe, p->delivery_system);
+		if (ret) {
+			return ret;
+		}
+	}
+
+	demod = priv->demod[priv->dmid];
+	if(!demod) {
+		silg_printk("%s : ERROR: no demod for index=%u\n", __func__, priv->dmid);
+		return -ENODEV;
+	}
+
+	if (priv->demod_bus_state[priv->dmid] != 1) { /* ts bus of the demod already enabled? */
+		ret = silg_ts_bus_ctrl(fe, 1); /* enable ts bus of the selected demod */
+		if (ret) {
+			return ret;
+		}
+	}
+
+	memcpy(&demod->dtv_property_cache, &fe->dtv_property_cache, sizeof(struct dtv_frontend_properties));
+	return demod ? demod->ops.tune(demod, re_tune, mode_flags, delay, status) : -ENODEV;
+}
+
+static enum dvbfe_algo silg_get_frontend_algo(struct dvb_frontend *fe)
+{
+	struct silg_priv *priv = fe->demodulator_priv;
+	struct dvb_frontend *demod = priv->demod[priv->dmid];
+
+	return demod ? demod->ops.get_frontend_algo(demod) : -ENODEV;
+}
+
+static enum dvbfe_search silg_search(struct dvb_frontend *fe)
+{
+	struct silg_priv *priv = fe->demodulator_priv;
+	struct dvb_frontend *demod;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	int ret = 0;
+
+	silg_printk("%s(): delsys=%s\n", __func__, delsys_name(p->delivery_system));
+
+	if (p->delivery_system != priv->delivery_system) {
+		ret = select_demod(fe, p->delivery_system);
+		if (ret) {
+			return ret;
+		}
+	}
+
+	demod = priv->demod[priv->dmid];
+	if(!demod) {
+		silg_printk("%s : ERROR: no demod for index=%u\n", __func__, priv->dmid);
+		return -ENODEV;
+	}
+
+	if (priv->demod_bus_state[priv->dmid] != 1) { /* ts bus of the demod already enabled? */
+		ret = silg_ts_bus_ctrl(fe, 1); /* enable ts bus of the selected demod */
+		if (ret) {
+			return ret;
+		}
+	}
+
+	memcpy(&demod->dtv_property_cache, &fe->dtv_property_cache, sizeof(struct dtv_frontend_properties));
+	return demod->ops.search(demod);
+}
+#endif /* CUSTOM_TUNING_ALGO */
+
+#ifdef FE_READ_STREAM_IDS
+static int silg_read_stream_ids(struct dvb_frontend *fe, struct dvb_stream_ids* ids)
+{
+	struct silg_priv *priv = fe->demodulator_priv;
+	struct dvb_frontend *demod = priv->demod[priv->dmid];
+
+	return demod ? demod->ops.read_stream_ids(demod, ids) : -ENODEV;
+}
+#endif /* FE_READ_STREAM_IDS */
+
+static const struct dvb_frontend_ops silg_ops = {
+		.delsys = { SYS_DVBC_ANNEX_B, SYS_ATSC, SYS_DVBT, SYS_DVBT2, SYS_DVBC_ANNEX_A },
+		.info = {
+				.name = "SILG DVB-T/T2/C ATSC",
+				.frequency_stepsize = 62500,
+				.frequency_min = 48000000,
+				.frequency_max = 870000000,
+				.symbol_rate_min = 870000,
+				.symbol_rate_max = 7501000,
+				.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3
+				| FE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8
+				| FE_CAN_FEC_AUTO | FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_32
+				| FE_CAN_QAM_64 | FE_CAN_QAM_128 | FE_CAN_QAM_256
+				| FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO
+				| FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO
+				| FE_CAN_MULTISTREAM | FE_CAN_2G_MODULATION | FE_CAN_MUTE_TS
+				| FE_CAN_8VSB
+		},
+
+		.release = silg_release,
+		/*.release_sec,*/
+
+		.init = silg_init,
+		.sleep = silg_sleep,
+
+		/*.write,*/
+
+		/* these two are only used for the swzigzag code */
+		.set_frontend = silg_set_frontend,
+		.get_tune_settings = silg_get_tune_settings,
+
+		.get_frontend = silg_get_frontend,
+
+		.read_status = silg_read_status,
+		.read_ber = silg_read_ber,
+		.read_signal_strength = silg_read_signal_strength,
+		.read_snr = silg_read_snr,
+		.read_ucblocks = silg_read_ucblocks,
+
+		.i2c_gate_ctrl = silg_i2c_gate_ctrl,
+		.ts_bus_ctrl = silg_ts_bus_ctrl,
+		/* .set_lna, */
+
+#ifdef CUSTOM_TUNING_ALGO
+		/* if this is set, it overrides the default swzigzag */
+		.tune = silg_tune,
+		/* get frontend tuning algorithm from the module */
+		.get_frontend_algo = silg_get_frontend_algo,
+
+		/* These callbacks are for devices that implement their own
+		 * tuning algorithms, rather than a simple swzigzag
+		 */
+		.search = silg_search,
+#endif
+
+		/* Allow the frontend to validate incoming properties */
+		/*.set_property, */
+		/*.get_property, */
+#ifdef FE_READ_STREAM_IDS
+		.read_stream_ids = silg_read_stream_ids,
+#endif
+};
+
+static int ops_incomplete(struct dvb_frontend *demod)
+{
+	int ret = 0;
+	if (!demod){
+		silg_printk("ERROR: demod==NULL\n"); return -1;
+	}
+	if (!demod->ops.release){
+		silg_printk("ERROR: ops.release missing\n"); ret = -1;
+	}
+	if (!demod->ops.sleep){
+		silg_printk("ERROR: ops.sleep missing\n"); ret = -1;
+	}
+	if (!demod->ops.sleep){
+		silg_printk("ERROR: ops.sleep missing\n"); ret = -1;
+	}
+	if (!demod->ops.set_frontend){
+		silg_printk("ERROR: ops.set_frontend missing\n"); ret = -1;
+	}
+	if (!demod->ops.get_tune_settings){
+		silg_printk("ERROR: ops.get_tune_settings missing\n"); ret = -1;
+	}
+	if (!demod->ops.get_frontend){
+		silg_printk("ERROR: ops.get_frontend missing\n"); ret = -1;
+	}
+	if (!demod->ops.read_status){
+		silg_printk("ERROR: ops.read_status missing\n"); ret = -1;
+	}
+	if (!demod->ops.read_ber){
+		silg_printk("ERROR: ops.read_ber missing\n"); ret = -1;
+	}
+	if (!demod->ops.read_signal_strength){
+		silg_printk("ERROR: ops.read_signal_strength missing\n"); ret = -1;
+	}
+	if (!demod->ops.read_snr){
+		silg_printk("ERROR: ops.read_snr missing\n"); ret = -1;
+	}
+	if (!demod->ops.read_ucblocks){
+		silg_printk("ERROR: ops.read_ucblocks missing\n"); ret = -1;
+	}
+	if (!demod->ops.i2c_gate_ctrl){
+		silg_printk("ERROR: ops.i2c_gate_ctrl missing\n"); ret = -1;
+	}
+	if (!demod->ops.ts_bus_ctrl){
+		silg_printk("ERROR: ops.ts_bus_ctrl missing\n"); ret = -1;
+	}
+
+#ifdef CUSTOM_TUNING_ALGO
+	if (!demod->ops.tune){
+		silg_printk("ERROR: ops.tune missing\n"); ret = -1;
+	}
+	if (!demod->ops.get_frontend_algo){
+		silg_printk("ERROR: ops.get_frontend_algo missing\n"); ret = -1;
+	}
+	if (!demod->ops.search){
+		silg_printk("ERROR: ops.search missing\n"); ret = -1;
+	}
+#endif
+
+#ifdef FE_READ_STREAM_IDS
+	if (!demod->ops.read_stream_ids){
+		silg_printk("ERROR: ops.read_stream_ids missing\n"); ret = -1;
+	}
+#endif
+	return ret;
+}
+
+struct dvb_frontend *silg_attach(const struct silg_config *config, struct i2c_adapter *i2c)
+{
+	struct silg_priv *priv = NULL;
+
+	silg_printk("%s()\n", __func__);
+
+	if (!config) {
+		silg_printk("ERROR: configuration missing\n");
+		goto error;
+	}
+
+	if (config->si_demod_enable == 0 && config->lg_demod_enable == 0) {
+		silg_printk("%s(): no demodulator configured.\n", __func__);
+		goto error;
+	}
+
+	/* allocate memory */
+	priv = kzalloc(sizeof(struct silg_priv), GFP_KERNEL);
+	if (priv == NULL) {
+		silg_printk("%s(): kzalloc() failed.\n", __func__);
+		goto error;
+	}
+
+	priv->si_demod_enable = config->si_demod_enable;
+	if (priv->si_demod_enable) {
+		priv->si2168b_cfg.demod_address = config->si_i2c_addr;
+		priv->si2168b_cfg.min_delay_ms = config->min_delay_ms;
+		priv->si2168b_cfg.ts_bus_mode = config->ts_bus_mode;
+		priv->si2168b_cfg.ts_clock_mode = config->ts_clock_mode;
+		priv->si2168b_cfg.clk_gapped_en = config->clk_gapped_en;
+		priv->si2168b_cfg.ts_par_clk_invert = config->ts_par_clk_invert;
+		priv->si2168b_cfg.ts_par_clk_shift = config->ts_par_clk_shift;
+		priv->si2168b_cfg.fef_mode = config->fef_mode;
+		priv->si2168b_cfg.fef_pin = config->fef_pin;
+		priv->si2168b_cfg.fef_level = config->fef_level;
+		priv->si2168b_cfg.indirect_i2c_connection = config->indirect_i2c_connection;
+		priv->si2168b_cfg.start_ctrl = config->start_ctrl;
+
+		priv->demod[_SI_] = dvb_attach(si2168b_attach, &priv->si2168b_cfg, i2c);
+		if (!priv->demod[_SI_]) {
+			silg_printk("%s(): ERROR: attaching module si2168b failed.\n", __func__);
+			kfree(priv);
+			goto error;
+		}
+		if (ops_incomplete(priv->demod[_SI_])) {
+			silg_printk("%s(): ERROR: interface of si2168b is incomplete.\n", __func__);
+			kfree(priv);
+			goto error;
+		}
+		priv->demod_bus_state[_SI_] = -1; /* undefined */
+		pr_info("%s(): attached si2168b\n", __func__);
+	}
+
+	priv->lg_demod_enable = config->si_demod_enable;
+	if (priv->lg_demod_enable) {
+		priv->lgdt3306a_cfg.i2c_addr           = config->lg_i2c_addr;
+		priv->lgdt3306a_cfg.mpeg_mode          = config->mpeg_mode;
+		priv->lgdt3306a_cfg.tpclk_edge         = config->tpclk_edge;
+		priv->lgdt3306a_cfg.tpvalid_polarity   = config->tpvalid_polarity;
+		priv->lgdt3306a_cfg.deny_i2c_rptr      = config->deny_i2c_rptr;
+		priv->lgdt3306a_cfg.spectral_inversion = config->spectral_inversion;
+		priv->lgdt3306a_cfg.qam_if_khz         = config->qam_if_khz;
+		priv->lgdt3306a_cfg.vsb_if_khz         = config->vsb_if_khz;
+		priv->lgdt3306a_cfg.xtalMHz            = config->xtalMHz;
+		priv->demod[_LG_] = dvb_attach(lgdt3306a_attach, &priv->lgdt3306a_cfg, i2c);
+		if (!priv->demod[_LG_]) {
+			silg_printk("%s(): ERROR: attaching module lgdt3306a failed.\n", __func__);
+			kfree(priv);
+			goto error;
+		}
+		if (ops_incomplete(priv->demod[_LG_])) {
+			silg_printk("%s(): ERROR: interface of lgdt3306a is incomplete.\n", __func__);
+			kfree(priv);
+			goto error;
+		}
+		priv->demod_bus_state[_LG_] = -1; /* undefined */
+		pr_info("%s(): attached lgdt3306a\n", __func__);
+	}
+
+	priv->dmid = (priv->si_demod_enable) ? _SI_ : _LG_; /* set default demod */
+	priv->delivery_system = SYS_UNDEFINED;
+
+	/* create dvb_frontend */
+	memcpy(&priv->frontend.ops, &silg_ops, sizeof(struct dvb_frontend_ops));
+	priv->frontend.demodulator_priv = priv;
+
+	return &priv->frontend;
+
+error:
+	return NULL;
+}
+EXPORT_SYMBOL(silg_attach);
+
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
+
+MODULE_DESCRIPTION("SILG SiLabs + LG Dual Demodulator Driver");
+MODULE_AUTHOR("Henning Garbers <hgarbers@pctvsystems.com>");
+/* MODULE_LICENSE("Proprietary"); */
+/* GPL discussion for silg not finished. Set to GPL for internal usage only. */
+/* The module uses GPL functions and is rejected by the kernel build if the */
+/* license is set to 'Proprietary'. */
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
--- linux-4.15/drivers/media/dvb-frontends/silg.h.0140~	2018-02-12 11:32:52.767582173 +0100
+++ linux-4.15/drivers/media/dvb-frontends/silg.h	2018-02-12 11:32:52.767582173 +0100
@@ -0,0 +1,69 @@
+#ifndef SILG_H
+#define SILG_H
+
+#include <linux/kconfig.h>
+#include <linux/dvb/frontend.h>
+#include "dvb_frontend.h"
+
+#include "lgdt3306a.h"
+#include "si2168b.h"
+
+#define CUSTOM_TUNING_ALGO
+
+struct silg_config {
+	/* Si2168B demodulator configuration */
+	int si_demod_enable:1; /* 0:no SiLabs demod 1:SiLabs demod present */
+
+	u8 si_i2c_addr; /* the Si2168B demodulator's i2c address */
+	u8 ts_bus_mode; /*1-serial, 2-parallel.*/
+	u8 ts_clock_mode; /*0-auto, 1-manual.*/
+	u8 clk_gapped_en; /*0-disabled, 1-enabled.*/
+	u8 ts_par_clk_invert; /* 0-not-invert, 1-invert */
+	u8 ts_par_clk_shift;
+    u8 fef_mode; /*0-slow normal AGC, 1-freeze pin, 2-slow initial AGC*/
+	u8 fef_pin; /* FEF pin connected to TER tuner AGC freeze input */
+	u8 fef_level; /* GPIO state on FEF_pin when used (during FEF periods) */
+
+	/* tuner i2c connection               */
+	/* 0-tuner connected through Si2168B  */
+	/* 1-tuner is direct accessible       */
+	u8 indirect_i2c_connection;
+
+	int min_delay_ms; /* minimum delay before retuning */
+	int (*start_ctrl)(struct dvb_frontend *fe);
+
+	/* LG3306A demodulator configuration */
+	int lg_demod_enable:1; /* 0:no LG demod 1:LG demod present */
+
+	u8 lg_i2c_addr; /* the LG3306A demodulator's i2c address */
+
+	/* user defined IF frequency in KHz */
+	u16 qam_if_khz;
+	u16 vsb_if_khz;
+
+	/* disable i2c repeater - 0:repeater enabled 1:repeater disabled */
+	int deny_i2c_rptr:1;
+
+	/* spectral inversion - 0:disabled 1:enabled */
+	int spectral_inversion:1;
+
+	enum lgdt3306a_mpeg_mode mpeg_mode;
+	enum lgdt3306a_tp_clock_edge tpclk_edge;
+	enum lgdt3306a_tp_valid_polarity tpvalid_polarity;
+
+	int  xtalMHz;//demod clock freq in MHz; 24 or 25 supported
+};
+
+#if IS_ENABLED(CONFIG_DVB_SILG)
+extern struct dvb_frontend *silg_attach(const struct silg_config *config,
+						struct i2c_adapter *i2c);
+#else
+static inline struct dvb_frontend *silg_attach(
+		const struct silg_config *config, struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif
--- linux-4.15/drivers/media/pci/saa7164/Kconfig.0140~	2018-01-28 22:20:33.000000000 +0100
+++ linux-4.15/drivers/media/pci/saa7164/Kconfig	2018-02-12 11:32:52.767582173 +0100
@@ -7,7 +7,10 @@ config VIDEO_SAA7164
 	select VIDEO_TVEEPROM
 	select DVB_TDA10048 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_S5H1411 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_LGDT3306A if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_SI2168B if MEDIA_SUBDRV_AUTOSELECT
 	select MEDIA_TUNER_TDA18271 if MEDIA_SUBDRV_AUTOSELECT
+	select MEDIA_TUNER_SILABS_TERCAB if MEDIA_SUBDRV_AUTOSELECT
 	---help---
 	  This is a video4linux driver for NXP SAA7164 based
 	  TV cards.
--- linux-4.15/drivers/media/pci/saa7164/saa7164-api.c.0140~	2018-01-28 22:20:33.000000000 +0100
+++ linux-4.15/drivers/media/pci/saa7164/saa7164-api.c	2018-02-12 11:32:52.767582173 +0100
@@ -560,12 +560,43 @@ int saa7164_api_set_audio_std(struct saa
 		printk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);
 
 	/* Manually select the appropriate TV audio standard */
-	if (port->encodernorm.id & V4L2_STD_NTSC) {
+	if ((port->encodernorm.id & V4L2_STD_NTSC_M) == port->encodernorm.id) {
+		dprintk(DBGLVL_API, " NTSC-M Audio\n");
 		tvaudio.std = TU_STANDARD_NTSC_M;
 		tvaudio.country = 1;
-	} else {
+	} else if ((port->encodernorm.id & V4L2_STD_NTSC_M_JP) == port->encodernorm.id) {
+		dprintk(DBGLVL_API, " NTSC-M-JP Audio\n");
+		tvaudio.std = TU_STANDARD_NTSC_M_J;
+		tvaudio.country = 81;
+	} else if ((port->encodernorm.id & V4L2_STD_NTSC_443) == port->encodernorm.id) {
+		dprintk(DBGLVL_API, " NTSC-443 Audio\n");
+		tvaudio.std = TU_STANDARD_NTSC_433;
+		tvaudio.country = 1;
+	} else if ((port->encodernorm.id & V4L2_STD_PAL_BG) == port->encodernorm.id) {
+		dprintk(DBGLVL_API, " PAL-BG Audio\n");
+		tvaudio.std = TU_STANDARD_PAL_B;
+		tvaudio.country = 49;
+	} else if ((port->encodernorm.id & V4L2_STD_PAL_I) == port->encodernorm.id) {
+		dprintk(DBGLVL_API, " PAL-I Audio\n");
 		tvaudio.std = TU_STANDARD_PAL_I;
 		tvaudio.country = 44;
+	} else if ((port->encodernorm.id & V4L2_STD_PAL_DK) == port->encodernorm.id) {
+		dprintk(DBGLVL_API, " PAL-DK Audio\n");
+		tvaudio.std = TU_STANDARD_PAL_D;
+		tvaudio.country = 48;
+	} else if ((port->encodernorm.id & V4L2_STD_SECAM_L) == port->encodernorm.id) {
+		dprintk(DBGLVL_API, " SECAM-L\n");
+		tvaudio.std = TU_STANDARD_SECAM_L;
+		tvaudio.country = 33;
+	} else if ((port->encodernorm.id & V4L2_STD_SECAM_LC) == port->encodernorm.id) {
+		dprintk(DBGLVL_API, " SECAM-Lc Audio\n");
+		tvaudio.std = TU_STANDARD_SECAM_L1;
+		tvaudio.country = 33;
+	} else {
+		/* Unknown standard, set NTSC-M */
+		tvaudio.std = 1;
+		tvaudio.country = 1;
+		dprintk(DBGLVL_API, " Unknown (assuming NTSC-M Audio)\n");
 	}
 
 	ret = saa7164_cmd_send(port->dev, port->tunerunit.unitid, SET_CUR,
@@ -573,6 +604,7 @@ int saa7164_api_set_audio_std(struct saa
 	if (ret != SAA_OK)
 		printk(KERN_ERR "%s() TU_STANDARD_CONTROL error, ret = 0x%x\n",
 			__func__, ret);
+
 	return ret;
 }
 
@@ -627,10 +659,14 @@ static int saa7164_api_set_dif(struct sa
 	dprintk(DBGLVL_API, "%s(nr=%d type=%d val=%x)\n", __func__,
 		port->nr, port->type, val);
 
-	if (port->nr == 0)
+	if (port->nr == SAA7164_PORT_ENC1) {
 		mas = 0xd0;
-	else
+	} else if (port->nr == SAA7164_PORT_ENC2) {
 		mas = 0xe0;
+	} else {
+		printk(KERN_ERR "%s() invalid port nr %d\n", __func__, port->nr);
+		return -EIO;
+	}
 
 	memset(buf, 0, sizeof(buf));
 
@@ -676,50 +712,45 @@ static int saa7164_api_set_dif(struct sa
 int saa7164_api_configure_dif(struct saa7164_port *port, u32 std)
 {
 	struct saa7164_dev *dev = port->dev;
-	u8 agc_disable;
+	int ret = 0;
+	u8 agc_disable = 0;
+	u8 video_standard = 0;
 
 	dprintk(DBGLVL_API, "%s(nr=%d, 0x%x)\n", __func__, port->nr, std);
 
-	if (std & V4L2_STD_NTSC) {
-		dprintk(DBGLVL_API, " NTSC\n");
-		saa7164_api_set_dif(port, 0x00, 0x01); /* Video Standard */
-		agc_disable = 0;
-	} else if (std & V4L2_STD_PAL_I) {
+	if ((std & V4L2_STD_NTSC_M) == std) {
+		dprintk(DBGLVL_API, " NTSC-M\n");
+		video_standard = 0x01;
+	} else if ((std & V4L2_STD_NTSC_M_JP) == std) {
+		dprintk(DBGLVL_API, " NTSC-M-JP\n");
+		video_standard = 0x01;
+	} else if ((std & V4L2_STD_NTSC_443) == std) {
+		dprintk(DBGLVL_API, " NTSC-443\n");
+		video_standard = 0x01;
+	} else if ((std & V4L2_STD_PAL_BG) == std) {
+		dprintk(DBGLVL_API, " PAL-BG\n");
+		video_standard = 0x02;
+	} else if ((std & V4L2_STD_PAL_I) == std) {
 		dprintk(DBGLVL_API, " PAL-I\n");
-		saa7164_api_set_dif(port, 0x00, 0x08); /* Video Standard */
-		agc_disable = 0;
-	} else if (std & V4L2_STD_PAL_M) {
-		dprintk(DBGLVL_API, " PAL-M\n");
-		saa7164_api_set_dif(port, 0x00, 0x01); /* Video Standard */
-		agc_disable = 0;
-	} else if (std & V4L2_STD_PAL_N) {
-		dprintk(DBGLVL_API, " PAL-N\n");
-		saa7164_api_set_dif(port, 0x00, 0x01); /* Video Standard */
-		agc_disable = 0;
-	} else if (std & V4L2_STD_PAL_Nc) {
-		dprintk(DBGLVL_API, " PAL-Nc\n");
-		saa7164_api_set_dif(port, 0x00, 0x01); /* Video Standard */
-		agc_disable = 0;
-	} else if (std & V4L2_STD_PAL_B) {
-		dprintk(DBGLVL_API, " PAL-B\n");
-		saa7164_api_set_dif(port, 0x00, 0x02); /* Video Standard */
-		agc_disable = 0;
-	} else if (std & V4L2_STD_PAL_DK) {
+		video_standard = 0x08;
+	} else if ((std & V4L2_STD_PAL_DK) == std) {
 		dprintk(DBGLVL_API, " PAL-DK\n");
-		saa7164_api_set_dif(port, 0x00, 0x10); /* Video Standard */
-		agc_disable = 0;
-	} else if (std & V4L2_STD_SECAM_L) {
+		video_standard = 0x10;
+	} else if ((std & V4L2_STD_SECAM_L) == std) {
 		dprintk(DBGLVL_API, " SECAM-L\n");
-		saa7164_api_set_dif(port, 0x00, 0x20); /* Video Standard */
-		agc_disable = 0;
+		video_standard = 0x20;
+	} else if ((std & V4L2_STD_SECAM_LC) == std) {
+		dprintk(DBGLVL_API, " SECAM-Lc\n");
+		video_standard = 0x40;
 	} else {
 		/* Unknown standard, assume DTV */
 		dprintk(DBGLVL_API, " Unknown (assuming DTV)\n");
 		/* Undefinded Video Standard */
-		saa7164_api_set_dif(port, 0x00, 0x80);
+		video_standard = 0x80;
 		agc_disable = 1;
 	}
 
+	saa7164_api_set_dif(port, 0x00, video_standard);
 	saa7164_api_set_dif(port, 0x48, 0xa0); /* AGC Functions 1 */
 	saa7164_api_set_dif(port, 0xc0, agc_disable); /* AGC Output Disable */
 	saa7164_api_set_dif(port, 0x7c, 0x04); /* CVBS EQ */
@@ -728,7 +759,7 @@ int saa7164_api_configure_dif(struct saa
 	saa7164_api_set_dif(port, 0x04, 0x00); /* Active (again) */
 	msleep(100);
 
-	return 0;
+	return ret;
 }
 
 /* Ensure the dif is in the correct state for the operating mode
--- linux-4.15/drivers/media/pci/saa7164/saa7164-cards.c.0140~	2018-01-28 22:20:33.000000000 +0100
+++ linux-4.15/drivers/media/pci/saa7164/saa7164-cards.c	2018-02-12 11:32:52.767582173 +0100
@@ -634,6 +634,52 @@ struct saa7164_board saa7164_boards[] =
 			.i2c_reg_len	= REGLEN_0bit,
 		} },
 	},
+	[SAA7164_BOARD_HAUPPAUGE_HVR2215] = {
+		.name		= "Hauppauge WinTV-HVR2215",
+		.porta		= SAA7164_MPEG_DVB,
+		.portb		= SAA7164_MPEG_DVB,
+		.portc		= SAA7164_MPEG_ENCODER,
+		.portd		= SAA7164_MPEG_ENCODER,
+		.porte		= SAA7164_MPEG_VBI,
+		.portf		= SAA7164_MPEG_VBI,
+		.chiprev	= SAA7164_CHIP_REV3,
+		.unit		= {{
+			.id		= 0x28,
+			.type		= SAA7164_UNIT_EEPROM,
+			.name		= "4K EEPROM",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_0,
+			.i2c_bus_addr	= 0xa0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x04,
+			.type		= SAA7164_UNIT_TUNER,
+			.name		= "SI2157-1",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_1,	/* physical i2c bus 0 */
+			.i2c_bus_addr	= 0xc0 >> 1,
+			.i2c_reg_len	= 0,
+		}, {
+			.id		= 0x05,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "SI2168B-1",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_1,	/* physical i2c bus 2 */
+			.i2c_bus_addr	= 0xc8 >> 1,
+			.i2c_reg_len	= 0,
+		}, {
+			.id		= 0x25,
+			.type		= SAA7164_UNIT_TUNER,
+			.name		= "SI2157-2",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_2,	/* physical i2c bus 1 */
+			.i2c_bus_addr	= 0xc0 >> 1,
+			.i2c_reg_len	= 0,
+		}, {
+			.id		= 0x26,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "SI2168B-2",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_2,
+			.i2c_bus_addr	= 0xcc >> 1,
+			.i2c_reg_len	= 0,
+		} },
+	},
 };
 const unsigned int saa7164_bcount = ARRAY_SIZE(saa7164_boards);
 
@@ -696,6 +742,10 @@ struct saa7164_subid saa7164_subids[] =
 		.subvendor = 0x0070,
 		.subdevice = 0xf120,
 		.card      = SAA7164_BOARD_HAUPPAUGE_HVR2205,
+	}, {
+		.subvendor = 0x0070,
+		.subdevice = 0xf123,
+		.card      = SAA7164_BOARD_HAUPPAUGE_HVR2215,
 	},
 };
 const unsigned int saa7164_idcount = ARRAY_SIZE(saa7164_subids);
@@ -747,6 +797,7 @@ void saa7164_gpio_setup(struct saa7164_d
 	case SAA7164_BOARD_HAUPPAUGE_HVR2255proto:
 	case SAA7164_BOARD_HAUPPAUGE_HVR2255:
 	case SAA7164_BOARD_HAUPPAUGE_HVR2205:
+	case SAA7164_BOARD_HAUPPAUGE_HVR2215:
 		/*
 		HVR2200 / HVR2250
 		GPIO 2: s5h1411 / tda10048-1 demod reset
@@ -856,6 +907,7 @@ void saa7164_card_setup(struct saa7164_d
 	case SAA7164_BOARD_HAUPPAUGE_HVR2255proto:
 	case SAA7164_BOARD_HAUPPAUGE_HVR2255:
 	case SAA7164_BOARD_HAUPPAUGE_HVR2205:
+	case SAA7164_BOARD_HAUPPAUGE_HVR2215:
 		hauppauge_eeprom(dev, &eeprom[0]);
 		break;
 	}
--- linux-4.15/drivers/media/pci/saa7164/saa7164-core.c.0140~	2018-01-28 22:20:33.000000000 +0100
+++ linux-4.15/drivers/media/pci/saa7164/saa7164-core.c	2018-02-12 11:32:52.767582173 +0100
@@ -34,6 +34,7 @@
 MODULE_DESCRIPTION("Driver for NXP SAA7164 based TV cards");
 MODULE_AUTHOR("Steven Toth <stoth@kernellabs.com>");
 MODULE_LICENSE("GPL");
+MODULE_VERSION("2015-07-10");
 
 /*
  *  1 Basic
--- linux-4.15/drivers/media/pci/saa7164/saa7164-dvb.c.0140~	2018-01-28 22:20:33.000000000 +0100
+++ linux-4.15/drivers/media/pci/saa7164/saa7164-dvb.c	2018-02-12 11:32:52.768582180 +0100
@@ -23,6 +23,8 @@
 #include "si2157.h"
 #include "si2168.h"
 #include "lgdt3306a.h"
+#include "si2168b.h"
+#include "silabs_tercab.h"
 
 #define DRIVER_NAME "saa7164"
 
@@ -81,6 +83,95 @@ static struct s5h1411_config hauppauge_s
 	.mpeg_timing   = S5H1411_MPEGTIMING_CONTINOUS_NONINVERTING_CLOCK,
 };
 
+static struct lgdt3306a_config hauppauge_lgdt3306a_1_config = {
+	/* LG3306A demodulator configuration */
+	.i2c_addr           = 0xB2 >> 1,
+
+	/* user defined IF frequency in KHz */
+	.qam_if_khz         = HVR19x5_QAM_IF, /* needs to match tuner */
+	.vsb_if_khz         = HVR19x5_VSB_IF, /* needs to match tuner */
+
+	/* disable i2c repeater - 0:repeater enabled 1:repeater disabled */
+	.deny_i2c_rptr      = 1,
+
+	/* spectral inversion - 0:disabled 1:enabled */
+	.spectral_inversion = 1,
+
+	.mpeg_mode          = LGDT3306A_MPEG_SERIAL,
+	.tpclk_edge         = LGDT3306A_TPCLK_RISING_EDGE,
+	.tpvalid_polarity   = LGDT3306A_TP_VALID_HIGH,
+
+	.xtalMHz            = 25, /* demod clock freq in MHz; 24 or 25 supported */
+};
+
+static struct lgdt3306a_config hauppauge_lgdt3306a_2_config = {
+	/* LG3306A demodulator configuration */
+	.i2c_addr           = 0x1C >> 1,
+
+	/* user defined IF frequency in KHz */
+	.qam_if_khz         = HVR19x5_QAM_IF, /* needs to match tuner */
+	.vsb_if_khz         = HVR19x5_VSB_IF, /* needs to match tuner */
+
+	/* disable i2c repeater - 0:repeater enabled 1:repeater disabled */
+	.deny_i2c_rptr      = 1,
+
+	/* spectral inversion - 0:disabled 1:enabled */
+	.spectral_inversion = 1,
+
+	.mpeg_mode          = LGDT3306A_MPEG_SERIAL,
+	.tpclk_edge         = LGDT3306A_TPCLK_RISING_EDGE,
+	.tpvalid_polarity   = LGDT3306A_TP_VALID_HIGH,
+
+	.xtalMHz            = 25, /* demod clock freq in MHz; 24 or 25 supported */
+};
+
+static struct si2168b_config hauppauge_si2168b_1_config = {
+	/* the demodulator's i2c address */
+	.demod_address = 0xC8 >> 1,
+
+	/* minimum delay before retuning */
+	.min_delay_ms = 85,
+	.ts_bus_mode = 1, /*1-serial, 2-parallel.*/
+	.ts_clock_mode = 1, /*0-auto_fixed, 1-auto_adapt, 2-manual.*/
+	.clk_gapped_en = 1, /*0-disabled, 1-enabled.*/
+	.ts_par_clk_invert = 1, /*0-not-invert, 1-invert*/
+	.ts_par_clk_shift = 1, /*DVB-C QAM256 fix*/
+	.fef_mode = 1, /* needs to match tuner */
+	.fef_pin = 3,
+	.fef_level = 0,
+	.indirect_i2c_connection = 1, /*Si2157 connected directly*/
+	.start_ctrl = NULL,
+};
+
+static struct si2168b_config hauppauge_si2168b_2_config = {
+	/* the demodulator's i2c address */
+	.demod_address = 0xCC >> 1,
+
+	/* minimum delay before retuning */
+	.min_delay_ms = 85,
+	.ts_bus_mode = 1, /*1-serial, 2-parallel.*/
+	.ts_clock_mode = 1, /*0-auto_fixed, 1-auto_adapt, 2-manual.*/
+	.clk_gapped_en = 1, /*0-disabled, 1-enabled.*/
+	.ts_par_clk_invert = 1, /*0-not-invert, 1-invert*/
+	.ts_par_clk_shift = 1, /*DVB-C QAM256 fix*/
+	.fef_mode = 1, /* needs to match tuner */
+	.fef_pin = 3,
+	.fef_level = 0,
+	.indirect_i2c_connection = 1, /*Si2157 connected directly*/
+	.start_ctrl = NULL,
+};
+
+static struct silabs_tercab_config hauppauge_si2157_config = {
+	.tuner_address           = 0xC0 >> 1,      /* address of the tuner for ATSC/DVB-T */
+	.qam_if_khz              = HVR19x5_QAM_IF, /* needs to match demods qam if */
+	.vsb_if_khz              = HVR19x5_VSB_IF, /* needs to match demods vsb if */
+	.tuner_clock_control     = 1, /* 0:always off 1:always on 2:clock managed */
+	.tuner_agc_control       = 1,
+	.fef_mode                = 1, /* fef mode slow normal agc */
+	.crystal_trim_xo_cap     = 8,
+	.indirect_i2c_connection = 1, /* Si2157 connected directly */
+};
+
 static struct lgdt3306a_config hauppauge_hvr2255a_config = {
 	.i2c_addr               = 0xb2 >> 1,
 	.qam_if_khz             = 4000,
@@ -729,6 +820,19 @@ int saa7164_dvb_register(struct saa7164_
 		}
 
 		break;
+	case SAA7164_BOARD_HAUPPAUGE_HVR2215:
+		i2c_bus = &dev->i2c_bus[port->nr + 1];
+
+		port->dvb.frontend = dvb_attach(si2168b_attach,
+			(port->nr == 0) ?
+			&hauppauge_si2168b_1_config : &hauppauge_si2168b_2_config,
+			&i2c_bus->i2c_adap);
+
+		if (port->dvb.frontend != NULL) {
+			dvb_attach(silabs_tercab_attach, port->dvb.frontend,
+				&i2c_bus->i2c_adap,	&hauppauge_si2157_config);
+		}
+		break;
 	default:
 		printk(KERN_ERR "%s: The frontend isn't supported\n",
 		       dev->name);
--- linux-4.15/drivers/media/pci/saa7164/saa7164-encoder.c.0140~	2018-02-12 11:32:52.013576649 +0100
+++ linux-4.15/drivers/media/pci/saa7164/saa7164-encoder.c	2018-02-12 11:32:52.768582180 +0100
@@ -40,6 +40,24 @@ static struct saa7164_tvnorm saa7164_tvn
 	}, {
 		.name      = "NTSC-JP",
 		.id        = V4L2_STD_NTSC_M_JP,
+	}, {
+		.name      = "NTSC-443",
+		.id        = V4L2_STD_NTSC_443,
+	}, {
+		.name      = "PAL-BG",
+		.id        = V4L2_STD_PAL_BG,
+	}, {
+		.name      = "PAL-I",
+		.id        = V4L2_STD_PAL_I,
+	}, {
+		.name      = "PAL-DK",
+		.id        = V4L2_STD_PAL_DK,
+	}, {
+		.name      = "SECAM-L",
+		.id        = V4L2_STD_SECAM_L,
+	}, {
+		.name      = "SECAM-Lc",
+		.id        = V4L2_STD_SECAM_LC,
 	}
 };
 
@@ -215,8 +233,8 @@ int saa7164_s_std(struct saa7164_port *p
 		return -EINVAL;
 
 	port->encodernorm = saa7164_tvnorms[i];
-	port->std = id;
 
+	port->std = id;
 	/* Update the audio decoder while is not running in
 	 * auto detect mode.
 	 */
@@ -1030,6 +1048,7 @@ int saa7164_encoder_register(struct saa7
 	/* Establish encoder defaults here */
 	/* Set default TV standard */
 	port->encodernorm = saa7164_tvnorms[0];
+	port->std = saa7164_tvnorms[0].id;
 	port->width = 720;
 	port->mux_input = 1; /* Composite */
 	port->video_format = EU_VIDEO_FORMAT_MPEG_2;
--- linux-4.15/drivers/media/pci/saa7164/saa7164-fw.c.0140~	2018-01-28 22:20:33.000000000 +0100
+++ linux-4.15/drivers/media/pci/saa7164/saa7164-fw.c	2018-02-12 11:32:52.768582180 +0100
@@ -26,6 +26,9 @@
 #define SAA7164_REV3_FIRMWARE		"NXP7164-2010-03-10.1.fw"
 #define SAA7164_REV3_FIRMWARE_SIZE	4019072
 
+#define SAA7164_HVR2255_FIRMWARE		"NXP7164-2010-04-01.1.fw"
+#define SAA7164_HVR2255_FIRMWARE_SIZE	3283792
+
 struct fw_header {
 	u32	firmwaresize;
 	u32	bslsize;
@@ -214,8 +217,15 @@ int saa7164_downloadfirmware(struct saa7
 		fwname = SAA7164_REV2_FIRMWARE;
 		fwlength = SAA7164_REV2_FIRMWARE_SIZE;
 	} else {
-		fwname = SAA7164_REV3_FIRMWARE;
-		fwlength = SAA7164_REV3_FIRMWARE_SIZE;
+		if (dev->board == SAA7164_BOARD_HAUPPAUGE_HVR2255
+				|| dev->board == SAA7164_BOARD_HAUPPAUGE_HVR2205
+				|| dev->board == SAA7164_BOARD_HAUPPAUGE_HVR2215) {
+			fwname = SAA7164_HVR2255_FIRMWARE;
+			fwlength = SAA7164_HVR2255_FIRMWARE_SIZE;
+		} else {
+			fwname = SAA7164_REV3_FIRMWARE;
+			fwlength = SAA7164_REV3_FIRMWARE_SIZE;
+		}
 	}
 
 	version = saa7164_getcurrentfirmwareversion(dev);
--- linux-4.15/drivers/media/pci/saa7164/saa7164.h.0140~	2018-02-12 11:32:52.013576649 +0100
+++ linux-4.15/drivers/media/pci/saa7164/saa7164.h	2018-02-12 11:32:52.768582180 +0100
@@ -82,6 +82,7 @@
 #define SAA7164_BOARD_HAUPPAUGE_HVR2255proto	11
 #define SAA7164_BOARD_HAUPPAUGE_HVR2255		12
 #define SAA7164_BOARD_HAUPPAUGE_HVR2205		13
+#define SAA7164_BOARD_HAUPPAUGE_HVR2215		14
 
 #define SAA7164_MAX_UNITS		8
 #define SAA7164_TS_NUMBER_OF_LINES	312
@@ -113,7 +114,8 @@
 #define DBGLVL_CPU 8192
 
 #define SAA7164_NORMS \
-	(V4L2_STD_NTSC_M | V4L2_STD_NTSC_M_JP)
+	(V4L2_STD_NTSC_M | V4L2_STD_NTSC_M_JP | V4L2_STD_NTSC_443 | V4L2_STD_PAL_BG | \
+	 V4L2_STD_PAL_I | V4L2_STD_PAL_DK | V4L2_STD_SECAM_L | V4L2_STD_SECAM_LC)
 
 /* TV frequency range copied from tuner-core.c */
 #define SAA7164_TV_MIN_FREQ (44U * 16U)
--- linux-4.15/drivers/media/pci/saa7164/saa7164-reg.h.0140~	2018-01-28 22:20:33.000000000 +0100
+++ linux-4.15/drivers/media/pci/saa7164/saa7164-reg.h	2018-02-12 11:32:52.768582180 +0100
@@ -177,7 +177,24 @@
 #define TU_STANDARD_AUTO_CONTROL	0x01
 #define TU_STANDARD_NONE		0x00
 #define TU_STANDARD_NTSC_M		0x01
+#define TU_STANDARD_NTSC_M_J	0x02
+#define TU_STANDARD_NTSC_433	0x03
+#define TU_STANDARD_PAL_B		0x04
+#define TU_STANDARD_PAL_D		0x05
+#define TU_STANDARD_PAL_G		0x06
+#define TU_STANDARD_PAL_H		0x07
 #define TU_STANDARD_PAL_I		0x08
+#define TU_STANDARD_PAL_M		0x09
+#define TU_STANDARD_PAL_N		0x0a
+#define TU_STANDARD_PAL_60		0x0b
+#define TU_STANDARD_SECAM_B		0x0c
+#define TU_STANDARD_SECAM_D		0x0d
+#define TU_STANDARD_SECAM_G		0x0e
+#define TU_STANDARD_SECAM_H		0x0f
+#define TU_STANDARD_SECAM_K		0x10
+#define TU_STANDARD_SECAM_K1	0x11
+#define TU_STANDARD_SECAM_L		0x12
+#define TU_STANDARD_SECAM_L1	0x13
 #define TU_STANDARD_MANUAL		0x00
 #define TU_STANDARD_AUTO		0x01
 
--- linux-4.15/drivers/media/tuners/Kconfig.0140~	2018-02-12 11:32:52.016576671 +0100
+++ linux-4.15/drivers/media/tuners/Kconfig	2018-02-12 11:32:52.768582180 +0100
@@ -255,6 +255,20 @@ config MEDIA_TUNER_SI2157
 	help
 	  Silicon Labs Si2157 silicon tuner driver.
 
+config MEDIA_TUNER_SILABS_TERCAB
+	tristate "Silicon Labs terrestrial/cable tuner series"
+	depends on MEDIA_SUPPORT && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  Silicon Labs hybrid terrestrial/cable tuner series driver.
+
+config MEDIA_TUNER_SILABS_TERCAB
+	tristate "Silicon Labs terrestrial/cable tuner series"
+	depends on MEDIA_SUPPORT && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  Silicon Labs hybrid terrestrial/cable tuner series driver.
+
 config MEDIA_TUNER_IT913X
 	tristate "ITE Tech IT913x silicon tuner"
 	depends on MEDIA_SUPPORT && I2C
--- linux-4.15/drivers/media/tuners/Makefile.0140~	2018-02-12 11:32:52.768582180 +0100
+++ linux-4.15/drivers/media/tuners/Makefile	2018-02-12 11:35:11.303551576 +0100
@@ -43,5 +43,6 @@ obj-$(CONFIG_MEDIA_TUNER_MXL301RF) += mx
 obj-$(CONFIG_MEDIA_TUNER_QM1D1C0042) += qm1d1c0042.o
 obj-$(CONFIG_MEDIA_TUNER_M88RS6000T) += m88rs6000t.o
 obj-$(CONFIG_MEDIA_TUNER_TDA18250) += tda18250.o
+obj-$(CONFIG_MEDIA_TUNER_SILABS_TERCAB) += silabs_tercab.o
 
 ccflags-y += -I$(srctree)/drivers/media/dvb-frontends
--- linux-4.15/drivers/media/tuners/silabs_tercab.c.0140~	2018-02-12 11:32:52.770582195 +0100
+++ linux-4.15/drivers/media/tuners/silabs_tercab.c	2018-02-12 11:32:52.770582195 +0100
@@ -0,0 +1,3452 @@
+/*
+ * silabs_tercab.c - Silicon Labs terrestrial/cable hybrid tuner driver
+ * for the tuners Si2157 and Si2177
+ *
+ * (C) Copyright 2014, PCTV Systems S.Ã  r.l
+ * Henning Garbers <hgarbers@pctvsystems.com>
+ *
+ */
+
+#include  <linux/delay.h>
+#include <linux/videodev2.h>
+#include "tuner-i2c.h"
+#include "silabs_tercab_priv.h"
+
+static int silabs_tercab_debug = 0;
+module_param_named(debug, silabs_tercab_debug, int, 0644);
+
+#ifdef SiTRACES
+static int silabs_tercab_trace = 0;
+module_param_named(sitrace, silabs_tercab_trace, int, 0644);
+#endif
+
+static DEFINE_MUTEX(silabs_tercab_list_mutex);
+static LIST_HEAD(hybrid_tuner_instance_list);
+
+/*---------------------------------------------------------------------*/
+
+#define DBG_INFO 1
+
+__attribute__((format(printf, 4, 5)))
+int _silabs_tercab_printk(struct silabs_tercab_priv *state, const char *level,
+		const char *func, const char *fmt, ...)
+{
+	struct va_format vaf;
+	va_list args;
+	int rtn;
+
+	va_start(args, fmt);
+
+	vaf.fmt = fmt;
+	vaf.va = &args;
+
+	if (state)
+		rtn = printk("%s%s: [%d-%04x] %pV",
+				level, func, i2c_adapter_id(state->i2c_props.adap),
+				state->i2c_props.addr,
+				&vaf);
+	else
+		rtn = printk("%s%s: %pV", level, func, &vaf);
+
+	va_end(args);
+
+	return rtn;
+}
+
+#define silabs_tercab_printk(st, lvl, fmt, arg...)			\
+		_silabs_tercab_printk(st, lvl, __func__, fmt, ##arg)
+
+#define si2158_dprintk(st, lvl, fmt, arg...)			\
+		do {								\
+			if (silabs_tercab_debug & lvl)				\
+			silabs_tercab_printk(st, KERN_DEBUG, fmt, ##arg);		\
+		} while (0)
+
+#define silabs_tercab_info(fmt, arg...) silabs_tercab_printk(priv, KERN_INFO, fmt, ##arg)
+#define silabs_tercab_warn(fmt, arg...) silabs_tercab_printk(priv, KERN_WARNING, fmt, ##arg)
+#define silabs_tercab_err(fmt, arg...)  silabs_tercab_printk(priv, KERN_ERR, fmt, ##arg)
+#define silabs_tercab_dbg(fmt, arg...)  si2158_dprintk(priv, DBG_INFO, fmt, ##arg)
+
+#define silabs_tercab_fail(ret)							     \
+		({									     \
+			int __ret;							     \
+			__ret = (ret != NO_SILABS_TERCAB_ERROR);						     \
+			if (__ret)							     \
+			silabs_tercab_printk(priv, KERN_ERR,				     \
+					"error %d on line %d\n", ret, __LINE__);	     \
+					__ret;								     \
+		})
+
+#ifdef SiTRACES
+#define SiTRACES_BUFFER_LENGTH  100000
+#define SiTRACES_NAMESIZE           30
+#define SiTRACES_FUNCTION_NAMESIZE  30
+
+#define CUSTOM_PRINTF(args...) \
+		do { \
+			if (silabs_tercab_trace) \
+			printk(KERN_INFO "Silabs tuner: " args); \
+		} while (0)
+
+typedef enum TYPE_OF_OUTPUT {
+	TRACE_NONE = 0,
+	TRACE_STDOUT,
+	TRACE_EXTERN_FILE,
+	TRACE_MEMORY
+} TYPE_OF_OUTPUT;
+
+static TYPE_OF_OUTPUT trace_output_type;
+
+static char trace_timer[50];
+
+static u8 trace_init_done         = 0;
+static u8 trace_suspend           = 0;
+static u8 trace_skip_info         = 0;
+static u8 trace_config_lines      = 0;
+static u8 trace_config_files      = 0;
+static u8 trace_config_functions  = 0;
+static u8 trace_config_time       = 0;
+static int trace_linenumber       = 0;
+static int trace_count            = 0;
+
+static char trace_timer[50];
+static char trace_elapsed_time[20];
+static char trace_source_file[100];
+static char trace_source_function[SiTRACES_FUNCTION_NAMESIZE+1];
+
+static void SiTraceFunction(const char *name, int trace_linenumber, const char *func, const char *fmt, ...);
+#define SiTRACE(...) SiTraceFunction(__FILE__, __LINE__, __FUNCTION__ ,__VA_ARGS__)
+
+/************************************************************************************************************************
+      traceElapsedTime function
+      Use:        SiTRACES time formatting function.
+                  It allows the user to know when the trace has been treated.
+                  It is used to insert the time before the trace when -time 'on'.
+      Returns:    text containing the execution time in HH:MM:SS.ms format.
+      Porting:    Not compiled if SiTRACES is not defined in Silabs_L0_ctx.h.
+************************************************************************************************************************/
+static char *traceElapsedTime(void)
+{
+	unsigned int timeElapsed, ms, sec, min, hours;
+	timeElapsed = jiffies_to_msecs(jiffies);
+	ms=timeElapsed%1000;
+	timeElapsed=timeElapsed/1000;
+	sec=timeElapsed%60;
+	timeElapsed=timeElapsed/60;
+	min=timeElapsed%60;
+	timeElapsed=timeElapsed/60;
+	hours=timeElapsed%60;
+	sprintf(trace_elapsed_time,"%02d:%02d:%02d.%03d ",hours,min,sec,ms);
+	return trace_elapsed_time;
+}
+
+/************************************************************************************************************************
+      traceToStdout function
+      Use:        SiTRACES stdout display function.
+                  It displays the current trace in the command window.
+                  It adds file name, line number,function name and time if selected.
+      Parameter:  trace
+      Returns:    void
+************************************************************************************************************************/
+static void traceToStdout(char* trace)
+{
+	if (!trace_skip_info) {
+		if (trace_config_files    ) { CUSTOM_PRINTF("%-40s ", trace_source_file    ); }
+		if (trace_config_lines    ) { CUSTOM_PRINTF("%5d "  , trace_linenumber     ); }
+		if (trace_config_functions) { CUSTOM_PRINTF("%-30s ", trace_source_function); }
+	}
+	if (trace_config_time     ) { CUSTOM_PRINTF("%s ",    traceElapsedTime()   ); }
+	CUSTOM_PRINTF("%s",     trace);
+}
+
+/************************************************************************************************************************
+  traceToDestination function
+  Use:        switch the trace in the selected output mode.
+  Comment:    In verbose mode, the trace is always displayed in stdout.
+  Parameter:  trace, the trace string
+  Returns:    void
+  Porting:    Not compiled if SiTRACES is not defined in Silabs_L0_ctx.h.
+************************************************************************************************************************/
+static void  traceToDestination(char* trace)
+{
+	int last;
+	if (trace_suspend) {
+		return;
+	}
+	/* If trace is a single CrLf, do not print the file/line/function info           */
+	if (strcmp(trace,"\n")==0) {
+		trace_skip_info = 1;
+	}
+	/* If file/line/function info printed, make sure there is a CrLf after each line */
+	if (trace_config_files + trace_config_lines + trace_config_functions + trace_config_time) {
+		last = (int)strlen(trace)-1;
+		if (trace[last] != 0x0a) {
+			sprintf(trace, "%s\n", trace);
+		}
+	}
+	traceToStdout(trace);
+	if (strcmp(trace,"\n")==0) {
+		trace_skip_info = 0;
+	}
+	trace_count++;
+}
+
+/************************************************************************************************************************
+  SiTraceFunction function
+  Use:        SiTRACES trace formatting function.
+              It formats the trace message with file name and line number and time if selected
+              then saves it to the trace output.
+  Parameter:  name    the file name where the trace is written.
+  Parameter:  number  the line number where the trace is written.
+  Parameter:  fmt     string content of trace message. Others arguments are sent thanks to the ellipse.
+  Returns:    void
+  Porting:    Not compiled if SiTRACES is not defined in Silabs_L0_ctx.h.
+************************************************************************************************************************/
+static void SiTraceFunction(const char *name, int number, const char *func, const char *fmt, ...)
+{
+	char        message[850];
+	const char *pname;
+	const char *pfunc;
+	va_list     ap;
+	/* print the line number in trace_linenumber */
+	trace_linenumber = number;
+	pname=name;
+
+	/* print the file name in trace_source_file */
+	if(strlen(pname)>SiTRACES_NAMESIZE) {
+		pname+=strlen(pname)-SiTRACES_NAMESIZE;
+	}
+	strncpy(trace_source_file,pname,SiTRACES_NAMESIZE);
+
+	/*print the function name in trace_source_function */
+	pfunc=func;
+	sprintf(trace_source_function,"%s","");
+	if(strlen(pfunc)>SiTRACES_FUNCTION_NAMESIZE) {
+		pfunc+=(strlen(pfunc)-SiTRACES_FUNCTION_NAMESIZE)+2;
+		strcpy(trace_source_function,"..");
+	}
+	strncat(trace_source_function,pfunc,SiTRACES_FUNCTION_NAMESIZE-2);
+
+	va_start(ap, fmt);
+	vsnprintf(message,900,fmt,ap);
+	traceToDestination(message);
+	va_end(ap);
+	return;
+}
+
+/************************************************************************************************************************
+  SiTraceDefaultConfiguration function
+  Use:        SiTRACES initialization function.
+              It is called on the first call to L0_Init (only once).
+              It defines the default output and inserts date and time in the default file.
+  Returns:    void
+  Porting:    Not compiled if SiTRACES is not defined in Silabs_L0_ctx.h.
+************************************************************************************************************************/
+static void SiTraceDefaultConfiguration(void)
+{
+	if (trace_init_done) return;
+	trace_output_type=TRACE_STDOUT;
+	trace_init_done=1;
+	sprintf(trace_timer, "time");
+}
+
+/************************************************************************************************************************
+  silabs_tercab_infos function
+  Use:        software information function
+              Used to retrieve information about the compilation
+  Parameter:  front_end, a pointer to the Si2158_L2_Context context to be initialized
+  Parameter:  infoString, a text buffer to be filled with teh information. It must be initialized by the caller.
+  Return:     the length of the information string
+ ************************************************************************************************************************/
+static int silabs_tercab_infos(struct silabs_tercab_priv *priv, char *infoString_UNUSED)
+{
+	if (infoString_UNUSED == NULL)
+		return 0;
+	if (!priv) {
+		SiTRACE("Si2158 front-end not initialized yet. Call silabs_tercab_sw_init first!\n");
+		return strlen(infoString_UNUSED);
+	}
+
+	SiTRACE("\n");
+	SiTRACE("--------------------------------------\n");
+	SiTRACE("Terrestrial/Cable Tuner Si21%u at 0x%02x\n", priv->tuner.part, priv->tuner.i2c_addr);
+	SiTRACE("--------------------------------------\n");
+	return strlen(infoString_UNUSED);
+}
+
+static inline void SiTracesSuspend(void)
+{
+	trace_suspend = 1;
+}
+static inline void SiTracesResume(void)
+{
+	trace_suspend = 0;
+}
+#else /* SiTRACES */
+#define SiTRACE(...)               /* empty */
+#define SiTracesSuspend()          /* empty */
+#define SiTracesResume()           /* empty */
+#endif /* SiTRACES */
+
+/************************************************************************************************************************
+  i2c_read_bytes function
+
+  Parameters: iNbBytes, the number of bytes to read.
+              *pbtDataBuffer, a pointer to a buffer used to store the bytes.
+  Returns:    the number of bytes read.
+************************************************************************************************************************/
+static u16 i2c_read_bytes(struct i2c_adapter *i2c_adap, u8 i2c_addr, u16 iNbBytes, u8 *pucDataBuffer)
+{
+	struct silabs_tercab_priv *priv = NULL; /* for debug output only */
+	u16 nbReadBytes = 0;
+	struct i2c_msg msg = {
+			.addr  = i2c_addr,
+			.flags = I2C_M_RD,
+			.buf   = pucDataBuffer,
+			.len   = iNbBytes,
+	};
+
+	if (i2c_adap == NULL) {
+		silabs_tercab_err("%s(): FATAL ERROR: i2c_adap is undefined!\n", __func__);
+		return 0;
+	}
+
+	if (i2c_transfer(i2c_adap, &msg, 1) == 1) {
+		nbReadBytes = iNbBytes;
+	} else {
+		silabs_tercab_err("%s(): i2c transfer failed\n", __func__);
+	}
+
+	return nbReadBytes;
+}
+
+/************************************************************************************************************************
+  i2c_write_bytes function
+
+  Parameters: iNbBytes, the number of bytes to write.
+              *pbtDataBuffer, a pointer to a buffer containing the bytes to write.
+  Returns:    the number of written bytes.
+************************************************************************************************************************/
+static u16 i2c_write_bytes(struct i2c_adapter *i2c_adap, u8 i2c_addr, u16 iNbBytes, u8 *pucDataBuffer)
+{
+	u16 nbWrittenBytes = 0;
+	int write_error = 0;
+	struct i2c_msg msg = {
+			.addr  = i2c_addr,
+			.flags = 0,
+			.buf   = pucDataBuffer,
+			.len   = iNbBytes
+	};
+	struct silabs_tercab_priv *priv = NULL; /* for debug output only */
+
+	if (i2c_adap == NULL) {
+		silabs_tercab_err("%s(): FATAL ERROR: i2c_adap is undefined!\n", __func__);
+		return 0;
+	}
+
+	nbWrittenBytes = 0;
+	write_error    = 0;
+	if (iNbBytes <= 64) {
+		if (i2c_transfer(i2c_adap, &msg, 1) == 1) {
+			nbWrittenBytes = iNbBytes;
+		} else {
+			silabs_tercab_err("%s(): i2c transfer failed\n", __func__);
+			write_error++;
+		}
+	} else {
+		silabs_tercab_err("%s(): numbers of bytes exceeds limit of 64\n", __func__);
+		write_error++;
+	}
+
+	if (write_error) return 0;
+	return nbWrittenBytes;
+}
+
+static u8 silabs_tercab_poll_cts(struct i2c_adapter *i2c_adap, u8 i2c_addr)
+{
+	u8 rspByteBuffer[1];
+	struct silabs_tercab_priv *priv = NULL; /* for debug output only */
+	unsigned int start_time = jiffies_to_msecs(jiffies);
+
+	do {
+		if (i2c_read_bytes(i2c_adap, i2c_addr, 1, rspByteBuffer) != 1) {
+			silabs_tercab_err("%s() ERROR reading byte 0!\n", __func__);
+			return ERROR_SILABS_TERCAB_POLLING_CTS;
+		}
+		/* return OK if CTS set */
+		if (rspByteBuffer[0] & 0x80) {
+			return NO_SILABS_TERCAB_ERROR;
+		}
+		msleep(10); /* FGR - pause a bit rather than just spinning on I2C */
+	} while (jiffies_to_msecs(jiffies) - start_time <1000);/* wait a maximum of 1000ms */
+
+	silabs_tercab_err("%s() ERROR CTS Timeout!\n", __func__);
+	return ERROR_SILABS_TERCAB_CTS_TIMEOUT;
+}
+
+static u8 silabs_tercab_poll_response(struct i2c_adapter *i2c_adap, u8 i2c_addr, u16 nbBytes, u8 *pByteBuffer, silabs_tercab_status *status)
+{
+	struct silabs_tercab_priv *priv = NULL; /* for debug output only */
+	unsigned int start_time = jiffies_to_msecs(jiffies);
+
+	do {
+		if (i2c_read_bytes(i2c_adap, i2c_addr, nbBytes, pByteBuffer) != nbBytes) {
+			silabs_tercab_err("%s() ERROR reading byte 0!\n", __func__);
+			return ERROR_SILABS_TERCAB_POLLING_RESPONSE;
+		}
+		/* return response err flag if CTS set */
+		if (pByteBuffer[0] & 0x80)  {
+			status->tunint = (pByteBuffer[0] >> 0) & 0x01;
+			status->atvint = (pByteBuffer[0] >> 1) & 0x01;
+			status->dtvint = (pByteBuffer[0] >> 2) & 0x01;
+			status->err    = (pByteBuffer[0] >> 6) & 0x01;
+			status->cts    = (pByteBuffer[0] >> 7) & 0x01;
+			if (status->err) {
+				silabs_tercab_info("ERROR flag is on!\n");
+			}
+			return (status->err ? ERROR_SILABS_TERCAB_ERR : NO_SILABS_TERCAB_ERROR);
+		}
+		msleep(10); /* pause a bit rather than just spinning on I2C */
+	} while (jiffies_to_msecs(jiffies) - start_time <1000); /* wait a maximum of 1000ms */
+
+	silabs_tercab_err("%s() ERROR CTS Timeout!\n", __func__);
+	return ERROR_SILABS_TERCAB_CTS_TIMEOUT;
+}
+
+/***********************************************************************************************************************
+  silabs_tercab_check_status function
+  Use:        Status information function
+              Used to retrieve the status byte
+  Returns:    0 if no error
+  Parameter:  error_code the error code.
+ ***********************************************************************************************************************/
+static u8 silabs_tercab_check_status(silabs_tercab_context *ctx)
+{
+	u8 rspByteBuffer[1];
+	return silabs_tercab_poll_response(ctx->i2c_adap, ctx->i2c_addr, 1, rspByteBuffer, &ctx->status);
+}
+
+/***********************************************************************************************************************
+  silabs_tercab_set_property function
+  Use:        property set function
+              Used to call L1_SET_PROPERTY with the property Id and data provided.
+  Parameter: *ctx     the Si2158 context
+  Parameter: prop     the property Id
+  Parameter: data     the property bytes
+  Returns:    0 if no error, an error code otherwise
+ ***********************************************************************************************************************/
+static u8 silabs_tercab_set_property(silabs_tercab_context *ctx, u16 prop, u16 data)
+{
+	u8 error_code = 0;
+	u8 reserved = 0;
+	u8 cmdByteBuffer[6];
+	u8 rspByteBuffer[4];
+
+	SiTRACE("%s(resv=0x%x prop=0x%x data=0x%x\n", __func__, reserved, prop, data);
+
+	cmdByteBuffer[0] = Si2158_SET_PROPERTY_CMD;
+	cmdByteBuffer[1] = (u8) ( ( reserved & Si2158_SET_PROPERTY_CMD_RESERVED_MASK ) << Si2158_SET_PROPERTY_CMD_RESERVED_LSB);
+	cmdByteBuffer[2] = (u8) ( ( prop     & Si2158_SET_PROPERTY_CMD_PROP_MASK     ) << Si2158_SET_PROPERTY_CMD_PROP_LSB    );
+	cmdByteBuffer[3] = (u8) ((( prop     & Si2158_SET_PROPERTY_CMD_PROP_MASK     ) << Si2158_SET_PROPERTY_CMD_PROP_LSB    ) >> 8);
+	cmdByteBuffer[4] = (u8) ( ( data     & Si2158_SET_PROPERTY_CMD_DATA_MASK     ) << Si2158_SET_PROPERTY_CMD_DATA_LSB    );
+	cmdByteBuffer[5] = (u8) ((( data     & Si2158_SET_PROPERTY_CMD_DATA_MASK     ) << Si2158_SET_PROPERTY_CMD_DATA_LSB    ) >> 8);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 6, cmdByteBuffer) != 6) {
+		SiTRACE("Error writing SET_PROPERTY bytes!\n");
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	error_code = silabs_tercab_poll_response(ctx->i2c_adap, ctx->i2c_addr, 4, rspByteBuffer, &ctx->status);
+	if (error_code) {
+		SiTRACE("Error polling SET_PROPERTY response\n");
+		return error_code;
+	}
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+static u8 silabs_tercab_power_up(struct i2c_adapter *i2c_adap,
+		u8   i2c_addr,
+		u8   subcode,
+		u8   clock_mode,
+		u8   en_xout,
+		u8   pd_ldo,
+		u8   reserved2,
+		u8   reserved3,
+		u8   reserved4,
+		u8   reserved5,
+		u8   reserved6,
+		u8   reserved7,
+		u8   reset,
+		u8   clock_freq,
+		u8   reserved8,
+		u8   func,
+#ifndef __SI2158__
+		u8   reserved9,
+#endif
+		u8   ctsien,
+		u8   wake_up,
+		silabs_tercab_status *status)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[15];
+	u8 rspByteBuffer[1];
+	struct silabs_tercab_priv *priv = NULL; /* for debug output only */
+	//ctx->rsp.power_up.STATUS = ctx->status;
+
+	silabs_tercab_info("%s(): clock mode=%u  en_xout=%u\n", __func__, clock_mode, en_xout);
+
+	cmdByteBuffer[0]  = Si2158_POWER_UP_CMD;
+	cmdByteBuffer[1]  = (u8) ( ( subcode    & Si2158_POWER_UP_CMD_SUBCODE_MASK    ) << Si2158_POWER_UP_CMD_SUBCODE_LSB   );
+	cmdByteBuffer[2]  = (u8) ( ( clock_mode & Si2158_POWER_UP_CMD_CLOCK_MODE_MASK ) << Si2158_POWER_UP_CMD_CLOCK_MODE_LSB|
+							   ( en_xout    & Si2158_POWER_UP_CMD_EN_XOUT_MASK    ) << Si2158_POWER_UP_CMD_EN_XOUT_LSB   );
+	cmdByteBuffer[3]  = (u8) ( ( pd_ldo     & Si2158_POWER_UP_CMD_PD_LDO_MASK     ) << Si2158_POWER_UP_CMD_PD_LDO_LSB    );
+	cmdByteBuffer[4]  = (u8) ( ( reserved2  & Si2158_POWER_UP_CMD_RESERVED2_MASK  ) << Si2158_POWER_UP_CMD_RESERVED2_LSB );
+	cmdByteBuffer[5]  = (u8) ( ( reserved3  & Si2158_POWER_UP_CMD_RESERVED3_MASK  ) << Si2158_POWER_UP_CMD_RESERVED3_LSB );
+	cmdByteBuffer[6]  = (u8) ( ( reserved4  & Si2158_POWER_UP_CMD_RESERVED4_MASK  ) << Si2158_POWER_UP_CMD_RESERVED4_LSB );
+	cmdByteBuffer[7]  = (u8) ( ( reserved5  & Si2158_POWER_UP_CMD_RESERVED5_MASK  ) << Si2158_POWER_UP_CMD_RESERVED5_LSB );
+	cmdByteBuffer[8]  = (u8) ( ( reserved6  & Si2158_POWER_UP_CMD_RESERVED6_MASK  ) << Si2158_POWER_UP_CMD_RESERVED6_LSB );
+	cmdByteBuffer[9]  = (u8) ( ( reserved7  & Si2158_POWER_UP_CMD_RESERVED7_MASK  ) << Si2158_POWER_UP_CMD_RESERVED7_LSB );
+	cmdByteBuffer[10] = (u8) ( ( reset      & Si2158_POWER_UP_CMD_RESET_MASK      ) << Si2158_POWER_UP_CMD_RESET_LSB     );
+	cmdByteBuffer[11] = (u8) ( ( clock_freq & Si2158_POWER_UP_CMD_CLOCK_FREQ_MASK ) << Si2158_POWER_UP_CMD_CLOCK_FREQ_LSB);
+	cmdByteBuffer[12] = (u8) ( ( reserved8  & Si2158_POWER_UP_CMD_RESERVED8_MASK  ) << Si2158_POWER_UP_CMD_RESERVED8_LSB );
+	cmdByteBuffer[13] = (u8) ( ( func       & Si2158_POWER_UP_CMD_FUNC_MASK       ) << Si2158_POWER_UP_CMD_FUNC_LSB      |
+							   ( reserved9  & Si2157_POWER_UP_CMD_RESERVED9_MASK  ) << Si2157_POWER_UP_CMD_RESERVED9_LSB |
+							   ( ctsien     & Si2158_POWER_UP_CMD_CTSIEN_MASK     ) << Si2158_POWER_UP_CMD_CTSIEN_LSB    );
+	cmdByteBuffer[14] = (u8) ( ( wake_up    & Si2158_POWER_UP_CMD_WAKE_UP_MASK    ) << Si2158_POWER_UP_CMD_WAKE_UP_LSB   );
+
+	if (i2c_write_bytes(i2c_adap, i2c_addr, 15, cmdByteBuffer) != 15) {
+		silabs_tercab_err("Error writing POWER_UP bytes!\n");
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	msleep(10);
+
+	error_code = silabs_tercab_poll_response(i2c_adap, i2c_addr, 1, rspByteBuffer, status);
+	if (error_code) {
+		silabs_tercab_err("Error polling POWER_UP response\n");
+		return error_code;
+	}
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+/*---------------------------------------------------*/
+/* Si2158_PART_INFO COMMAND                        */
+/*---------------------------------------------------*/
+static u8 si2158_part_info(struct i2c_adapter *i2c_adap, u8 i2c_addr, struct part_info *part_info)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[1];
+	u8 rspByteBuffer[13];
+	silabs_tercab_status status;
+	struct silabs_tercab_priv *priv = NULL; /* for debug output only */
+	//ctx->rsp.part_info.STATUS = ctx->status;
+
+	silabs_tercab_info("%s()\n", __func__);
+
+	cmdByteBuffer[0] = Si2158_PART_INFO_CMD;
+
+	if (i2c_write_bytes(i2c_adap, i2c_addr, 1, cmdByteBuffer) != 1) {
+		silabs_tercab_err("Error writing PART_INFO bytes!\n");
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	error_code = silabs_tercab_poll_response(i2c_adap, i2c_addr, 13, rspByteBuffer, &status);
+	if (error_code) {
+		silabs_tercab_err("Error polling PART_INFO response\n");
+		return error_code;
+	}
+
+	part_info->chiprev  = rspByteBuffer[1] & 0x0f;
+	part_info->part     = rspByteBuffer[2];
+	part_info->pmajor   = rspByteBuffer[3];
+	part_info->pminor   = rspByteBuffer[4];
+	part_info->pbuild   = rspByteBuffer[5];
+	part_info->reserved = (( ( rspByteBuffer[6] | (rspByteBuffer[7]  << 8 )) >> 0 ) & 0xffff );
+	part_info->serial   = (( ( rspByteBuffer[8] | (rspByteBuffer[9]  << 8 ) | (rspByteBuffer[10] << 16 ) | (rspByteBuffer[11] << 24 )) >> 0 ) & 0xffffffff );
+	part_info->romid    = rspByteBuffer[12];
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+/***********************************************************************************************************************
+  silabs_tercab_error_text function
+  Use:        Error information function
+              Used to retrieve a text based on an error code
+  Returns:    the error text
+  Parameter:  error_code the error code.
+  Porting:    Useful for application development for debug purposes.
+  Porting:    May not be required for the final application, can be removed if not used.
+ ***********************************************************************************************************************/
+static char* silabs_tercab_error_text(int error_code)
+{
+	switch (error_code) {
+	case NO_SILABS_TERCAB_ERROR                     : return (char *)"No error";
+	case ERROR_SILABS_TERCAB_ALLOCATING_CONTEXT     : return (char *)"Error while allocating Si2158 context";
+	case ERROR_SILABS_TERCAB_PARAMETER_OUT_OF_RANGE : return (char *)"parameter(s) out of range";
+	case ERROR_SILABS_TERCAB_SENDING_COMMAND        : return (char *)"Error while sending Si2158 command";
+	case ERROR_SILABS_TERCAB_CTS_TIMEOUT            : return (char *)"CTS timeout";
+	case ERROR_SILABS_TERCAB_ERR                    : return (char *)"Error (status 'err' bit 1)";
+	case ERROR_SILABS_TERCAB_POLLING_CTS            : return (char *)"Error while polling CTS";
+	case ERROR_SILABS_TERCAB_POLLING_RESPONSE       : return (char *)"Error while polling response";
+	case ERROR_SILABS_TERCAB_LOADING_FIRMWARE       : return (char *)"Error while loading firmware";
+	case ERROR_SILABS_TERCAB_LOADING_BOOTBLOCK      : return (char *)"Error while loading bootblock";
+	case ERROR_SILABS_TERCAB_STARTING_FIRMWARE      : return (char *)"Error while starting firmware";
+	case ERROR_SILABS_TERCAB_SW_RESET               : return (char *)"Error during software reset";
+	case ERROR_SILABS_TERCAB_INCOMPATIBLE_PART      : return (char *)"Error Incompatible part";
+#ifndef __SI2158__
+	case ERROR_Si2157_UNKNOWN_COMMAND               : return (char *)"Error unknown command";
+	case ERROR_Si2157_UNKNOWN_PROPERTY              : return (char *)"Error unknown property";
+#endif
+	/* _specific_error_text_string_insertion_start */
+	case ERROR_SILABS_TERCAB_TUNINT_TIMEOUT         : return (char *)"Error TUNINT Timeout";
+	case ERROR_SILABS_TERCAB_xTVINT_TIMEOUT         : return (char *)"Error xTVINT Timeout";
+	case ERROR_SILABS_TERCAB_CRC_CHECK_ERROR        : return (char *)"Error CRC Check Error";
+	/* _specific_error_text_string_insertion_point */
+	default                                         : return (char *)"Unknown silabs_tercab error code";
+	}
+}
+
+/***********************************************************************************************************************
+  silabs_tercab_firmware_patch function
+  Use:        Patch information function
+              Used to send a number of bytes to the Si2158. Useful to download the firmware.
+  Returns:    0 if no error
+  Parameter:  error_code the error code.
+  Porting:    Useful for application development for debug purposes.
+  Porting:    May not be required for the final application, can be removed if not used.
+ ***********************************************************************************************************************/
+static u8 silabs_tercab_firmware_patch(silabs_tercab_context *ctx, u16 iNbBytes, u8 *pucDataBuffer)
+{
+	int res;
+	u8 rspByteBuffer[1];
+
+	SiTRACE("Si2158 Patch %d bytes\n",iNbBytes);
+
+	res = i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, iNbBytes, pucDataBuffer);
+	if (res!=iNbBytes) {
+		SiTRACE("silabs_tercab_firmware_patch error writing bytes: %s\n", silabs_tercab_error_text(ERROR_SILABS_TERCAB_LOADING_FIRMWARE) );
+		return ERROR_SILABS_TERCAB_LOADING_FIRMWARE;
+	}
+
+	res = silabs_tercab_poll_response(ctx->i2c_adap, ctx->i2c_addr, 1, rspByteBuffer, &ctx->status);
+	if (res != NO_SILABS_TERCAB_ERROR) {
+		SiTRACE("silabs_tercab_firmware_patch error 0x%02x polling response: %s\n", res, silabs_tercab_error_text(res) );
+		return ERROR_SILABS_TERCAB_POLLING_RESPONSE;
+	}
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+/************************************************************************************************************************
+  NAME: silabs_tercab_load_firmware_16
+  DESCRIPTION: Load firmware from firmware_struct array in Si2158_Firmware_x_y_build_z.h file into Si2158
+              Requires Si2158 to be in bootloader mode after PowerUp
+  Programming Guide Reference:    Flowchart A.3 (Download FW PATCH flowchart)
+
+  Parameter:  Si2158 Context (I2C address)
+  Parameter:  pointer to firmware_struct array
+  Parameter:  number of lines in firmware table array (size in bytes / firmware_struct)
+  Returns:    Si2158/I2C transaction error code, NO_SILABS_TERCAB_ERROR if successful
+ ************************************************************************************************************************/
+static int silabs_tercab_load_firmware_16(silabs_tercab_context *ctx, firmware_struct fw_table[], int nbLines)
+{
+	int return_code;
+	int line;
+	return_code = NO_SILABS_TERCAB_ERROR;
+
+	SiTRACE ("silabs_tercab_load_firmware_16 nbLines=%d\n", nbLines);
+
+	/* for each line in fw_table */
+	for (line = 0; line < nbLines; line++)
+	{
+		if (fw_table[line].firmware_len > 0)  /* don't download if length is 0 , e.g. dummy firmware */
+		{
+			/* send firmware_len bytes (up to 16) to Si2158 */
+			if ((return_code = silabs_tercab_firmware_patch(ctx, fw_table[line].firmware_len, fw_table[line].firmware_table)) != NO_SILABS_TERCAB_ERROR)
+			{
+				SiTRACE("silabs_tercab_load_firmware_16 error 0x%02x patching line %d: %s\n", return_code, line, silabs_tercab_error_text(return_code) );
+				if (line == 0) {
+					SiTRACE("The firmware is incompatible with the part!\n");
+				}
+				return ERROR_SILABS_TERCAB_LOADING_FIRMWARE;
+			}
+			if (line==3) {
+				SiTracesSuspend();
+			}
+		}
+	}
+	SiTracesResume();
+	SiTRACE ("silabs_tercab_load_firmware_16 complete...\n");
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+/************************************************************************************************************************
+  NAME: silabs_tercab_load_firmware
+  DESCRIPTON: Load firmware from FIRMWARE_TABLE array in Si2158_Firmware_x_y_build_z.h file into Si2158
+              Requires Si2158 to be in bootloader mode after PowerUp
+  Programming Guide Reference:    Flowchart A.3 (Download FW PATCH flowchart)
+
+  Parameter:  Si2158 Context (I2C address)
+  Parameter:  pointer to firmware table array
+  Parameter:  number of lines in firmware table array (size in bytes / BYTES_PER_LINE)
+  Returns:    Si2158/I2C transaction error code, NO_SILABS_TERCAB_ERROR if successful
+ ************************************************************************************************************************/
+static int silabs_tercab_load_firmware(silabs_tercab_context *ctx, u8 fw_table[], int nbLines)
+{
+	int return_code;
+	int line;
+	return_code = NO_SILABS_TERCAB_ERROR;
+
+	SiTRACE ("silabs_tercab_load_firmware nbLines=%d\n", nbLines);
+
+	/* for each line in fw_table */
+	for (line = 0; line < nbLines; line++)
+	{
+		/* send Si2158_BYTES_PER_LINE fw bytes to Si2158 */
+		if ((return_code = silabs_tercab_firmware_patch(ctx, Si2158_BYTES_PER_LINE, fw_table + Si2158_BYTES_PER_LINE*line)) != NO_SILABS_TERCAB_ERROR)
+		{
+			SiTRACE("silabs_tercab_load_firmware error 0x%02x patching line %d: %s\n", return_code, line, silabs_tercab_error_text(return_code) );
+			if (line == 0) {
+				SiTRACE("The firmware is incompatible with the part!\n");
+			}
+			return ERROR_SILABS_TERCAB_LOADING_FIRMWARE;
+		}
+		if (line==3) {
+			SiTracesSuspend();
+		}
+	}
+	SiTracesResume();
+	SiTRACE ("silabs_tercab_load_firmware complete...\n");
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+/*---------------------------------------------------*/
+/* Si2158_EXIT_BOOTLOADER COMMAND                  */
+/*---------------------------------------------------*/
+static u8 silabs_tercab_exit_bootloader(silabs_tercab_context *ctx,
+		u8   func,
+		u8   ctsien)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[1];
+	//ctx->rsp.exit_bootloader.STATUS = ctx->status;
+
+	SiTRACE("%s()\n", __func__);
+
+	cmdByteBuffer[0] = Si2158_EXIT_BOOTLOADER_CMD;
+	cmdByteBuffer[1] = (u8) ( ( func   & Si2158_EXIT_BOOTLOADER_CMD_FUNC_MASK   ) << Si2158_EXIT_BOOTLOADER_CMD_FUNC_LSB  |
+			( ctsien & Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_MASK ) << Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing EXIT_BOOTLOADER bytes!\n");
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	error_code = silabs_tercab_poll_response(ctx->i2c_adap, ctx->i2c_addr, 1, rspByteBuffer, &ctx->status);
+	if (error_code) {
+		SiTRACE("Error polling EXIT_BOOTLOADER response\n");
+		return error_code;
+	}
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+/************************************************************************************************************************
+  NAME: silabs_tercab_start_firmware
+  DESCRIPTION: Start Si2158 firmware (put the Si2158 into run mode)
+  Parameter:   Si2158 Context (I2C address)
+  Parameter (passed by Reference):   ExitBootloadeer Response Status byte : tunint, atvint, dtvint, err, cts
+  Returns:     I2C transaction error code, NO_SILABS_TERCAB_ERROR if successful
+ ************************************************************************************************************************/
+static int silabs_tercab_start_firmware(silabs_tercab_context *ctx)
+{
+	if (silabs_tercab_exit_bootloader(ctx, Si2158_EXIT_BOOTLOADER_CMD_FUNC_TUNER, Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_OFF) != NO_SILABS_TERCAB_ERROR)	{
+		return ERROR_SILABS_TERCAB_STARTING_FIRMWARE;
+	}
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+/************************************************************************************************************************
+  NAME: silabs_tercab_power_up_with_patch
+  DESCRIPTION: Send Si2158 ctx PowerUp Command with PowerUp to bootloader,
+  Check the Chip rev and part, and ROMID are compared to expected values.
+  Load the Firmware Patch then Start the Firmware.
+  Programming Guide Reference:    Flowchart A.2 (POWER_UP with patch flowchart)
+
+  Parameter:  pointer to Si2158 Context
+  Returns:    Si2158/I2C transaction error code, NO_SILABS_TERCAB_ERROR if successful
+ ************************************************************************************************************************/
+static int silabs_tercab_power_up_with_patch(struct silabs_tercab_priv *priv)
+{
+	silabs_tercab_context *ctx = &priv->tuner;
+	struct part_info part_info;
+	int return_code = NO_SILABS_TERCAB_ERROR;
+	u16 docrc = 0;
+
+	/* always wait for CTS prior to POWER_UP command */
+	if ((return_code = silabs_tercab_poll_cts(ctx->i2c_adap, ctx->i2c_addr)) != NO_SILABS_TERCAB_ERROR) {
+		SiTRACE ("Si2158_pollForCTS error 0x%02x\n", return_code);
+		return return_code;
+	}
+
+	if ((return_code = silabs_tercab_power_up(ctx->i2c_adap, ctx->i2c_addr,
+			Si2158_POWER_UP_CMD_SUBCODE_CODE,
+			Si2158_POWER_UP_CMD_CLOCK_MODE_XTAL,
+			Si2158_POWER_UP_CMD_EN_XOUT_EN_XOUT,
+			Si2158_POWER_UP_CMD_PD_LDO_LDO_POWER_UP,
+			Si2158_POWER_UP_CMD_RESERVED2_RESERVED,
+			Si2158_POWER_UP_CMD_RESERVED3_RESERVED,
+			Si2158_POWER_UP_CMD_RESERVED4_RESERVED,
+			Si2158_POWER_UP_CMD_RESERVED5_RESERVED,
+			Si2158_POWER_UP_CMD_RESERVED6_RESERVED,
+			Si2158_POWER_UP_CMD_RESERVED7_RESERVED,
+			Si2158_POWER_UP_CMD_RESET_RESET,
+			Si2158_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ,
+			Si2158_POWER_UP_CMD_RESERVED8_RESERVED,
+			Si2158_POWER_UP_CMD_FUNC_BOOTLOADER,
+#ifndef __SI2158__
+			Si2157_POWER_UP_CMD_RESERVED9_RESERVED,
+#endif
+			Si2158_POWER_UP_CMD_CTSIEN_DISABLE,
+			Si2158_POWER_UP_CMD_WAKE_UP_WAKE_UP,
+			&ctx->status
+	)) != NO_SILABS_TERCAB_ERROR) {
+		/* _power_up_call_insertion_point */
+
+		SiTRACE ("silabs_tercab power up error 0x%02x: %s\n", return_code, silabs_tercab_error_text(return_code) );
+		return return_code;
+	}
+
+	/* Get the Part Info from the chip.   This command is only valid in Bootloader mode */
+	if ((return_code = si2158_part_info(priv->i2c_props.adap, priv->i2c_props.addr, &part_info)) != NO_SILABS_TERCAB_ERROR) {
+		SiTRACE ("silabs_tercab part info error 0x%02x: %s\n", return_code, silabs_tercab_error_text(return_code) );
+		return return_code;
+	}
+	ctx->rsp.part_info.chiprev  = part_info.chiprev;
+	ctx->rsp.part_info.part     = part_info.part;
+	ctx->rsp.part_info.pmajor   = part_info.pmajor;
+	ctx->rsp.part_info.pbuild   = part_info.pbuild;
+	ctx->rsp.part_info.romid    = part_info.romid;
+	ctx->rsp.part_info.reserved = part_info.reserved;
+	ctx->rsp.part_info.serial   = part_info.serial;
+
+#ifdef SiTRACES
+	SiTRACE("chiprev %d\n",        ctx->rsp.part_info.chiprev);
+	SiTRACE("part    Si21%d\n",    ctx->rsp.part_info.part   );
+	SiTRACE("pmajor  %d\n",        ctx->rsp.part_info.pmajor );
+	if (ctx->rsp.part_info.pmajor >= 0x30) {
+		SiTRACE("pmajor '%c'\n",       ctx->rsp.part_info.pmajor );
+	}
+	SiTRACE("pminor  %d\n",        ctx->rsp.part_info.pminor );
+	if (ctx->rsp.part_info.pminor >= 0x30) {
+		SiTRACE("pminor '%c'\n",       ctx->rsp.part_info.pminor );
+	}
+#ifndef __SI2158__
+	SiTRACE("pbuild %d\n",         ctx->rsp.part_info.pbuild );
+#endif
+	SiTRACE("romid %3d/0x%02x\n",  ctx->rsp.part_info.romid,  ctx->rsp.part_info.romid );
+#endif /* SiTRACES */
+
+	if (ctx->rsp.part_info.part == 77) {
+#ifdef PART_INTEGRITY_CHECKS
+		/* Check the Chip revision, part and ROMID against expected values and report an error if incompatible */
+		if (ctx->rsp.part_info.chiprev != ctx->chiprev) {
+			SiTRACE ("INCOMPATIBLE PART error chiprev %d (expected %d)\n", ctx->rsp.part_info.chiprev, ctx->chiprev);
+			return_code = ERROR_Si2177_INCOMPATIBLE_PART;
+		}
+		/* Part Number is represented as the last 2 digits */
+		if (ctx->rsp.part_info.part != ctx->part) {
+			SiTRACE ("INCOMPATIBLE PART error part   %d (expected %d)\n", ctx->rsp.part_info.part, ctx->part);
+			return_code = ERROR_Si2177_INCOMPATIBLE_PART;
+		}
+		/* Part Major Version in ASCII */
+		if (ctx->rsp.part_info.pmajor != ctx->partMajorVersion) {
+			SiTRACE ("INCOMPATIBLE PART error pmajor %d (expected %d)\n", ctx->rsp.part_info.pmajor, ctx->partMajorVersion);
+			return_code = ERROR_Si2177_INCOMPATIBLE_PART;
+		}
+		/* Part Minor Version in ASCII */
+		if (ctx->rsp.part_info.pminor != ctx->partMinorVersion) {
+			SiTRACE ("INCOMPATIBLE PART error pminor %d (expected %d)\n", ctx->rsp.part_info.pminor, ctx->partMinorVersion);
+			return_code = ERROR_Si2177_INCOMPATIBLE_PART;
+		}
+		/* ROMID in byte representation */
+		if (ctx->rsp.part_info.romid != ctx->partRomid) {
+			SiTRACE ("INCOMPATIBLE PART error romid %3d (expected %2d)\n", ctx->rsp.part_info.romid, ctx->partRomid);
+			return_code = ERROR_Si2177_INCOMPATIBLE_PART;
+		}
+		if (return_code != NO_SILABS_TERCAB_ERROR) return return_code;
+#endif /* PART_INTEGRITY_CHECKS */
+		if (ctx->rsp.part_info.romid == 0x50) {
+			if ((return_code = silabs_tercab_load_firmware_16(ctx, Si2177_FW_3_0bx, FIRMWARE_LINES_3_0bx)) != NO_SILABS_TERCAB_ERROR) {
+				SiTRACE ("silabs_tercab_load_firmware_16 error 0x%02x: %s\n", return_code, silabs_tercab_error_text(return_code) );
+				return return_code;
+			}
+		} else {
+			SiTRACE ("Invalid ROMID error 0x%02x: ROMID=%02x\n", ERROR_SILABS_TERCAB_INCOMPATIBLE_PART, ctx->rsp.part_info.romid );
+			return ERROR_SILABS_TERCAB_INCOMPATIBLE_PART;
+		}
+	}
+
+	docrc = RAM_CRC_2_1b9;//FGR Si2158
+
+#ifndef __SI2158__
+	if (ctx->rsp.part_info.romid == 0x50) {
+		docrc = 0;//FGR - 21x7 have no CRC command
+		SiTRACE ("silabs_tercab_load_firmware found Si21x7\n");
+
+		/* Only load the Firmware if we are NOT a Si2157-A30 part*/
+		if ((ctx->rsp.part_info.pmajor == '3') && (ctx->rsp.part_info.pminor == '0') && (ctx->rsp.part_info.pbuild == 5)) {
+			SiTRACE ("No firmware to download for Si21x7-A30. Loading from NVM only\n" );
+		} else {
+			if ((return_code = silabs_tercab_load_firmware_16(ctx, Si2157_FW_3_0b5, FIRMWARE_LINES_3_0b5)) != NO_SILABS_TERCAB_ERROR) {
+				SiTRACE ("silabs_tercab_load_firmware error 0x%02x: %s\n", return_code, silabs_tercab_error_text(return_code) );
+				return return_code;
+			}
+		}
+	} else
+#endif
+		/* Load the Firmware based on ROMID */
+		if (ctx->rsp.part_info.romid == 0x32) {
+			/* Load the Firmware */
+			if ((return_code = silabs_tercab_load_firmware(ctx, Si2158_FW_0_Eb15, FIRMWARE_LINES_0_Eb15)) != NO_SILABS_TERCAB_ERROR) {
+				SiTRACE ("silabs_tercab_load_firmware error 0x%02x: %s\n", return_code, silabs_tercab_error_text(return_code) );
+				return return_code;
+			}
+		} else if (ctx->rsp.part_info.romid == 0x33) { /* if Si2158-A20 part load firmware patch (currently a dummy patch , 20bx) */
+			/* This dummy patch (20bx) will skip the loadFirmware function and boot from NVM only.
+           When a new patch is available for the Si2158-A20, include the patch file and replace the firmware array and size in the function below */
+			if ((return_code = silabs_tercab_load_firmware_16(ctx, Si2158_FW_2_1b9, FIRMWARE_LINES_2_1b9)) != NO_SILABS_TERCAB_ERROR) {
+				SiTRACE ("silabs_tercab_load_firmware_16 error 0x%02x: %s\n", return_code, silabs_tercab_error_text(return_code) );
+				return return_code;
+			}
+		} else {
+			SiTRACE ("INCOMPATIBLE PART error ROMID 0x%02x\n", ctx->rsp.part_info.romid);
+			return ERROR_SILABS_TERCAB_INCOMPATIBLE_PART;
+		}
+#ifdef RAM_CRC_CHECK
+	if (docrc) {
+		/* Check the RAM_CRC value and compare with the expected value */
+		/* If they match then move on,  otherwise indicate error */
+		/* This check is bypassed by default to speed boot time. */
+
+		if ((return_code = Si2158_L1_RAM_CRC(ctx)) != NO_SILABS_TERCAB_ERROR) {
+			SiTRACE ("Si2158_L1_RAM_CRC error 0x%02x: %s\n", return_code, silabs_tercab_error_text(return_code) );
+			return return_code;
+		}
+		SiTRACE("RAM CRC = 0x%X\n",ctx->rsp.ram_crc.crc);
+		if (ctx->rsp.ram_crc.crc != docrc) {
+			return_code = ERROR_SILABS_TERCAB_CRC_CHECK_ERROR;
+			SiTRACE ("RAM_CRC (0x%X) does not match expected (0x%X) error 0x%02x: %s\n",ctx->rsp.ram_crc.crc,docrc,return_code, silabs_tercab_error_text(return_code) );
+			return return_code;
+		}
+	}
+#endif /* RAM_CRC_CHECK */
+
+	/* Start the Firmware */
+	return_code = silabs_tercab_start_firmware(ctx);
+	if (return_code != NO_SILABS_TERCAB_ERROR) {
+		SiTRACE("silabs_tercab_start_firmware error 0x%02x: %s\n", return_code, silabs_tercab_error_text(return_code));
+		return return_code;
+	}
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+/*---------------------------------------------------*/
+/* Si2158_CONFIG_PINS COMMAND                      */
+/*---------------------------------------------------*/
+static u8 silabs_tercab_config_pins(silabs_tercab_context *ctx,
+		u8   gpio1_mode,
+		u8   gpio1_read,
+		u8   gpio2_mode,
+		u8   gpio2_read,
+		u8   reserved1,
+		u8   reserved2,
+		u8   reserved3)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[6];
+	u8 rspByteBuffer[6];
+
+	SiTRACE("%s()\n", __func__);
+
+	cmdByteBuffer[0] = Si2158_CONFIG_PINS_CMD;
+	cmdByteBuffer[1] = (u8) ( ( gpio1_mode & Si2158_CONFIG_PINS_CMD_GPIO1_MODE_MASK ) << Si2158_CONFIG_PINS_CMD_GPIO1_MODE_LSB|
+							  ( gpio1_read & Si2158_CONFIG_PINS_CMD_GPIO1_READ_MASK ) << Si2158_CONFIG_PINS_CMD_GPIO1_READ_LSB);
+	cmdByteBuffer[2] = (u8) ( ( gpio2_mode & Si2158_CONFIG_PINS_CMD_GPIO2_MODE_MASK ) << Si2158_CONFIG_PINS_CMD_GPIO2_MODE_LSB|
+							  ( gpio2_read & Si2158_CONFIG_PINS_CMD_GPIO2_READ_MASK ) << Si2158_CONFIG_PINS_CMD_GPIO2_READ_LSB);
+	cmdByteBuffer[3] = (u8) ( ( reserved1  & Si2158_CONFIG_PINS_CMD_RESERVED1_MASK  ) << Si2158_CONFIG_PINS_CMD_RESERVED1_LSB );
+	cmdByteBuffer[4] = (u8) ( ( reserved2  & Si2158_CONFIG_PINS_CMD_RESERVED2_MASK  ) << Si2158_CONFIG_PINS_CMD_RESERVED2_LSB );
+	cmdByteBuffer[5] = (u8) ( ( reserved3  & Si2158_CONFIG_PINS_CMD_RESERVED3_MASK  ) << Si2158_CONFIG_PINS_CMD_RESERVED3_LSB );
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 6, cmdByteBuffer) != 6) {
+		SiTRACE("Error writing CONFIG_PINS bytes!\n");
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	error_code = silabs_tercab_poll_response(ctx->i2c_adap, ctx->i2c_addr, 6, rspByteBuffer, &ctx->status);
+	if (error_code) {
+		SiTRACE("Error polling CONFIG_PINS response\n");
+		return error_code;
+	}
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+/***********************************************************************************************************************
+  silabs_tercab_ctx_init function
+  Use:        software initialisation function
+              Used to initialize the software context
+  Returns:    0 if no error
+  Comments:   It should be called first and once only when starting the application
+  Parameter:   **ppctx         a pointer to the ctx context to initialize
+  Parameter:  add            the Si2158 I2C address
+  Porting:    Allocation errors need to be properly managed.
+  Porting:    I2C initialization needs to be adapted to use the available I2C functions
+ ***********************************************************************************************************************/
+static u8 silabs_tercab_ctx_init(silabs_tercab_context *ctx, u8 addr, struct i2c_adapter *i2c_adap)
+{
+	ctx->i2c_addr = addr;
+	ctx->i2c_adap = i2c_adap;
+
+#ifdef SiTRACES
+	if (!trace_init_done) {
+		CUSTOM_PRINTF("********** SiTRACES activated *********\n");
+		CUSTOM_PRINTF("Comment the '#define SiTRACES' line\n");
+		CUSTOM_PRINTF("in silabs_tercab_priv.h\n");
+		CUSTOM_PRINTF("to deactivate all traces.\n");
+		CUSTOM_PRINTF("***************************************\n");
+		SiTraceDefaultConfiguration();
+	}
+#endif /* SiTRACES */
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+/************************************************************************************************************************
+  silabs_tercab_sw_init function
+  Use:        software initialization function
+              Used to initialize the Si2158 and tuner structures
+  Behavior:   This function performs all the steps necessary to initialize the Si2158 tuner instances
+  Parameter:  front_end, a pointer to the Si2158_L2_Context context to be initialized
+  Parameter:  tunerAdd, the I2C address of the tuner
+  Comments:     It MUST be called first and once before using any other function.
+                It can be used to build a multi-demod/multi-tuner application, if called several times from the upper layer with different pointers and addresses
+                After execution, all demod and tuner functions are accessible.
+ ************************************************************************************************************************/
+static char silabs_tercab_sw_init(struct silabs_tercab_priv *priv
+		, int tunerAdd
+		, void *p_context
+		, struct i2c_adapter *i2c_adap
+)
+{
+#ifdef    SiTRACES
+	char infoStringBuffer[1000] = { 0 };
+	char *infoString;
+	infoString = &(infoStringBuffer[0]);
+#endif /* SiTRACE */
+
+	/* Pointers initialization */
+	priv->silabs_tercab_init_done = 0;
+	priv->firmware_started = 0;
+	/* Calling underlying SW initialization functions */
+	SiTRACE("silabs_tercab_ctx_init starting...\n");
+	silabs_tercab_ctx_init(&priv->tuner, tunerAdd, i2c_adap);
+#ifdef    SiTRACES
+	if (silabs_tercab_infos(priv, infoString)) {
+		SiTRACE("%s\n", infoString);
+	}
+#endif /* SiTRACE */
+	SiTRACE("silabs_tercab_ctx_init complete\n");
+	return 1;
+}
+
+/*****************************************************************************************
+NAME: silabs_tercab_download_atv_properties
+ DESCRIPTION: Setup Si2158 ATV properties configuration
+ This function will download all the ATV configuration properties.
+ The function SetupATVDefaults() should be called before the first call to this function.
+ Parameter:  Pointer to Si2158 Context
+ Returns:    I2C transaction error code, NO_SILABS_TERCAB_ERROR if successful
+ Programming Guide Reference:    ATV setup flowchart
+ ******************************************************************************************/
+static int silabs_tercab_download_atv_properties(silabs_tercab_context *ctx)
+{
+	const u16 atv_afc_range_khz                   = 1000; /* (default  1000) */
+	const u8  atv_af_out_mute                     = Si2177_ATV_AF_OUT_PROP_MUTE_NORMAL; /* Si2177 (default 'NORMAL') */
+	const u8  atv_af_out_volume                   = 0; /* Si2177 (default     0) */
+	const u8  atv_agc_speed_if_agc_speed          = Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO; /* (default 'AUTO') */
+	const u8  atv_agc_speed_low_rssi_if_agc_speed = Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_158; /* (default '158') */
+	const s8  atv_agc_speed_low_rssi_thld         = -128; /* (default  -128) */
+	const u8  atv_artificial_snow_gain            = Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_AUTO; /* (default 'AUTO') */
+	const s8  atv_artificial_snow_offset          = 0; /* (default     0) */
+	const u8  atv_artificial_snow_period          = Si2177_ATV_ARTIFICIAL_SNOW_PROP_PERIOD_LONG; /* (default 'LONG') */
+	const u8  atv_artificial_snow_sound           = Si2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_MUTE; /* (default 'MUTE') */
+	const u8  atv_audio_mode_audio_sys            = Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_DEFAULT; /* Si2177 (default 'DEFAULT') */
+	const u8  atv_audio_mode_chan_bw              = Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_DEFAULT; /* Si2177 (default 'DEFAULT') */
+	const u8  atv_audio_mode_demod_mode           = Si2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_SIF; /* Si2177 (default 'SIF') */
+	const u8  atv_config_if_port_atv_agc_source   = Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_AGC1_3DB; /* Si2158 (default 'INTERNAL') */
+	const u8  atv_config_if_port_atv_out_type     = Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LIF_DIFF_IF1; /* (default 'LIF_DIFF_IF1') */
+	const u8  atv_cvbs_out_amp                    = 200; /* Si2177 (default   200) */
+	const u8  atv_cvbs_out_offset                 = 25; /* Si2177 (default    25) */
+	const u8  atv_cvbs_out_fine_amp               = 100; /* Si2177 (default   100) */
+	const s8  atv_cvbs_out_fine_offset            = 0; /* Si2177 (default     0) */
+	const u8  atv_hsync_out_gpio_sel              = Si2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_NONE ; /* (default 'NONE') */
+	const s8  atv_hsync_out_offset                = 0; /* Si2177 (default     0) */
+	const u8  atv_hsync_out_width                 = 42; /* Si2177 (default    42) */
+	const u8  atv_ext_agc_max_10mv                = 200; /* (default   200) */
+	const u8  atv_ext_agc_min_10mv                = 50; /* (default    50) */
+	const u8  atv_ien_chlien                      = Si2158_ATV_IEN_PROP_CHLIEN_ENABLE;           /* (default 'ENABLE') */
+	const u8  atv_ien_pclien                      = Si2158_ATV_IEN_PROP_PCLIEN_DISABLE;          /* (default 'DISABLE') */
+	const u8  atv_ien_dlien                       = Si2177_ATV_IEN_PROP_DLIEN_DISABLE;           /* (default 'DISABLE') */
+	const u8  atv_ien_snrlien                     = Si2177_ATV_IEN_PROP_SNRLIEN_DISABLE;         /* (default 'DISABLE') */
+	const u8  atv_ien_snrhien                     = Si2177_ATV_IEN_PROP_SNRHIEN_DISABLE;         /* (default 'DISABLE') */
+	const u8  atv_int_sense_chlnegen              = Si2158_ATV_INT_SENSE_PROP_CHLNEGEN_DISABLE;  /* (default 'DISABLE') */
+	const u8  atv_int_sense_pclnegen              = Si2158_ATV_INT_SENSE_PROP_PCLNEGEN_DISABLE;  /* (default 'DISABLE') */
+	const u8  atv_int_sense_chlposen              = Si2158_ATV_INT_SENSE_PROP_CHLPOSEN_ENABLE ;  /* (default 'ENABLE') */
+	const u8  atv_int_sense_pclposen              = Si2158_ATV_INT_SENSE_PROP_PCLPOSEN_ENABLE;   /* (default 'ENABLE') */
+	const u8  atv_int_sense_dlnegen               = Si2177_ATV_INT_SENSE_PROP_DLNEGEN_DISABLE;   /* (default 'DISABLE') */
+	const u8  atv_int_sense_snrlnegen             = Si2177_ATV_INT_SENSE_PROP_SNRLNEGEN_DISABLE; /* (default 'DISABLE') */
+	const u8  atv_int_sense_snrhnegen             = Si2177_ATV_INT_SENSE_PROP_SNRHNEGEN_DISABLE; /* (default 'DISABLE') */
+	const u8  atv_int_sense_dlposen               = Si2177_ATV_INT_SENSE_PROP_DLPOSEN_ENABLE;    /* (default 'ENABLE') */
+	const u8  atv_int_sense_snrlposen             = Si2177_ATV_INT_SENSE_PROP_SNRLPOSEN_ENABLE;  /* (default 'ENABLE') */
+	const u8  atv_int_sense_snrhposen             = Si2177_ATV_INT_SENSE_PROP_SNRHPOSEN_ENABLE;  /* (default 'ENABLE') */
+	const u16 atv_lif_freq_offset                 = 4000; /* (default  5000) */
+	const u8  atv_lif_out_amp                     = 100; /* (default   100) */
+	const u8  atv_lif_out_offset                  = 148; /* (default   148) */
+	const u8  atv_pga_target_override_enable      = Si2158_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DISABLE; /* (default 'DISABLE') */
+	const s8  atv_pga_target_pga_target           = 0; /* (default     0) */
+	const u8  atv_rf_top_atv_rf_top               = Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_AUTO; /* (default 'AUTO') */
+	const s8  atv_rsq_rssi_threshold_hi           = 0; /* (default     0) */
+	const s8  atv_rsq_rssi_threshold_lo           = -70; /* (default   -70) */
+	const u8  atv_rsq_snr_threshold_hi            = 45; /* Si2177 (default    45) */
+	const u8  atv_rsq_snr_threshold_lo            = 25; /* Si2177 (default    25) */
+	const u8  atv_sif_out_amp                     = 60; /* Si2177 (default    60) */
+	const u8  atv_sif_out_offset                  = 135; /* Si2177 (default   135) */
+	const s8  atv_sound_agc_limit_max_gain        = 84; /* Si2177 (default    84) */
+	const s8  atv_sound_agc_limit_min_gain        = -84; /* Si2177 (default   -84) */
+	const u8  atv_sound_agc_speed_other_systems   = 4; /* Si2177 (default     4) */
+	const u8  atv_sound_agc_speed_system_l        = 5; /* Si2177 (default     5) */
+	const s8  atv_video_equalizer_slope           = 0; /* Si2177 (default     0) */
+	const u8  atv_video_mode_color                = Si2158_ATV_VIDEO_MODE_PROP_COLOR_PAL_NTSC; /* (default 'PAL_NTSC') */
+	const u8  atv_video_mode_invert_spectrum      = Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_INVERTED; /* (default 'INVERTED') */
+	const u8  atv_video_mode_video_sys            = Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_M; /* (default 'B') */
+	const u8  atv_vsnr_cap_atv_vsnr_cap           = 0; /* (default     0) */
+
+	u16 si2158_atv_afc_range__prop_data;
+	u16 si2177_atv_af_out__prop_data;
+	u16 si2158_atv_agc_speed__prop_data;
+	u16 si2158_atv_agc_speed_low_rssi__prop_data;
+	u16 si2177_atv_artificial_snow__prop_data;
+	u16 si2158_atv_artificial_snow__prop_data;
+	u16 si2177_atv_audio_mode__prop_data;
+	u16 si2158_atv_config_if_port__prop_data;
+	u16 si2177_atv_config_if_port__prop_data;
+	u16 si2158_atv_ext_agc__prop_data;
+	u16 si2177_atv_cvbs_out__prop_data;
+	u16 si2177_atv_cvbs_out_fine__prop_data;
+	u16 si2177_atv_hsync_out__prop_data;
+	u16 si2158_atv_ien__prop_data;
+	u16 si2177_atv_ien__prop_data;
+	u16 si2158_atv_int_sense__prop_data;
+	u16 si2177_atv_int_sense__prop_data;
+	u16 si2158_atv_lif_freq__prop_data;
+	u16 si2158_atv_lif_out__prop_data;
+	u16 si2158_atv_pga_target__prop_data;
+	u16 si2158_atv_rf_top__prop_data;
+	u16 si2158_atv_rsq_rssi_threshold__prop_data;
+	u16 si2177_atv_rsq_snr_threshold__prop_data;
+	u16 si2177_atv_sif_out__prop_data;
+	u16 si2177_atv_sound_agc_limit__prop_data;
+	u16 si2177_atv_sound_agc_speed__prop_data;
+	u16 si2177_atv_video_equalizer__prop_data;
+	u16 si2158_atv_video_mode__prop_data;
+	u16 si2177_atv_video_mode__prop_data;
+	u16 si2158_atv_vsnr_cap__prop_data;
+
+	SiTRACE("%s()\n", __func__);
+
+	si2158_atv_afc_range__prop_data = (atv_afc_range_khz & Si2158_ATV_AFC_RANGE_PROP_RANGE_KHZ_MASK) << Si2158_ATV_AFC_RANGE_PROP_RANGE_KHZ_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_ATV_AFC_RANGE_PROP_CODE, si2158_atv_afc_range__prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	if (ctx->part == 77) {
+		si2177_atv_af_out__prop_data = (atv_af_out_volume & Si2177_ATV_AF_OUT_PROP_VOLUME_MASK) << Si2177_ATV_AF_OUT_PROP_VOLUME_LSB  |
+			   (atv_af_out_mute   & Si2177_ATV_AF_OUT_PROP_MUTE_MASK  ) << Si2177_ATV_AF_OUT_PROP_MUTE_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2177_ATV_AF_OUT_PROP_CODE, si2177_atv_af_out__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+	}
+
+	si2158_atv_agc_speed__prop_data = (atv_agc_speed_if_agc_speed & Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_ATV_AGC_SPEED_PROP_CODE, si2158_atv_agc_speed__prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_atv_agc_speed_low_rssi__prop_data = (atv_agc_speed_low_rssi_if_agc_speed & Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_MASK) << Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_LSB  |
+		   (atv_agc_speed_low_rssi_thld         & Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_MASK        ) << Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_CODE, si2158_atv_agc_speed_low_rssi__prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	if (ctx->part == 77) {
+		si2177_atv_artificial_snow__prop_data = (atv_artificial_snow_gain   & Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_MASK  ) << Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_LSB  |
+				(atv_artificial_snow_sound  & Si2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_MASK ) << Si2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_LSB  |
+				(atv_artificial_snow_period & Si2177_ATV_ARTIFICIAL_SNOW_PROP_PERIOD_MASK) << Si2177_ATV_ARTIFICIAL_SNOW_PROP_PERIOD_LSB  |
+				(atv_artificial_snow_offset & Si2158_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_MASK) << Si2158_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2158_ATV_ARTIFICIAL_SNOW_PROP_CODE, si2177_atv_artificial_snow__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+	} else {
+		si2158_atv_artificial_snow__prop_data = (atv_artificial_snow_gain   & Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_MASK  ) << Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_LSB  |
+			   (atv_artificial_snow_offset & Si2158_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_MASK) << Si2158_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_LSB ;
+
+		if (silabs_tercab_set_property(ctx, Si2158_ATV_ARTIFICIAL_SNOW_PROP_CODE, si2158_atv_artificial_snow__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+	}
+
+	if (ctx->part == 77) {
+		si2177_atv_audio_mode__prop_data = (atv_audio_mode_audio_sys  & Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MASK ) << Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_LSB  |
+			   (atv_audio_mode_demod_mode & Si2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_MASK) << Si2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_LSB  |
+			   (atv_audio_mode_chan_bw    & Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_MASK   ) << Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2177_ATV_AUDIO_MODE_PROP_CODE, si2177_atv_audio_mode__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+	}
+
+	switch (ctx->part) {
+	case 57:
+		si2158_atv_config_if_port__prop_data = (atv_config_if_port_atv_out_type   & Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_MASK  ) << Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LSB  |
+		       (atv_config_if_port_atv_agc_source & Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_MASK) << Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2158_ATV_CONFIG_IF_PORT_PROP_CODE, si2158_atv_config_if_port__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+		break;
+	case 77: /* Si2177 has no ATV_AGC_SOURCE */
+		si2177_atv_config_if_port__prop_data = (atv_config_if_port_atv_out_type & Si2177_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_MASK) << Si2177_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2158_ATV_CONFIG_IF_PORT_PROP_CODE, si2177_atv_config_if_port__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+		break;
+	default:
+		pr_warn("%s(): unsupported tuner model Si21%02u\n", __func__, ctx->part);
+		break;
+	}
+
+	si2158_atv_ext_agc__prop_data = (atv_ext_agc_min_10mv & Si2158_ATV_EXT_AGC_PROP_MIN_10MV_MASK) << Si2158_ATV_EXT_AGC_PROP_MIN_10MV_LSB  |
+		   (atv_ext_agc_max_10mv & Si2158_ATV_EXT_AGC_PROP_MAX_10MV_MASK) << Si2158_ATV_EXT_AGC_PROP_MAX_10MV_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_ATV_EXT_AGC_PROP_CODE, si2158_atv_ext_agc__prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	if (ctx->part == 77) {
+		si2177_atv_cvbs_out__prop_data = (atv_cvbs_out_offset & Si2177_ATV_CVBS_OUT_PROP_OFFSET_MASK) << Si2177_ATV_CVBS_OUT_PROP_OFFSET_LSB  |
+			   (atv_cvbs_out_amp    & Si2177_ATV_CVBS_OUT_PROP_AMP_MASK   ) << Si2177_ATV_CVBS_OUT_PROP_AMP_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2177_ATV_CVBS_OUT_PROP_CODE, si2177_atv_cvbs_out__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+
+		si2177_atv_cvbs_out_fine__prop_data = (atv_cvbs_out_fine_offset & Si2177_ATV_CVBS_OUT_FINE_PROP_OFFSET_MASK) << Si2177_ATV_CVBS_OUT_FINE_PROP_OFFSET_LSB  |
+			   (atv_cvbs_out_fine_amp    & Si2177_ATV_CVBS_OUT_FINE_PROP_AMP_MASK   ) << Si2177_ATV_CVBS_OUT_FINE_PROP_AMP_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2177_ATV_CVBS_OUT_FINE_PROP_CODE, si2177_atv_cvbs_out_fine__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+
+		si2177_atv_hsync_out__prop_data = (atv_hsync_out_gpio_sel & Si2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_MASK) << Si2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_LSB  |
+	           (atv_hsync_out_width    & Si2177_ATV_HSYNC_OUT_PROP_WIDTH_MASK   ) << Si2177_ATV_HSYNC_OUT_PROP_WIDTH_LSB  |
+	           (atv_hsync_out_offset   & Si2177_ATV_HSYNC_OUT_PROP_OFFSET_MASK  ) << Si2177_ATV_HSYNC_OUT_PROP_OFFSET_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2177_ATV_HSYNC_OUT_PROP_CODE, si2177_atv_hsync_out__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+	}
+
+	switch (ctx->part) {
+	case 57:
+		si2158_atv_ien__prop_data = (atv_ien_chlien & Si2158_ATV_IEN_PROP_CHLIEN_MASK) << Si2158_ATV_IEN_PROP_CHLIEN_LSB  |
+		       (atv_ien_pclien & Si2158_ATV_IEN_PROP_PCLIEN_MASK) << Si2158_ATV_IEN_PROP_PCLIEN_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2158_ATV_IEN_PROP_CODE, si2158_atv_ien__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+		break;
+	case 77:
+		si2177_atv_ien__prop_data = (atv_ien_chlien  & Si2158_ATV_IEN_PROP_CHLIEN_MASK ) << Si2158_ATV_IEN_PROP_CHLIEN_LSB  |
+		       (atv_ien_pclien  & Si2158_ATV_IEN_PROP_PCLIEN_MASK ) << Si2158_ATV_IEN_PROP_PCLIEN_LSB  |
+		       (atv_ien_dlien   & Si2177_ATV_IEN_PROP_DLIEN_MASK  ) << Si2177_ATV_IEN_PROP_DLIEN_LSB  |
+		       (atv_ien_snrlien & Si2177_ATV_IEN_PROP_SNRLIEN_MASK) << Si2177_ATV_IEN_PROP_SNRLIEN_LSB  |
+		       (atv_ien_snrhien & Si2177_ATV_IEN_PROP_SNRHIEN_MASK) << Si2177_ATV_IEN_PROP_SNRHIEN_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2158_ATV_IEN_PROP_CODE, si2177_atv_ien__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+		break;
+	default:
+		pr_warn("%s(): unsupported tuner model Si21%02u\n", __func__, ctx->part);
+		break;
+	}
+
+	switch (ctx->part) {
+	case 57:
+		si2158_atv_int_sense__prop_data = (atv_int_sense_chlnegen & Si2158_ATV_INT_SENSE_PROP_CHLNEGEN_MASK) << Si2158_ATV_INT_SENSE_PROP_CHLNEGEN_LSB  |
+		       (atv_int_sense_pclnegen & Si2158_ATV_INT_SENSE_PROP_PCLNEGEN_MASK) << Si2158_ATV_INT_SENSE_PROP_PCLNEGEN_LSB  |
+		       (atv_int_sense_chlposen & Si2158_ATV_INT_SENSE_PROP_CHLPOSEN_MASK) << Si2158_ATV_INT_SENSE_PROP_CHLPOSEN_LSB  |
+		       (atv_int_sense_pclposen & Si2158_ATV_INT_SENSE_PROP_PCLPOSEN_MASK) << Si2158_ATV_INT_SENSE_PROP_PCLPOSEN_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2158_ATV_INT_SENSE_PROP_CODE, si2158_atv_int_sense__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+		break;
+	case 77:
+		si2177_atv_int_sense__prop_data = (atv_int_sense_chlnegen  & Si2158_ATV_INT_SENSE_PROP_CHLNEGEN_MASK ) << Si2158_ATV_INT_SENSE_PROP_CHLNEGEN_LSB  |
+		       (atv_int_sense_pclnegen  & Si2158_ATV_INT_SENSE_PROP_PCLNEGEN_MASK ) << Si2158_ATV_INT_SENSE_PROP_PCLNEGEN_LSB  |
+		       (atv_int_sense_dlnegen   & Si2177_ATV_INT_SENSE_PROP_DLNEGEN_MASK  ) << Si2177_ATV_INT_SENSE_PROP_DLNEGEN_LSB  |
+		       (atv_int_sense_snrlnegen & Si2177_ATV_INT_SENSE_PROP_SNRLNEGEN_MASK) << Si2177_ATV_INT_SENSE_PROP_SNRLNEGEN_LSB  |
+		       (atv_int_sense_snrhnegen & Si2177_ATV_INT_SENSE_PROP_SNRHNEGEN_MASK) << Si2177_ATV_INT_SENSE_PROP_SNRHNEGEN_LSB  |
+		       (atv_int_sense_chlposen  & Si2158_ATV_INT_SENSE_PROP_CHLPOSEN_MASK ) << Si2158_ATV_INT_SENSE_PROP_CHLPOSEN_LSB  |
+		       (atv_int_sense_pclposen  & Si2158_ATV_INT_SENSE_PROP_PCLPOSEN_MASK ) << Si2158_ATV_INT_SENSE_PROP_PCLPOSEN_LSB  |
+		       (atv_int_sense_dlposen   & Si2177_ATV_INT_SENSE_PROP_DLPOSEN_MASK  ) << Si2177_ATV_INT_SENSE_PROP_DLPOSEN_LSB  |
+		       (atv_int_sense_snrlposen & Si2177_ATV_INT_SENSE_PROP_SNRLPOSEN_MASK) << Si2177_ATV_INT_SENSE_PROP_SNRLPOSEN_LSB  |
+		       (atv_int_sense_snrhposen & Si2177_ATV_INT_SENSE_PROP_SNRHPOSEN_MASK) << Si2177_ATV_INT_SENSE_PROP_SNRHPOSEN_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2158_ATV_INT_SENSE_PROP_CODE, si2177_atv_int_sense__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+		break;
+	default:
+		pr_warn("%s(): unsupported tuner model Si21%02u\n", __func__, ctx->part);
+		break;
+	}
+
+	si2158_atv_lif_freq__prop_data = (atv_lif_freq_offset & Si2158_ATV_LIF_FREQ_PROP_OFFSET_MASK) << Si2158_ATV_LIF_FREQ_PROP_OFFSET_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_ATV_LIF_FREQ_PROP_CODE, si2158_atv_lif_freq__prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_atv_lif_out__prop_data = (atv_lif_out_offset & Si2158_ATV_LIF_OUT_PROP_OFFSET_MASK) << Si2158_ATV_LIF_OUT_PROP_OFFSET_LSB  |
+		   (atv_lif_out_amp    & Si2158_ATV_LIF_OUT_PROP_AMP_MASK   ) << Si2158_ATV_LIF_OUT_PROP_AMP_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_ATV_LIF_OUT_PROP_CODE, si2158_atv_lif_out__prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_atv_pga_target__prop_data = (atv_pga_target_pga_target      & Si2158_ATV_PGA_TARGET_PROP_PGA_TARGET_MASK     ) << Si2158_ATV_PGA_TARGET_PROP_PGA_TARGET_LSB  |
+		   (atv_pga_target_override_enable & Si2158_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_MASK) << Si2158_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_ATV_PGA_TARGET_PROP_CODE, si2158_atv_pga_target__prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_atv_rf_top__prop_data = (atv_rf_top_atv_rf_top & Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_MASK) << Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_ATV_RF_TOP_PROP_CODE, si2158_atv_rf_top__prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_atv_rsq_rssi_threshold__prop_data = (atv_rsq_rssi_threshold_lo & Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK) << Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB  |
+		   (atv_rsq_rssi_threshold_hi & Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK) << Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_CODE, si2158_atv_rsq_rssi_threshold__prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	if (ctx->part == 77) {
+		si2177_atv_rsq_snr_threshold__prop_data = (atv_rsq_snr_threshold_lo & Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_MASK) << Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LSB  |
+			   (atv_rsq_snr_threshold_hi & Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_MASK) << Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_CODE, si2177_atv_rsq_snr_threshold__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+
+		si2177_atv_sif_out__prop_data = (atv_sif_out_offset & Si2177_ATV_SIF_OUT_PROP_OFFSET_MASK) << Si2177_ATV_SIF_OUT_PROP_OFFSET_LSB  |
+			   (atv_sif_out_amp    & Si2177_ATV_SIF_OUT_PROP_AMP_MASK   ) << Si2177_ATV_SIF_OUT_PROP_AMP_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2177_ATV_SIF_OUT_PROP_CODE, si2177_atv_sif_out__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+
+		si2177_atv_sound_agc_limit__prop_data = (atv_sound_agc_limit_max_gain & Si2177_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MASK) << Si2177_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_LSB  |
+			   (atv_sound_agc_limit_min_gain & Si2177_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MASK) << Si2177_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2177_ATV_SOUND_AGC_LIMIT_PROP_CODE, si2177_atv_sound_agc_limit__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+
+		si2177_atv_sound_agc_speed__prop_data = (atv_sound_agc_speed_system_l      & Si2177_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_MASK     ) << Si2177_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_LSB  |
+			   (atv_sound_agc_speed_other_systems & Si2177_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_MASK) << Si2177_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2177_ATV_SOUND_AGC_SPEED_PROP_CODE, si2177_atv_sound_agc_speed__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+
+		si2177_atv_video_equalizer__prop_data = (atv_video_equalizer_slope & Si2177_ATV_VIDEO_EQUALIZER_PROP_SLOPE_MASK) << Si2177_ATV_VIDEO_EQUALIZER_PROP_SLOPE_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2177_ATV_VIDEO_EQUALIZER_PROP_CODE, si2177_atv_video_equalizer__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+	}
+
+	switch (ctx->part) {
+	case 57:
+		si2158_atv_video_mode__prop_data = (atv_video_mode_video_sys       & Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_MASK      ) << Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LSB  |
+		       (atv_video_mode_color           & Si2158_ATV_VIDEO_MODE_PROP_COLOR_MASK          ) << Si2158_ATV_VIDEO_MODE_PROP_COLOR_LSB  |
+		       (atv_video_mode_invert_spectrum & Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_MASK) << Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2158_ATV_VIDEO_MODE_PROP_CODE, si2158_atv_video_mode__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+		break;
+	case 77:
+		si2177_atv_video_mode__prop_data = (atv_video_mode_video_sys       & Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_MASK    ) << Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LSB  |
+		       (atv_video_mode_color           & Si2158_ATV_VIDEO_MODE_PROP_COLOR_MASK        ) << Si2158_ATV_VIDEO_MODE_PROP_COLOR_LSB  |
+		       (atv_video_mode_invert_spectrum & Si2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_MASK) << Si2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2158_ATV_VIDEO_MODE_PROP_CODE, si2177_atv_video_mode__prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+		break;
+	default:
+		pr_warn("%s(): unsupported tuner model Si21%02u\n", __func__, ctx->part);
+		break;
+	}
+
+	si2158_atv_vsnr_cap__prop_data = (atv_vsnr_cap_atv_vsnr_cap & Si2158_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_MASK) << Si2158_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_ATV_VSNR_CAP_PROP_CODE, si2158_atv_vsnr_cap__prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+/*****************************************************************************************
+NAME: silabs_tercap_download_common_properties
+ DESCRIPTION: Setup Si2158 COMMON properties configuration
+ This function will download all the COMMON configuration properties.
+ The function SetupCOMMONDefaults() should be called before the first call to this function.
+ Parameter:  Pointer to Si2158 Context
+ Returns:    I2C transaction error code, NO_SILABS_TERCAB_ERROR if successful
+ Programming Guide Reference:    COMMON setup flowchart
+ ******************************************************************************************/
+static int silabs_tercap_download_common_properties(silabs_tercab_context *ctx)
+{
+	const u8 crystal_trim_xo_cap = Si2158_CRYSTAL_TRIM_PROP_XO_CAP_6P7PF ; /* (default '8') */
+	const u8 master_ien_atvien   = Si2158_MASTER_IEN_PROP_ATVIEN_OFF ; /* (default 'OFF') */
+	const u8 master_ien_ctsien   = Si2158_MASTER_IEN_PROP_CTSIEN_OFF ; /* (default 'OFF') */
+	const u8 master_ien_dtvien   = Si2158_MASTER_IEN_PROP_DTVIEN_OFF ; /* (default 'OFF') */
+	const u8 master_ien_errien   = Si2158_MASTER_IEN_PROP_ERRIEN_OFF ; /* (default 'OFF') */
+	const u8 master_ien_tunien   = Si2158_MASTER_IEN_PROP_TUNIEN_OFF ; /* (default 'OFF') */
+	const u8 xout_amp            = Si2158_XOUT_PROP_AMP_HIGH ; /* (default 'HIGH') */
+
+	u16 si2158_crystal_trim_prop_data;
+	u16 si2158_master_ien_prop_data;
+	u16 si2158_xout_prop_data;
+
+	SiTRACE("%s()\n", __func__);
+
+	si2158_crystal_trim_prop_data = (crystal_trim_xo_cap & Si2158_CRYSTAL_TRIM_PROP_XO_CAP_MASK) << Si2158_CRYSTAL_TRIM_PROP_XO_CAP_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_CRYSTAL_TRIM_PROP_CODE, si2158_crystal_trim_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_master_ien_prop_data = (master_ien_tunien & Si2158_MASTER_IEN_PROP_TUNIEN_MASK) << Si2158_MASTER_IEN_PROP_TUNIEN_LSB  |
+		   (master_ien_atvien & Si2158_MASTER_IEN_PROP_ATVIEN_MASK) << Si2158_MASTER_IEN_PROP_ATVIEN_LSB  |
+		   (master_ien_dtvien & Si2158_MASTER_IEN_PROP_DTVIEN_MASK) << Si2158_MASTER_IEN_PROP_DTVIEN_LSB  |
+		   (master_ien_errien & Si2158_MASTER_IEN_PROP_ERRIEN_MASK) << Si2158_MASTER_IEN_PROP_ERRIEN_LSB  |
+		   (master_ien_ctsien & Si2158_MASTER_IEN_PROP_CTSIEN_MASK) << Si2158_MASTER_IEN_PROP_CTSIEN_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_MASTER_IEN_PROP_CODE, si2158_master_ien_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_xout_prop_data = (xout_amp & Si2158_XOUT_PROP_AMP_MASK) << Si2158_XOUT_PROP_AMP_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_XOUT_PROP_CODE, si2158_xout_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+/*****************************************************************************************
+NAME: silabs_tercap_download_dtv_properties
+ DESCRIPTION: Setup Si2158 DTV properties configuration
+ This function will download all the DTV configuration properties.
+ The function SetupDTVDefaults() should be called before the first call to this function.
+ Parameter:  Pointer to Si2158 Context
+ Returns:    I2C transaction error code, NO_SILABS_TERCAB_ERROR if successful
+ Programming Guide Reference:    DTV setup flowchart
+ ******************************************************************************************/
+static int silabs_tercap_download_dtv_properties(silabs_tercab_context *ctx)
+{
+	const u8  dtv_agc_freeze_input_level          = Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LOW  ; /* (default 'LOW') */
+	const u8  dtv_agc_freeze_input_pin            = Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_NONE   ; /* (default 'NONE') */
+	const u8  dtv_agc_speed_agc_decim             = Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF     ; /* (default 'OFF') */
+	const u8  dtv_agc_speed_if_agc_speed          = Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO ; /* (default 'AUTO') */
+	const u8  dtv_config_if_port_dtv_agc_source   = Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_AGC2_3DB ; /* (default 'INTERNAL') */
+	const u8  dtv_config_if_port_dtv_out_type     = Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF2   ; /* (default 'LIF_IF2') */
+	const u8  dtv_ext_agc_max_10mv                =   200; /* (default   200) */
+	const u8  dtv_ext_agc_min_10mv                =    50; /* (default    50) */
+	const u8  dtv_filter_select_filter            = Si2158_DTV_FILTER_SELECT_PROP_FILTER_CUSTOM1 ; /* (default 'CUSTOM1') */
+	const u8  dtv_ien_chlien                      = Si2158_DTV_IEN_PROP_CHLIEN_ENABLE ; /* (default 'ENABLE') */
+	const u8  dtv_initial_agc_speed_agc_decim     = Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_OFF     ; /* (default 'OFF') */
+	const u8  dtv_initial_agc_speed_if_agc_speed  = Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO ; /* (default 'AUTO') */
+	const u16 dtv_initial_agc_speed_period        =     0; /* (default     0) */
+	const u8  dtv_internal_zif_atsc               = Si2158_DTV_INTERNAL_ZIF_PROP_ATSC_LIF   ; /* (default 'LIF') */
+	const u8  dtv_internal_zif_dtmb               = Si2158_DTV_INTERNAL_ZIF_PROP_DTMB_LIF   ; /* (default 'LIF') */
+	const u8  dtv_internal_zif_dvbc               = Si2158_DTV_INTERNAL_ZIF_PROP_DVBC_LIF   ; /* (default 'LIF') */
+	const u8  dtv_internal_zif_dvbt               = Si2158_DTV_INTERNAL_ZIF_PROP_DVBT_LIF   ; /* (default 'LIF') */
+	const u8  dtv_internal_zif_isdbc              = Si2158_DTV_INTERNAL_ZIF_PROP_ISDBC_LIF  ; /* (default 'LIF') */
+	const u8  dtv_internal_zif_isdbt              = Si2158_DTV_INTERNAL_ZIF_PROP_ISDBT_LIF  ; /* (default 'LIF') */
+	const u8  dtv_internal_zif_qam_us             = Si2158_DTV_INTERNAL_ZIF_PROP_QAM_US_LIF ; /* (default 'LIF') */
+	const u8  dtv_int_sense_chlnegen              = Si2158_DTV_INT_SENSE_PROP_CHLNEGEN_DISABLE ; /* (default 'DISABLE') */
+	const u8  dtv_int_sense_chlposen              = Si2158_DTV_INT_SENSE_PROP_CHLPOSEN_ENABLE  ; /* (default 'ENABLE') */
+	const u16 dtv_lif_freq_offset                 =  4000; /* (default  5000) */
+	const u8  dtv_lif_out_amp                     =    27; /* (default    27) */
+	const u8  dtv_lif_out_offset                  =   148; /* (default   148) */
+	const u8  dtv_mode_bw                         = Si2158_DTV_MODE_PROP_BW_BW_6MHZ              ; /* (default 'BW_8MHZ') */
+	const u8  dtv_mode_invert_spectrum            = Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_NORMAL  ; /* (default 'NORMAL') */
+	const u8  dtv_mode_modulation                 = Si2158_DTV_MODE_PROP_MODULATION_ATSC         ; /* (default 'DVBT') */
+	const s8  dtv_pga_limits_max                  =    -1; /* (default    -1) */
+	const s8  dtv_pga_limits_min                  =    -1; /* (default    -1) */
+	const u8  dtv_pga_target_override_enable      = Si2158_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DISABLE ; /* (default 'DISABLE') */
+	const s8  dtv_pga_target_pga_target           =     0; /* (default     0) */
+	const u8  dtv_rf_top_dtv_rf_top               = Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_AUTO ; /* (default 'AUTO') */
+	const s8  dtv_rsq_rssi_threshold_hi           =     0; /* (default     0) */
+	const s8  dtv_rsq_rssi_threshold_lo           =   -80; /* (default   -80) */
+	const u8  dtv_zif_dc_canceller_bw_bandwidth   = Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_DEFAULT ; /* (default 'DEFAULT') */
+
+	u16 si2158_dtv_agc_freeze_input_prop_data;
+	u16 si2158_dtv_agc_speed_prop_data;
+	u16 si2158_dtv_config_if_port_prop_data;
+	u16 si2158_dtv_ext_agc_prop_data;
+	u16 si2158_dtv_filter_select_prop_data;
+	u16 si2158_dtv_ien_prop_data;
+	u16 si2158_dtv_initial_agc_speed_prop_data;
+	u16 si2158_dtv_initial_agc_speed_period_prop_data;
+	u16 si2158_dtv_internal_zif_prop_data;
+	u16 si2158_dtv_int_sense_prop_data;
+	u16 si2158_dtv_lif_freq_prop_data;
+	u16 si2158_dtv_lif_out_prop_data;
+	u16 si2158_dtv_mode_prop_data;
+	u16 si2158_dtv_pga_limits_prop_data;
+	u16 si2158_dtv_pga_target_prop_data;
+	u16 si2158_dtv_rf_top_prop_data;
+	u16 si2158_dtv_rsq_rssi_threshold_prop_data;
+	u16 si2158_dtv_zif_dc_canceller_bw_prop_data;
+
+	SiTRACE("%s()\n", __func__);
+
+	si2158_dtv_agc_freeze_input_prop_data = (dtv_agc_freeze_input_level & Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_MASK) << Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LSB  |
+		   (dtv_agc_freeze_input_pin   & Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_MASK  ) << Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_DTV_AGC_FREEZE_INPUT_PROP_CODE, si2158_dtv_agc_freeze_input_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_dtv_agc_speed_prop_data = (dtv_agc_speed_if_agc_speed & Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB  |
+		   (dtv_agc_speed_agc_decim    & Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_MASK   ) << Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_DTV_AGC_SPEED_PROP_CODE, si2158_dtv_agc_speed_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_dtv_config_if_port_prop_data = (dtv_config_if_port_dtv_out_type   & Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_MASK  ) << Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LSB  |
+		   (dtv_config_if_port_dtv_agc_source & Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_MASK) << Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_DTV_CONFIG_IF_PORT_PROP_CODE, si2158_dtv_config_if_port_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_dtv_ext_agc_prop_data = (dtv_ext_agc_min_10mv & Si2158_DTV_EXT_AGC_PROP_MIN_10MV_MASK) << Si2158_DTV_EXT_AGC_PROP_MIN_10MV_LSB  |
+		   (dtv_ext_agc_max_10mv & Si2158_DTV_EXT_AGC_PROP_MAX_10MV_MASK) << Si2158_DTV_EXT_AGC_PROP_MAX_10MV_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_DTV_EXT_AGC_PROP_CODE, si2158_dtv_ext_agc_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	switch (ctx->part) {
+	case 58:
+		si2158_dtv_filter_select_prop_data = (dtv_filter_select_filter & Si2158_DTV_FILTER_SELECT_PROP_FILTER_MASK) << Si2158_DTV_FILTER_SELECT_PROP_FILTER_LSB ;
+		if (silabs_tercab_set_property(ctx, Si2158_DTV_FILTER_SELECT_PROP_CODE, si2158_dtv_filter_select_prop_data) != NO_SILABS_TERCAB_ERROR) {
+			return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+		}
+		break;
+	default:
+		break;
+	}
+
+	si2158_dtv_ien_prop_data = (dtv_ien_chlien & Si2158_DTV_IEN_PROP_CHLIEN_MASK) << Si2158_DTV_IEN_PROP_CHLIEN_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_DTV_IEN_PROP_CODE, si2158_dtv_ien_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_dtv_initial_agc_speed_prop_data = (dtv_initial_agc_speed_if_agc_speed & Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_LSB  |
+		   (dtv_initial_agc_speed_agc_decim    & Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_MASK   ) << Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_DTV_INITIAL_AGC_SPEED_PROP_CODE, si2158_dtv_initial_agc_speed_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_dtv_initial_agc_speed_period_prop_data = (dtv_initial_agc_speed_period & Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_MASK) << Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE, si2158_dtv_initial_agc_speed_period_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_dtv_internal_zif_prop_data = (dtv_internal_zif_atsc   & Si2158_DTV_INTERNAL_ZIF_PROP_ATSC_MASK  ) << Si2158_DTV_INTERNAL_ZIF_PROP_ATSC_LSB  |
+		   (dtv_internal_zif_qam_us & Si2158_DTV_INTERNAL_ZIF_PROP_QAM_US_MASK) << Si2158_DTV_INTERNAL_ZIF_PROP_QAM_US_LSB  |
+		   (dtv_internal_zif_dvbt   & Si2158_DTV_INTERNAL_ZIF_PROP_DVBT_MASK  ) << Si2158_DTV_INTERNAL_ZIF_PROP_DVBT_LSB  |
+		   (dtv_internal_zif_dvbc   & Si2158_DTV_INTERNAL_ZIF_PROP_DVBC_MASK  ) << Si2158_DTV_INTERNAL_ZIF_PROP_DVBC_LSB  |
+		   (dtv_internal_zif_isdbt  & Si2158_DTV_INTERNAL_ZIF_PROP_ISDBT_MASK ) << Si2158_DTV_INTERNAL_ZIF_PROP_ISDBT_LSB  |
+		   (dtv_internal_zif_isdbc  & Si2158_DTV_INTERNAL_ZIF_PROP_ISDBC_MASK ) << Si2158_DTV_INTERNAL_ZIF_PROP_ISDBC_LSB  |
+		   (dtv_internal_zif_dtmb   & Si2158_DTV_INTERNAL_ZIF_PROP_DTMB_MASK  ) << Si2158_DTV_INTERNAL_ZIF_PROP_DTMB_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_DTV_INTERNAL_ZIF_PROP_CODE, si2158_dtv_internal_zif_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_dtv_int_sense_prop_data = (dtv_int_sense_chlnegen & Si2158_DTV_INT_SENSE_PROP_CHLNEGEN_MASK) << Si2158_DTV_INT_SENSE_PROP_CHLNEGEN_LSB  |
+		   (dtv_int_sense_chlposen & Si2158_DTV_INT_SENSE_PROP_CHLPOSEN_MASK) << Si2158_DTV_INT_SENSE_PROP_CHLPOSEN_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_DTV_INT_SENSE_PROP_CODE, si2158_dtv_int_sense_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_dtv_lif_freq_prop_data = (dtv_lif_freq_offset & Si2158_DTV_LIF_FREQ_PROP_OFFSET_MASK) << Si2158_DTV_LIF_FREQ_PROP_OFFSET_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_DTV_LIF_FREQ_PROP_CODE, si2158_dtv_lif_freq_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_dtv_lif_out_prop_data = (dtv_lif_out_offset & Si2158_DTV_LIF_OUT_PROP_OFFSET_MASK) << Si2158_DTV_LIF_OUT_PROP_OFFSET_LSB  |
+		   (dtv_lif_out_amp    & Si2158_DTV_LIF_OUT_PROP_AMP_MASK   ) << Si2158_DTV_LIF_OUT_PROP_AMP_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_DTV_LIF_OUT_PROP_CODE, si2158_dtv_lif_out_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_dtv_mode_prop_data = (dtv_mode_bw              & Si2158_DTV_MODE_PROP_BW_MASK             ) << Si2158_DTV_MODE_PROP_BW_LSB  |
+		   (dtv_mode_modulation      & Si2158_DTV_MODE_PROP_MODULATION_MASK     ) << Si2158_DTV_MODE_PROP_MODULATION_LSB  |
+		   (dtv_mode_invert_spectrum & Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_MASK) << Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_DTV_MODE_PROP_CODE, si2158_dtv_mode_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_dtv_pga_limits_prop_data = (dtv_pga_limits_min & Si2158_DTV_PGA_LIMITS_PROP_MIN_MASK) << Si2158_DTV_PGA_LIMITS_PROP_MIN_LSB  |
+		   (dtv_pga_limits_max & Si2158_DTV_PGA_LIMITS_PROP_MAX_MASK) << Si2158_DTV_PGA_LIMITS_PROP_MAX_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_DTV_PGA_LIMITS_PROP_CODE, si2158_dtv_pga_limits_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_dtv_pga_target_prop_data = (dtv_pga_target_pga_target      & Si2158_DTV_PGA_TARGET_PROP_PGA_TARGET_MASK     ) << Si2158_DTV_PGA_TARGET_PROP_PGA_TARGET_LSB  |
+		   (dtv_pga_target_override_enable & Si2158_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_MASK) << Si2158_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_DTV_PGA_TARGET_PROP_CODE, si2158_dtv_pga_target_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_dtv_rf_top_prop_data = (dtv_rf_top_dtv_rf_top & Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_MASK) << Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_DTV_RF_TOP_PROP_CODE, si2158_dtv_rf_top_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_dtv_rsq_rssi_threshold_prop_data = (dtv_rsq_rssi_threshold_lo & Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK) << Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB  |
+		   (dtv_rsq_rssi_threshold_hi & Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK) << Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_CODE, si2158_dtv_rsq_rssi_threshold_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_dtv_zif_dc_canceller_bw_prop_data = (dtv_zif_dc_canceller_bw_bandwidth & Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_MASK) << Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_CODE, si2158_dtv_zif_dc_canceller_bw_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+/*****************************************************************************************
+NAME: silabs_tercap_download_tuner_properties
+ DESCRIPTION: Setup Si2158 TUNER properties configuration
+ This function will download all the TUNER configuration properties.
+ The function SetupTUNERDefaults() should be called before the first call to this function.
+ Parameter:  Pointer to Si2158 Context
+ Returns:    I2C transaction error code, NO_SILABS_TERCAB_ERROR if successful
+ Programming Guide Reference:    TUNER setup flowchart
+ ******************************************************************************************/
+static int silabs_tercap_download_tuner_properties(silabs_tercab_context *ctx)
+{
+	const s16 tuner_blocked_vco_vco_code = 0x8000; /* (default 0x8000) */
+	const u8  tuner_ien_rssihien         = Si2158_TUNER_IEN_PROP_RSSIHIEN_DISABLE;          /* (default 'DISABLE') */
+	const u8  tuner_ien_rssilien         = Si2158_TUNER_IEN_PROP_RSSILIEN_DISABLE;          /* (default 'DISABLE') */
+	const u8  tuner_ien_tcien            = Si2158_TUNER_IEN_PROP_TCIEN_ENABLE;              /* (default 'ENABLE') */
+	const u8  tuner_int_sense_tcnegen    = Si2158_TUNER_INT_SENSE_PROP_TCNEGEN_DISABLE;     /* (default 'DISABLE') */
+	const u8  tuner_int_sense_rssilnegen = Si2158_TUNER_INT_SENSE_PROP_RSSILNEGEN_DISABLE;  /* (default 'DISABLE') */
+	const u8  tuner_int_sense_rssihnegen = Si2158_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DISABLE;  /* (default 'DISABLE') */
+	const u8  tuner_int_sense_tcposen    = Si2158_TUNER_INT_SENSE_PROP_TCPOSEN_ENABLE;      /* (default 'ENABLE') */
+	const u8  tuner_int_sense_rssilposen = Si2158_TUNER_INT_SENSE_PROP_RSSILPOSEN_ENABLE;   /* (default 'ENABLE') */
+	const u8  tuner_int_sense_rssihposen = Si2158_TUNER_INT_SENSE_PROP_RSSIHPOSEN_ENABLE;   /* (default 'ENABLE') */
+	const u8  tuner_lo_injection_band_1  = Si2158_TUNER_LO_INJECTION_PROP_BAND_1_HIGH_SIDE; /* (default 'HIGH_SIDE') */
+	const u8  tuner_lo_injection_band_2  = Si2158_TUNER_LO_INJECTION_PROP_BAND_2_LOW_SIDE;  /* (default 'LOW_SIDE') */
+	const u8  tuner_lo_injection_band_3  = Si2158_TUNER_LO_INJECTION_PROP_BAND_3_LOW_SIDE;  /* (default 'LOW_SIDE') */
+	const u8  tuner_return_loss_config   = Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_127;        /* (default '127') */
+	const u8  tuner_return_loss_mode     = Si2158_TUNER_RETURN_LOSS_PROP_MODE_TERRESTRIAL;  /* (default 'TERRESTRIAL') */
+
+	u16 si2158_tuner_blocked_vco_prop_data;
+	u16 si2158_tuner_ien_prop_data;
+	u16 si2158_tuner_int_sense_prop_data;
+	u16 si2158_tuner_lo_injection_prop_data;
+	u16 si2158_tuner_return_loss_prop_data;
+
+	SiTRACE("%s()\n", __func__);
+
+	si2158_tuner_blocked_vco_prop_data = (tuner_blocked_vco_vco_code & Si2158_TUNER_BLOCKED_VCO_PROP_VCO_CODE_MASK) << Si2158_TUNER_BLOCKED_VCO_PROP_VCO_CODE_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_TUNER_BLOCKED_VCO_PROP_CODE, si2158_tuner_blocked_vco_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_tuner_ien_prop_data = (tuner_ien_tcien    & Si2158_TUNER_IEN_PROP_TCIEN_MASK   ) << Si2158_TUNER_IEN_PROP_TCIEN_LSB  |
+		   (tuner_ien_rssilien & Si2158_TUNER_IEN_PROP_RSSILIEN_MASK) << Si2158_TUNER_IEN_PROP_RSSILIEN_LSB  |
+		   (tuner_ien_rssihien & Si2158_TUNER_IEN_PROP_RSSIHIEN_MASK) << Si2158_TUNER_IEN_PROP_RSSIHIEN_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_TUNER_IEN_PROP_CODE, si2158_tuner_ien_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_tuner_int_sense_prop_data = (tuner_int_sense_tcnegen    & Si2158_TUNER_INT_SENSE_PROP_TCNEGEN_MASK   ) << Si2158_TUNER_INT_SENSE_PROP_TCNEGEN_LSB  |
+		   (tuner_int_sense_rssilnegen & Si2158_TUNER_INT_SENSE_PROP_RSSILNEGEN_MASK) << Si2158_TUNER_INT_SENSE_PROP_RSSILNEGEN_LSB  |
+		   (tuner_int_sense_rssihnegen & Si2158_TUNER_INT_SENSE_PROP_RSSIHNEGEN_MASK) << Si2158_TUNER_INT_SENSE_PROP_RSSIHNEGEN_LSB  |
+		   (tuner_int_sense_tcposen    & Si2158_TUNER_INT_SENSE_PROP_TCPOSEN_MASK   ) << Si2158_TUNER_INT_SENSE_PROP_TCPOSEN_LSB  |
+		   (tuner_int_sense_rssilposen & Si2158_TUNER_INT_SENSE_PROP_RSSILPOSEN_MASK) << Si2158_TUNER_INT_SENSE_PROP_RSSILPOSEN_LSB  |
+		   (tuner_int_sense_rssihposen & Si2158_TUNER_INT_SENSE_PROP_RSSIHPOSEN_MASK) << Si2158_TUNER_INT_SENSE_PROP_RSSIHPOSEN_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_TUNER_INT_SENSE_PROP_CODE, si2158_tuner_int_sense_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_tuner_lo_injection_prop_data = (tuner_lo_injection_band_1 & Si2158_TUNER_LO_INJECTION_PROP_BAND_1_MASK) << Si2158_TUNER_LO_INJECTION_PROP_BAND_1_LSB  |
+		   (tuner_lo_injection_band_2 & Si2158_TUNER_LO_INJECTION_PROP_BAND_2_MASK) << Si2158_TUNER_LO_INJECTION_PROP_BAND_2_LSB  |
+		   (tuner_lo_injection_band_3 & Si2158_TUNER_LO_INJECTION_PROP_BAND_3_MASK) << Si2158_TUNER_LO_INJECTION_PROP_BAND_3_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_TUNER_LO_INJECTION_PROP_CODE, si2158_tuner_lo_injection_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	si2158_tuner_return_loss_prop_data = (tuner_return_loss_config & Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_MASK) << Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_LSB  |
+		   (tuner_return_loss_mode   & Si2158_TUNER_RETURN_LOSS_PROP_MODE_MASK  ) << Si2158_TUNER_RETURN_LOSS_PROP_MODE_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_TUNER_RETURN_LOSS_PROP_CODE, si2158_tuner_return_loss_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+static int silabs_tercap_download_all_properties(silabs_tercab_context *ctx)
+{
+	struct silabs_tercab_priv *priv = NULL; /* for debug output only */
+	int err = NO_SILABS_TERCAB_ERROR;
+	int ret = silabs_tercab_download_atv_properties(ctx);
+	if (ret) {
+		err = ret;
+		silabs_tercab_err("ERROR: download all ATV properties failed=0x%x\n", err);
+	}
+	ret = silabs_tercap_download_common_properties(ctx);
+	if (ret) {
+		err = ret;
+		silabs_tercab_err("ERROR: download all COMMON properties failed=0x%x\n", err);
+	}
+	ret = silabs_tercap_download_dtv_properties(ctx);
+	if (ret) {
+		err = ret;
+		silabs_tercab_err("ERROR: download all DTV properties failed=0x%x\n", err);
+	}
+	ret = silabs_tercap_download_tuner_properties(ctx);
+	if (ret) {
+		err = ret;
+		silabs_tercab_err("ERROR: download all TUNER properties failed=0x%x\n", err);
+	}
+	return err;
+}
+
+/************************************************************************************************************************
+  NAME: silabs_tercab_configure
+  DESCRIPTION: Setup Si2158 video filters, GPIOs/clocks, Common Properties startup, etc.
+  Parameter:  Pointer to Si2158 Context
+  Returns:    I2C transaction error code, NO_SILABS_TERCAB_ERROR if successful
+ ************************************************************************************************************************/
+static int silabs_tercab_configure(silabs_tercab_context *ctx)
+{
+	/* Set All Properties startup configuration */
+	return silabs_tercap_download_all_properties(ctx);
+}
+
+/************************************************************************************************************************
+  NAME: silabs_tercab_init
+  DESCRIPTION:Reset and Initialize Si2158
+  Parameter:  Si2158 Context (I2C address)
+  Returns:    I2C transaction error code, NO_SILABS_TERCAB_ERROR if successful
+ ************************************************************************************************************************/
+static int silabs_tercab_init(struct silabs_tercab_priv *priv)
+{
+	silabs_tercab_context *ctx = &priv->tuner;
+	int return_code;
+	SiTRACE("silabs_tercab_init starting...\n");
+
+	/* PowerUp into bootloader */
+	return_code = silabs_tercab_power_up_with_patch(priv);
+	if (return_code != NO_SILABS_TERCAB_ERROR) {
+		SiTRACE ("silabs_tercab_power_up_with_patch error 0x%02x: %s\n", return_code, silabs_tercab_error_text(return_code) );
+		return return_code;
+	}
+	/* At this point, FW is loaded and started.  */
+	silabs_tercab_configure(ctx);
+	SiTRACE("silabs_tercab_init complete...\n");
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+/*---------------------------------------------------*/
+/* Si2158_CONFIG_CLOCKS COMMAND                    */
+/*---------------------------------------------------*/
+static u8 silabs_tercab_config_clocks(silabs_tercab_context *ctx,
+		u8   subcode,
+		u8   clock_mode,
+		u8   en_xout)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[3];
+	u8 rspByteBuffer[1];
+
+	SiTRACE("%s()\n", __func__);
+
+	cmdByteBuffer[0] = Si2158_CONFIG_CLOCKS_CMD;
+	cmdByteBuffer[1] = (u8) ( ( subcode    & Si2158_CONFIG_CLOCKS_CMD_SUBCODE_MASK    ) << Si2158_CONFIG_CLOCKS_CMD_SUBCODE_LSB   );
+	cmdByteBuffer[2] = (u8) ( ( clock_mode & Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_MASK ) << Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_LSB|
+			                  ( en_xout    & Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_MASK    ) << Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_LSB   );
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 3, cmdByteBuffer) != 3) {
+		SiTRACE("Error writing CONFIG_CLOCKS bytes!\n");
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	error_code = silabs_tercab_poll_response(ctx->i2c_adap, ctx->i2c_addr, 1, rspByteBuffer, &ctx->status);
+	if (error_code) {
+		SiTRACE("Error polling CONFIG_CLOCKS response\n");
+		return error_code;
+	}
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+/************************************************************************************************************************
+  NAME: silabs_tercab_xout_on
+  Parameter:  Pointer to Si2158 Context (I2C address)
+  Returns:    I2C transaction error code, NO_SILABS_TERCAB_ERROR if successful
+ ************************************************************************************************************************/
+static int silabs_tercab_xout_on(silabs_tercab_context *ctx)
+{
+	SiTRACE("Turning Xout ON\n");
+
+	return silabs_tercab_config_clocks(ctx,
+				Si2158_CONFIG_CLOCKS_CMD_SUBCODE_CODE,
+				Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_XTAL,
+				Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_EN_XOUT);
+}
+
+/************************************************************************************************************************
+  NAME: silabs_tercab_xout_off
+  Parameter:  Pointer to Si2158 Context (I2C address)
+  Returns:    I2C transaction error code, NO_SILABS_TERCAB_ERROR if successful
+ ************************************************************************************************************************/
+static int silabs_tercab_xout_off(silabs_tercab_context *ctx)
+{
+	SiTRACE("Turning Xout OFF\n");
+
+	return silabs_tercab_config_clocks(ctx,
+			Si2158_CONFIG_CLOCKS_CMD_SUBCODE_CODE,
+			Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_XTAL,
+			Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_DIS_XOUT);
+}
+
+static int silabs_tercab_initialize(struct dvb_frontend *fe)
+{
+	struct silabs_tercab_priv *priv = fe->tuner_priv;
+	int ter_clock_needed = 1;
+	int res = 0;
+	int ret = 0;
+	u16 data;
+
+	mutex_lock(&priv->lock);
+
+	/* Do a full init of the Ter Tuner only if it has not been already done */
+	if (priv->silabs_tercab_init_done==0) {
+		silabs_tercab_info("%s()\n", __func__);
+		SiTRACE("Init terrestrial tuner @ 0x%02X\n", priv->tuner.i2c_addr);
+		if ((res= silabs_tercab_init(priv)) != NO_SILABS_TERCAB_ERROR) {
+			silabs_tercab_err("silabs_tercab_init() failed.\n");
+			SiTRACE("Terrestrial tuner HW init error: 0x%02x : %s\n",res, silabs_tercab_error_text(res) );
+			ret = -ENODEV;
+			goto fail;
+		}
+		priv->tuner.part = priv->tuner.rsp.part_info.part;
+		priv->tuner.chiprev = priv->tuner.rsp.part_info.chiprev;
+		silabs_tercab_info("Silicon Labs tuner Si21%u rev. %u detected\n", priv->tuner.part, priv->tuner.chiprev);
+		if (priv->agc_control) {
+			data = (Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF1 & Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_MASK  ) << Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LSB  |
+				   (Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_INTERNAL & Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_MASK) << Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_LSB ;
+			silabs_tercab_set_property(&priv->tuner, Si2158_DTV_CONFIG_IF_PORT_PROP_CODE, data);
+		}
+		data = (priv->crystal_trim_xo_cap & Si2158_CRYSTAL_TRIM_PROP_XO_CAP_MASK) << Si2158_CRYSTAL_TRIM_PROP_XO_CAP_LSB;
+		if (silabs_tercab_set_property(&priv->tuner, Si2158_CRYSTAL_TRIM_PROP_CODE, data) != NO_SILABS_TERCAB_ERROR) {
+			ret = -EIO;
+			goto fail;
+		}
+	} else {
+		SiTRACE("Wakeup terrestrial tuner\n");
+		if ((res= silabs_tercab_poll_cts(priv->i2c_props.adap, priv->i2c_props.addr)) != NO_SILABS_TERCAB_ERROR) {
+			silabs_tercab_err("tuner Si2158 wake up failed.\n");
+			SiTRACE("Terrestrial tuner wake up error: 0x%02x : %s\n",res, silabs_tercab_error_text(res) );
+			ret = -ENODEV;
+			goto fail;
+		}
+	}
+
+	/* ------------------------------------------------------------ */
+	/* If the terrestrial tuner's clock is required, activate it    */
+	/* ------------------------------------------------------------ */
+	SiTRACE("ter_clock_needed %d\n",ter_clock_needed);
+	if (ter_clock_needed) {
+		SiTRACE("Turn terrestrial tuner clock on\n");
+		if (priv->clock_control != 0 /* Si2168B_CLOCK_ALWAYS_OFF */) {
+			SiTRACE("Terrestrial tuner CLOCK ON\n");
+			if ((res = silabs_tercab_xout_on(&priv->tuner) ) != 0) {
+				SiTRACE("Terrestrial tuner CLOCK ON error: 0x%02x : %s\n",res, silabs_tercab_error_text(res) );
+				ret = -ENODEV;
+				goto fail;
+			}
+		}
+	}
+
+fail:
+	mutex_unlock(&priv->lock);
+
+	if (ret==0) {
+		priv->silabs_tercab_init_done = 1;
+		silabs_tercab_dbg("initializing tuner succeeded\n");
+	} else {
+		priv->silabs_tercab_init_done = 0;
+	}
+
+	return ret;
+}
+
+#if 0
+/*---------------------------------------------------*/
+/* Si2158_STANDBY COMMAND                          */
+/*---------------------------------------------------*/
+static u8 silabs_tercab_standby(silabs_tercab_context *ctx,	u8 type)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[1];
+	ctx->rsp.standby.STATUS = ctx->status;
+
+	SiTRACE("%s()\n", __func__);
+
+	cmdByteBuffer[0] = Si2158_STANDBY_CMD;
+	cmdByteBuffer[1] = (u8) ( ( type & Si2158_STANDBY_CMD_TYPE_MASK ) << Si2158_STANDBY_CMD_TYPE_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing STANDBY bytes!\n");
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	error_code = Si2158_pollForResponse(ctx, 1, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling STANDBY response\n");
+		return error_code;
+	}
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+/*---------------------------------------------------*/
+/* Si2158_POWER_DOWN COMMAND                       */
+/*---------------------------------------------------*/
+static u8 silabs_tercab_power_down(silabs_tercab_context *ctx)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[1];
+	u8 rspByteBuffer[1];
+	ctx->rsp.power_down.STATUS = ctx->status;
+
+	SiTRACE("%s()\n", __func__);
+
+	cmdByteBuffer[0] = Si2158_POWER_DOWN_CMD;
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 1, cmdByteBuffer) != 1) {
+		SiTRACE("Error writing POWER_DOWN bytes!\n");
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	error_code = Si2158_pollForResponse(ctx, 1, rspByteBuffer);
+	if (error_code) {
+		SiTRACE("Error polling POWER_DOWN response\n");
+		return error_code;
+	}
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+#endif
+
+static int silabs_tercab_sleep(struct dvb_frontend *fe)
+{
+	struct silabs_tercab_priv *priv = fe->tuner_priv;
+	int res;
+	int ret = 0;
+
+	silabs_tercab_dbg("\n");
+
+	mutex_lock(&priv->lock);
+
+	if (priv->clock_control != 1 /* Si2168B_CLOCK_ALWAYS_ON */) {
+		SiTRACE("Terrestrial tuner clock OFF\n");
+		res = silabs_tercab_xout_off(&priv->tuner);
+		if (res) {
+			SiTRACE("Terrestrial tuner CLOCK OFF error: 0x%02x : %s\n",res, silabs_tercab_error_text(res) );
+			ret = -EPERM;
+		}
+	}
+#if 1
+#if 0
+#define  Si2158_STANDBY_CMD_TYPE_MIN 0
+	priv->silabs_tercab_init_done = 0;
+	priv->firmware_started = 0;
+	SiTRACE("Terrestrial tuner STANDBY\n");
+	if ((res= silabs_tercab_standby(&priv->tuner, Si2158_STANDBY_CMD_TYPE_MIN)) !=0 ) {
+		SiTRACE("Terrestrial tuner Standby error: 0x%02x : %s\n",res, silabs_tercab_error_text(res) );
+		ret = -EPERM;
+	};
+#else
+	silabs_tercab_info("Standby ignored\n");
+#endif
+#else
+	priv->silabs_tercab_init_done = 0;
+	priv->firmware_started = 0;
+	if (silabs_tercab_power_down(&priv->tuner) != NO_SILABS_TERCAB_ERROR) {
+		silabs_tercab_err("silabs_tercab_power_down() failed\n");
+		ret = -EPERM;
+	}
+#endif
+
+	mutex_unlock(&priv->lock);
+
+	return ret;
+}
+
+/************************************************************************************************************************
+  silabs_tercab_fef function
+  Use:        TER tuner FEF activation function
+              Used to enable/disable the FEF mode in the terrestrial tuner
+  Comments:   If the tuner is connected via the demodulator's I2C switch, enabling/disabling the i2c_passthru is required before/after tuning.
+  Parameter:  *front_end, the front-end handle
+  Parameter:  fef, a flag controlling the selection between FEF 'off'(0) and FEF 'on'(1)
+  Returns:    1
+ ************************************************************************************************************************/
+static int silabs_tercab_fef(struct dvb_frontend *fe, int fef)
+{
+	struct silabs_tercab_priv *priv = fe->tuner_priv;
+	u8  agc_freeze_input_pin;
+	u8  agc_speed_agc_decim;
+	u8  agc_speed_if_agc_speed;
+	u16 si2158_dtv_agc_freeze_input__prop_data;
+	u16 si2158_dtv_agc_speed__prop_data;
+
+	SiTRACE("%s(): FEF MODE=%d FEF=%d\n", __func__, priv->fef_mode, fef);
+
+	if (priv->fef_mode == Si2177_FEF_MODE_FREEZE_PIN) {
+		SiTRACE("FEF mode Si2177_FEF_MODE_FREEZE_PIN\n");
+		if (fef == 0) {
+			agc_freeze_input_pin = Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_NONE;
+		} else {
+			agc_freeze_input_pin = Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_GPIO1;
+		}
+		si2158_dtv_agc_freeze_input__prop_data = (Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_HIGH & Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_MASK) << Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LSB  |
+			   (agc_freeze_input_pin   & Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_MASK  ) << Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_LSB ;
+		silabs_tercab_set_property(&priv->tuner,  Si2158_DTV_AGC_FREEZE_INPUT_PROP_CODE, si2158_dtv_agc_freeze_input__prop_data);
+	}
+
+#ifdef L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP
+	if (priv->fef_mode == Si2177_FEF_MODE_SLOW_INITIAL_AGC) {
+		SiTRACE("FEF mode Si2168B_FEF_MODE_SLOW_INITIAL_AGC (AGC slowed down after tuning)\n");
+	}
+#endif /* L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP */
+
+#ifdef L1_RF_TER_TUNER_FEF_MODE_SLOW_NORMAL_AGC_SETUP
+	if (priv->fef_mode == Si2177_FEF_MODE_SLOW_NORMAL_AGC) {
+		SiTRACE("FEF mode Si2168B_FEF_MODE_SLOW_NORMAL_AGC: AGC slowed down\n");
+		if (fef == 0) {
+			agc_speed_agc_decim    = Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF;
+			agc_speed_if_agc_speed = Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;
+		} else {
+			agc_speed_if_agc_speed = Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_39;
+			agc_speed_agc_decim    = Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_4;
+		}
+		si2158_dtv_agc_speed__prop_data = (agc_speed_if_agc_speed & Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB  |
+			   (agc_speed_agc_decim    & Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_MASK   ) << Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_LSB ;
+		silabs_tercab_set_property(&priv->tuner, Si2158_DTV_AGC_SPEED_PROP_CODE, si2158_dtv_agc_speed__prop_data);
+	}
+#endif /* L1_RF_TER_TUNER_FEF_MODE_SLOW_NORMAL_AGC_SETUP */
+	SiTRACE("silabs_tercab_fef done\n");
+	return 1;
+}
+
+/************************************************************************************************************************
+  silabs_tercab_fef_setup function
+  Use:        TER tuner LPF setting function
+              Used to configure the FEF mode in the terrestrial tuner
+  Comments:   If the tuner is connected via the demodulator's I2C switch, enabling/disabling the i2c_passthru is required before/after tuning.
+  Behavior:   This function closes the Si2168B's I2C switch then sets the TER FEF mode and finally reopens the I2C switch
+  Parameter:  *front_end, the front-end handle
+  Parameter:  fef, a flag controlling the selection between FEF 'off'(0) and FEF 'on'(1)
+  Returns:    1
+ ************************************************************************************************************************/
+static int silabs_tercab_fef_setup(struct dvb_frontend *fe, int fef)
+{
+	struct silabs_tercab_priv *priv = fe->tuner_priv;
+	u8  initial_agc_speed_agc_decim;
+	u8  initial_agc_speed_if_agc_speed;
+	u16 initial_agc_speed_period;
+	u8  agc_speed_agc_decim;
+	u8  agc_speed_if_agc_speed;
+	u16 initial_agc_speed_period_prop;
+	u16 agc_speed_prop;
+
+	SiTRACE("%s(): FEF=%d\n", __func__, fef);
+
+#ifdef L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN_SETUP
+	if (priv->fef_mode == Si2177_FEF_MODE_FREEZE_PIN) {
+		SiTRACE("FEF mode Si2168B_FEF_MODE_FREEZE_PIN\n");
+		initial_agc_speed_agc_decim    = Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_OFF;
+		initial_agc_speed_if_agc_speed = Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;
+		initial_agc_speed_period       = 0;
+		agc_speed_agc_decim            = Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF;
+		agc_speed_if_agc_speed         = Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;
+		//Si2158_L1_SendCommand2(&priv->tuner, Si2158_CONFIG_PINS_CMD_CODE);
+		silabs_tercab_config_pins (&priv->tuner,
+				Si2158_CONFIG_PINS_CMD_GPIO1_MODE_DISABLE,
+				Si2158_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ,
+				Si2158_CONFIG_PINS_CMD_GPIO2_MODE_DISABLE,
+				Si2158_CONFIG_PINS_CMD_GPIO2_READ_DO_NOT_READ,
+				Si2158_CONFIG_PINS_CMD_RESERVED1_RESERVED,
+				Si2158_CONFIG_PINS_CMD_RESERVED2_RESERVED,
+				Si2158_CONFIG_PINS_CMD_RESERVED3_RESERVED);
+
+		initial_agc_speed_period_prop = (initial_agc_speed_period & Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_MASK) << Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_LSB ;
+		silabs_tercab_set_property(&priv->tuner, Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE, initial_agc_speed_period_prop);
+
+		agc_speed_prop = (agc_speed_if_agc_speed & Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB  |
+			   (agc_speed_agc_decim & Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_MASK) << Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_LSB ;
+		silabs_tercab_set_property(&priv->tuner, Si2158_DTV_AGC_SPEED_PROP_CODE, agc_speed_prop);
+	}
+#endif /* L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN_SETUP */
+
+#ifdef L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP
+	if (priv->fef_mode == Si2177_FEF_MODE_SLOW_INITIAL_AGC) {
+		SiTRACE("FEF mode Si2168B_FEF_MODE_SLOW_INITIAL_AGC (AGC slowed down after tuning)\n");
+		if (fef == 0) {
+			initial_agc_speed_agc_decim    = Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_OFF;
+		    initial_agc_speed_if_agc_speed = Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;
+		    initial_agc_speed_period       = 0;
+		    agc_speed_agc_decim            = Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF;
+		    agc_speed_if_agc_speed         = Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;
+		} else {
+			initial_agc_speed_agc_decim    = Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_OFF;
+			initial_agc_speed_if_agc_speed = Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;
+			initial_agc_speed_period       = 240;
+			agc_speed_agc_decim            = Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_4;
+			agc_speed_if_agc_speed         = Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_39;
+		}
+		initial_agc_speed_period_prop = (initial_agc_speed_period & Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_MASK) << Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_LSB ;
+		silabs_tercab_set_property(&priv->tuner, Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE, initial_agc_speed_period_prop);
+
+		agc_speed_prop = (agc_speed_if_agc_speed & Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB  |
+			   (agc_speed_agc_decim    & Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_MASK   ) << Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_LSB ;
+		silabs_tercab_set_property(&priv->tuner, Si2158_DTV_AGC_SPEED_PROP_CODE, agc_speed_prop);
+	}
+#endif /* L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP */
+
+#ifdef L1_RF_TER_TUNER_FEF_MODE_SLOW_NORMAL_AGC_SETUP
+	if (priv->fef_mode == Si2177_FEF_MODE_SLOW_NORMAL_AGC ) {
+		SiTRACE("FEF mode Si2168B_FEF_MODE_SLOW_NORMAL_AGC: AGC slowed down\n");
+		initial_agc_speed_period = 0;
+		if (fef == 0) {
+			agc_speed_agc_decim    = Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF;
+			agc_speed_if_agc_speed = Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;
+		} else {
+			agc_speed_if_agc_speed = Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_39;
+			agc_speed_agc_decim    = Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_4;
+		}
+		initial_agc_speed_period_prop = (initial_agc_speed_period & Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_MASK) << Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_LSB ;
+		silabs_tercab_set_property(&priv->tuner, Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE, initial_agc_speed_period_prop);
+
+		agc_speed_prop = (agc_speed_if_agc_speed & Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB  |
+			   (agc_speed_agc_decim & Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_MASK) << Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_LSB ;
+		silabs_tercab_set_property(&priv->tuner, Si2158_DTV_AGC_SPEED_PROP_CODE, agc_speed_prop);
+	}
+#endif /* L1_RF_TER_TUNER_FEF_MODE_SLOW_NORMAL_AGC */
+
+	silabs_tercab_fef(fe, fef);
+
+	SiTRACE("%s done\n", __func__);
+	return 1;
+}
+
+/*---------------------------------------------------*/
+/* Si2158_TUNER_TUNE_FREQ COMMAND                  */
+/*---------------------------------------------------*/
+static u8 silabs_tercab_tune_freq(silabs_tercab_context *ctx, u8  mode, u32 freq)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[8];
+	u8 rspByteBuffer[1];
+
+	SiTRACE("%s()\n", __func__);
+
+	cmdByteBuffer[0] = Si2158_TUNER_TUNE_FREQ_CMD;
+	cmdByteBuffer[1] = (u8) ( ( mode & Si2158_TUNER_TUNE_FREQ_CMD_MODE_MASK ) << Si2158_TUNER_TUNE_FREQ_CMD_MODE_LSB);
+	cmdByteBuffer[2] = (u8) 0x00;
+	cmdByteBuffer[3] = (u8) 0x00;
+	cmdByteBuffer[4] = (u8) ( ( freq & Si2158_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << Si2158_TUNER_TUNE_FREQ_CMD_FREQ_LSB);
+	cmdByteBuffer[5] = (u8) ((( freq & Si2158_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << Si2158_TUNER_TUNE_FREQ_CMD_FREQ_LSB) >> 8);
+	cmdByteBuffer[6] = (u8) ((( freq & Si2158_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << Si2158_TUNER_TUNE_FREQ_CMD_FREQ_LSB) >> 16);
+	cmdByteBuffer[7] = (u8) ((( freq & Si2158_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << Si2158_TUNER_TUNE_FREQ_CMD_FREQ_LSB) >> 24);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 8, cmdByteBuffer) != 8) {
+		SiTRACE("Error writing TUNER_TUNE_FREQ bytes!\n");
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	error_code = silabs_tercab_poll_response(ctx->i2c_adap, ctx->i2c_addr, 1, rspByteBuffer, &ctx->status);
+	if (error_code) {
+		SiTRACE("Error polling TUNER_TUNE_FREQ response\n");
+		return error_code;
+	}
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+/************************************************************************************************************************
+ NAME: Si2158_Tune
+ DESCRIPTIION: Tune Si2158 in specified mode (ATV/DTV) at center frequency, wait for TUNINT and xTVINT with timeout
+
+ Parameter:  Pointer to Si2158 Context (I2C address)
+ Parameter:  Mode (ATV or DTV) use Si2158_TUNER_TUNE_FREQ_CMD_MODE_ATV or Si2158_TUNER_TUNE_FREQ_CMD_MODE_DTV constants
+ Parameter:  frequency (Hz) as a u32 integer
+ Returns:    0 if channel found.  A nonzero value means either an error occurred or channel not locked.
+ Programming Guide Reference:    Flowchart A.7 (Tune flowchart)
+ ************************************************************************************************************************/
+static int silabs_tercab_tune(silabs_tercab_context *ctx, u8 mode, u32 freq)
+{
+	unsigned int start_time  = 0;
+	int return_code = 0;
+	unsigned int timeout = 40;//FGR allow for PC clock granularity
+
+	if (silabs_tercab_tune_freq(ctx, mode, freq) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	start_time = jiffies_to_msecs(jiffies);
+
+	/* wait for TUNINT, timeout is 36ms */
+	while ( (jiffies_to_msecs(jiffies) - start_time) < timeout )
+	{
+		if ((return_code = silabs_tercab_check_status(ctx)) != NO_SILABS_TERCAB_ERROR)
+			return return_code;
+		if (ctx->status.tunint)
+			break;
+        msleep(5);
+	}
+	if (!ctx->status.tunint) {
+		SiTRACE("Timeout waiting for TUNINT\n");
+		return ERROR_SILABS_TERCAB_TUNINT_TIMEOUT;
+	}
+
+	/* wait for xTVINT, timeout is 150ms for ATVINT and 10 ms for DTVINT */
+	start_time = jiffies_to_msecs(jiffies);
+	timeout    = ((mode==Si2158_TUNER_TUNE_FREQ_CMD_MODE_ATV) ? 300 : 100);//FGR allow for PC clock granularity
+	while ( (jiffies_to_msecs(jiffies) - start_time) < timeout )
+	{
+		if ((return_code = silabs_tercab_check_status(ctx)) != NO_SILABS_TERCAB_ERROR)
+			return return_code;
+		if (mode == Si2158_TUNER_TUNE_FREQ_CMD_MODE_ATV) {
+			if (ctx->status.atvint)
+				break;
+		} else {
+			if (ctx->status.dtvint)
+				break;
+		}
+        msleep(5);
+	}
+
+	if (mode == Si2158_TUNER_TUNE_FREQ_CMD_MODE_ATV) {
+		if (ctx->status.atvint) {
+			SiTRACE("ATV Tune Successful\n");
+			return NO_SILABS_TERCAB_ERROR;
+		} else {
+			SiTRACE("Timeout waiting for ATVINT\n");
+		}
+	} else {
+		if (ctx->status.dtvint) {
+			SiTRACE("DTV Tune Successful\n");
+			return NO_SILABS_TERCAB_ERROR;
+		} else {
+			SiTRACE("Timeout waiting for DTVINT\n");
+		}
+	}
+
+	return ERROR_SILABS_TERCAB_xTVINT_TIMEOUT;
+}
+
+/************************************************************************************************************************
+ NAME: silabs_tercab_dtv_tune
+ DESCRIPTION: Update DTV_MODE and tune DTV mode at center frequency
+ Parameter:  Pointer to Si2158 Context (I2C address)
+ Parameter:  frequency (Hz)
+ Parameter:  bandwidth , 6,7 or 8 MHz
+ Parameter:  modulation,  e.g. use constant Si2158_DTV_MODE_PROP_MODULATION_DVBT for DVBT mode
+ Parameter:  rsp - commandResp structure to returns tune status info.
+ Returns:    I2C transaction error code, 0 if successful
+ Programming Guide Reference:    Flowchart A.7 (Tune flowchart)
+ ************************************************************************************************************************/
+static int silabs_tercab_dtv_tune(silabs_tercab_context *ctx, u32 freq, u8 bw, u8 modulation, u8 invert_spectrum)
+{
+	u16 data;
+
+	/* update DTV_MODE_PROP property */
+	data = (bw              & Si2158_DTV_MODE_PROP_BW_MASK             ) << Si2158_DTV_MODE_PROP_BW_LSB  |
+		   (modulation      & Si2158_DTV_MODE_PROP_MODULATION_MASK     ) << Si2158_DTV_MODE_PROP_MODULATION_LSB  |
+		   (invert_spectrum & Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_MASK) << Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_LSB ;
+	if (silabs_tercab_set_property(ctx, Si2158_DTV_MODE_PROP_CODE, data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	return silabs_tercab_tune(ctx, Si2158_TUNER_TUNE_FREQ_CMD_MODE_DTV, freq);
+}
+
+/* ------------------------------------------------------------------ */
+#if 0
+/*---------------------------------------------------*/
+/* Si2177_GET_PROPERTY COMMAND                     */
+/*---------------------------------------------------*/
+static u8 silabs_tercab_get_property(silabs_tercab_context *ctx, u16 prop, u16 *data)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[4];
+	u8 rspByteBuffer[4];
+	u8 reserved = 0;
+
+	SiTRACE("Si2177 GET_PROPERTY\n");
+
+	cmdByteBuffer[0] = Si2158_GET_PROPERTY_CMD;
+	cmdByteBuffer[1] = (u8) ( ( reserved & Si2158_GET_PROPERTY_CMD_RESERVED_MASK ) << Si2158_GET_PROPERTY_CMD_RESERVED_LSB);
+	cmdByteBuffer[2] = (u8) ( ( prop     & Si2158_GET_PROPERTY_CMD_PROP_MASK     ) << Si2158_GET_PROPERTY_CMD_PROP_LSB    );
+	cmdByteBuffer[3] = (u8) ((( prop     & Si2158_GET_PROPERTY_CMD_PROP_MASK     ) << Si2158_GET_PROPERTY_CMD_PROP_LSB    )>>8);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 4, cmdByteBuffer) != 4) {
+		SiTRACE("Error writing GET_PROPERTY bytes!\n");
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	error_code = silabs_tercab_poll_response(ctx->i2c_adap, ctx->i2c_addr, 4, rspByteBuffer, &ctx->status);
+	if (error_code) {
+		SiTRACE("Error polling SET_PROPERTY response\n");
+		return error_code;
+	}
+
+	reserved =   (( ( (rspByteBuffer[1]  )) >> Si2158_GET_PROPERTY_RESPONSE_RESERVED_LSB ) & Si2158_GET_PROPERTY_RESPONSE_RESERVED_MASK );
+	*data    =   (( ( (rspByteBuffer[2]  ) | (rspByteBuffer[3]  << 8 )) >> Si2158_GET_PROPERTY_RESPONSE_DATA_LSB     ) & Si2158_GET_PROPERTY_RESPONSE_DATA_MASK     );
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+#endif
+
+static int silabs_tercab_set_params(struct dvb_frontend *fe)
+{
+	struct silabs_tercab_priv *priv = fe->tuner_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u32 freq          = c->frequency;
+	u8 bw             = c->bandwidth_hz/1000000;
+	u8 modulation     = Si2158_DTV_MODE_PROP_MODULATION_DEFAULT;
+	u8 invert_signal  = Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_DEFAULT;
+	u16 if_freq       = Si2158_DTV_LIF_FREQ_PROP_OFFSET_DEFAULT;
+	u8 lif_out_offset = 148; /* (default   148) */
+	u8 lif_out_amp    = Si2158_DTV_LIF_OUT_PROP_AMP_DEFAULT;
+	int res, ret=0;
+	u16 data;
+
+	silabs_tercab_dbg("delivery system=%u\n", (u32)c->delivery_system);
+	silabs_tercab_dbg("frequency=%u\n", c->frequency);
+	silabs_tercab_dbg("modulation=%u\n", (u32)c->modulation);
+	silabs_tercab_dbg("inversion=%u\n", (u32)c->inversion);
+	silabs_tercab_dbg("bandwidth=%u (%u MHz)\n", c->bandwidth_hz, bw);
+
+	priv->mode = SILABS_TERCAB_DIGITAL;
+
+	switch(c->inversion) {
+	case INVERSION_OFF:  invert_signal = Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_NORMAL;   break;
+	case INVERSION_ON:   invert_signal = Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_INVERTED; break;
+	case INVERSION_AUTO:
+		silabs_tercab_dbg("inversion AUTO not supported!\n");
+		/* return -EINVAL; */
+		/* fall through */
+	default:
+		break;
+	}
+
+	switch (c->delivery_system) {
+	case SYS_ATSC:
+		invert_signal = Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_INVERTED;
+		modulation = Si2158_DTV_MODE_PROP_MODULATION_ATSC;
+		if_freq = priv->vsb_if_khz;
+		bw = 6; /* always use 6 MHz bandwidth */
+		break;
+	case SYS_ISDBT:
+	case SYS_DVBT:
+	case SYS_DVBT2:
+		modulation = Si2158_DTV_MODE_PROP_MODULATION_DVBT;
+		lif_out_amp = 32;
+		break;
+	case SYS_DVBC_ANNEX_B:
+		invert_signal = Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_NORMAL;
+		modulation = Si2158_DTV_MODE_PROP_MODULATION_QAM_US;
+		if_freq = priv->qam_if_khz;
+		bw = 6; /* always use 6 MHz bandwidth */
+		break;
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_C:
+		modulation = Si2158_DTV_MODE_PROP_MODULATION_DVBC;
+		lif_out_amp = 43;
+		//invert_signal = Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_INVERTED;
+		bw = 8; /* always use 8 MHz bandwidth */
+		break;
+	default:
+		silabs_tercab_warn("modulation type not supported!\n");
+		return -EINVAL;
+	}
+
+	/* When tuning digital, the analog demod must be tri-stated */
+	if (fe->ops.analog_ops.standby)
+		fe->ops.analog_ops.standby(fe);
+
+	mutex_lock(&priv->lock);
+
+	SiTRACE("Wakeup terrestrial tuner\n");
+	res= silabs_tercab_poll_cts(priv->i2c_props.adap, priv->i2c_props.addr);
+	if (res != NO_SILABS_TERCAB_ERROR) {
+		silabs_tercab_err("tuner Si2177 wake up failed.\n");
+		SiTRACE("Terrestrial tuner wake up error: 0x%02x : %s\n",res, silabs_tercab_error_text(res) );
+		ret = -EIO;
+		goto fail;
+	}
+
+	switch (priv->tuner.part) {
+	case 57:
+		if (!priv->firmware_started) {
+			if (silabs_tercab_power_up_with_patch(priv) == NO_SILABS_TERCAB_ERROR) {
+				priv->firmware_started = 1;
+			} else {
+				silabs_tercab_err("%s(): ERROR: Si2177_PowerUpWithPatch() failed\n", __func__);
+			}
+		}
+		break;
+	case 77:
+	default:
+		break;
+	}
+
+	/* ------------------------------------------------------------ */
+	/* Manage FEF mode in TER tuner                                 */
+	/* ------------------------------------------------------------ */
+	if (c->delivery_system == SYS_DVBT2) {
+		silabs_tercab_fef_setup(fe, 1);
+	} else {
+		silabs_tercab_fef_setup(fe, 0);
+	}
+
+	data = (lif_out_offset & Si2158_DTV_LIF_OUT_PROP_OFFSET_MASK) << Si2158_DTV_LIF_OUT_PROP_OFFSET_LSB  |
+		   (lif_out_amp    & Si2158_DTV_LIF_OUT_PROP_AMP_MASK   ) << Si2158_DTV_LIF_OUT_PROP_AMP_LSB ;
+	silabs_tercab_set_property(&priv->tuner, Si2158_DTV_LIF_OUT_PROP_CODE, data);
+
+	//Set IF Center freq
+	data = (if_freq & Si2158_DTV_LIF_FREQ_PROP_OFFSET_MASK) << Si2158_DTV_LIF_FREQ_PROP_OFFSET_LSB ;
+	silabs_tercab_set_property(&priv->tuner, Si2158_DTV_LIF_FREQ_PROP_CODE, data);
+
+	silabs_tercab_dbg("silabs_tercab_dtv_tune( , %u, %u, %u, %u) (IF=%u kHz)\n", freq, bw, modulation, invert_signal, if_freq);
+	res = silabs_tercab_dtv_tune(&priv->tuner, freq, bw, modulation, invert_signal);
+	msleep(85);
+	if (c->delivery_system == SYS_DVBT2) {
+		silabs_tercab_fef(fe, 1);
+	}
+
+	if (res != NO_SILABS_TERCAB_ERROR) {
+		silabs_tercab_err("silabs_tercab_dtv_tune() failed.\n");
+		SiTRACE("silabs_tercab_dtv_tune() failed. Error: 0x%02x : %s\n", res, silabs_tercab_error_text(res));
+		ret = -EIO;
+		goto fail;
+	}
+
+	priv->frequency    = freq;
+	priv->if_frequency = 1000 * if_freq;
+	priv->bandwidth    = 1000000 * bw;
+
+fail:
+	mutex_unlock(&priv->lock);
+	return ret;
+}
+
+/************************************************************************************************************************
+ NAME: silabs_tercab_atv_tune
+ DESCRIPTION:Update ATV_VIDEO_MODE and tune ATV mode at center frequency
+ Parameter:  Pointer to Si2158 Context (I2C address)
+ Parameter:  frequency (Hz)
+ Parameter:  Video system , e.g. use constant Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_M for system M
+ Parameter:  transport,  e.g. use constant Si2158_ATV_VIDEO_MODE_PROP_TRANS_TERRESTRIAL for terrestrial
+ Parameter:  color , e.g. use constant Si2158_ATV_VIDEO_MODE_PROP_COLOR_PAL_NTSC for PAL or NTSC
+ Parameter:  invert_signal, 0= normal, 1= inverted
+ Parameter:  rsp - commandResp structure to returns tune status info.
+ Returns:    I2C transaction error code, 0 if successful
+ Programming Guide Reference:    Flowchart A.7 (Tune flowchart)
+ ************************************************************************************************************************/
+static int silabs_tercab_atv_tune(silabs_tercab_context *ctx, u32 freq, u8 video_sys, u8 color, u8 invert_spectrum)
+{
+	Si2158_ATV_VIDEO_MODE_PROP_struct atv_video_mode;
+	u16 data;
+
+	/* update ATV_VIDEO_MODE property */
+	atv_video_mode.video_sys       = video_sys;
+	atv_video_mode.color           = color;
+	atv_video_mode.invert_spectrum = invert_spectrum;
+	switch (ctx->part) {
+	case 57:
+		data = (atv_video_mode.video_sys       & Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_MASK      ) << Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LSB  |
+		       (atv_video_mode.color           & Si2158_ATV_VIDEO_MODE_PROP_COLOR_MASK          ) << Si2158_ATV_VIDEO_MODE_PROP_COLOR_LSB  |
+		       (atv_video_mode.invert_spectrum & Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_MASK) << Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_LSB;
+		break;
+	case 77:
+		data = (atv_video_mode.video_sys       & Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_MASK    ) << Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LSB  |
+		       (atv_video_mode.color           & Si2158_ATV_VIDEO_MODE_PROP_COLOR_MASK        ) << Si2158_ATV_VIDEO_MODE_PROP_COLOR_LSB  |
+		       (atv_video_mode.invert_spectrum & Si2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_MASK) << Si2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_LSB;
+		break;
+	default:
+		pr_warn("%s(): unsupported tuner model Si21%02u\n", __func__, ctx->part);
+		return ERROR_SILABS_TERCAB_INCOMPATIBLE_PART;
+	}
+	if (silabs_tercab_set_property(ctx, Si2158_ATV_VIDEO_MODE_PROP_CODE, data) != NO_SILABS_TERCAB_ERROR) {
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	return silabs_tercab_tune(ctx, Si2158_TUNER_TUNE_FREQ_CMD_MODE_ATV, freq);
+}
+
+/*---------------------------------------------------*/
+/* Si2158_ATV_STATUS COMMAND                       */
+/*---------------------------------------------------*/
+static u8 silabs_tercab_atv_status(struct silabs_tercab_priv *priv, u8 intack)
+{
+	silabs_tercab_context *ctx = &priv->tuner;
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[12]; /* Si2177 */
+
+	ctx->rsp.atv_status.STATUS = &ctx->status;
+
+	SiTRACE("%s()\n", __func__);
+
+	cmdByteBuffer[0] = Si2158_ATV_STATUS_CMD;
+	cmdByteBuffer[1] = (u8) ( ( intack & Si2158_ATV_STATUS_CMD_INTACK_MASK ) << Si2158_ATV_STATUS_CMD_INTACK_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing ATV_STATUS bytes!\n");
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	error_code = silabs_tercab_poll_response(ctx->i2c_adap, ctx->i2c_addr, sizeof(rspByteBuffer), rspByteBuffer, &ctx->status);
+	if (error_code) {
+		SiTRACE("Error polling ATV_STATUS response\n");
+		return error_code;
+	}
+
+	ctx->rsp.atv_status.chlint    = (rspByteBuffer[1] >> Si2158_ATV_STATUS_RESPONSE_CHLINT_LSB)    & Si2158_ATV_STATUS_RESPONSE_CHLINT_MASK;
+	ctx->rsp.atv_status.pclint    = (rspByteBuffer[1] >> Si2158_ATV_STATUS_RESPONSE_PCLINT_LSB)    & Si2158_ATV_STATUS_RESPONSE_PCLINT_MASK;
+	ctx->rsp.atv_status.chl       = (rspByteBuffer[2] >> Si2158_ATV_STATUS_RESPONSE_CHL_LSB)       & Si2158_ATV_STATUS_RESPONSE_CHL_MASK;
+	ctx->rsp.atv_status.pcl       = (rspByteBuffer[2] >> Si2158_ATV_STATUS_RESPONSE_PCL_LSB)       & Si2158_ATV_STATUS_RESPONSE_PCL_MASK;
+	ctx->rsp.atv_status.afc_freq  = (((((rspByteBuffer[4] | (rspByteBuffer[5] << 8)) >> Si2158_ATV_STATUS_RESPONSE_AFC_FREQ_LSB) & Si2158_ATV_STATUS_RESPONSE_AFC_FREQ_MASK) << Si2158_ATV_STATUS_RESPONSE_AFC_FREQ_SHIFT) >> Si2158_ATV_STATUS_RESPONSE_AFC_FREQ_SHIFT);
+	ctx->rsp.atv_status.video_sys = (rspByteBuffer[8] >> Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_LSB) & Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_MASK;
+	ctx->rsp.atv_status.color     = (rspByteBuffer[8] >> Si2158_ATV_STATUS_RESPONSE_COLOR_LSB)     & Si2158_ATV_STATUS_RESPONSE_COLOR_MASK;
+
+	switch (priv->tuner.part) {
+	case 57:
+		break;
+	case 77:
+		ctx->rsp.atv_status.dlint            = (rspByteBuffer[1]  >> Si2177_ATV_STATUS_RESPONSE_DLINT_LSB    ) & Si2177_ATV_STATUS_RESPONSE_DLINT_MASK;
+		ctx->rsp.atv_status.snrlint          = (rspByteBuffer[1]  >> Si2177_ATV_STATUS_RESPONSE_SNRLINT_LSB  ) & Si2177_ATV_STATUS_RESPONSE_SNRLINT_MASK;
+		ctx->rsp.atv_status.snrhint          = (rspByteBuffer[1]  >> Si2177_ATV_STATUS_RESPONSE_SNRHINT_LSB  ) & Si2177_ATV_STATUS_RESPONSE_SNRHINT_MASK;
+		ctx->rsp.atv_status.dl               = (rspByteBuffer[2]  >> Si2177_ATV_STATUS_RESPONSE_DL_LSB       ) & Si2177_ATV_STATUS_RESPONSE_DL_MASK;
+		ctx->rsp.atv_status.snrl             = (rspByteBuffer[2]  >> Si2177_ATV_STATUS_RESPONSE_SNRL_LSB     ) & Si2177_ATV_STATUS_RESPONSE_SNRL_MASK;
+		ctx->rsp.atv_status.snrh             = (rspByteBuffer[2]  >> Si2177_ATV_STATUS_RESPONSE_SNRH_LSB     ) & Si2177_ATV_STATUS_RESPONSE_SNRH_MASK;
+		ctx->rsp.atv_status.video_snr        = (rspByteBuffer[3]  >> Si2177_ATV_STATUS_RESPONSE_VIDEO_SNR_LSB) & Si2177_ATV_STATUS_RESPONSE_VIDEO_SNR_MASK;
+		ctx->rsp.atv_status.video_sc_spacing = (((((rspByteBuffer[6] | (rspByteBuffer[7] << 8)) >> Si2177_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_LSB) & Si2177_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_MASK) << Si2177_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_SHIFT) >> Si2177_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_SHIFT);
+		ctx->rsp.atv_status.lines            = (rspByteBuffer[8]  >> Si2177_ATV_STATUS_RESPONSE_LINES_LSB           ) & Si2177_ATV_STATUS_RESPONSE_LINES_MASK;
+		ctx->rsp.atv_status.audio_sys        = (rspByteBuffer[9]  >> Si2177_ATV_STATUS_RESPONSE_AUDIO_SYS_LSB       ) & Si2177_ATV_STATUS_RESPONSE_AUDIO_SYS_MASK;
+		ctx->rsp.atv_status.audio_demod_mode = (rspByteBuffer[9]  >> Si2177_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_LSB) & Si2177_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_MASK;
+		ctx->rsp.atv_status.audio_chan_bw    = (rspByteBuffer[10] >> Si2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_LSB   ) & Si2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_MASK;
+		ctx->rsp.atv_status.sound_level      = ((((rspByteBuffer[11] >> Si2177_ATV_STATUS_RESPONSE_SOUND_LEVEL_LSB ) & Si2177_ATV_STATUS_RESPONSE_SOUND_LEVEL_MASK) << Si2177_ATV_STATUS_RESPONSE_SOUND_LEVEL_SHIFT) >> Si2177_ATV_STATUS_RESPONSE_SOUND_LEVEL_SHIFT);
+		break;
+	default:
+		break;
+	}
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+static int silabs_tercab_set_analog_params(struct dvb_frontend *fe, struct analog_parameters *params)
+{
+	struct silabs_tercab_priv *priv = fe->tuner_priv;
+	int res, ret     = 0;
+	u32 freq         = params->frequency * 125 * ((params->mode == V4L2_TUNER_RADIO) ? 1 : 1000) / 2;
+	u32 centerfreq   = 0;
+	u32 if_frequency = 5400000;
+	u32 bw           = 8000000;
+	u8 video_sys     = Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DEFAULT;
+	u8 color         = Si2158_ATV_VIDEO_MODE_PROP_COLOR_DEFAULT;
+	u8 invert_signal = Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_DEFAULT;
+
+	const u16 atv_afc_range_khz    =  1000; //1500;
+	const u8  tuner_ien_tcien     =  Si2158_TUNER_IEN_PROP_TCIEN_ENABLE;
+	const u8  tuner_ien_rssilien  =  Si2158_TUNER_IEN_PROP_RSSILIEN_DISABLE;
+	const u8  tuner_ien_rssihien  =  Si2158_TUNER_IEN_PROP_RSSIHIEN_DISABLE;
+	const u8  atv_agc_speed_if_agc_speed = Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;
+	const u8  atv_lif_out_amp = 100; /* (default    100) */
+	const u8  atv_lif_out_offset = 148; /* (default   148) */
+	const s8  atv_rsq_rssi_threshold_hi = 0;
+	const s8  atv_rsq_rssi_threshold_lo = -70;
+	const u8  atv_ien_chlien    =  Si2158_ATV_IEN_PROP_CHLIEN_ENABLE;
+	const u8  atv_ien_pclien    =  Si2158_ATV_IEN_PROP_PCLIEN_DISABLE;
+	const u8  atv_config_if_port_atv_agc_source = Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_AGC2_3DB;
+	const u8  atv_config_if_port_atv_out_type_58 = Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LIF_DIFF_IF1;
+
+	/* Si2177 */
+	const u8  atv_config_if_port_atv_out_type_77 = Si2177_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_CVBS_IF2B_SOUND_IF2A;
+	const u8  atv_sif_out_amp = 60; /* 77 (default 60) */
+	const u8  atv_sif_out_offset = 135;  /* 77 (default 135) */
+	const u8  atv_cvbs_out_amp = 200; /* 77 (default 200) */
+	const u8  atv_cvbs_out_offset = 25;  /* 77 (default 25) */
+	const u8  atv_cvbs_out_fine_amp = 100; /* 77 (default 100) */
+	const s8  atv_cvbs_out_fine_offset = 0;  /* 77 (default 0) */
+	const s8  atv_video_equalizer_slope = 0;  /* 77 (default 0) */
+	const u8  atv_rsq_snr_threshold_hi = Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_DEFAULT;// 77 45 maxSNRHalfdB;
+	const u8  atv_rsq_snr_threshold_lo = Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_DEFAULT;// 77 25 minSNRHalfdB;
+	const u8  atv_ien_dlien     =  Si2177_ATV_IEN_PROP_DLIEN_DISABLE;
+	const u8  atv_ien_snrhien   =  Si2177_ATV_IEN_PROP_SNRHIEN_DISABLE;
+	const u8  atv_ien_snrlien   =  Si2177_ATV_IEN_PROP_SNRLIEN_DISABLE;
+	const u8  atv_audio_mode_audio_sys  = Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_DEFAULT;
+	const u8  atv_audio_mode_chan_bw    = Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_DEFAULT;
+	const u8  atv_audio_mode_demod_mode = Si2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_SIF;
+	const u8  atv_ext_agc_min_10mv = 50; // 58 (default  50)
+	const u8  atv_ext_agc_max_10mv = 200; // 58 (default 200)
+
+	u16 lif_freq_offset;
+
+	u16 si2158_atv_agc_speed_prop_data;
+	u16 si2158_atv_lif_out_prop_data;
+	u16 si2158_atv_lif_freq_prop_data;
+	u16 si2158_atv_config_if_port_prop_data;
+	u16 si2177_atv_config_if_port_prop_data;
+	u16 si2177_atv_sif_out_prop_data;
+	u16 si2177_atv_cvbs_out_prop_data;
+	u16 si2177_atv_cvbs_out_fine_prop_data;
+	u16 si2177_atv_video_equalizer_prop_data;
+	u16 si2158_atv_ext_agc_prop_data;
+	u16 si2158_atv_rsq_rssi_threshold_prop_data;
+	u16 si2177_atv_rsq_snr_threshold_prop_data;
+	u16 si2158_tuner_ien__prop_data;
+	u16 si2158_atv_ien_prop_data;
+	u16 si2177_atv_ien_prop_data;
+	u16 si2177_atv_audio_mode_prop_data;
+	u16 si2158_atv_afc_range_prop_data;
+
+	silabs_tercab_dbg("freq = %d, video_sys = %u, color = %u\n", freq, video_sys, color);
+
+	priv->mode = SILABS_TERCAB_ANALOG;
+
+	if (params->mode == V4L2_TUNER_RADIO) {
+		video_sys = Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DEFAULT;
+		silabs_tercab_warn("radio mode is not supported\n");
+	} else if (params->std & (V4L2_STD_MN | V4L2_STD_NTSC_443)) {
+		if_frequency = 5400000;  /*5.4MHz	*/
+		bw = 6000000;
+		video_sys = Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_M;
+		silabs_tercab_info("using video_sys Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_M\n");
+	} else if (params->std & V4L2_STD_B) {
+		if_frequency = 6000000;  /*6.0MHz	*/
+		bw = 7000000;
+		video_sys = Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_B;
+		silabs_tercab_info("using video_sys Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_B\n");
+	} else if (params->std & (V4L2_STD_PAL_DK | V4L2_STD_SECAM_DK)){
+		if_frequency = 6900000;  /*6.9MHz	*/
+		bw = 8000000;
+		video_sys = Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DK;
+	} else if (params->std & V4L2_STD_GH){
+		if_frequency = 7100000;  /*7.1MHz	*/
+		bw = 8000000;
+		video_sys = Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_GH;
+		silabs_tercab_info("using video_sys Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_GH\n");
+	} else if (params->std & V4L2_STD_PAL_I){
+		if_frequency = 7250000;  /*7.25MHz	*/
+		bw = 8000000;
+		video_sys = Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_I;
+	} else if (params->std & V4L2_STD_SECAM_L){
+		if_frequency = 6900000;  /*6.9MHz	*/
+		bw = 8000000;
+		video_sys = Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_L;
+		color = Si2158_ATV_VIDEO_MODE_PROP_COLOR_SECAM;
+	} else if (params->std & V4L2_STD_SECAM_LC){
+		if_frequency = 1250000;  /*1.25MHz	*/
+		bw = 7000000;
+		video_sys = Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LP; /* ToDo: lc == lp? */
+		color = Si2158_ATV_VIDEO_MODE_PROP_COLOR_SECAM;
+	} else {
+		video_sys = Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DEFAULT;
+		silabs_tercab_warn("unsupported video system\n");
+	}
+
+	mutex_lock(&priv->lock);
+
+	SiTRACE("Wakeup terrestrial tuner\n");
+	res = silabs_tercab_poll_cts(priv->i2c_props.adap, priv->i2c_props.addr);
+	if (res != NO_SILABS_TERCAB_ERROR) {
+		silabs_tercab_err("tuner Si2158 wake up failed.\n");
+		SiTRACE("Terrestrial tuner wake up error: 0x%02x : %s\n", res, silabs_tercab_error_text(res));
+		ret = -EIO;
+		goto fail;
+	}
+
+	//Calc IF Center for given Video Carrier
+	//uIF = if_frequency + 1250000 - (bw/2);
+	//invert_signal = Si2177_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_INVERTED;
+
+	//Set IF output level
+	//dwValue = 100; //m_Config.uIFLEVEL;
+
+	switch (priv->tuner.part) {
+	case 57:
+		silabs_tercab_info("%s(): initializing tuner type Si21%02u\n", __func__, priv->tuner.part);
+
+		if (!priv->firmware_started) {
+			if (silabs_tercab_power_up_with_patch(priv) == NO_SILABS_TERCAB_ERROR) {
+				priv->firmware_started = 1;
+			} else {
+				silabs_tercab_err("%s(): ERROR: Si2177_PowerUpWithPatch() failed\n", __func__);
+			}
+		}
+		invert_signal = Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_DEFAULT;
+
+		si2158_atv_agc_speed_prop_data = (atv_agc_speed_if_agc_speed & Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB ;
+		silabs_tercab_set_property(&priv->tuner, Si2158_ATV_AGC_SPEED_PROP_CODE, si2158_atv_agc_speed_prop_data); /* windows 0x0 */
+
+		si2158_atv_lif_out_prop_data = (atv_lif_out_offset & Si2158_ATV_LIF_OUT_PROP_OFFSET_MASK) << Si2158_ATV_LIF_OUT_PROP_OFFSET_LSB  |
+			   (atv_lif_out_amp    & Si2158_ATV_LIF_OUT_PROP_AMP_MASK   ) << Si2158_ATV_LIF_OUT_PROP_AMP_LSB ;
+		silabs_tercab_set_property(&priv->tuner, Si2158_ATV_LIF_OUT_PROP_CODE, si2158_atv_lif_out_prop_data); /* windows 0x6494 */
+
+		//Set IF Center freq
+		lif_freq_offset = (u16)((if_frequency + 1250000 - (bw/2))/1000);
+		silabs_tercab_info("atv_lif_freq.offset=%u uBW=%u video_sys=%u\n", lif_freq_offset, bw, video_sys);
+		si2158_atv_lif_freq_prop_data = (lif_freq_offset & Si2158_ATV_LIF_FREQ_PROP_OFFSET_MASK) << Si2158_ATV_LIF_FREQ_PROP_OFFSET_LSB ;
+		silabs_tercab_set_property(&priv->tuner, Si2158_ATV_LIF_FREQ_PROP_CODE, si2158_atv_lif_freq_prop_data); /* windows 0xe42 */
+
+		si2158_atv_config_if_port_prop_data = (atv_config_if_port_atv_out_type_58 & Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_MASK  ) << Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LSB  |
+			   (atv_config_if_port_atv_agc_source & Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_MASK) << Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_LSB ;
+
+		//atv_agc_source isn't really supported on si2177, but lets set it to a known value
+		//atv_config_if_port_atv_agc_source = (u8)Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_INTERNAL;
+
+		silabs_tercab_set_property(&priv->tuner, Si2158_ATV_CONFIG_IF_PORT_PROP_CODE, si2158_atv_config_if_port_prop_data); /* windows 0x208 */
+		break;
+
+	case 77:
+		silabs_tercab_info("%s(): initializing tuner type Si21%02u\n", __func__, priv->tuner.part);
+
+		invert_signal = Si2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_DEFAULT;
+
+		si2177_atv_config_if_port_prop_data = (atv_config_if_port_atv_out_type_77 & Si2177_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_MASK) << Si2177_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LSB ;
+		silabs_tercab_set_property(&priv->tuner, Si2158_ATV_CONFIG_IF_PORT_PROP_CODE, si2177_atv_config_if_port_prop_data);
+
+		si2177_atv_sif_out_prop_data = (atv_sif_out_offset & Si2177_ATV_SIF_OUT_PROP_OFFSET_MASK) << Si2177_ATV_SIF_OUT_PROP_OFFSET_LSB  |
+			   (atv_sif_out_amp    & Si2177_ATV_SIF_OUT_PROP_AMP_MASK   ) << Si2177_ATV_SIF_OUT_PROP_AMP_LSB ;
+		silabs_tercab_set_property(&priv->tuner, Si2177_ATV_SIF_OUT_PROP_CODE, si2177_atv_sif_out_prop_data);
+
+		si2177_atv_cvbs_out_prop_data = (atv_cvbs_out_offset & Si2177_ATV_CVBS_OUT_PROP_OFFSET_MASK) << Si2177_ATV_CVBS_OUT_PROP_OFFSET_LSB  |
+			   (atv_cvbs_out_amp    & Si2177_ATV_CVBS_OUT_PROP_AMP_MASK   ) << Si2177_ATV_CVBS_OUT_PROP_AMP_LSB ;
+		silabs_tercab_set_property(&priv->tuner, Si2177_ATV_CVBS_OUT_PROP_CODE, si2177_atv_cvbs_out_prop_data);
+
+		si2177_atv_cvbs_out_fine_prop_data = (atv_cvbs_out_fine_offset & Si2177_ATV_CVBS_OUT_FINE_PROP_OFFSET_MASK) << Si2177_ATV_CVBS_OUT_FINE_PROP_OFFSET_LSB  |
+			   (atv_cvbs_out_fine_amp    & Si2177_ATV_CVBS_OUT_FINE_PROP_AMP_MASK   ) << Si2177_ATV_CVBS_OUT_FINE_PROP_AMP_LSB ;
+		silabs_tercab_set_property(&priv->tuner, Si2177_ATV_CVBS_OUT_FINE_PROP_CODE, si2177_atv_cvbs_out_fine_prop_data);
+
+		si2177_atv_video_equalizer_prop_data = (atv_video_equalizer_slope & Si2177_ATV_VIDEO_EQUALIZER_PROP_SLOPE_MASK) << Si2177_ATV_VIDEO_EQUALIZER_PROP_SLOPE_LSB ;
+		silabs_tercab_set_property(&priv->tuner, Si2177_ATV_VIDEO_EQUALIZER_PROP_CODE, si2177_atv_video_equalizer_prop_data);
+		break;
+
+	default:
+		silabs_tercab_warn("%s(): unsupported tuner model Si21%02u\n", __func__, priv->tuner.part);
+		break;
+	}
+
+	if (priv->tuner.part != 77) {
+		/* setup external AGC settings */
+		si2158_atv_ext_agc_prop_data = (atv_ext_agc_min_10mv & Si2158_ATV_EXT_AGC_PROP_MIN_10MV_MASK) << Si2158_ATV_EXT_AGC_PROP_MIN_10MV_LSB  |
+		   (atv_ext_agc_max_10mv & Si2158_ATV_EXT_AGC_PROP_MAX_10MV_MASK) << Si2158_ATV_EXT_AGC_PROP_MAX_10MV_LSB ;
+		silabs_tercab_set_property (&priv->tuner, Si2158_ATV_EXT_AGC_PROP_CODE, si2158_atv_ext_agc_prop_data); /* windows 0xc832 */
+	}
+
+	/* configure the RSQ / RSSI threshold properties */
+	si2158_atv_rsq_rssi_threshold_prop_data = (atv_rsq_rssi_threshold_lo & Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK) << Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB  |
+		   (atv_rsq_rssi_threshold_hi & Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK) << Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB ;
+
+	if (silabs_tercab_set_property(&priv->tuner, Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_CODE, si2158_atv_rsq_rssi_threshold_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		silabs_tercab_err("%s() silabs_tercab_set_property(Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_CODE) failed.\n", __func__);
+		ret = -EIO;
+		goto fail;
+	}
+
+	if (priv->tuner.part == 77) { //Si2177
+		/* configure the RSQ / SNR threshold properties */
+		si2177_atv_rsq_snr_threshold_prop_data = (atv_rsq_snr_threshold_lo & Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_MASK) << Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LSB  |
+			   (atv_rsq_snr_threshold_hi & Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_MASK) << Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_LSB ;
+		if (silabs_tercab_set_property(&priv->tuner, Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_CODE, si2177_atv_rsq_snr_threshold_prop_data) != NO_SILABS_TERCAB_ERROR) {
+			silabs_tercab_warn("%s() silabs_tercab_set_property(Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_CODE) failed.\n", __func__);
+		}
+	}
+
+	/* setup IEN properties to enable TUNINT on TC  */
+	si2158_tuner_ien__prop_data = (tuner_ien_tcien    & Si2158_TUNER_IEN_PROP_TCIEN_MASK   ) << Si2158_TUNER_IEN_PROP_TCIEN_LSB  |
+		   (tuner_ien_rssilien & Si2158_TUNER_IEN_PROP_RSSILIEN_MASK) << Si2158_TUNER_IEN_PROP_RSSILIEN_LSB  |
+		   (tuner_ien_rssihien & Si2158_TUNER_IEN_PROP_RSSIHIEN_MASK) << Si2158_TUNER_IEN_PROP_RSSIHIEN_LSB ;
+	if (silabs_tercab_set_property(&priv->tuner, Si2158_TUNER_IEN_PROP_CODE, si2158_tuner_ien__prop_data) != NO_SILABS_TERCAB_ERROR) {
+		silabs_tercab_warn("%s() silabs_tercab_set_property(Si2158_TUNER_IEN_PROP_CODE) failed.\n", __func__);
+	}
+
+	/* setup IEN properties to enable ATVINT on CHL  */
+	if (priv->tuner.part == 77) { //Si2177
+		si2177_atv_ien_prop_data = (atv_ien_chlien  & Si2158_ATV_IEN_PROP_CHLIEN_MASK ) << Si2158_ATV_IEN_PROP_CHLIEN_LSB  |
+			   (atv_ien_pclien  & Si2158_ATV_IEN_PROP_PCLIEN_MASK ) << Si2158_ATV_IEN_PROP_PCLIEN_LSB  |
+			   (atv_ien_dlien   & Si2177_ATV_IEN_PROP_DLIEN_MASK  ) << Si2177_ATV_IEN_PROP_DLIEN_LSB  |
+			   (atv_ien_snrlien & Si2177_ATV_IEN_PROP_SNRLIEN_MASK) << Si2177_ATV_IEN_PROP_SNRLIEN_LSB  |
+			   (atv_ien_snrhien & Si2177_ATV_IEN_PROP_SNRHIEN_MASK) << Si2177_ATV_IEN_PROP_SNRHIEN_LSB ;
+		if (silabs_tercab_set_property(&priv->tuner, Si2158_ATV_IEN_PROP_CODE, si2177_atv_ien_prop_data) != NO_SILABS_TERCAB_ERROR) { /* windows 0x1 */
+			silabs_tercab_warn("%s() silabs_tercab_set_property(Si2158_ATV_IEN_PROP_CODE) failed.\n", __func__);
+		}
+	} else {
+		si2158_atv_ien_prop_data = (atv_ien_chlien  & Si2158_ATV_IEN_PROP_CHLIEN_MASK ) << Si2158_ATV_IEN_PROP_CHLIEN_LSB  |
+			   (atv_ien_pclien  & Si2158_ATV_IEN_PROP_PCLIEN_MASK ) << Si2158_ATV_IEN_PROP_PCLIEN_LSB ;
+		if (silabs_tercab_set_property(&priv->tuner, Si2158_ATV_IEN_PROP_CODE, si2158_atv_ien_prop_data) != NO_SILABS_TERCAB_ERROR) { /* windows 0x1 */
+			silabs_tercab_warn("%s() silabs_tercab_set_property(Si2158_ATV_IEN_PROP_CODE) failed.\n", __func__);
+		}
+	}
+	if (priv->tuner.part == 77) { //Si2177
+		/* setup ATV audio property for wide SIF scanning*/
+		si2177_atv_audio_mode_prop_data = (atv_audio_mode_audio_sys  & Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MASK ) << Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_LSB  |
+			   (atv_audio_mode_demod_mode & Si2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_MASK) << Si2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_LSB  |
+			   (atv_audio_mode_chan_bw    & Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_MASK   ) << Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_LSB ;
+		if (silabs_tercab_set_property(&priv->tuner, Si2177_ATV_AUDIO_MODE_PROP_CODE, si2177_atv_audio_mode_prop_data) != NO_SILABS_TERCAB_ERROR) {
+			silabs_tercab_warn("%s() silabs_tercab_set_property(Si2177_ATV_AUDIO_MODE_PROP_CODE) failed.\n", __func__);
+		}
+	}
+	/* setup AFC acquisition range property to 1.5MHz for scanning */
+	si2158_atv_afc_range_prop_data = (atv_afc_range_khz & Si2158_ATV_AFC_RANGE_PROP_RANGE_KHZ_MASK) << Si2158_ATV_AFC_RANGE_PROP_RANGE_KHZ_LSB ;
+	if (silabs_tercab_set_property(&priv->tuner, Si2158_ATV_AFC_RANGE_PROP_CODE, si2158_atv_afc_range_prop_data) != NO_SILABS_TERCAB_ERROR) {
+		silabs_tercab_warn("%s() silabs_tercab_set_property(Si2158_ATV_AFC_RANGE_PROP) failed.\n", __func__);
+	}
+
+	centerfreq = freq - 1250000 + (bw/2);
+
+	//tune to channel center freq
+	silabs_tercab_dbg("tuning to center frequency %u, video system %u, color %u, invert %u\n", centerfreq, video_sys, color, invert_signal);
+
+	res = silabs_tercab_atv_tune(&priv->tuner, centerfreq, video_sys, color, invert_signal);
+	if (res == NO_SILABS_TERCAB_ERROR) {
+		/* Get ATV status */
+		if (silabs_tercab_atv_status (priv, Si2158_ATV_STATUS_CMD_INTACK_OK)) {
+			silabs_tercab_err("%s() silabs_tercab_atv_status() failed.\n", __func__);
+			ret = -EIO;
+			goto fail;
+		}
+	} else {
+		silabs_tercab_dbg("silabs_tercab_atv_tune(fe, %u, %u, %u, %u) failed (err=%d %s).\n",
+				centerfreq, video_sys, color, invert_signal, res, silabs_tercab_error_text(res));
+		ret = -EIO;
+		goto fail;
+	}
+	msleep(85);
+
+	priv->frequency = freq;
+	priv->if_frequency = if_frequency;
+	priv->bandwidth = bw;
+	ret = 0;
+
+fail:
+	mutex_unlock(&priv->lock);
+
+	return ret;
+}
+
+static void silabs_tercab_release(struct dvb_frontend *fe)
+{
+	struct silabs_tercab_priv *priv = fe->tuner_priv;
+
+	silabs_tercab_dbg("\n");
+
+	mutex_lock(&silabs_tercab_list_mutex);
+
+	if (priv)
+		hybrid_tuner_release_state(priv);
+
+	mutex_unlock(&silabs_tercab_list_mutex);
+
+	fe->tuner_priv = NULL;
+}
+
+static int silabs_tercab_get_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct silabs_tercab_priv *priv = fe->tuner_priv;
+	silabs_tercab_dbg("frequency=%u\n", priv->frequency);
+	*frequency = priv->frequency;
+	return 0;
+}
+
+static int silabs_tercab_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)
+{
+	struct silabs_tercab_priv *priv = fe->tuner_priv;
+	silabs_tercab_dbg("bandwidth=%u\n", priv->bandwidth);
+	*bandwidth = priv->bandwidth;
+	return 0;
+}
+
+static int silabs_tercab_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct silabs_tercab_priv *priv = fe->tuner_priv;
+	silabs_tercab_dbg("if_frequency=%u\n", priv->if_frequency);
+	*frequency = (u32)priv->if_frequency;
+	return 0;
+}
+
+/*---------------------------------------------------*/
+/* Si2158_DTV_STATUS COMMAND                       */
+/*---------------------------------------------------*/
+static u8 silabs_tercab_dtv_status(silabs_tercab_context *ctx, u8 intack)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[4];
+	ctx->rsp.dtv_status.STATUS = &ctx->status;
+
+	SiTRACE("%s()\n", __func__);
+
+	cmdByteBuffer[0] = Si2158_DTV_STATUS_CMD;
+	cmdByteBuffer[1] = (u8)((intack & Si2158_DTV_STATUS_CMD_INTACK_MASK) << Si2158_DTV_STATUS_CMD_INTACK_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing DTV_STATUS bytes!\n");
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	error_code = silabs_tercab_poll_response(ctx->i2c_adap, ctx->i2c_addr, 4, rspByteBuffer, &ctx->status);
+	if (error_code) {
+		SiTRACE("Error polling DTV_STATUS response\n");
+		return error_code;
+	}
+
+	ctx->rsp.dtv_status.chlint     = (rspByteBuffer[1] >> Si2158_DTV_STATUS_RESPONSE_CHLINT_LSB    ) & Si2158_DTV_STATUS_RESPONSE_CHLINT_MASK;
+	ctx->rsp.dtv_status.chl        = (rspByteBuffer[2] >> Si2158_DTV_STATUS_RESPONSE_CHL_LSB       ) & Si2158_DTV_STATUS_RESPONSE_CHL_MASK;
+	ctx->rsp.dtv_status.bw         = (rspByteBuffer[3] >> Si2158_DTV_STATUS_RESPONSE_BW_LSB        ) & Si2158_DTV_STATUS_RESPONSE_BW_MASK;
+	ctx->rsp.dtv_status.modulation = (rspByteBuffer[3] >> Si2158_DTV_STATUS_RESPONSE_MODULATION_LSB) & Si2158_DTV_STATUS_RESPONSE_MODULATION_MASK;
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+static int silabs_tercab_get_status(struct dvb_frontend *fe, u32 *status)
+{
+	struct silabs_tercab_priv *priv = fe->tuner_priv;
+	u8 res;
+	u8 ATV_Sync_Lock;
+	u8 ATV_Master_Lock;
+
+	*status = 0;
+
+	if (priv->mode == SILABS_TERCAB_ANALOG) {
+		mutex_lock(&priv->lock);
+		res = silabs_tercab_atv_status(priv, Si2158_ATV_STATUS_CMD_INTACK_OK);
+		mutex_unlock(&priv->lock);
+		if (res != NO_SILABS_TERCAB_ERROR) {
+			silabs_tercab_err("Si2177_L1_ATV_STATUS() failed (err=%d)\n", res);
+			return -EIO;
+		}
+		ATV_Sync_Lock   = priv->tuner.rsp.atv_status.pcl;
+		ATV_Master_Lock = priv->tuner.rsp.atv_status.dl;
+
+		silabs_tercab_dbg("ATV_Sync_Lock=%u  ATV_Master_Lock=%u  Channel=%u\n", ATV_Sync_Lock, ATV_Master_Lock, priv->tuner.rsp.atv_status.chl);
+
+		if (ATV_Sync_Lock && ATV_Master_Lock) {
+			*status = TUNER_STATUS_LOCKED;
+		}
+	} else {
+		mutex_lock(&priv->lock);
+		res = silabs_tercab_dtv_status(&priv->tuner, Si2158_DTV_STATUS_CMD_INTACK_OK);
+		mutex_unlock(&priv->lock);
+		if (res != NO_SILABS_TERCAB_ERROR) {
+			silabs_tercab_err("Si2177_L1_DTV_STATUS() failed (err=%d)\n", res);
+			return -EIO;
+		}
+		silabs_tercab_dbg("Channel=%u\n", priv->tuner.rsp.dtv_status.chl);
+		if (priv->tuner.rsp.dtv_status.chl) { /* ToDo: is this a lock indicator? */
+			*status = TUNER_STATUS_LOCKED;
+		}
+	}
+
+#if 0
+	if (tuner_stereo(priv->type, tuner_status))
+		*status |= TUNER_STATUS_STEREO;
+#endif
+
+	silabs_tercab_dbg("Status=%d\n", *status);
+
+	return 0;
+}
+
+/*---------------------------------------------------*/
+/* Si2158_TUNER_STATUS COMMAND                     */
+/*---------------------------------------------------*/
+static u8 silabs_tercab_tuner_status(silabs_tercab_context *ctx, u8 intack)
+{
+	u8 error_code = 0;
+	u8 cmdByteBuffer[2];
+	u8 rspByteBuffer[12];
+	ctx->rsp.tuner_status.STATUS = &ctx->status;
+
+	SiTRACE("%s()\n", __func__);
+
+	cmdByteBuffer[0] = Si2158_TUNER_STATUS_CMD;
+	cmdByteBuffer[1] = (u8) ( ( intack & Si2158_TUNER_STATUS_CMD_INTACK_MASK ) << Si2158_TUNER_STATUS_CMD_INTACK_LSB);
+
+	if (i2c_write_bytes(ctx->i2c_adap, ctx->i2c_addr, 2, cmdByteBuffer) != 2) {
+		SiTRACE("Error writing TUNER_STATUS bytes!\n");
+		return ERROR_SILABS_TERCAB_SENDING_COMMAND;
+	}
+
+	error_code = silabs_tercab_poll_response(ctx->i2c_adap, ctx->i2c_addr, 12, rspByteBuffer, &ctx->status);
+	if (error_code) {
+		SiTRACE("Error polling TUNER_STATUS response\n");
+		return error_code;
+	}
+
+	ctx->rsp.tuner_status.tcint    =   (( ( (rspByteBuffer[1]  )) >> Si2158_TUNER_STATUS_RESPONSE_TCINT_LSB    ) & Si2158_TUNER_STATUS_RESPONSE_TCINT_MASK    );
+	ctx->rsp.tuner_status.rssilint =   (( ( (rspByteBuffer[1]  )) >> Si2158_TUNER_STATUS_RESPONSE_RSSILINT_LSB ) & Si2158_TUNER_STATUS_RESPONSE_RSSILINT_MASK );
+	ctx->rsp.tuner_status.rssihint =   (( ( (rspByteBuffer[1]  )) >> Si2158_TUNER_STATUS_RESPONSE_RSSIHINT_LSB ) & Si2158_TUNER_STATUS_RESPONSE_RSSIHINT_MASK );
+	ctx->rsp.tuner_status.tc       =   (( ( (rspByteBuffer[2]  )) >> Si2158_TUNER_STATUS_RESPONSE_TC_LSB       ) & Si2158_TUNER_STATUS_RESPONSE_TC_MASK       );
+	ctx->rsp.tuner_status.rssil    =   (( ( (rspByteBuffer[2]  )) >> Si2158_TUNER_STATUS_RESPONSE_RSSIL_LSB    ) & Si2158_TUNER_STATUS_RESPONSE_RSSIL_MASK    );
+	ctx->rsp.tuner_status.rssih    =   (( ( (rspByteBuffer[2]  )) >> Si2158_TUNER_STATUS_RESPONSE_RSSIH_LSB    ) & Si2158_TUNER_STATUS_RESPONSE_RSSIH_MASK    );
+	ctx->rsp.tuner_status.rssi     = (((( ( (rspByteBuffer[3]  )) >> Si2158_TUNER_STATUS_RESPONSE_RSSI_LSB     ) & Si2158_TUNER_STATUS_RESPONSE_RSSI_MASK) << Si2158_TUNER_STATUS_RESPONSE_RSSI_SHIFT ) >> Si2158_TUNER_STATUS_RESPONSE_RSSI_SHIFT);
+	ctx->rsp.tuner_status.freq     =   (( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 ) | (rspByteBuffer[6]  << 16 ) | (rspByteBuffer[7]  << 24 )) >> Si2158_TUNER_STATUS_RESPONSE_FREQ_LSB     ) & Si2158_TUNER_STATUS_RESPONSE_FREQ_MASK);
+	ctx->rsp.tuner_status.mode     =   (( ( (rspByteBuffer[8]  )) >> Si2158_TUNER_STATUS_RESPONSE_MODE_LSB     ) & Si2158_TUNER_STATUS_RESPONSE_MODE_MASK     );
+	ctx->rsp.tuner_status.vco_code = (((( ( (rspByteBuffer[10] ) | (rspByteBuffer[11] << 8 )) >> Si2158_TUNER_STATUS_RESPONSE_VCO_CODE_LSB ) & Si2158_TUNER_STATUS_RESPONSE_VCO_CODE_MASK) << Si2158_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT) >> Si2158_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT);
+
+	return NO_SILABS_TERCAB_ERROR;
+}
+
+static int silabs_tercab_get_signal(struct dvb_frontend *fe, u16 *strength)
+{
+	struct silabs_tercab_priv *priv = fe->tuner_priv;
+	int rc = 0;
+	char rssi = 0;
+	u8 res;
+	u32 freq;
+	u8 mode;
+	u8 ATV_Sync_Lock;
+	u8 ATV_Master_Lock;
+	u8 chl;
+
+	mutex_lock(&priv->lock);
+	res = silabs_tercab_tuner_status(&priv->tuner, Si2158_TUNER_STATUS_CMD_INTACK_OK);
+	mutex_unlock(&priv->lock);
+	if (res != NO_SILABS_TERCAB_ERROR) {
+		silabs_tercab_err("Si2177_L1_TUNER_STATUS() failed (err=%d)\n", res);
+		return -EIO;
+	}
+
+	//vco_code =  priv->tuner.rsp.tuner_status.vco_code;
+	//tc       =  priv->tuner.rsp.tuner_status.tc;
+	//rssil    =  priv->tuner.rsp.tuner_status.rssil;
+	//rssih    =  priv->tuner.rsp.tuner_status.rssih;
+	rssi     =  priv->tuner.rsp.tuner_status.rssi;
+	freq     =  priv->tuner.rsp.tuner_status.freq;
+	mode     =  priv->tuner.rsp.tuner_status.mode;
+
+	silabs_tercab_dbg("freq=%u  mode=%u\n", freq, mode);
+
+	if (priv->mode == SILABS_TERCAB_ANALOG) {
+		mutex_lock(&priv->lock);
+		res = silabs_tercab_atv_status(priv, Si2158_ATV_STATUS_CMD_INTACK_OK);
+		mutex_unlock(&priv->lock);
+		if (res != NO_SILABS_TERCAB_ERROR) {
+			silabs_tercab_err("Si2177_L1_ATV_STATUS() failed (err=%d)\n", res);
+			return -EIO;
+		}
+		ATV_Sync_Lock    = priv->tuner.rsp.atv_status.pcl;
+		ATV_Master_Lock  = priv->tuner.rsp.atv_status.dl;
+
+		silabs_tercab_dbg("chlint           = %d\n", priv->tuner.rsp.atv_status.chlint);
+		silabs_tercab_dbg("pclint           = %d\n", priv->tuner.rsp.atv_status.pclint);
+		silabs_tercab_dbg("dlint            = %d\n", priv->tuner.rsp.atv_status.dlint);
+		silabs_tercab_dbg("snrlint          = %d\n", priv->tuner.rsp.atv_status.snrlint);
+		silabs_tercab_dbg("snrhint          = %d\n", priv->tuner.rsp.atv_status.snrhint);
+		silabs_tercab_dbg("chl              = %d\n", priv->tuner.rsp.atv_status.chl);
+		silabs_tercab_dbg("snrl             = %d\n", priv->tuner.rsp.atv_status.snrl);
+		silabs_tercab_dbg("snrh             = %d\n", priv->tuner.rsp.atv_status.snrh);
+		silabs_tercab_dbg("video_snr        = %d\n", priv->tuner.rsp.atv_status.video_snr);
+		silabs_tercab_dbg("afc_freq         = %d\n", priv->tuner.rsp.atv_status.afc_freq);
+		silabs_tercab_dbg("video_sc_spacing = %d\n", priv->tuner.rsp.atv_status.video_sc_spacing);
+		silabs_tercab_dbg("video_sys        = %d\n", priv->tuner.rsp.atv_status.video_sys);
+		silabs_tercab_dbg("lines            = %d\n", priv->tuner.rsp.atv_status.lines);
+		silabs_tercab_dbg("audio_sys        = %d\n", priv->tuner.rsp.atv_status.audio_sys);
+		silabs_tercab_dbg("audio_demod_mode = %d\n", priv->tuner.rsp.atv_status.audio_demod_mode);
+		silabs_tercab_dbg("audio_chan_bw    = %d\n", priv->tuner.rsp.atv_status.audio_chan_bw);
+		silabs_tercab_dbg("sound_level      = %d\n", priv->tuner.rsp.atv_status.sound_level);
+
+		silabs_tercab_dbg("ATV_Sync_Lock=%u  ATV_Master_Lock=%u\n", ATV_Sync_Lock, ATV_Master_Lock);
+
+		if (priv->tuner.rsp.atv_status.chl && priv->tuner.rsp.atv_status.pcl) {
+			silabs_tercab_dbg("RSSI analog: %ddBm\n", rssi);
+			*strength = (rssi > -50) ? (u16)rssi + 120 : 0;
+		} else {
+			silabs_tercab_dbg("RSSI analog: no signal\n");
+			*strength = 0;
+		}
+	} else {
+		mutex_lock(&priv->lock);
+		res = silabs_tercab_dtv_status(&priv->tuner, Si2158_DTV_STATUS_CMD_INTACK_OK);
+		mutex_unlock(&priv->lock);
+		if (res != NO_SILABS_TERCAB_ERROR) {
+			silabs_tercab_err("Si2177_L1_DTV_STATUS() failed (err=%d)\n", res);
+			return -EIO;
+		}
+		chl                =  priv->tuner.rsp.dtv_status.chl;
+		//bw                 =  priv->tuner.rsp.dtv_status.bw;
+		//modulation         =  priv->tuner.rsp.dtv_status.modulation;
+		silabs_tercab_dbg("RSSI digital: %ddBm (channel=%u)\n", rssi, chl);
+		*strength = (rssi > -50) ? (u16)rssi + 120 : 0;
+	}
+	return rc;
+}
+
+static int silabs_tercab_setup_configuration(struct dvb_frontend *fe,
+		struct silabs_tercab_config *cfg)
+{
+	struct silabs_tercab_priv *priv = fe->tuner_priv;
+
+	silabs_tercab_dbg("\n");
+
+	priv->config = cfg;
+
+	priv->qam_if_khz              = (cfg) ? cfg->qam_if_khz : 4000;
+	priv->vsb_if_khz              = (cfg) ? cfg->vsb_if_khz : 3250;
+	priv->clock_control           = (cfg) ? cfg->tuner_clock_control : _Si2168B_CLOCK_MANAGED;
+	priv->agc_control             = (cfg) ? cfg->tuner_agc_control : 1;
+	priv->fef_mode                = (cfg) ? cfg->fef_mode : Si2177_FEF_MODE_SLOW_NORMAL_AGC;
+	priv->crystal_trim_xo_cap     = (cfg) ? cfg->crystal_trim_xo_cap : Si2158_CRYSTAL_TRIM_PROP_XO_CAP_DEFAULT;
+	priv->indirect_i2c_connection = (cfg) ? cfg->indirect_i2c_connection : 1;
+	return 0;
+}
+
+static int silabs_tercab_set_config(struct dvb_frontend *fe, void *priv_cfg)
+{
+	struct silabs_tercab_priv *priv = fe->tuner_priv;
+	struct silabs_tercab_config *cfg = (struct silabs_tercab_config *) priv_cfg;
+
+	silabs_tercab_dbg("\n");
+
+	silabs_tercab_setup_configuration(fe, cfg);
+
+	return 0;
+}
+
+int silabs_tercab_autodetection(struct i2c_adapter* i2c_adapter, u8 i2c_addr)
+{
+	u8 power_up_clock_mode = 0; /* clock mode xtal */
+	u8 power_up_en_xout = 0;    /* disable xout */
+	struct silabs_tercab_priv *priv = NULL; /* for debug output only */
+	struct part_info part_info;
+	silabs_tercab_status status;
+	int return_code = 0;
+
+	silabs_tercab_info("%s(): i2c addr=0x%02X  clock mode=%u  en_xou=%u\n", __func__, i2c_addr, power_up_clock_mode, power_up_en_xout);
+
+	/* always wait for CTS prior to POWER_UP command */
+	if ((return_code = silabs_tercab_poll_cts(i2c_adapter, i2c_addr)) != 0) {
+		silabs_tercab_err("silabs_tercab_poll_cts error 0x%02x\n", return_code);
+		return -ENODEV;
+	}
+
+	if ((return_code = silabs_tercab_power_up(i2c_adapter, i2c_addr, Si2158_POWER_UP_CMD_SUBCODE_CODE,
+			power_up_clock_mode,
+			power_up_en_xout,
+			Si2158_POWER_UP_CMD_PD_LDO_LDO_POWER_UP,
+			Si2158_POWER_UP_CMD_RESERVED2_RESERVED,
+			Si2158_POWER_UP_CMD_RESERVED3_RESERVED,
+			Si2158_POWER_UP_CMD_RESERVED4_RESERVED,
+			Si2158_POWER_UP_CMD_RESERVED5_RESERVED,
+			Si2158_POWER_UP_CMD_RESERVED6_RESERVED,
+			Si2158_POWER_UP_CMD_RESERVED7_RESERVED,
+			Si2158_POWER_UP_CMD_RESET_RESET,
+			Si2158_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ,
+			Si2158_POWER_UP_CMD_RESERVED8_RESERVED,
+			Si2158_POWER_UP_CMD_FUNC_BOOTLOADER,
+#ifndef __SI2158__
+			Si2157_POWER_UP_CMD_RESERVED9_RESERVED,
+#endif
+			Si2158_POWER_UP_CMD_CTSIEN_DISABLE,
+			Si2158_POWER_UP_CMD_WAKE_UP_WAKE_UP,
+			&status)) != 0)
+	{
+		silabs_tercab_err("silabs_tercab_power_up() failed (err 0x%02x).\n", return_code);
+		return -ENODEV;
+	}
+
+	/* Get the Part Info from the chip.   This command is only valid in Bootloader mode */
+	if ((return_code = si2158_part_info(i2c_adapter, i2c_addr, &part_info)) != 0) {
+		silabs_tercab_err("si2158_part_info() failed (err 0x%02x).\n", return_code);
+		return -ENODEV;
+	}
+	switch (part_info.part) {
+	case 57:
+	case 77:
+		/* supported */
+		break;
+	default:
+		silabs_tercab_info("unsupported Silicon Labs tuner (part %d)\n", part_info.part);
+		return -ENODEV;
+	}
+
+	silabs_tercab_info("detected Silicon Labs tuner Si21%d (Rev. %d)\n", part_info.part, part_info.chiprev);
+	silabs_tercab_info("pmajor  %d\n",        part_info.pmajor );
+	if (part_info.pmajor >= 0x30) {
+		silabs_tercab_info("pmajor '%c'\n",   part_info.pmajor );
+	}
+	silabs_tercab_info("pminor  %d\n",        part_info.pminor );
+	if (part_info.pminor >= 0x30) {
+		silabs_tercab_info("pminor '%c'\n",   part_info.pminor );
+	}
+	silabs_tercab_info("pbuild %d\n",         part_info.pbuild );
+	silabs_tercab_info("romid %3d/0x%02x\n",  part_info.romid,  part_info.romid );
+
+	return 0; /* Silicon Labs tuner detected */
+}
+EXPORT_SYMBOL(silabs_tercab_autodetection);
+
+static const struct dvb_tuner_ops si2158_tuner_ops = {
+		.info = {
+				.name = "Silicon Labs terrestrial/cable tuner",
+				.frequency_min  =  45000000,
+				.frequency_max  = 864000000,
+				.frequency_step =     62500
+		},
+		/* int (*release)(struct dvb_frontend *fe); */
+		.release           = silabs_tercab_release,
+		/* int (*init)(struct dvb_frontend *fe); */
+		.init              = silabs_tercab_initialize,
+		/* int (*sleep)(struct dvb_frontend *fe); */
+		.sleep             = silabs_tercab_sleep,
+
+		/** This is for simple PLLs - set all parameters in one go. */
+		/* int (*set_params)(struct dvb_frontend *fe); */
+		.set_params        = silabs_tercab_set_params,
+		/* int (*set_analog_params)(struct dvb_frontend *fe, struct analog_parameters *p); */
+		.set_analog_params = silabs_tercab_set_analog_params,
+
+		/** This is support for demods like the mt352 - fills out the supplied buffer with what to write. */
+		/* int (*calc_regs)(struct dvb_frontend *fe, u8 *buf, int buf_len); */
+
+		/** This is to allow setting tuner-specific configs */
+		/* int (*set_config)(struct dvb_frontend *fe, void *priv_cfg); */
+		.set_config        = silabs_tercab_set_config,
+
+		/* int (*get_frequency)(struct dvb_frontend *fe, u32 *frequency); */
+		.get_frequency     = silabs_tercab_get_frequency,
+		/* int (*get_bandwidth)(struct dvb_frontend *fe, u32 *bandwidth); */
+		.get_bandwidth     = silabs_tercab_get_bandwidth,
+		/* int (*get_if_frequency)(struct dvb_frontend *fe, u32 *frequency); */
+		.get_if_frequency  = silabs_tercab_get_if_frequency,
+
+		/* int (*get_status)(struct dvb_frontend *fe, u32 *status); */
+		.get_status        = silabs_tercab_get_status,
+		/* int (*get_rf_strength)(struct dvb_frontend *fe, u16 *strength); */
+		.get_rf_strength   = silabs_tercab_get_signal,
+		/* int (*get_afc)(struct dvb_frontend *fe, s32 *afc); */
+
+		/** These are provided separately from set_params in order to facilitate silicon
+		 * tuners which require sophisticated tuning loops, controlling each parameter separately. */
+		/* int (*set_frequency)(struct dvb_frontend *fe, u32 frequency); */
+		/* int (*set_bandwidth)(struct dvb_frontend *fe, u32 bandwidth); */
+
+		/*
+		 * These are provided separately from set_params in order to facilitate silicon
+		 * tuners which require sophisticated tuning loops, controlling each parameter separately.
+		 */
+		/* int (*set_state)(struct dvb_frontend *fe, enum tuner_param param, struct tuner_state *state); */
+		/* int (*get_state)(struct dvb_frontend *fe, enum tuner_param param, struct tuner_state *state); */
+};
+
+struct dvb_frontend *silabs_tercab_attach(struct dvb_frontend *fe,
+		struct i2c_adapter *i2c,
+		struct silabs_tercab_config *cfg)
+{
+	struct silabs_tercab_priv *priv = NULL;
+	struct part_info part_info;
+	int instance, ret;
+
+	mutex_lock(&silabs_tercab_list_mutex);
+
+	if (!cfg) {
+		silabs_tercab_err("no configuration submitted\n");
+		goto fail;
+	}
+
+	instance = hybrid_tuner_request_state(struct silabs_tercab_priv, priv,
+			hybrid_tuner_instance_list,
+			i2c, cfg->tuner_address, "silabs_tercab");
+
+	switch (instance) {
+	case 0:
+		goto fail;
+	case 1:
+		/* new tuner instance */
+		silabs_tercab_info("%s(): new instance for tuner @0x%02x\n", __func__, cfg->tuner_address);
+		fe->tuner_priv = priv;
+
+		silabs_tercab_setup_configuration(fe, cfg);
+
+		mutex_init(&priv->lock);
+
+		break;
+	default:
+		/* existing tuner instance */
+		fe->tuner_priv = priv;
+
+		/* allow dvb driver to override configuration settings */
+		if (cfg) {
+			silabs_tercab_info("%s(0x%02X): dvb driver submitted configuration\n", __func__, cfg->tuner_address);
+			priv->clock_control       = cfg->tuner_clock_control;
+			priv->agc_control         = cfg->tuner_agc_control;
+			priv->fef_mode            = cfg->fef_mode;
+			priv->crystal_trim_xo_cap = cfg->crystal_trim_xo_cap;
+		} else {
+			silabs_tercab_info("%s(0x%02X): default configuration\n", __func__, priv->tuner.i2c_addr);
+		}
+		break;
+	}
+
+	if (!priv->indirect_i2c_connection && fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1); /* enable i2c gate */
+
+	if (silabs_tercab_autodetection(priv->i2c_props.adap, cfg->tuner_address)) {
+		silabs_tercab_err("autodetection failed.\n");
+		goto fail;
+	}
+
+	/* Get the Part Info from the chip.   This command is only valid in Bootloader mode */
+	if (si2158_part_info(priv->i2c_props.adap, cfg->tuner_address, &part_info)) {
+		silabs_tercab_err("si2158_part_info() failed \n");
+		goto fail;
+	}
+	priv->tuner.part    = part_info.part;
+	priv->tuner.chiprev = part_info.chiprev;
+
+	silabs_tercab_info("%s(): Silicon Labs tuner Si21%02d rev. %d @0x%02x\n", __func__, priv->tuner.part, priv->tuner.chiprev, cfg->tuner_address);
+
+	if (!silabs_tercab_sw_init(priv, priv->i2c_props.addr, NULL, priv->i2c_props.adap)) {
+		silabs_tercab_err("silabs_tercab_sw_init() failed.\n");
+		goto fail;
+	}
+
+	if (silabs_tercab_initialize(fe)) {
+		silabs_tercab_err("silabs_tercab_initialize() failed.\n");
+		goto fail;
+	}
+
+	/* enter standby mode, with required output features enabled */
+	ret = silabs_tercab_sleep(fe);
+	silabs_tercab_fail(ret);
+
+	if (!priv->indirect_i2c_connection && fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0); /* disable i2c gate */
+
+	mutex_unlock(&silabs_tercab_list_mutex);
+
+	memcpy(&fe->ops.tuner_ops, &si2158_tuner_ops, sizeof(struct dvb_tuner_ops));
+
+	return fe;
+
+fail:
+	mutex_unlock(&silabs_tercab_list_mutex);
+
+	if (!priv->indirect_i2c_connection && fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0); /* disable i2c gate */
+
+	silabs_tercab_release(fe);
+	return NULL;
+}
+EXPORT_SYMBOL(silabs_tercab_attach);
+
+static int silabs_tercab_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	struct silabs_tercab_config *cfg = client->dev.platform_data;
+	struct silabs_tercab_priv *priv = NULL;
+	struct dvb_frontend *fe;
+
+	printk(KERN_INFO "%s: attaching Silicon Labs tuner...\n", __func__);
+
+	fe = silabs_tercab_attach(cfg->fe, client->adapter, cfg);
+
+	if (fe == NULL) {
+		printk(KERN_ERR "%s: attaching Silicon Labs tuner failed\n", __func__);
+		dev_dbg(&client->dev, "%s: failed\n", __func__);
+		return -ENODEV;
+	}
+	priv = fe->tuner_priv;
+	priv->client = client;
+	priv->fe = cfg->fe;
+
+	i2c_set_clientdata(client, fe->tuner_priv);
+
+	dev_info(&priv->client->dev,
+			"%s: Silicon Labs Tuner successfully attached\n",
+			KBUILD_MODNAME);
+
+	return 0;
+}
+
+static int silabs_tercab_remove(struct i2c_client *client)
+{
+	struct silabs_tercab_priv *priv = i2c_get_clientdata(client);
+	struct dvb_frontend *fe = priv->fe;
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+
+	memset(&fe->ops.tuner_ops, 0, sizeof(struct dvb_tuner_ops));
+	silabs_tercab_release(fe);
+	return 0;
+}
+
+static const struct i2c_device_id silabs_tercab_id[] = {
+		{"silabs_tercab", 0},
+		{}
+};
+MODULE_DEVICE_TABLE(i2c, silabs_tercab_id);
+
+static struct i2c_driver silabs_tercab_driver = {
+		.driver = {
+				.owner	= THIS_MODULE,
+				.name	= "silabs_tercab",
+		},
+		.probe		= silabs_tercab_probe,
+		.remove		= silabs_tercab_remove,
+		.id_table	= silabs_tercab_id,
+};
+
+module_i2c_driver(silabs_tercab_driver);
+
+MODULE_DESCRIPTION("Silicon Labs terrestrial/cable hybrid tuner driver");
+MODULE_AUTHOR("Source code provided by Silicon Laboratories Inc.");
+MODULE_AUTHOR("Henning Garbers <hgarbers@pctvsystems.com>");
+MODULE_LICENSE("PROPRIETARY AND CONFIDENTIAL");
+MODULE_VERSION("2015-02-05");
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
--- linux-4.15/drivers/media/tuners/silabs_tercab.h.0140~	2018-02-12 11:32:52.770582195 +0100
+++ linux-4.15/drivers/media/tuners/silabs_tercab.h	2018-02-12 11:32:52.770582195 +0100
@@ -0,0 +1,102 @@
+/*
+ * silabs_tercab.h - header for the Silicon Laboratories terrestrial/cable
+ * hybrid tuner series
+ *
+ * (C) Copyright 2014, PCTV Systems S.Ã  r.l
+ * Henning Garbers <hgarbers@pctvsystems.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ */
+
+#ifndef __SILABS_TERCAB_H__
+#define __SILABS_TERCAB_H__
+
+#include <linux/i2c.h>
+#include "dvb_frontend.h"
+
+#define HVR19x5_QAM_IF 4000
+#define HVR19x5_VSB_IF 3250
+
+#define _Si2168B_CLOCK_ALWAYS_OFF 0  /* turn clock ON then never switch it off, used when the clock is provided to another part */
+#define _Si2168B_CLOCK_ALWAYS_ON  1  /* never switch it on, used when the clock is not going anywhere */
+#define _Si2168B_CLOCK_MANAGED    2  /* control clock state as before */
+
+/* settings for the Silicon Labs demod driver */
+#define L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN_SETUP
+#define L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP
+#define L1_RF_TER_TUNER_FEF_MODE_SLOW_NORMAL_AGC_SETUP
+
+/******************************************************************************/
+/* Si2177 Tuner FEF management options */
+/******************************************************************************/
+#define Si2177_FEF_MODE_SLOW_NORMAL_AGC  0
+#define Si2177_FEF_MODE_FREEZE_PIN       1
+#define Si2177_FEF_MODE_SLOW_INITIAL_AGC 2
+
+struct silabs_tercab_config {
+	/* the tuner's i2c address */
+	u8 tuner_address;
+
+	/* user defined IF frequencies in KHz */
+	u16 qam_if_khz;
+	u16 vsb_if_khz;
+
+	/* tuner clock_control:   how the TER clock must be controlled
+       possible modes:
+       CLOCK_ALWAYS_ON  (=0)
+       CLOCK_ALWAYS_OFF (=1)
+	   CLOCK_MANAGED    (=2) */
+	u8 tuner_clock_control;
+
+	/* enable / disable AGC */
+	u8 tuner_agc_control;
+
+	/* FEF management options
+	   FEF_MODE_SLOW_NORMAL_AGC  (=0)
+	   FEF_MODE_FREEZE_PIN       (=1)
+	   FEF_MODE_SLOW_INITIAL_AGC (=2) */
+    u8 fef_mode;
+
+    u8  crystal_trim_xo_cap;
+
+	/* tuner i2c connection               */
+	/* 0-tuner connected through Si2168B  */
+	/* 1-tuner is direct accessible       */
+	u8 indirect_i2c_connection;
+
+	struct dvb_frontend *fe;
+};
+
+#if IS_ENABLED(CONFIG_MEDIA_TUNER_SILABS_TERCAB)
+extern int silabs_tercab_autodetection(struct i2c_adapter* i2c_adapter, u8 i2c_addr);
+
+extern struct dvb_frontend *silabs_tercab_attach(struct dvb_frontend *fe,
+					    struct i2c_adapter *i2c,
+					    struct silabs_tercab_config *cfg);
+#else
+static inline int silabs_tercab_autodetection(struct i2c_adapter* i2c_adapter,
+					u8 i2c_addr)
+{
+	printk(KERN_INFO "%s: not probed - driver disabled by Kconfig\n",
+	       __func__);
+	return -EINVAL;
+}
+
+static inline struct dvb_frontend *silabs_tercab_attach(struct dvb_frontend *fe,
+						   struct i2c_adapter *i2c,
+						   struct silabs_tercab_config *cfg)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* __SILABS_TERCAB_H__ */
--- linux-4.15/drivers/media/tuners/silabs_tercab_priv.h.0140~	2018-02-12 11:32:52.773582217 +0100
+++ linux-4.15/drivers/media/tuners/silabs_tercab_priv.h	2018-02-12 11:32:52.773582217 +0100
@@ -0,0 +1,5651 @@
+/*************************************************************************************
+                  Silicon Laboratories Broadcast Si2158 Layer 1 API
+   API types used by commands and properties
+   FILE: Si2158_typedefs.h
+   Supported IC : Si2158
+   Compiled for ROM 33 firmware 2_1_build_9
+   Revision: 0.1
+   Date: March 20 2013
+  (C) Copyright 2013, Silicon Laboratories, Inc. All rights reserved.
+ **************************************************************************************/
+#ifndef __SILABS_TERCAB_PRIV_H__
+#define __SILABS_TERCAB_PRIV_H__
+
+#include "silabs_tercab.h"
+
+/* Uncomment the following line to activate all traces in the code */
+/* #define SiTRACES */
+
+#ifdef _DEBUG
+#define RAM_CRC_CHECK 1
+#endif
+
+#define DOWNLOAD_ON_CHANGE 1
+#define DOWNLOAD_ALWAYS    0
+
+#define __SI2157__
+#define __SI2177__
+
+/* Si2158 API Specific Includes */
+#define Si2158_BYTES_PER_LINE 8
+
+enum silabs_tercab_mode {
+	SILABS_TERCAB_ANALOG = 0,
+	SILABS_TERCAB_DIGITAL,
+};
+
+typedef struct silabs_tercab_i2c_context
+{
+	u8 address;
+	struct i2c_adapter *i2c_adap; /* linux kernel */
+} silabs_tercab_i2c_context;
+
+#ifndef __SILABS_FIRMWARE_STRUCT__
+#define __SILABS_FIRMWARE_STRUCT__
+typedef struct  {
+	u8 firmware_len;
+	u8 firmware_table[16];
+} firmware_struct;
+#endif /* __SILABS_FIRMWARE_STRUCT__ */
+
+/* STATUS structure definition */
+typedef struct { /* silabs_tercab_status */
+	u8   tunint;
+	u8   atvint;
+	u8   dtvint;
+	u8   err;
+	u8   cts;
+}  silabs_tercab_status;
+
+/* STATUS fields definition */
+/* STATUS, TUNINT field definition (address 0, size 1, lsb 0, unsigned)*/
+#define Si2158_STATUS_TUNINT_LSB         0
+#define Si2158_STATUS_TUNINT_MASK        0x01
+#define Si2158_STATUS_TUNINT_NOT_TRIGGERED  0
+#define Si2158_STATUS_TUNINT_TRIGGERED      1
+/* STATUS, ATVINT field definition (address 0, size 1, lsb 1, unsigned)*/
+#define Si2158_STATUS_ATVINT_LSB         1
+#define Si2158_STATUS_ATVINT_MASK        0x01
+#define Si2158_STATUS_ATVINT_NOT_TRIGGERED  0
+#define Si2158_STATUS_ATVINT_TRIGGERED      1
+/* STATUS, DTVINT field definition (address 0, size 1, lsb 2, unsigned)*/
+#define Si2158_STATUS_DTVINT_LSB         2
+#define Si2158_STATUS_DTVINT_MASK        0x01
+#define Si2158_STATUS_DTVINT_NOT_TRIGGERED  0
+#define Si2158_STATUS_DTVINT_TRIGGERED      1
+/* STATUS, ERR field definition (address 0, size 1, lsb 6, unsigned)*/
+#define Si2158_STATUS_ERR_LSB         6
+#define Si2158_STATUS_ERR_MASK        0x01
+#define Si2158_STATUS_ERR_ERROR     1
+#define Si2158_STATUS_ERR_NO_ERROR  0
+/* STATUS, CTS field definition (address 0, size 1, lsb 7, unsigned)*/
+#define Si2158_STATUS_CTS_LSB         7
+#define Si2158_STATUS_CTS_MASK        0x01
+#define Si2158_STATUS_CTS_COMPLETED  1
+#define Si2158_STATUS_CTS_WAIT       0
+
+/* Si2158_AGC_OVERRIDE command definition */
+#define Si2158_AGC_OVERRIDE_CMD 0x44
+
+#define Si2158_AGC_OVERRIDE_CMD_CODE 0x010044
+
+typedef struct { /* Si2158_AGC_OVERRIDE_CMD_struct */
+	u8   force_max_gain;
+	u8   force_top_gain;
+} Si2158_AGC_OVERRIDE_CMD_struct;
+
+typedef struct { /* Si2158_AGC_OVERRIDE_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+}  Si2158_AGC_OVERRIDE_CMD_REPLY_struct;
+
+/* AGC_OVERRIDE command, FORCE_MAX_GAIN field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2158_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_LSB         0
+#define Si2158_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MASK        0x01
+#define Si2158_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MIN         0
+#define Si2158_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MAX         1
+#define Si2158_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_DISABLE  0
+#define Si2158_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_ENABLE   1
+/* AGC_OVERRIDE command, FORCE_TOP_GAIN field definition (address 1,size 1, lsb 1, unsigned) */
+#define Si2158_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_LSB         1
+#define Si2158_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MASK        0x01
+#define Si2158_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MIN         0
+#define Si2158_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MAX         1
+#define Si2158_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_DISABLE  0
+#define Si2158_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_ENABLE   1
+
+/* Si2158_ATV_CW_TEST command definition */
+#define Si2158_ATV_CW_TEST_CMD 0x53
+
+#define Si2158_ATV_CW_TEST_CMD_CODE 0x010053
+
+typedef struct { /* Si2158_ATV_CW_TEST_CMD_struct */
+	u8   pc_lock;
+} Si2158_ATV_CW_TEST_CMD_struct;
+
+
+typedef struct { /* Si2158_ATV_CW_TEST_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+}  Si2158_ATV_CW_TEST_CMD_REPLY_struct;
+
+/* ATV_CW_TEST command, PC_LOCK field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2158_ATV_CW_TEST_CMD_PC_LOCK_LSB         0
+#define Si2158_ATV_CW_TEST_CMD_PC_LOCK_MASK        0x01
+#define Si2158_ATV_CW_TEST_CMD_PC_LOCK_MIN         0
+#define Si2158_ATV_CW_TEST_CMD_PC_LOCK_MAX         1
+#define Si2158_ATV_CW_TEST_CMD_PC_LOCK_LOCK    1
+#define Si2158_ATV_CW_TEST_CMD_PC_LOCK_UNLOCK  0
+
+/* Si2158_ATV_RESTART command definition */
+#define Si2158_ATV_RESTART_CMD 0x51
+
+#define Si2158_ATV_RESTART_CMD_CODE 0x010051
+
+typedef struct { /* Si2158_ATV_RESTART_CMD_struct */
+	u8   mode;
+} Si2158_ATV_RESTART_CMD_struct;
+
+typedef struct { /* Si2158_ATV_RESTART_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+}  Si2158_ATV_RESTART_CMD_REPLY_struct;
+
+#ifdef __SI2177__
+/* ATV_RESTART command, MODE field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2177_ATV_RESTART_CMD_MODE_LSB         0
+#define Si2177_ATV_RESTART_CMD_MODE_MASK        0x01
+#define Si2177_ATV_RESTART_CMD_MODE_MIN         0
+#define Si2177_ATV_RESTART_CMD_MODE_MAX         1
+#define Si2177_ATV_RESTART_CMD_MODE_AUDIO_ONLY  1
+#define Si2177_ATV_RESTART_CMD_MODE_AUDIO_VIDEO 0
+#endif /* __SI2177__ */
+
+/* Si2158_ATV_STATUS command definition */
+#define Si2158_ATV_STATUS_CMD 0x52
+
+#define Si2158_ATV_STATUS_CMD_CODE 0x010052
+
+typedef struct { /* Si2158_ATV_STATUS_CMD_struct */
+	u8   intack;
+} Si2158_ATV_STATUS_CMD_struct;
+
+#ifdef __SI2158__
+typedef struct { /* Si2158_ATV_STATUS_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+	u8  chlint;
+	u8  pclint;
+	u8  chl;
+	u8  pcl;
+	u32 afc_freq;
+	u8  video_sys;
+	u8  color;
+}  Si2158_ATV_STATUS_CMD_REPLY_struct;
+#endif /* __SI2158__ */
+
+#ifdef __SI2177__
+typedef struct { /* Si2177_ATV_STATUS_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+	u8   chlint;
+	u8   pclint;
+	u8   dlint;
+	u8   snrlint;
+	u8   snrhint;
+	u8   audio_chan_bw;
+	s8   sound_level;
+	u8   chl;
+	u8   pcl;
+	u8   dl;
+	u8   snrl;
+	u8   snrh;
+	u8   video_snr;
+	u32  afc_freq;
+	u32  video_sc_spacing;
+	u8   video_sys;
+	u8   color;
+	u8   lines;
+	u8   audio_sys;
+	u8   audio_demod_mode;
+}  Si2158_ATV_STATUS_CMD_REPLY_struct;
+#endif /* __SI2177__ */
+
+/* ATV_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2158_ATV_STATUS_CMD_INTACK_LSB         0
+#define Si2158_ATV_STATUS_CMD_INTACK_MASK        0x01
+#define Si2158_ATV_STATUS_CMD_INTACK_MIN         0
+#define Si2158_ATV_STATUS_CMD_INTACK_MAX         1
+#define Si2158_ATV_STATUS_CMD_INTACK_CLEAR  1
+#define Si2158_ATV_STATUS_CMD_INTACK_OK     0
+/* ATV_STATUS command, CHLINT field definition (address 1, size 1, lsb 0, unsigned)*/
+#define Si2158_ATV_STATUS_RESPONSE_CHLINT_LSB         0
+#define Si2158_ATV_STATUS_RESPONSE_CHLINT_MASK        0x01
+#define Si2158_ATV_STATUS_RESPONSE_CHLINT_CHANGED    1
+#define Si2158_ATV_STATUS_RESPONSE_CHLINT_NO_CHANGE  0
+/* ATV_STATUS command, PCLINT field definition (address 1, size 1, lsb 1, unsigned)*/
+#define Si2158_ATV_STATUS_RESPONSE_PCLINT_LSB         1
+#define Si2158_ATV_STATUS_RESPONSE_PCLINT_MASK        0x01
+#define Si2158_ATV_STATUS_RESPONSE_PCLINT_CHANGED    1
+#define Si2158_ATV_STATUS_RESPONSE_PCLINT_NO_CHANGE  0
+#ifdef __SI2177__
+/* ATV_STATUS command, DLINT field definition (address 1, size 1, lsb 2, unsigned)*/
+#define Si2177_ATV_STATUS_RESPONSE_DLINT_LSB         2
+#define Si2177_ATV_STATUS_RESPONSE_DLINT_MASK        0x01
+#define Si2177_ATV_STATUS_RESPONSE_DLINT_CHANGED    1
+#define Si2177_ATV_STATUS_RESPONSE_DLINT_NO_CHANGE  0
+/* ATV_STATUS command, SNRLINT field definition (address 1, size 1, lsb 3, unsigned)*/
+#define Si2177_ATV_STATUS_RESPONSE_SNRLINT_LSB         3
+#define Si2177_ATV_STATUS_RESPONSE_SNRLINT_MASK        0x01
+#define Si2177_ATV_STATUS_RESPONSE_SNRLINT_CHANGED    1
+#define Si2177_ATV_STATUS_RESPONSE_SNRLINT_NO_CHANGE  0
+/* ATV_STATUS command, SNRHINT field definition (address 1, size 1, lsb 4, unsigned)*/
+#define Si2177_ATV_STATUS_RESPONSE_SNRHINT_LSB         4
+#define Si2177_ATV_STATUS_RESPONSE_SNRHINT_MASK        0x01
+#define Si2177_ATV_STATUS_RESPONSE_SNRHINT_CHANGED    1
+#define Si2177_ATV_STATUS_RESPONSE_SNRHINT_NO_CHANGE  0
+/* ATV_STATUS command, AUDIO_CHAN_BW field definition (address 10, size 4, lsb 0, unsigned)*/
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_LSB         0
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_MASK        0x0f
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_12X_OVERMOD     3
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_150_KHZ_OFFSET  8
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_15_KHZ_OFFSET   5
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_30_KHZ_OFFSET   6
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_4X_OVERMOD      1
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_75_KHZ_OFFSET   7
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_7P5_KHZ_OFFSET  4
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_8X_OVERMOD      2
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_CUSTOM          9
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_RSVD            0
+/* ATV_STATUS command, SOUND_LEVEL field definition (address 11, size 8, lsb 0, signed)*/
+#define Si2177_ATV_STATUS_RESPONSE_SOUND_LEVEL_LSB         0
+#define Si2177_ATV_STATUS_RESPONSE_SOUND_LEVEL_MASK        0xff
+#define Si2177_ATV_STATUS_RESPONSE_SOUND_LEVEL_SHIFT       24
+#endif /* __SI2177__ */
+/* ATV_STATUS command, CHL field definition (address 2, size 1, lsb 0, unsigned)*/
+#define Si2158_ATV_STATUS_RESPONSE_CHL_LSB         0
+#define Si2158_ATV_STATUS_RESPONSE_CHL_MASK        0x01
+#define Si2158_ATV_STATUS_RESPONSE_CHL_CHANNEL     1
+#define Si2158_ATV_STATUS_RESPONSE_CHL_NO_CHANNEL  0
+/* ATV_STATUS command, PCL field definition (address 2, size 1, lsb 1, unsigned)*/
+#define Si2158_ATV_STATUS_RESPONSE_PCL_LSB         1
+#define Si2158_ATV_STATUS_RESPONSE_PCL_MASK        0x01
+#define Si2158_ATV_STATUS_RESPONSE_PCL_LOCKED   1
+#define Si2158_ATV_STATUS_RESPONSE_PCL_NO_LOCK  0
+#ifdef __SI2177__
+/* ATV_STATUS command, DL field definition (address 2, size 1, lsb 2, unsigned)*/
+#define Si2177_ATV_STATUS_RESPONSE_DL_LSB         2
+#define Si2177_ATV_STATUS_RESPONSE_DL_MASK        0x01
+#define Si2177_ATV_STATUS_RESPONSE_DL_LOCKED   1
+#define Si2177_ATV_STATUS_RESPONSE_DL_NO_LOCK  0
+/* ATV_STATUS command, SNRL field definition (address 2, size 1, lsb 3, unsigned)*/
+#define Si2177_ATV_STATUS_RESPONSE_SNRL_LSB         3
+#define Si2177_ATV_STATUS_RESPONSE_SNRL_MASK        0x01
+#define Si2177_ATV_STATUS_RESPONSE_SNRL_SNR_LOW      1
+#define Si2177_ATV_STATUS_RESPONSE_SNRL_SNR_NOT_LOW  0
+/* ATV_STATUS command, SNRH field definition (address 2, size 1, lsb 4, unsigned)*/
+#define Si2177_ATV_STATUS_RESPONSE_SNRH_LSB         4
+#define Si2177_ATV_STATUS_RESPONSE_SNRH_MASK        0x01
+#define Si2177_ATV_STATUS_RESPONSE_SNRH_SNR_HIGH      1
+#define Si2177_ATV_STATUS_RESPONSE_SNRH_SNR_NOT_HIGH  0
+/* ATV_STATUS command, VIDEO_SNR field definition (address 3, size 8, lsb 0, unsigned)*/
+#define Si2177_ATV_STATUS_RESPONSE_VIDEO_SNR_LSB         0
+#define Si2177_ATV_STATUS_RESPONSE_VIDEO_SNR_MASK        0xff
+#endif /* __SI2177__ */
+/* ATV_STATUS command, AFC_FREQ field definition (address 4, size 16, lsb 0, signed)*/
+#define Si2158_ATV_STATUS_RESPONSE_AFC_FREQ_LSB         0
+#define Si2158_ATV_STATUS_RESPONSE_AFC_FREQ_MASK        0xffff
+#define Si2158_ATV_STATUS_RESPONSE_AFC_FREQ_SHIFT       16
+#ifdef __SI2177__
+/* ATV_STATUS command, VIDEO_SC_SPACING field definition (address 6, size 16, lsb 0, signed)*/
+#define Si2177_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_LSB         0
+#define Si2177_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_MASK        0xffff
+#define Si2177_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_SHIFT       16
+#endif /* __SI2177__ */
+/* ATV_STATUS command, VIDEO_SYS field definition (address 8, size 3, lsb 0, unsigned)*/
+#define Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_LSB         0
+#define Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_MASK        0x07
+#define Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_B   0
+#define Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_DK  5
+#define Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_GH  1
+#define Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_I   4
+#define Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_L   6
+#define Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_LP  7
+#define Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_M   2
+#define Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_N   3
+/* ATV_STATUS command, COLOR field definition (address 8, size 1, lsb 4, unsigned)*/
+#define Si2158_ATV_STATUS_RESPONSE_COLOR_LSB         4
+#define Si2158_ATV_STATUS_RESPONSE_COLOR_MASK        0x01
+#define Si2158_ATV_STATUS_RESPONSE_COLOR_PAL_NTSC  0
+#define Si2158_ATV_STATUS_RESPONSE_COLOR_SECAM     1
+
+#ifdef __SI2177__
+/* ATV_STATUS command, LINES field definition (address 8, size 1, lsb 7, unsigned)*/
+#define Si2177_ATV_STATUS_RESPONSE_LINES_LSB         7
+#define Si2177_ATV_STATUS_RESPONSE_LINES_MASK        0x01
+#define Si2177_ATV_STATUS_RESPONSE_LINES_525  0
+#define Si2177_ATV_STATUS_RESPONSE_LINES_625  1
+/* ATV_STATUS command, AUDIO_SYS field definition (address 9, size 4, lsb 0, unsigned)*/
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_SYS_LSB         0
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_SYS_MASK        0x0f
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_SYS_A2               3
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_SYS_A2_DK2           4
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_SYS_A2_DK3           5
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_SYS_A2_DK4           9
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_SYS_BTSC             6
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_SYS_EIAJ             7
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_SYS_MONO             1
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_SYS_MONO_NICAM       2
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_SYS_MONO_NICAM_10DB  12
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_SYS_MONO_NICAM_6DB   11
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_SYS_RSVD             0
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_SYS_SCAN             8
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_SYS_WIDE_SCAN        10
+/* ATV_STATUS command, AUDIO_DEMOD_MODE field definition (address 9, size 2, lsb 4, unsigned)*/
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_LSB         4
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_MASK        0x03
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_AM   1
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_FM1  2
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_FM2  3
+#define Si2177_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_SIF  0
+#endif /* __SI2177__ */
+
+/* Si2158_CONFIG_CLOCKS command definition */
+#define Si2158_CONFIG_CLOCKS_CMD 0xc0
+
+#define Si2158_CONFIG_CLOCKS_CMD_CODE 0x0100c0
+
+typedef struct { /* Si2158_CONFIG_CLOCKS_CMD_struct */
+	u8   subcode;
+	u8   clock_mode;
+	u8   en_xout;
+} Si2158_CONFIG_CLOCKS_CMD_struct;
+
+typedef struct { /* Si2158_CONFIG_CLOCKS_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+}  Si2158_CONFIG_CLOCKS_CMD_REPLY_struct;
+
+/* CONFIG_CLOCKS command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2158_CONFIG_CLOCKS_CMD_SUBCODE_LSB         0
+#define Si2158_CONFIG_CLOCKS_CMD_SUBCODE_MASK        0xff
+#define Si2158_CONFIG_CLOCKS_CMD_SUBCODE_MIN         0
+#define Si2158_CONFIG_CLOCKS_CMD_SUBCODE_MAX         0
+#define Si2158_CONFIG_CLOCKS_CMD_SUBCODE_CODE  0
+/* CONFIG_CLOCKS command, CLOCK_MODE field definition (address 2,size 2, lsb 0, unsigned) */
+#define Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_LSB         0
+#define Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_MASK        0x03
+#define Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_MIN         0
+#define Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_MAX         2
+#define Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_EXTCLK  2
+#define Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_XTAL    0
+/* CONFIG_CLOCKS command, EN_XOUT field definition (address 2,size 3, lsb 2, unsigned) */
+#define Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_LSB         2
+#define Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_MASK        0x07
+#define Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_MIN         0
+#define Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_MAX         3
+#define Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_DIS_XOUT  0
+#define Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_EN_XOUT   3
+
+#ifdef __SI2177__
+/* Si2177_CONFIG_I2C command definition */
+#define Si2177_CONFIG_I2C_CMD 0xc0
+
+#define Si2177_CONFIG_I2C_CMD_CODE 0x0200c0
+
+typedef struct { /* Si2177_CONFIG_I2C_CMD_struct */
+	u8   subcode;
+	u8   i2c_broadcast;
+} Si2177_CONFIG_I2C_CMD_struct;
+
+
+typedef struct { /* Si2177_CONFIG_I2C_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+}  Si2177_CONFIG_I2C_CMD_REPLY_struct;
+
+/* CONFIG_I2C command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2177_CONFIG_I2C_CMD_SUBCODE_LSB         0
+#define Si2177_CONFIG_I2C_CMD_SUBCODE_MASK        0xff
+#define Si2177_CONFIG_I2C_CMD_SUBCODE_MIN         36
+#define Si2177_CONFIG_I2C_CMD_SUBCODE_MAX         36
+#define Si2177_CONFIG_I2C_CMD_SUBCODE_CODE  36
+/* CONFIG_I2C command, I2C_BROADCAST field definition (address 2,size 2, lsb 0, unsigned) */
+#define Si2177_CONFIG_I2C_CMD_I2C_BROADCAST_LSB         0
+#define Si2177_CONFIG_I2C_CMD_I2C_BROADCAST_MASK        0x03
+#define Si2177_CONFIG_I2C_CMD_I2C_BROADCAST_MIN         0
+#define Si2177_CONFIG_I2C_CMD_I2C_BROADCAST_MAX         1
+#define Si2177_CONFIG_I2C_CMD_I2C_BROADCAST_DISABLED  0
+#define Si2177_CONFIG_I2C_CMD_I2C_BROADCAST_ENABLED   1
+#endif /* __SI2177__ */
+
+/* Si2158_CONFIG_PINS command definition */
+#define Si2158_CONFIG_PINS_CMD 0x12
+
+#define Si2158_CONFIG_PINS_CMD_CODE 0x010012
+
+typedef struct { /* Si2158_CONFIG_PINS_CMD_struct */
+	u8   gpio1_mode;
+	u8   gpio1_read;
+	u8   gpio2_mode;
+	u8   gpio2_read;
+	u8   reserved1;
+	u8   reserved2;
+	u8   reserved3;
+} Si2158_CONFIG_PINS_CMD_struct;
+
+
+typedef struct { /* Si2158_CONFIG_PINS_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+	u8   gpio1_mode;
+	u8   gpio1_state;
+	u8   gpio2_mode;
+	u8   gpio2_state;
+	u8   reserved1;
+	u8   reserved2;
+	u8   reserved3;
+}  Si2158_CONFIG_PINS_CMD_REPLY_struct;
+
+/* CONFIG_PINS command, GPIO1_MODE field definition (address 1,size 7, lsb 0, unsigned) */
+#define Si2158_CONFIG_PINS_CMD_GPIO1_MODE_LSB         0
+#define Si2158_CONFIG_PINS_CMD_GPIO1_MODE_MASK        0x7f
+#define Si2158_CONFIG_PINS_CMD_GPIO1_MODE_MIN         0
+#define Si2158_CONFIG_PINS_CMD_GPIO1_MODE_MAX         3
+#define Si2158_CONFIG_PINS_CMD_GPIO1_MODE_DISABLE    1
+#define Si2158_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_0    2
+#define Si2158_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_1    3
+#define Si2158_CONFIG_PINS_CMD_GPIO1_MODE_NO_CHANGE  0
+/* CONFIG_PINS command, GPIO1_READ field definition (address 1,size 1, lsb 7, unsigned) */
+#define Si2158_CONFIG_PINS_CMD_GPIO1_READ_LSB         7
+#define Si2158_CONFIG_PINS_CMD_GPIO1_READ_MASK        0x01
+#define Si2158_CONFIG_PINS_CMD_GPIO1_READ_MIN         0
+#define Si2158_CONFIG_PINS_CMD_GPIO1_READ_MAX         1
+#define Si2158_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ  0
+#define Si2158_CONFIG_PINS_CMD_GPIO1_READ_READ         1
+/* CONFIG_PINS command, GPIO2_MODE field definition (address 2,size 7, lsb 0, unsigned) */
+#define Si2158_CONFIG_PINS_CMD_GPIO2_MODE_LSB         0
+#define Si2158_CONFIG_PINS_CMD_GPIO2_MODE_MASK        0x7f
+#define Si2158_CONFIG_PINS_CMD_GPIO2_MODE_MIN         0
+#define Si2158_CONFIG_PINS_CMD_GPIO2_MODE_MAX         3
+#define Si2158_CONFIG_PINS_CMD_GPIO2_MODE_DISABLE    1
+#define Si2158_CONFIG_PINS_CMD_GPIO2_MODE_DRIVE_0    2
+#define Si2158_CONFIG_PINS_CMD_GPIO2_MODE_DRIVE_1    3
+#define Si2158_CONFIG_PINS_CMD_GPIO2_MODE_NO_CHANGE  0
+/* CONFIG_PINS command, GPIO2_READ field definition (address 2,size 1, lsb 7, unsigned) */
+#define Si2158_CONFIG_PINS_CMD_GPIO2_READ_LSB         7
+#define Si2158_CONFIG_PINS_CMD_GPIO2_READ_MASK        0x01
+#define Si2158_CONFIG_PINS_CMD_GPIO2_READ_MIN         0
+#define Si2158_CONFIG_PINS_CMD_GPIO2_READ_MAX         1
+#define Si2158_CONFIG_PINS_CMD_GPIO2_READ_DO_NOT_READ  0
+#define Si2158_CONFIG_PINS_CMD_GPIO2_READ_READ         1
+/* CONFIG_PINS command, RESERVED1 field definition (address 3,size 8, lsb 0, unsigned) */
+#define Si2158_CONFIG_PINS_CMD_RESERVED1_LSB         0
+#define Si2158_CONFIG_PINS_CMD_RESERVED1_MASK        0xff
+#define Si2158_CONFIG_PINS_CMD_RESERVED1_MIN         1
+#define Si2158_CONFIG_PINS_CMD_RESERVED1_MAX         1
+#define Si2158_CONFIG_PINS_CMD_RESERVED1_RESERVED  1
+/* CONFIG_PINS command, RESERVED2 field definition (address 4,size 8, lsb 0, unsigned) */
+#define Si2158_CONFIG_PINS_CMD_RESERVED2_LSB         0
+#define Si2158_CONFIG_PINS_CMD_RESERVED2_MASK        0xff
+#define Si2158_CONFIG_PINS_CMD_RESERVED2_MIN         1
+#define Si2158_CONFIG_PINS_CMD_RESERVED2_MAX         1
+#define Si2158_CONFIG_PINS_CMD_RESERVED2_RESERVED  1
+/* CONFIG_PINS command, RESERVED3 field definition (address 5,size 8, lsb 0, unsigned) */
+#define Si2158_CONFIG_PINS_CMD_RESERVED3_LSB         0
+#define Si2158_CONFIG_PINS_CMD_RESERVED3_MASK        0xff
+#define Si2158_CONFIG_PINS_CMD_RESERVED3_MIN         1
+#define Si2158_CONFIG_PINS_CMD_RESERVED3_MAX         1
+#define Si2158_CONFIG_PINS_CMD_RESERVED3_RESERVED  1
+/* CONFIG_PINS command, GPIO1_MODE field definition (address 1, size 7, lsb 0, unsigned)*/
+#define Si2158_CONFIG_PINS_RESPONSE_GPIO1_MODE_LSB         0
+#define Si2158_CONFIG_PINS_RESPONSE_GPIO1_MODE_MASK        0x7f
+#define Si2158_CONFIG_PINS_RESPONSE_GPIO1_MODE_DISABLE  1
+#define Si2158_CONFIG_PINS_RESPONSE_GPIO1_MODE_DRIVE_0  2
+#define Si2158_CONFIG_PINS_RESPONSE_GPIO1_MODE_DRIVE_1  3
+/* CONFIG_PINS command, GPIO1_STATE field definition (address 1, size 1, lsb 7, unsigned)*/
+#define Si2158_CONFIG_PINS_RESPONSE_GPIO1_STATE_LSB         7
+#define Si2158_CONFIG_PINS_RESPONSE_GPIO1_STATE_MASK        0x01
+#define Si2158_CONFIG_PINS_RESPONSE_GPIO1_STATE_READ_0  0
+#define Si2158_CONFIG_PINS_RESPONSE_GPIO1_STATE_READ_1  1
+/* CONFIG_PINS command, GPIO2_MODE field definition (address 2, size 7, lsb 0, unsigned)*/
+#define Si2158_CONFIG_PINS_RESPONSE_GPIO2_MODE_LSB         0
+#define Si2158_CONFIG_PINS_RESPONSE_GPIO2_MODE_MASK        0x7f
+#define Si2158_CONFIG_PINS_RESPONSE_GPIO2_MODE_DISABLE  1
+#define Si2158_CONFIG_PINS_RESPONSE_GPIO2_MODE_DRIVE_0  2
+#define Si2158_CONFIG_PINS_RESPONSE_GPIO2_MODE_DRIVE_1  3
+/* CONFIG_PINS command, GPIO2_STATE field definition (address 2, size 1, lsb 7, unsigned)*/
+#define Si2158_CONFIG_PINS_RESPONSE_GPIO2_STATE_LSB         7
+#define Si2158_CONFIG_PINS_RESPONSE_GPIO2_STATE_MASK        0x01
+#define Si2158_CONFIG_PINS_RESPONSE_GPIO2_STATE_READ_0  0
+#define Si2158_CONFIG_PINS_RESPONSE_GPIO2_STATE_READ_1  1
+/* CONFIG_PINS command, RESERVED1 field definition (address 3, size 8, lsb 0, unsigned)*/
+#define Si2158_CONFIG_PINS_RESPONSE_RESERVED1_LSB         0
+#define Si2158_CONFIG_PINS_RESPONSE_RESERVED1_MASK        0xff
+#define Si2158_CONFIG_PINS_RESPONSE_RESERVED1_RESERVED1_MIN  1
+#define Si2158_CONFIG_PINS_RESPONSE_RESERVED1_RESERVED1_MAX  1
+/* CONFIG_PINS command, RESERVED2 field definition (address 4, size 8, lsb 0, unsigned)*/
+#define Si2158_CONFIG_PINS_RESPONSE_RESERVED2_LSB         0
+#define Si2158_CONFIG_PINS_RESPONSE_RESERVED2_MASK        0xff
+#define Si2158_CONFIG_PINS_RESPONSE_RESERVED2_RESERVED2_MIN  1
+#define Si2158_CONFIG_PINS_RESPONSE_RESERVED2_RESERVED2_MAX  1
+/* CONFIG_PINS command, RESERVED3 field definition (address 5, size 8, lsb 0, unsigned)*/
+#define Si2158_CONFIG_PINS_RESPONSE_RESERVED3_LSB         0
+#define Si2158_CONFIG_PINS_RESPONSE_RESERVED3_MASK        0xff
+#define Si2158_CONFIG_PINS_RESPONSE_RESERVED3_RESERVED3_MIN  1
+#define Si2158_CONFIG_PINS_RESPONSE_RESERVED3_RESERVED3_MAX  1
+
+
+/* Si2158_DTV_RESTART command definition */
+#define Si2158_DTV_RESTART_CMD 0x61
+
+#define Si2158_DTV_RESTART_CMD_CODE 0x010061
+
+typedef struct { /* Si2158_DTV_RESTART_CMD_struct */
+	u8   nothing;
+} Si2158_DTV_RESTART_CMD_struct;
+
+typedef struct { /* Si2158_DTV_RESTART_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+}  Si2158_DTV_RESTART_CMD_REPLY_struct;
+
+
+/* Si2158_DTV_STATUS command definition */
+#define Si2158_DTV_STATUS_CMD 0x62
+
+#define Si2158_DTV_STATUS_CMD_CODE 0x010062
+
+typedef struct { /* Si2158_DTV_STATUS_CMD_struct */
+	u8   intack;
+} Si2158_DTV_STATUS_CMD_struct;
+
+typedef struct { /* Si2158_DTV_STATUS_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+	u8   chlint;
+	u8   chl;
+	u8   bw;
+	u8   modulation;
+}  Si2158_DTV_STATUS_CMD_REPLY_struct;
+
+/* DTV_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2158_DTV_STATUS_CMD_INTACK_LSB         0
+#define Si2158_DTV_STATUS_CMD_INTACK_MASK        0x01
+#define Si2158_DTV_STATUS_CMD_INTACK_MIN         0
+#define Si2158_DTV_STATUS_CMD_INTACK_MAX         1
+#define Si2158_DTV_STATUS_CMD_INTACK_CLEAR  1
+#define Si2158_DTV_STATUS_CMD_INTACK_OK     0
+/* DTV_STATUS command, CHLINT field definition (address 1, size 1, lsb 0, unsigned)*/
+#define Si2158_DTV_STATUS_RESPONSE_CHLINT_LSB         0
+#define Si2158_DTV_STATUS_RESPONSE_CHLINT_MASK        0x01
+#define Si2158_DTV_STATUS_RESPONSE_CHLINT_CHANGED    1
+#define Si2158_DTV_STATUS_RESPONSE_CHLINT_NO_CHANGE  0
+/* DTV_STATUS command, CHL field definition (address 2, size 1, lsb 0, unsigned)*/
+#define Si2158_DTV_STATUS_RESPONSE_CHL_LSB         0
+#define Si2158_DTV_STATUS_RESPONSE_CHL_MASK        0x01
+#define Si2158_DTV_STATUS_RESPONSE_CHL_CHANNEL     1
+#define Si2158_DTV_STATUS_RESPONSE_CHL_NO_CHANNEL  0
+/* DTV_STATUS command, BW field definition (address 3, size 4, lsb 0, unsigned)*/
+#define Si2158_DTV_STATUS_RESPONSE_BW_LSB         0
+#define Si2158_DTV_STATUS_RESPONSE_BW_MASK        0x0f
+#define Si2157_DTV_STATUS_RESPONSE_BW_BW_1P7MHZ  9
+#define Si2158_DTV_STATUS_RESPONSE_BW_BW_6MHZ  6
+#define Si2157_DTV_STATUS_RESPONSE_BW_BW_6P1MHZ  10
+#define Si2158_DTV_STATUS_RESPONSE_BW_BW_7MHZ  7
+#define Si2158_DTV_STATUS_RESPONSE_BW_BW_8MHZ  8
+/* DTV_STATUS command, MODULATION field definition (address 3, size 4, lsb 4, unsigned)*/
+#define Si2158_DTV_STATUS_RESPONSE_MODULATION_LSB         4
+#define Si2158_DTV_STATUS_RESPONSE_MODULATION_MASK        0x0f
+#define Si2158_DTV_STATUS_RESPONSE_MODULATION_ATSC    0
+#define Si2158_DTV_STATUS_RESPONSE_MODULATION_DTMB    6
+#define Si2158_DTV_STATUS_RESPONSE_MODULATION_DVBC    3
+#define Si2158_DTV_STATUS_RESPONSE_MODULATION_DVBT    2
+#define Si2158_DTV_STATUS_RESPONSE_MODULATION_ISDBC   5
+#define Si2158_DTV_STATUS_RESPONSE_MODULATION_ISDBT   4
+#define Si2158_DTV_STATUS_RESPONSE_MODULATION_QAM_US  1
+
+
+/* Si2158_EXIT_BOOTLOADER command definition */
+#define Si2158_EXIT_BOOTLOADER_CMD 0x01
+
+#define Si2158_EXIT_BOOTLOADER_CMD_CODE 0x010001
+
+typedef struct { /* Si2158_EXIT_BOOTLOADER_CMD_struct */
+	u8   func;
+	u8   ctsien;
+} Si2158_EXIT_BOOTLOADER_CMD_struct;
+
+
+typedef struct { /* Si2158_EXIT_BOOTLOADER_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+}  Si2158_EXIT_BOOTLOADER_CMD_REPLY_struct;
+
+/* EXIT_BOOTLOADER command, FUNC field definition (address 1,size 4, lsb 0, unsigned) */
+#define Si2158_EXIT_BOOTLOADER_CMD_FUNC_LSB         0
+#define Si2158_EXIT_BOOTLOADER_CMD_FUNC_MASK        0x0f
+#define Si2158_EXIT_BOOTLOADER_CMD_FUNC_MIN         0
+#define Si2158_EXIT_BOOTLOADER_CMD_FUNC_MAX         1
+#define Si2158_EXIT_BOOTLOADER_CMD_FUNC_BOOTLOADER  0
+#define Si2158_EXIT_BOOTLOADER_CMD_FUNC_TUNER       1
+/* EXIT_BOOTLOADER command, CTSIEN field definition (address 1,size 1, lsb 7, unsigned) */
+#define Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_LSB         7
+#define Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_MASK        0x01
+#define Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_MIN         0
+#define Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_MAX         1
+#define Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_OFF  0
+#define Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_ON   1
+
+/* Si2158_FINE_TUNE command definition */
+#define Si2158_FINE_TUNE_CMD 0x45
+
+#define Si2158_FINE_TUNE_CMD_CODE 0x010045
+
+typedef struct { /* Si2158_FINE_TUNE_CMD_struct */
+	u8  persistence;
+	u8  apply_to_lif;
+	s16 offset_500hz;
+} Si2158_FINE_TUNE_CMD_struct;
+
+typedef struct { /* Si2158_FINE_TUNE_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+}  Si2158_FINE_TUNE_CMD_REPLY_struct;
+
+/* FINE_TUNE command, PERSISTENCE field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2158_FINE_TUNE_CMD_PERSISTENCE_LSB         0
+#define Si2158_FINE_TUNE_CMD_PERSISTENCE_MASK        0x01
+#define Si2158_FINE_TUNE_CMD_PERSISTENCE_MIN         0
+#define Si2158_FINE_TUNE_CMD_PERSISTENCE_MAX         1
+#define Si2158_FINE_TUNE_CMD_PERSISTENCE_NON_PERSISTENT  0
+#define Si2158_FINE_TUNE_CMD_PERSISTENCE_PERSISTENT      1
+/* FINE_TUNE command, APPLY_TO_LIF field definition (address 1,size 1, lsb 1, unsigned) */
+#define Si2158_FINE_TUNE_CMD_APPLY_TO_LIF_LSB         1
+#define Si2158_FINE_TUNE_CMD_APPLY_TO_LIF_MASK        0x01
+#define Si2158_FINE_TUNE_CMD_APPLY_TO_LIF_MIN         0
+#define Si2158_FINE_TUNE_CMD_APPLY_TO_LIF_MAX         1
+#define Si2158_FINE_TUNE_CMD_APPLY_TO_LIF_APPLY_TO_LIF         1
+#define Si2158_FINE_TUNE_CMD_APPLY_TO_LIF_DO_NOT_APPLY_TO_LIF  0
+/* FINE_TUNE command, OFFSET_500HZ field definition (address 2,size 16, lsb 0, signed) */
+#define Si2158_FINE_TUNE_CMD_OFFSET_500HZ_LSB         0
+#define Si2158_FINE_TUNE_CMD_OFFSET_500HZ_MASK        0xffff
+#define Si2158_FINE_TUNE_CMD_OFFSET_500HZ_SHIFT       16
+#define Si2158_FINE_TUNE_CMD_OFFSET_500HZ_MIN         -4000
+#define Si2158_FINE_TUNE_CMD_OFFSET_500HZ_MAX         4000
+#define Si2158_FINE_TUNE_CMD_OFFSET_500HZ_OFFSET_500HZ_MIN  -4000
+#define Si2158_FINE_TUNE_CMD_OFFSET_500HZ_OFFSET_500HZ_MAX  4000
+
+/* Si2158_GET_PROPERTY command definition */
+#define Si2158_GET_PROPERTY_CMD 0x15
+
+#define Si2158_GET_PROPERTY_CMD_CODE 0x010015
+
+typedef struct { /* Si2158_GET_PROPERTY_CMD_struct */
+	u8  reserved;
+	u16 prop;
+} Si2158_GET_PROPERTY_CMD_struct;
+
+typedef struct { /* Si2158_GET_PROPERTY_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+	u8  reserved;
+	u16 data;
+}  Si2158_GET_PROPERTY_CMD_REPLY_struct;
+
+/* GET_PROPERTY command, RESERVED field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2158_GET_PROPERTY_CMD_RESERVED_LSB         0
+#define Si2158_GET_PROPERTY_CMD_RESERVED_MASK        0xff
+#define Si2158_GET_PROPERTY_CMD_RESERVED_MIN         0
+#define Si2158_GET_PROPERTY_CMD_RESERVED_MAX         0
+#define Si2158_GET_PROPERTY_CMD_RESERVED_RESERVED_MIN  0
+#define Si2158_GET_PROPERTY_CMD_RESERVED_RESERVED_MAX  0
+/* GET_PROPERTY command, PROP field definition (address 2,size 16, lsb 0, unsigned) */
+#define Si2158_GET_PROPERTY_CMD_PROP_LSB         0
+#define Si2158_GET_PROPERTY_CMD_PROP_MASK        0xffff
+#define Si2158_GET_PROPERTY_CMD_PROP_MIN         0
+#define Si2158_GET_PROPERTY_CMD_PROP_MAX         65535
+#define Si2158_GET_PROPERTY_CMD_PROP_PROP_MIN  0
+#define Si2158_GET_PROPERTY_CMD_PROP_PROP_MAX  65535
+/* GET_PROPERTY command, RESERVED field definition (address 1, size 8, lsb 0, unsigned)*/
+#define Si2158_GET_PROPERTY_RESPONSE_RESERVED_LSB         0
+#define Si2158_GET_PROPERTY_RESPONSE_RESERVED_MASK        0xff
+/* GET_PROPERTY command, DATA field definition (address 2, size 16, lsb 0, unsigned)*/
+#define Si2158_GET_PROPERTY_RESPONSE_DATA_LSB         0
+#define Si2158_GET_PROPERTY_RESPONSE_DATA_MASK        0xffff
+
+
+/* Si2158_GET_REV command definition */
+#define Si2158_GET_REV_CMD 0x11
+
+#define Si2158_GET_REV_CMD_CODE 0x010011
+
+typedef struct { /* Si2158_GET_REV_CMD_struct */
+	u8   nothing;
+} Si2158_GET_REV_CMD_struct;
+
+
+typedef struct { /* Si2158_GET_REV_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+	u8   pn;
+	u8   fwmajor;
+	u8   fwminor;
+	u16  patch;
+	u8   cmpmajor;
+	u8   cmpminor;
+	u8   cmpbuild;
+	u8   chiprev;
+}  Si2158_GET_REV_CMD_REPLY_struct;
+
+/* GET_REV command, PN field definition (address 1, size 8, lsb 0, unsigned)*/
+#define Si2158_GET_REV_RESPONSE_PN_LSB         0
+#define Si2158_GET_REV_RESPONSE_PN_MASK        0xff
+/* GET_REV command, FWMAJOR field definition (address 2, size 8, lsb 0, unsigned)*/
+#define Si2158_GET_REV_RESPONSE_FWMAJOR_LSB         0
+#define Si2158_GET_REV_RESPONSE_FWMAJOR_MASK        0xff
+/* GET_REV command, FWMINOR field definition (address 3, size 8, lsb 0, unsigned)*/
+#define Si2158_GET_REV_RESPONSE_FWMINOR_LSB         0
+#define Si2158_GET_REV_RESPONSE_FWMINOR_MASK        0xff
+/* GET_REV command, PATCH field definition (address 4, size 16, lsb 0, unsigned)*/
+#define Si2158_GET_REV_RESPONSE_PATCH_LSB         0
+#define Si2158_GET_REV_RESPONSE_PATCH_MASK        0xffff
+/* GET_REV command, CMPMAJOR field definition (address 6, size 8, lsb 0, unsigned)*/
+#define Si2158_GET_REV_RESPONSE_CMPMAJOR_LSB         0
+#define Si2158_GET_REV_RESPONSE_CMPMAJOR_MASK        0xff
+/* GET_REV command, CMPMINOR field definition (address 7, size 8, lsb 0, unsigned)*/
+#define Si2158_GET_REV_RESPONSE_CMPMINOR_LSB         0
+#define Si2158_GET_REV_RESPONSE_CMPMINOR_MASK        0xff
+/* GET_REV command, CMPBUILD field definition (address 8, size 8, lsb 0, unsigned)*/
+#define Si2158_GET_REV_RESPONSE_CMPBUILD_LSB         0
+#define Si2158_GET_REV_RESPONSE_CMPBUILD_MASK        0xff
+#define Si2158_GET_REV_RESPONSE_CMPBUILD_CMPBUILD_MIN  0
+#define Si2158_GET_REV_RESPONSE_CMPBUILD_CMPBUILD_MAX  255
+/* GET_REV command, CHIPREV field definition (address 9, size 4, lsb 0, unsigned)*/
+#define Si2158_GET_REV_RESPONSE_CHIPREV_LSB         0
+#define Si2158_GET_REV_RESPONSE_CHIPREV_MASK        0x0f
+#define Si2158_GET_REV_RESPONSE_CHIPREV_A  1
+#define Si2158_GET_REV_RESPONSE_CHIPREV_B  2
+
+
+/* Si2158_PART_INFO command definition */
+#define Si2158_PART_INFO_CMD 0x02
+
+#define Si2158_PART_INFO_CMD_CODE 0x010002
+
+typedef struct { /* Si2158_PART_INFO_CMD_struct */
+	u8   nothing;
+} Si2158_PART_INFO_CMD_struct;
+
+
+typedef struct { /* Si2158_PART_INFO_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+	u8   chiprev;
+	u8   romid;
+	u8   part;
+	u8   pmajor;
+	u8   pminor;
+	u8   pbuild;
+	u16  reserved;
+	u32  serial;
+}  Si2158_PART_INFO_CMD_REPLY_struct;
+
+/* PART_INFO command, CHIPREV field definition (address 1, size 4, lsb 0, unsigned)*/
+#define Si2158_PART_INFO_RESPONSE_CHIPREV_LSB         0
+#define Si2158_PART_INFO_RESPONSE_CHIPREV_MASK        0x0f
+#define Si2158_PART_INFO_RESPONSE_CHIPREV_A  1
+#define Si2158_PART_INFO_RESPONSE_CHIPREV_B  2
+/* PART_INFO command, ROMID field definition (address 12, size 8, lsb 0, unsigned)*/
+#define Si2158_PART_INFO_RESPONSE_ROMID_LSB         0
+#define Si2158_PART_INFO_RESPONSE_ROMID_MASK        0xff
+/* PART_INFO command, PART field definition (address 2, size 8, lsb 0, unsigned)*/
+#define Si2158_PART_INFO_RESPONSE_PART_LSB         0
+#define Si2158_PART_INFO_RESPONSE_PART_MASK        0xff
+/* PART_INFO command, PMAJOR field definition (address 3, size 8, lsb 0, unsigned)*/
+#define Si2158_PART_INFO_RESPONSE_PMAJOR_LSB         0
+#define Si2158_PART_INFO_RESPONSE_PMAJOR_MASK        0xff
+/* PART_INFO command, PMINOR field definition (address 4, size 8, lsb 0, unsigned)*/
+#define Si2158_PART_INFO_RESPONSE_PMINOR_LSB         0
+#define Si2158_PART_INFO_RESPONSE_PMINOR_MASK        0xff
+/* PART_INFO command, PBUILD field definition (address 5, size 8, lsb 0, unsigned)*/
+#define Si2158_PART_INFO_RESPONSE_PBUILD_LSB         0
+#define Si2158_PART_INFO_RESPONSE_PBUILD_MASK        0xff
+/* PART_INFO command, RESERVED field definition (address 6, size 16, lsb 0, unsigned)*/
+#define Si2158_PART_INFO_RESPONSE_RESERVED_LSB         0
+#define Si2158_PART_INFO_RESPONSE_RESERVED_MASK        0xffff
+/* PART_INFO command, SERIAL field definition (address 8, size 32, lsb 0, unsigned)*/
+#define Si2158_PART_INFO_RESPONSE_SERIAL_LSB         0
+#define Si2158_PART_INFO_RESPONSE_SERIAL_MASK        0xffffffff
+
+
+/* Si2158_POWER_DOWN command definition */
+#define Si2158_POWER_DOWN_CMD 0x13
+
+#define Si2158_POWER_DOWN_CMD_CODE 0x010013
+
+typedef struct { /* Si2158_POWER_DOWN_CMD_struct */
+	u8   nothing;
+} Si2158_POWER_DOWN_CMD_struct;
+
+
+typedef struct { /* Si2158_POWER_DOWN_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+}  Si2158_POWER_DOWN_CMD_REPLY_struct;
+
+
+/* Si2158_POWER_DOWN_HW command definition */
+#define Si2158_POWER_DOWN_HW_CMD 0xc0
+
+#define Si2158_POWER_DOWN_HW_CMD_CODE 0x0200c0
+
+typedef struct { /* Si2158_POWER_DOWN_HW_CMD_struct */
+	u8   subcode;
+	u8   pd_xo_osc;
+	u8   reserved1;
+	u8   en_xout;
+	u8   reserved2;
+	u8   pd_ldo;
+	u8   reserved3;
+	u8   reserved4;
+	u8   reserved5;
+	u8   reserved6;
+	u8   reserved7;
+	u8   reserved8;
+} Si2158_POWER_DOWN_HW_CMD_struct;
+
+typedef struct { /* Si2158_POWER_DOWN_HW_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+}  Si2158_POWER_DOWN_HW_CMD_REPLY_struct;
+
+/* POWER_DOWN_HW command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2158_POWER_DOWN_HW_CMD_SUBCODE_LSB         0
+#define Si2158_POWER_DOWN_HW_CMD_SUBCODE_MASK        0xff
+#define Si2158_POWER_DOWN_HW_CMD_SUBCODE_MIN         0
+#define Si2158_POWER_DOWN_HW_CMD_SUBCODE_MAX         0
+#define Si2158_POWER_DOWN_HW_CMD_SUBCODE_CODE  0
+/* POWER_DOWN_HW command, PD_XO_OSC field definition (address 2,size 1, lsb 0, unsigned) */
+#define Si2158_POWER_DOWN_HW_CMD_PD_XO_OSC_LSB         0
+#define Si2158_POWER_DOWN_HW_CMD_PD_XO_OSC_MASK        0x01
+#define Si2158_POWER_DOWN_HW_CMD_PD_XO_OSC_MIN         0
+#define Si2158_POWER_DOWN_HW_CMD_PD_XO_OSC_MAX         1
+#define Si2158_POWER_DOWN_HW_CMD_PD_XO_OSC_XO_OSC_POWER_DOWN  1
+#define Si2158_POWER_DOWN_HW_CMD_PD_XO_OSC_XO_OSC_POWER_UP    0
+/* POWER_DOWN_HW command, RESERVED1 field definition (address 2,size 1, lsb 1, unsigned) */
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED1_LSB         1
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED1_MASK        0x01
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED1_MIN         0
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED1_MAX         0
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED1_RESERVED  0
+/* POWER_DOWN_HW command, EN_XOUT field definition (address 2,size 3, lsb 2, unsigned) */
+#define Si2158_POWER_DOWN_HW_CMD_EN_XOUT_LSB         2
+#define Si2158_POWER_DOWN_HW_CMD_EN_XOUT_MASK        0x07
+#define Si2158_POWER_DOWN_HW_CMD_EN_XOUT_MIN         0
+#define Si2158_POWER_DOWN_HW_CMD_EN_XOUT_MAX         3
+#define Si2158_POWER_DOWN_HW_CMD_EN_XOUT_DIS_XOUT  0
+#define Si2158_POWER_DOWN_HW_CMD_EN_XOUT_EN_XOUT   3
+/* POWER_DOWN_HW command, RESERVED2 field definition (address 2,size 4, lsb 4, unsigned) */
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED2_LSB         5
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED2_MASK        0x07
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED2_MIN         1
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED2_MAX         1
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED2_RESERVED  1
+/* POWER_DOWN_HW command, PD_LDO field definition (address 3,size 1, lsb 0, unsigned) */
+#define Si2158_POWER_DOWN_HW_CMD_PD_LDO_LSB         0
+#define Si2158_POWER_DOWN_HW_CMD_PD_LDO_MASK        0x01
+#define Si2158_POWER_DOWN_HW_CMD_PD_LDO_MIN         0
+#define Si2158_POWER_DOWN_HW_CMD_PD_LDO_MAX         1
+#define Si2158_POWER_DOWN_HW_CMD_PD_LDO_LDO_POWER_DOWN  1
+#define Si2158_POWER_DOWN_HW_CMD_PD_LDO_LDO_POWER_UP    0
+/* POWER_DOWN_HW command, RESERVED3 field definition (address 4,size 8, lsb 0, unsigned) */
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED3_LSB         0
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED3_MASK        0xff
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED3_MIN         0
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED3_MAX         0
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED3_RESERVED  0
+/* POWER_DOWN_HW command, RESERVED4 field definition (address 5,size 8, lsb 0, unsigned) */
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED4_LSB         0
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED4_MASK        0xff
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED4_MIN         1
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED4_MAX         1
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED4_RESERVED  1
+/* POWER_DOWN_HW command, RESERVED5 field definition (address 6,size 8, lsb 0, unsigned) */
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED5_LSB         0
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED5_MASK        0xff
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED5_MIN         0
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED5_MAX         0
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED5_RESERVED  0
+/* POWER_DOWN_HW command, RESERVED6 field definition (address 7,size 8, lsb 0, unsigned) */
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED6_LSB         0
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED6_MASK        0xff
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED6_MIN         0
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED6_MAX         0
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED6_RESERVED  0
+/* POWER_DOWN_HW command, RESERVED7 field definition (address 8,size 8, lsb 0, unsigned) */
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED7_LSB         0
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED7_MASK        0xff
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED7_MIN         0
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED7_MAX         0
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED7_RESERVED  0
+/* POWER_DOWN_HW command, RESERVED8 field definition (address 9,size 8, lsb 0, unsigned) */
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED8_LSB         0
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED8_MASK        0xff
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED8_MIN         0
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED8_MAX         0
+#define Si2158_POWER_DOWN_HW_CMD_RESERVED8_RESERVED  0
+
+/* Si2158_POWER_UP command definition */
+#define Si2158_POWER_UP_CMD 0xc0
+
+#define Si2158_POWER_UP_CMD_CODE 0x0300c0
+
+typedef struct { /* Si2158_POWER_UP_CMD_struct */
+	u8   subcode;
+//	u8   clock_mode;
+//	u8   en_xout;
+	u8   pd_ldo;
+	u8   reserved2;
+	u8   reserved3;
+	u8   reserved4;
+	u8   reserved5;
+	u8   reserved6;
+	u8   reserved7;
+	u8   reset;
+	u8   clock_freq;
+	u8   reserved8;
+	u8   func;
+#ifndef __SI2158__
+	u8   reserved9;
+#endif /* __SI2158__ */
+	u8   ctsien;
+	u8   wake_up;
+} Si2158_POWER_UP_CMD_struct;
+
+
+typedef struct { /* Si2158_POWER_UP_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+}  Si2158_POWER_UP_CMD_REPLY_struct;
+
+/* POWER_UP command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2158_POWER_UP_CMD_SUBCODE_LSB         0
+#define Si2158_POWER_UP_CMD_SUBCODE_MASK        0xff
+#define Si2158_POWER_UP_CMD_SUBCODE_MIN         0
+#define Si2158_POWER_UP_CMD_SUBCODE_MAX         0
+#define Si2158_POWER_UP_CMD_SUBCODE_CODE  0
+/* POWER_UP command, CLOCK_MODE field definition (address 2,size 2, lsb 0, unsigned) */
+#define Si2158_POWER_UP_CMD_CLOCK_MODE_LSB         0
+#define Si2158_POWER_UP_CMD_CLOCK_MODE_MASK        0x03
+#define Si2158_POWER_UP_CMD_CLOCK_MODE_MIN         0
+#define Si2158_POWER_UP_CMD_CLOCK_MODE_MAX         2
+#define Si2158_POWER_UP_CMD_CLOCK_MODE_EXTCLK  2
+#define Si2158_POWER_UP_CMD_CLOCK_MODE_XTAL    0
+/* POWER_UP command, EN_XOUT field definition (address 2,size 3, lsb 2, unsigned) */
+#define Si2158_POWER_UP_CMD_EN_XOUT_LSB         2
+#define Si2158_POWER_UP_CMD_EN_XOUT_MASK        0x07
+#define Si2158_POWER_UP_CMD_EN_XOUT_MIN         0
+#define Si2158_POWER_UP_CMD_EN_XOUT_MAX         3
+#define Si2158_POWER_UP_CMD_EN_XOUT_DIS_XOUT  0
+#define Si2158_POWER_UP_CMD_EN_XOUT_EN_XOUT   3
+/* POWER_UP command, PD_LDO field definition (address 3,size 1, lsb 0, unsigned) */
+#define Si2158_POWER_UP_CMD_PD_LDO_LSB         0
+#define Si2158_POWER_UP_CMD_PD_LDO_MASK        0x01
+#define Si2158_POWER_UP_CMD_PD_LDO_MIN         0
+#define Si2158_POWER_UP_CMD_PD_LDO_MAX         1
+#define Si2158_POWER_UP_CMD_PD_LDO_LDO_POWER_DOWN  1
+#define Si2158_POWER_UP_CMD_PD_LDO_LDO_POWER_UP    0
+/* POWER_UP command, RESERVED2 field definition (address 4,size 8, lsb 0, unsigned) */
+#define Si2158_POWER_UP_CMD_RESERVED2_LSB         0
+#define Si2158_POWER_UP_CMD_RESERVED2_MASK        0xff
+#define Si2158_POWER_UP_CMD_RESERVED2_MIN         0
+#define Si2158_POWER_UP_CMD_RESERVED2_MAX         0
+#define Si2158_POWER_UP_CMD_RESERVED2_RESERVED  0
+/* POWER_UP command, RESERVED3 field definition (address 5,size 8, lsb 0, unsigned) */
+#define Si2158_POWER_UP_CMD_RESERVED3_LSB         0
+#define Si2158_POWER_UP_CMD_RESERVED3_MASK        0xff
+#define Si2158_POWER_UP_CMD_RESERVED3_MIN         1
+#define Si2158_POWER_UP_CMD_RESERVED3_MAX         1
+#define Si2158_POWER_UP_CMD_RESERVED3_RESERVED  1
+/* POWER_UP command, RESERVED4 field definition (address 6,size 8, lsb 0, unsigned) */
+#define Si2158_POWER_UP_CMD_RESERVED4_LSB         0
+#define Si2158_POWER_UP_CMD_RESERVED4_MASK        0xff
+#define Si2158_POWER_UP_CMD_RESERVED4_MIN         1
+#define Si2158_POWER_UP_CMD_RESERVED4_MAX         1
+#define Si2158_POWER_UP_CMD_RESERVED4_RESERVED  1
+/* POWER_UP command, RESERVED5 field definition (address 7,size 8, lsb 0, unsigned) */
+#define Si2158_POWER_UP_CMD_RESERVED5_LSB         0
+#define Si2158_POWER_UP_CMD_RESERVED5_MASK        0xff
+#define Si2158_POWER_UP_CMD_RESERVED5_MIN         1
+#define Si2158_POWER_UP_CMD_RESERVED5_MAX         1
+#define Si2158_POWER_UP_CMD_RESERVED5_RESERVED  1
+/* POWER_UP command, RESERVED6 field definition (address 8,size 8, lsb 0, unsigned) */
+#define Si2158_POWER_UP_CMD_RESERVED6_LSB         0
+#define Si2158_POWER_UP_CMD_RESERVED6_MASK        0xff
+#define Si2158_POWER_UP_CMD_RESERVED6_MIN         1
+#define Si2158_POWER_UP_CMD_RESERVED6_MAX         1
+#define Si2158_POWER_UP_CMD_RESERVED6_RESERVED  1
+/* POWER_UP command, RESERVED7 field definition (address 9,size 8, lsb 0, unsigned) */
+#define Si2158_POWER_UP_CMD_RESERVED7_LSB         0
+#define Si2158_POWER_UP_CMD_RESERVED7_MASK        0xff
+#define Si2158_POWER_UP_CMD_RESERVED7_MIN         1
+#define Si2158_POWER_UP_CMD_RESERVED7_MAX         1
+#define Si2158_POWER_UP_CMD_RESERVED7_RESERVED  1
+/* POWER_UP command, RESET field definition (address 10,size 8, lsb 0, unsigned) */
+#define Si2158_POWER_UP_CMD_RESET_LSB         0
+#define Si2158_POWER_UP_CMD_RESET_MASK        0xff
+#define Si2158_POWER_UP_CMD_RESET_MIN         1
+#define Si2158_POWER_UP_CMD_RESET_MAX         1
+#define Si2158_POWER_UP_CMD_RESET_RESET  1
+/* POWER_UP command, CLOCK_FREQ field definition (address 11,size 2, lsb 0, unsigned) */
+#define Si2158_POWER_UP_CMD_CLOCK_FREQ_LSB         0
+#define Si2158_POWER_UP_CMD_CLOCK_FREQ_MASK        0x03
+#define Si2158_POWER_UP_CMD_CLOCK_FREQ_MIN         0
+#define Si2158_POWER_UP_CMD_CLOCK_FREQ_MAX         3
+#define Si2158_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ  2
+/* POWER_UP command, RESERVED8 field definition (address 12,size 8, lsb 0, unsigned) */
+#define Si2158_POWER_UP_CMD_RESERVED8_LSB         0
+#define Si2158_POWER_UP_CMD_RESERVED8_MASK        0xff
+#define Si2158_POWER_UP_CMD_RESERVED8_MIN         0
+#define Si2158_POWER_UP_CMD_RESERVED8_MAX         0
+#define Si2158_POWER_UP_CMD_RESERVED8_RESERVED  0
+/* POWER_UP command, FUNC field definition (address 13,size 4, lsb 0, unsigned) */
+#define Si2158_POWER_UP_CMD_FUNC_LSB         0
+#define Si2158_POWER_UP_CMD_FUNC_MASK        0x07
+#define Si2158_POWER_UP_CMD_FUNC_MIN         0
+#define Si2158_POWER_UP_CMD_FUNC_MAX         1
+#define Si2158_POWER_UP_CMD_FUNC_BOOTLOADER  0
+#define Si2158_POWER_UP_CMD_FUNC_NORMAL      1
+#ifdef __SI2157__
+/* POWER_UP command, RESERVED9 field definition (address 13,size 4, lsb 3, unsigned) */
+#define Si2157_POWER_UP_CMD_RESERVED9_LSB         3
+#define Si2157_POWER_UP_CMD_RESERVED9_MASK        0x0f
+#define Si2157_POWER_UP_CMD_RESERVED9_MIN         0
+#define Si2157_POWER_UP_CMD_RESERVED9_MAX         0
+#define Si2157_POWER_UP_CMD_RESERVED9_RESERVED  0
+#endif /* __SI2157__ */
+/* POWER_UP command, CTSIEN field definition (address 13,size 1, lsb 7, unsigned) */
+#define Si2158_POWER_UP_CMD_CTSIEN_LSB         7
+#define Si2158_POWER_UP_CMD_CTSIEN_MASK        0x01
+#define Si2158_POWER_UP_CMD_CTSIEN_MIN         0
+#define Si2158_POWER_UP_CMD_CTSIEN_MAX         1
+#define Si2158_POWER_UP_CMD_CTSIEN_DISABLE  0
+#define Si2158_POWER_UP_CMD_CTSIEN_ENABLE   1
+/* POWER_UP command, WAKE_UP field definition (address 14,size 1, lsb 0, unsigned) */
+#define Si2158_POWER_UP_CMD_WAKE_UP_LSB         0
+#define Si2158_POWER_UP_CMD_WAKE_UP_MASK        0x01
+#define Si2158_POWER_UP_CMD_WAKE_UP_MIN         1
+#define Si2158_POWER_UP_CMD_WAKE_UP_MAX         1
+#define Si2158_POWER_UP_CMD_WAKE_UP_WAKE_UP  1
+
+/* Si2158_RAM_CRC command definition */
+#define Si2158_RAM_CRC_CMD 0x03
+
+#define Si2158_RAM_CRC_CMD_CODE 0x010003
+
+typedef struct { /* Si2158_RAM_CRC_CMD_struct */
+	u8   nothing;
+} Si2158_RAM_CRC_CMD_struct;
+
+typedef struct { /* Si2158_RAM_CRC_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+	u16 crc;
+}  Si2158_RAM_CRC_CMD_REPLY_struct;
+
+/* RAM_CRC command, CRC field definition (address 2, size 16, lsb 0, unsigned)*/
+#define Si2158_RAM_CRC_RESPONSE_CRC_LSB         0
+#define Si2158_RAM_CRC_RESPONSE_CRC_MASK        0xffff
+
+
+/* Si2158_SET_PROPERTY command definition */
+#define Si2158_SET_PROPERTY_CMD 0x14
+
+#define Si2158_SET_PROPERTY_CMD_CODE 0x010014
+
+typedef struct { /* Si2158_SET_PROPERTY_CMD_struct */
+	u8  reserved;
+	u16 prop;
+	u16 data;
+} Si2158_SET_PROPERTY_CMD_struct;
+
+typedef struct { /* Si2158_SET_PROPERTY_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+	u8  reserved;
+	u16 data;
+}  Si2158_SET_PROPERTY_CMD_REPLY_struct;
+
+/* SET_PROPERTY command, RESERVED field definition (address 1,size 8, lsb 0, unsigned) */
+#define Si2158_SET_PROPERTY_CMD_RESERVED_LSB         0
+#define Si2158_SET_PROPERTY_CMD_RESERVED_MASK        0xff
+#define Si2158_SET_PROPERTY_CMD_RESERVED_MIN         0
+#define Si2158_SET_PROPERTY_CMD_RESERVED_MAX         255.0
+/* SET_PROPERTY command, PROP field definition (address 2,size 16, lsb 0, unsigned) */
+#define Si2158_SET_PROPERTY_CMD_PROP_LSB         0
+#define Si2158_SET_PROPERTY_CMD_PROP_MASK        0xffff
+#define Si2158_SET_PROPERTY_CMD_PROP_MIN         0
+#define Si2158_SET_PROPERTY_CMD_PROP_MAX         65535
+#define Si2158_SET_PROPERTY_CMD_PROP_PROP_MIN  0
+#define Si2158_SET_PROPERTY_CMD_PROP_PROP_MAX  65535
+/* SET_PROPERTY command, DATA field definition (address 4,size 16, lsb 0, unsigned) */
+#define Si2158_SET_PROPERTY_CMD_DATA_LSB         0
+#define Si2158_SET_PROPERTY_CMD_DATA_MASK        0xffff
+#define Si2158_SET_PROPERTY_CMD_DATA_MIN         0
+#define Si2158_SET_PROPERTY_CMD_DATA_MAX         65535
+#define Si2158_SET_PROPERTY_CMD_DATA_DATA_MIN  0
+#define Si2158_SET_PROPERTY_CMD_DATA_DATA_MAX  65535
+/* SET_PROPERTY command, RESERVED field definition (address 1, size 8, lsb 0, unsigned)*/
+#define Si2158_SET_PROPERTY_RESPONSE_RESERVED_LSB         0
+#define Si2158_SET_PROPERTY_RESPONSE_RESERVED_MASK        0xff
+#define Si2158_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MIN  0
+#define Si2158_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MAX  0
+/* SET_PROPERTY command, DATA field definition (address 2, size 16, lsb 0, unsigned)*/
+#define Si2158_SET_PROPERTY_RESPONSE_DATA_LSB         0
+#define Si2158_SET_PROPERTY_RESPONSE_DATA_MASK        0xffff
+
+
+/* Si2158_STANDBY command definition */
+#define Si2158_STANDBY_CMD 0x16
+
+#define Si2158_STANDBY_CMD_CODE 0x010016
+
+typedef struct { /* Si2158_STANDBY_CMD_struct */
+	u8   type;
+} Si2158_STANDBY_CMD_struct;
+
+
+typedef struct { /* Si2158_STANDBY_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+}  Si2158_STANDBY_CMD_REPLY_struct;
+
+/* STANDBY command, TYPE field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2158_STANDBY_CMD_TYPE_LSB         0
+#define Si2158_STANDBY_CMD_TYPE_MASK        0x01
+#define Si2158_STANDBY_CMD_TYPE_MIN         0
+#define Si2158_STANDBY_CMD_TYPE_MAX         1
+#define Si2158_STANDBY_CMD_TYPE_LNA_OFF  1
+#define Si2158_STANDBY_CMD_TYPE_LNA_ON   0
+
+/* Si2158_TUNER_STATUS command definition */
+#define Si2158_TUNER_STATUS_CMD 0x42
+
+#define Si2158_TUNER_STATUS_CMD_CODE 0x010042
+
+typedef struct { /* Si2158_TUNER_STATUS_CMD_struct */
+	u8   intack;
+} Si2158_TUNER_STATUS_CMD_struct;
+
+
+typedef struct { /* Si2158_TUNER_STATUS_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+	u8  tcint;
+	u8  rssilint;
+	u8  rssihint;
+	s16 vco_code;
+	u8  tc;
+	u8  rssil;
+	u8  rssih;
+	s8  rssi;
+	u32 freq;
+	u8  mode;
+}  Si2158_TUNER_STATUS_CMD_REPLY_struct;
+
+/* TUNER_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2158_TUNER_STATUS_CMD_INTACK_LSB         0
+#define Si2158_TUNER_STATUS_CMD_INTACK_MASK        0x01
+#define Si2158_TUNER_STATUS_CMD_INTACK_MIN         0
+#define Si2158_TUNER_STATUS_CMD_INTACK_MAX         1
+#define Si2158_TUNER_STATUS_CMD_INTACK_CLEAR  1
+#define Si2158_TUNER_STATUS_CMD_INTACK_OK     0
+/* TUNER_STATUS command, TCINT field definition (address 1, size 1, lsb 0, unsigned)*/
+#define Si2158_TUNER_STATUS_RESPONSE_TCINT_LSB         0
+#define Si2158_TUNER_STATUS_RESPONSE_TCINT_MASK        0x01
+#define Si2158_TUNER_STATUS_RESPONSE_TCINT_CHANGED    1
+#define Si2158_TUNER_STATUS_RESPONSE_TCINT_NO_CHANGE  0
+/* TUNER_STATUS command, RSSILINT field definition (address 1, size 1, lsb 1, unsigned)*/
+#define Si2158_TUNER_STATUS_RESPONSE_RSSILINT_LSB         1
+#define Si2158_TUNER_STATUS_RESPONSE_RSSILINT_MASK        0x01
+#define Si2158_TUNER_STATUS_RESPONSE_RSSILINT_CHANGED    1
+#define Si2158_TUNER_STATUS_RESPONSE_RSSILINT_NO_CHANGE  0
+/* TUNER_STATUS command, RSSIHINT field definition (address 1, size 1, lsb 2, unsigned)*/
+#define Si2158_TUNER_STATUS_RESPONSE_RSSIHINT_LSB         2
+#define Si2158_TUNER_STATUS_RESPONSE_RSSIHINT_MASK        0x01
+#define Si2158_TUNER_STATUS_RESPONSE_RSSIHINT_CHANGED    1
+#define Si2158_TUNER_STATUS_RESPONSE_RSSIHINT_NO_CHANGE  0
+/* TUNER_STATUS command, VCO_CODE field definition (address 10, size 16, lsb 0, signed)*/
+#define Si2158_TUNER_STATUS_RESPONSE_VCO_CODE_LSB         0
+#define Si2158_TUNER_STATUS_RESPONSE_VCO_CODE_MASK        0xffff
+#define Si2158_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT       16
+/* TUNER_STATUS command, TC field definition (address 2, size 1, lsb 0, unsigned)*/
+#define Si2158_TUNER_STATUS_RESPONSE_TC_LSB         0
+#define Si2158_TUNER_STATUS_RESPONSE_TC_MASK        0x01
+#define Si2158_TUNER_STATUS_RESPONSE_TC_BUSY  0
+#define Si2158_TUNER_STATUS_RESPONSE_TC_DONE  1
+/* TUNER_STATUS command, RSSIL field definition (address 2, size 1, lsb 1, unsigned)*/
+#define Si2158_TUNER_STATUS_RESPONSE_RSSIL_LSB         1
+#define Si2158_TUNER_STATUS_RESPONSE_RSSIL_MASK        0x01
+#define Si2158_TUNER_STATUS_RESPONSE_RSSIL_LOW  1
+#define Si2158_TUNER_STATUS_RESPONSE_RSSIL_OK   0
+/* TUNER_STATUS command, RSSIH field definition (address 2, size 1, lsb 2, unsigned)*/
+#define Si2158_TUNER_STATUS_RESPONSE_RSSIH_LSB         2
+#define Si2158_TUNER_STATUS_RESPONSE_RSSIH_MASK        0x01
+#define Si2158_TUNER_STATUS_RESPONSE_RSSIH_HIGH  1
+#define Si2158_TUNER_STATUS_RESPONSE_RSSIH_OK    0
+/* TUNER_STATUS command, RSSI field definition (address 3, size 8, lsb 0, signed)*/
+#define Si2158_TUNER_STATUS_RESPONSE_RSSI_LSB         0
+#define Si2158_TUNER_STATUS_RESPONSE_RSSI_MASK        0xff
+#define Si2158_TUNER_STATUS_RESPONSE_RSSI_SHIFT       24
+/* TUNER_STATUS command, FREQ field definition (address 4, size 32, lsb 0, unsigned)*/
+#define Si2158_TUNER_STATUS_RESPONSE_FREQ_LSB         0
+#define Si2158_TUNER_STATUS_RESPONSE_FREQ_MASK        0xffffffff
+/* TUNER_STATUS command, MODE field definition (address 8, size 1, lsb 0, unsigned)*/
+#define Si2158_TUNER_STATUS_RESPONSE_MODE_LSB         0
+#define Si2158_TUNER_STATUS_RESPONSE_MODE_MASK        0x01
+#define Si2158_TUNER_STATUS_RESPONSE_MODE_ATV  1
+#define Si2158_TUNER_STATUS_RESPONSE_MODE_DTV  0
+
+
+/* Si2158_TUNER_TUNE_FREQ command definition */
+#define Si2158_TUNER_TUNE_FREQ_CMD 0x41
+
+#define Si2158_TUNER_TUNE_FREQ_CMD_CODE 0x010041
+
+typedef struct { /* Si2158_TUNER_TUNE_FREQ_CMD_struct */
+	u8  mode;
+	u32 freq;
+} Si2158_TUNER_TUNE_FREQ_CMD_struct;
+
+
+typedef struct { /* Si2158_TUNER_TUNE_FREQ_CMD_REPLY_struct */
+	silabs_tercab_status * STATUS;
+}  Si2158_TUNER_TUNE_FREQ_CMD_REPLY_struct;
+
+/* TUNER_TUNE_FREQ command, MODE field definition (address 1,size 1, lsb 0, unsigned) */
+#define Si2158_TUNER_TUNE_FREQ_CMD_MODE_LSB         0
+#define Si2158_TUNER_TUNE_FREQ_CMD_MODE_MASK        0x01
+#define Si2158_TUNER_TUNE_FREQ_CMD_MODE_MIN         0
+#define Si2158_TUNER_TUNE_FREQ_CMD_MODE_MAX         1
+#define Si2158_TUNER_TUNE_FREQ_CMD_MODE_ATV  1
+#define Si2158_TUNER_TUNE_FREQ_CMD_MODE_DTV  0
+/* TUNER_TUNE_FREQ command, FREQ field definition (address 4,size 32, lsb 0, unsigned) */
+#define Si2158_TUNER_TUNE_FREQ_CMD_FREQ_LSB         0
+#define Si2158_TUNER_TUNE_FREQ_CMD_FREQ_MASK        0xffffffff
+#define Si2158_TUNER_TUNE_FREQ_CMD_FREQ_MIN         40000000
+#define Si2158_TUNER_TUNE_FREQ_CMD_FREQ_MAX         1002000000
+#define Si2158_TUNER_TUNE_FREQ_CMD_FREQ_FREQ_MIN  40000000
+#define Si2158_TUNER_TUNE_FREQ_CMD_FREQ_FREQ_MAX  1002000000
+
+/* _commands_reply_struct_insertion_point */
+
+#ifdef _DEBUG
+#define Si2158_GET_COMMAND_STRINGS
+#endif
+
+/* Si2158 ATV_AFC_RANGE property definition */
+#define Si2158_ATV_AFC_RANGE_PROP 0x0610
+
+#define Si2158_ATV_AFC_RANGE_PROP_CODE 0x000610
+
+typedef struct { /* Si2158_ATV_AFC_RANGE_PROP_struct */
+	u16 range_khz;
+} Si2158_ATV_AFC_RANGE_PROP_struct;
+
+/* ATV_AFC_RANGE property, RANGE_KHZ field definition (NO TITLE)*/
+#define Si2158_ATV_AFC_RANGE_PROP_RANGE_KHZ_LSB         0
+#define Si2158_ATV_AFC_RANGE_PROP_RANGE_KHZ_MASK        0xffff
+#define Si2158_ATV_AFC_RANGE_PROP_RANGE_KHZ_DEFAULT    1000
+#define Si2158_ATV_AFC_RANGE_PROP_RANGE_KHZ_RANGE_KHZ_MIN  0
+#define Si2158_ATV_AFC_RANGE_PROP_RANGE_KHZ_RANGE_KHZ_MAX  65535
+
+
+#ifdef __SI2177__
+/* Si2177 ATV_AF_OUT property definition */
+#define Si2177_ATV_AF_OUT_PROP 0x060b
+
+#define Si2177_ATV_AF_OUT_PROP_CODE 0x00060b
+
+
+typedef struct { /* Si2177_ATV_AF_OUT_PROP_struct */
+	u8   mute;
+	u8   volume;
+} Si2177_ATV_AF_OUT_PROP_struct;
+
+/* ATV_AF_OUT property, MUTE field definition (NO TITLE)*/
+#define Si2177_ATV_AF_OUT_PROP_MUTE_LSB         6
+#define Si2177_ATV_AF_OUT_PROP_MUTE_MASK        0x01
+#define Si2177_ATV_AF_OUT_PROP_MUTE_DEFAULT    0
+#define Si2177_ATV_AF_OUT_PROP_MUTE_NORMAL  0
+#define Si2177_ATV_AF_OUT_PROP_MUTE_MUTE    1
+
+/* ATV_AF_OUT property, VOLUME field definition (NO TITLE)*/
+#define Si2177_ATV_AF_OUT_PROP_VOLUME_LSB         0
+#define Si2177_ATV_AF_OUT_PROP_VOLUME_MASK        0x3f
+#define Si2177_ATV_AF_OUT_PROP_VOLUME_DEFAULT    0
+#define Si2177_ATV_AF_OUT_PROP_VOLUME_VOLUME_MIN  0
+#define Si2177_ATV_AF_OUT_PROP_VOLUME_VOLUME_MAX  63
+#endif /* __SI2177__ */
+
+/* Si2158 ATV_AGC_SPEED property definition */
+#define Si2158_ATV_AGC_SPEED_PROP 0x0611
+
+#define Si2158_ATV_AGC_SPEED_PROP_CODE 0x000611
+
+
+typedef struct { /* Si2158_ATV_AGC_SPEED_PROP_struct */
+	u8   if_agc_speed;
+} Si2158_ATV_AGC_SPEED_PROP_struct;
+
+/* ATV_AGC_SPEED property, IF_AGC_SPEED field definition (NO TITLE)*/
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB         0
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK        0xff
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_DEFAULT    0
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO    0
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_89      89
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_105     105
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_121     121
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_137     137
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_158     158
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_172     172
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_178     178
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_185     185
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_196     196
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_206     206
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_216     216
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_219     219
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_222     222
+#define Si2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_223     223
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_248     248
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_250     250
+#define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_251     251
+
+
+/* Si2158 ATV_AGC_SPEED_LOW_RSSI property definition */
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP 0x0623
+
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_CODE 0x000623
+
+
+typedef struct { /* Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_struct */
+	u8 if_agc_speed;
+	s8 thld;
+} Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_struct;
+
+/* ATV_AGC_SPEED_LOW_RSSI property, IF_AGC_SPEED field definition (NO TITLE)*/
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_LSB         0
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_MASK        0xff
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_DEFAULT    158
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_89      89
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_105     105
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_121     121
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_137     137
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_158     158
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_172     172
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_178     178
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_185     185
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_196     196
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_206     206
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_216     216
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_219     219
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_222     222
+#define Si2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_223     223
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_248     248
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_250     250
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_251     251
+
+/* ATV_AGC_SPEED_LOW_RSSI property, THLD field definition (NO TITLE)*/
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_LSB         8
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_MASK        0xff
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_DEFAULT    -128
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_THLD_MIN  -128
+#define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_THLD_MAX  127
+
+
+/* Si2158 ATV_ARTIFICIAL_SNOW property definition */
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP 0x0624
+
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_CODE 0x000624
+
+typedef struct { /* Si2158_ATV_ARTIFICIAL_SNOW_PROP_struct */
+	u8 gain;
+	s8 offset;
+	u8 period;
+	u8 sound;
+} Si2158_ATV_ARTIFICIAL_SNOW_PROP_struct;
+
+/* ATV_ARTIFICIAL_SNOW property, GAIN field definition (NO TITLE)*/
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_LSB         0
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_MASK        0x0f
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_DEFAULT    0
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_AUTO  0
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_0DB   1
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_6DB   2
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_12DB  3
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_18DB  4
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_24DB  5
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_30DB  6
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_36DB  7
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_42DB  8
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_OFF   9
+
+/* ATV_ARTIFICIAL_SNOW property, OFFSET field definition (NO TITLE)*/
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_LSB         8
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_MASK        0xff
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_DEFAULT    0
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_OFFSET_MIN  -128
+#define Si2158_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_OFFSET_MAX  127
+
+/* ATV_ARTIFICIAL_SNOW property, PERIOD field definition (NO TITLE)*/
+#define Si2177_ATV_ARTIFICIAL_SNOW_PROP_PERIOD_LSB         7
+#define Si2177_ATV_ARTIFICIAL_SNOW_PROP_PERIOD_MASK        0x01
+#define Si2177_ATV_ARTIFICIAL_SNOW_PROP_PERIOD_DEFAULT    0
+#define Si2177_ATV_ARTIFICIAL_SNOW_PROP_PERIOD_LONG   0
+#define Si2177_ATV_ARTIFICIAL_SNOW_PROP_PERIOD_SHORT  1
+
+/* ATV_ARTIFICIAL_SNOW property, SOUND field definition (NO TITLE)*/
+#define Si2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_LSB         4
+#define Si2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_MASK        0x07
+#define Si2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_DEFAULT    0
+#define Si2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_MUTE          0
+#define Si2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_6DB           1
+#define Si2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_12DB          2
+#define Si2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_18DB          3
+#define Si2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_24DB          4
+#define Si2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_30DB          5
+#define Si2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_36DB          6
+#define Si2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_PASS_THROUGH  7
+
+
+#ifdef __SI2177__
+/* Si2177 ATV_AUDIO_MODE property definition */
+#define Si2177_ATV_AUDIO_MODE_PROP 0x0602
+
+#define Si2177_ATV_AUDIO_MODE_PROP_CODE 0x000602
+
+
+typedef struct { /* Si2177_ATV_AUDIO_MODE_PROP_struct */
+	u8   audio_sys;
+	u8   chan_bw;
+	u8   demod_mode;
+} Si2177_ATV_AUDIO_MODE_PROP_struct;
+
+/* ATV_AUDIO_MODE property, AUDIO_SYS field definition (NO TITLE)*/
+#define Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_LSB         0
+#define Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MASK        0x0f
+#define Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_DEFAULT    0
+#define Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_DEFAULT          0
+#define Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MONO             1
+#define Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MONO_NICAM       2
+#define Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_A2               3
+#define Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_A2_DK2           4
+#define Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_A2_DK3           5
+#define Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_BTSC             6
+#define Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_EIAJ             7
+#define Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_SCAN             8
+#define Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_A2_DK4           9
+#define Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_WIDE_SCAN        10
+#define Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MONO_NICAM_6DB   11
+#define Si2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MONO_NICAM_10DB  12
+
+/* ATV_AUDIO_MODE property, CHAN_BW field definition (NO TITLE)*/
+#define Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_LSB         8
+#define Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_MASK        0x0f
+#define Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_DEFAULT    0
+#define Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_DEFAULT         0
+#define Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_4X_OVERMOD      1
+#define Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_8X_OVERMOD      2
+#define Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_12X_OVERMOD     3
+#define Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_7P5_KHZ_OFFSET  4
+#define Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_15_KHZ_OFFSET   5
+#define Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_30_KHZ_OFFSET   6
+#define Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_75_KHZ_OFFSET   7
+#define Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_150_KHZ_OFFSET  8
+#define Si2177_ATV_AUDIO_MODE_PROP_CHAN_BW_CUSTOM          9
+
+/* ATV_AUDIO_MODE property, DEMOD_MODE field definition (NO TITLE)*/
+#define Si2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_LSB         4
+#define Si2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_MASK        0x03
+#define Si2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_DEFAULT    0
+#define Si2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_SIF  0
+#define Si2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_AM   1
+#define Si2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_FM1  2
+#define Si2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_FM2  3
+#endif /* __SI2177__ */
+
+/* Si2158 ATV_CONFIG_IF_PORT property definition */
+#define Si2158_ATV_CONFIG_IF_PORT_PROP 0x0603
+
+#define Si2158_ATV_CONFIG_IF_PORT_PROP_CODE 0x000603
+
+typedef struct { /* Si2158_ATV_CONFIG_IF_PORT_PROP_struct */
+	u8   atv_agc_source; /* Si2177 has no ATV_AGC_SOURCE */
+	u8   atv_out_type;
+} Si2158_ATV_CONFIG_IF_PORT_PROP_struct;
+
+/* ATV_CONFIG_IF_PORT property, ATV_AGC_SOURCE field definition (NO TITLE)*/
+#define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_LSB         8
+#define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_MASK        0x07
+#define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_DEFAULT    0
+#define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_INTERNAL  0
+#define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_AGC1_3DB  1
+#define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_AGC2_3DB  2
+
+/* ATV_CONFIG_IF_PORT property, ATV_OUT_TYPE field definition (NO TITLE)*/
+#define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LSB         0
+#define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_MASK        0x0f
+#define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_DEFAULT    8
+#define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LIF_DIFF_IF1  8
+#define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LIF_DIFF_IF2  10
+#define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LIF_SE_IF1A   12
+#define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LIF_SE_IF2A   14
+#ifdef __SI2177__
+/* ATV_CONFIG_IF_PORT property, ATV_OUT_TYPE field definition (NO TITLE)*/
+#define Si2177_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LSB         0
+#define Si2177_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_MASK        0x0f
+#define Si2177_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_DEFAULT    0
+#define Si2177_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_CVBS_IF2B_SOUND_IF2A  0
+#endif /* __SI2177__ */
+
+
+#ifdef __SI2177__
+/* Si2177 ATV_CVBS_OUT property definition */
+#define Si2177_ATV_CVBS_OUT_PROP 0x0609
+
+#define Si2177_ATV_CVBS_OUT_PROP_CODE 0x000609
+
+
+typedef struct { /* Si2177_ATV_CVBS_OUT_PROP_struct */
+	u8   amp;
+	u8   offset;
+} Si2177_ATV_CVBS_OUT_PROP_struct;
+
+/* ATV_CVBS_OUT property, AMP field definition (NO TITLE)*/
+#define Si2177_ATV_CVBS_OUT_PROP_AMP_LSB         8
+#define Si2177_ATV_CVBS_OUT_PROP_AMP_MASK        0xff
+#define Si2177_ATV_CVBS_OUT_PROP_AMP_DEFAULT    200
+#define Si2177_ATV_CVBS_OUT_PROP_AMP_AMP_MIN  0
+#define Si2177_ATV_CVBS_OUT_PROP_AMP_AMP_MAX  255
+
+/* ATV_CVBS_OUT property, OFFSET field definition (NO TITLE)*/
+#define Si2177_ATV_CVBS_OUT_PROP_OFFSET_LSB         0
+#define Si2177_ATV_CVBS_OUT_PROP_OFFSET_MASK        0xff
+#define Si2177_ATV_CVBS_OUT_PROP_OFFSET_DEFAULT    25
+#define Si2177_ATV_CVBS_OUT_PROP_OFFSET_OFFSET_MIN  0
+#define Si2177_ATV_CVBS_OUT_PROP_OFFSET_OFFSET_MAX  255
+
+
+/* Si2177 ATV_CVBS_OUT_FINE property definition */
+#define Si2177_ATV_CVBS_OUT_FINE_PROP 0x0614
+#define Si2177_ATV_CVBS_OUT_FINE_PROP_CODE 0x000614
+
+typedef struct { /* Si2177_ATV_CVBS_OUT_FINE_PROP_struct */
+	u8 amp;
+	s8 offset;
+} Si2177_ATV_CVBS_OUT_FINE_PROP_struct;
+
+/* ATV_CVBS_OUT_FINE property, AMP field definition (NO TITLE)*/
+#define Si2177_ATV_CVBS_OUT_FINE_PROP_AMP_LSB         8
+#define Si2177_ATV_CVBS_OUT_FINE_PROP_AMP_MASK        0xff
+#define Si2177_ATV_CVBS_OUT_FINE_PROP_AMP_DEFAULT    100
+#define Si2177_ATV_CVBS_OUT_FINE_PROP_AMP_AMP_MIN  25
+#define Si2177_ATV_CVBS_OUT_FINE_PROP_AMP_AMP_MAX  100
+
+/* ATV_CVBS_OUT_FINE property, OFFSET field definition (NO TITLE)*/
+#define Si2177_ATV_CVBS_OUT_FINE_PROP_OFFSET_LSB         0
+#define Si2177_ATV_CVBS_OUT_FINE_PROP_OFFSET_MASK        0xff
+#define Si2177_ATV_CVBS_OUT_FINE_PROP_OFFSET_DEFAULT    0
+#define Si2177_ATV_CVBS_OUT_FINE_PROP_OFFSET_OFFSET_MIN  -128
+#define Si2177_ATV_CVBS_OUT_FINE_PROP_OFFSET_OFFSET_MAX  127
+#endif /* __SI2177__ */
+
+/* Si2158 ATV_EXT_AGC property definition */
+#define Si2158_ATV_EXT_AGC_PROP 0x0607
+
+#define Si2158_ATV_EXT_AGC_PROP_CODE 0x000607
+
+typedef struct { /* Si2158_ATV_EXT_AGC_PROP_struct */
+	u8   max_10mv;
+	u8   min_10mv;
+} Si2158_ATV_EXT_AGC_PROP_struct;
+
+/* ATV_EXT_AGC property, MAX_10MV field definition (NO TITLE)*/
+#define Si2158_ATV_EXT_AGC_PROP_MAX_10MV_LSB         8
+#define Si2158_ATV_EXT_AGC_PROP_MAX_10MV_MASK        0xff
+#define Si2158_ATV_EXT_AGC_PROP_MAX_10MV_DEFAULT    200
+#define Si2158_ATV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MIN  0
+#define Si2158_ATV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MAX  255
+
+/* ATV_EXT_AGC property, MIN_10MV field definition (NO TITLE)*/
+#define Si2158_ATV_EXT_AGC_PROP_MIN_10MV_LSB         0
+#define Si2158_ATV_EXT_AGC_PROP_MIN_10MV_MASK        0xff
+#define Si2158_ATV_EXT_AGC_PROP_MIN_10MV_DEFAULT    50
+#define Si2158_ATV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MIN  0
+#define Si2158_ATV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MAX  255
+
+#ifdef __SI2177__
+/* Si2177 ATV_HSYNC_OUT property definition */
+#define Si2177_ATV_HSYNC_OUT_PROP 0x0627
+#define Si2177_ATV_HSYNC_OUT_PROP_CODE 0x000627
+
+typedef struct { /* Si2177_ATV_HSYNC_OUT_PROP_struct */
+	u8 gpio_sel;
+	s8 offset;
+	u8 width;
+} Si2177_ATV_HSYNC_OUT_PROP_struct;
+
+/* ATV_HSYNC_OUT property, GPIO_SEL field definition (NO TITLE)*/
+#define Si2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_LSB         0
+#define Si2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_MASK        0x03
+#define Si2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_DEFAULT    0
+#define Si2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_NONE   0
+#define Si2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_GPIO1  1
+#define Si2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_GPIO2  2
+
+/* ATV_HSYNC_OUT property, OFFSET field definition (NO TITLE)*/
+#define Si2177_ATV_HSYNC_OUT_PROP_OFFSET_LSB         8
+#define Si2177_ATV_HSYNC_OUT_PROP_OFFSET_MASK        0xff
+#define Si2177_ATV_HSYNC_OUT_PROP_OFFSET_DEFAULT    0
+#define Si2177_ATV_HSYNC_OUT_PROP_OFFSET_OFFSET_MIN  -128
+#define Si2177_ATV_HSYNC_OUT_PROP_OFFSET_OFFSET_MAX  127
+
+/* ATV_HSYNC_OUT property, WIDTH field definition (NO TITLE)*/
+#define Si2177_ATV_HSYNC_OUT_PROP_WIDTH_LSB         2
+#define Si2177_ATV_HSYNC_OUT_PROP_WIDTH_MASK        0x3f
+#define Si2177_ATV_HSYNC_OUT_PROP_WIDTH_DEFAULT    42
+#define Si2177_ATV_HSYNC_OUT_PROP_WIDTH_WIDTH_MIN  0
+#define Si2177_ATV_HSYNC_OUT_PROP_WIDTH_WIDTH_MAX  51
+#endif /* __SI2177__ */
+
+/* Si2158 ATV_IEN property definition */
+#define Si2158_ATV_IEN_PROP 0x0601
+
+#define Si2158_ATV_IEN_PROP_CODE 0x000601
+
+
+#ifdef __SI2158__
+typedef struct { /* Si2158_ATV_IEN_PROP_struct */
+	u8   chlien;
+	u8   pclien;
+} Si2158_ATV_IEN_PROP_struct;
+#endif /* __SI2158__ */
+
+#ifdef __SI2177__
+typedef struct { /* Si2177_ATV_IEN_PROP_struct */
+	u8   chlien;
+	u8   dlien;
+	u8   pclien;
+	u8   snrhien;
+	u8   snrlien;
+} Si2158_ATV_IEN_PROP_struct;
+#endif /* __SI2177__ */
+
+/* ATV_IEN property, CHLIEN field definition (NO TITLE)*/
+#define Si2158_ATV_IEN_PROP_CHLIEN_LSB         0
+#define Si2158_ATV_IEN_PROP_CHLIEN_MASK        0x01
+#define Si2158_ATV_IEN_PROP_CHLIEN_DEFAULT    1
+#define Si2158_ATV_IEN_PROP_CHLIEN_DISABLE  0
+#define Si2158_ATV_IEN_PROP_CHLIEN_ENABLE   1
+
+#ifdef __SI2177__
+/* ATV_IEN property, DLIEN field definition (NO TITLE)*/
+#define Si2177_ATV_IEN_PROP_DLIEN_LSB         2
+#define Si2177_ATV_IEN_PROP_DLIEN_MASK        0x01
+#define Si2177_ATV_IEN_PROP_DLIEN_DEFAULT    0
+#define Si2177_ATV_IEN_PROP_DLIEN_DISABLE  0
+#define Si2177_ATV_IEN_PROP_DLIEN_ENABLE   1
+#endif /* __SI2177__ */
+
+/* ATV_IEN property, PCLIEN field definition (NO TITLE)*/
+#define Si2158_ATV_IEN_PROP_PCLIEN_LSB         1
+#define Si2158_ATV_IEN_PROP_PCLIEN_MASK        0x01
+#define Si2158_ATV_IEN_PROP_PCLIEN_DEFAULT    0
+#define Si2158_ATV_IEN_PROP_PCLIEN_DISABLE  0
+#define Si2158_ATV_IEN_PROP_PCLIEN_ENABLE   1
+
+#ifdef __SI2177__
+/* ATV_IEN property, SNRHIEN field definition (NO TITLE)*/
+#define Si2177_ATV_IEN_PROP_SNRHIEN_LSB         4
+#define Si2177_ATV_IEN_PROP_SNRHIEN_MASK        0x01
+#define Si2177_ATV_IEN_PROP_SNRHIEN_DEFAULT    0
+#define Si2177_ATV_IEN_PROP_SNRHIEN_DISABLE  0
+#define Si2177_ATV_IEN_PROP_SNRHIEN_ENABLE   1
+
+/* ATV_IEN property, SNRLIEN field definition (NO TITLE)*/
+#define Si2177_ATV_IEN_PROP_SNRLIEN_LSB         3
+#define Si2177_ATV_IEN_PROP_SNRLIEN_MASK        0x01
+#define Si2177_ATV_IEN_PROP_SNRLIEN_DEFAULT    0
+#define Si2177_ATV_IEN_PROP_SNRLIEN_DISABLE  0
+#define Si2177_ATV_IEN_PROP_SNRLIEN_ENABLE   1
+#endif /* __SI2177__ */
+
+
+/* Si2158 ATV_INT_SENSE property definition */
+#define Si2158_ATV_INT_SENSE_PROP 0x0613
+
+#define Si2158_ATV_INT_SENSE_PROP_CODE 0x000613
+
+
+#ifdef __SI2158__
+typedef struct { /* Si2158_ATV_INT_SENSE_PROP_struct */
+	u8   chlnegen;
+	u8   chlposen;
+	u8   pclnegen;
+	u8   pclposen;
+} Si2158_ATV_INT_SENSE_PROP_struct;
+#endif /* __SI2158__ */
+
+#ifdef __SI2177__
+typedef struct { /* Si2177_ATV_INT_SENSE_PROP_struct */
+	u8   chlnegen;
+	u8   chlposen;
+	u8   dlnegen;
+	u8   dlposen;
+	u8   pclnegen;
+	u8   pclposen;
+	u8   snrhnegen;
+	u8   snrhposen;
+	u8   snrlnegen;
+	u8   snrlposen;
+} Si2158_ATV_INT_SENSE_PROP_struct;
+#endif /* __SI2177__ */
+
+/* ATV_INT_SENSE property, CHLNEGEN field definition (NO TITLE)*/
+#define Si2158_ATV_INT_SENSE_PROP_CHLNEGEN_LSB         0
+#define Si2158_ATV_INT_SENSE_PROP_CHLNEGEN_MASK        0x01
+#define Si2158_ATV_INT_SENSE_PROP_CHLNEGEN_DEFAULT    0
+#define Si2158_ATV_INT_SENSE_PROP_CHLNEGEN_DISABLE  0
+#define Si2158_ATV_INT_SENSE_PROP_CHLNEGEN_ENABLE   1
+
+/* ATV_INT_SENSE property, CHLPOSEN field definition (NO TITLE)*/
+#define Si2158_ATV_INT_SENSE_PROP_CHLPOSEN_LSB         8
+#define Si2158_ATV_INT_SENSE_PROP_CHLPOSEN_MASK        0x01
+#define Si2158_ATV_INT_SENSE_PROP_CHLPOSEN_DEFAULT    1
+#define Si2158_ATV_INT_SENSE_PROP_CHLPOSEN_DISABLE  0
+#define Si2158_ATV_INT_SENSE_PROP_CHLPOSEN_ENABLE   1
+
+#ifdef __SI2177__
+/* ATV_INT_SENSE property, DLNEGEN field definition (NO TITLE)*/
+#define Si2177_ATV_INT_SENSE_PROP_DLNEGEN_LSB         2
+#define Si2177_ATV_INT_SENSE_PROP_DLNEGEN_MASK        0x01
+#define Si2177_ATV_INT_SENSE_PROP_DLNEGEN_DEFAULT    0
+#define Si2177_ATV_INT_SENSE_PROP_DLNEGEN_DISABLE  0
+#define Si2177_ATV_INT_SENSE_PROP_DLNEGEN_ENABLE   1
+
+/* ATV_INT_SENSE property, DLPOSEN field definition (NO TITLE)*/
+#define Si2177_ATV_INT_SENSE_PROP_DLPOSEN_LSB         10
+#define Si2177_ATV_INT_SENSE_PROP_DLPOSEN_MASK        0x01
+#define Si2177_ATV_INT_SENSE_PROP_DLPOSEN_DEFAULT    1
+#define Si2177_ATV_INT_SENSE_PROP_DLPOSEN_DISABLE  0
+#define Si2177_ATV_INT_SENSE_PROP_DLPOSEN_ENABLE   1
+
+#endif /* __SI2177__ */
+/* ATV_INT_SENSE property, PCLNEGEN field definition (NO TITLE)*/
+#define Si2158_ATV_INT_SENSE_PROP_PCLNEGEN_LSB         1
+#define Si2158_ATV_INT_SENSE_PROP_PCLNEGEN_MASK        0x01
+#define Si2158_ATV_INT_SENSE_PROP_PCLNEGEN_DEFAULT    0
+#define Si2158_ATV_INT_SENSE_PROP_PCLNEGEN_DISABLE  0
+#define Si2158_ATV_INT_SENSE_PROP_PCLNEGEN_ENABLE   1
+
+/* ATV_INT_SENSE property, PCLPOSEN field definition (NO TITLE)*/
+#define Si2158_ATV_INT_SENSE_PROP_PCLPOSEN_LSB         9
+#define Si2158_ATV_INT_SENSE_PROP_PCLPOSEN_MASK        0x01
+#define Si2158_ATV_INT_SENSE_PROP_PCLPOSEN_DEFAULT    1
+#define Si2158_ATV_INT_SENSE_PROP_PCLPOSEN_DISABLE  0
+#define Si2158_ATV_INT_SENSE_PROP_PCLPOSEN_ENABLE   1
+
+
+#ifdef __SI2177__
+/* ATV_INT_SENSE property, SNRHNEGEN field definition (NO TITLE)*/
+#define Si2177_ATV_INT_SENSE_PROP_SNRHNEGEN_LSB         4
+#define Si2177_ATV_INT_SENSE_PROP_SNRHNEGEN_MASK        0x01
+#define Si2177_ATV_INT_SENSE_PROP_SNRHNEGEN_DEFAULT    0
+#define Si2177_ATV_INT_SENSE_PROP_SNRHNEGEN_DISABLE  0
+#define Si2177_ATV_INT_SENSE_PROP_SNRHNEGEN_ENABLE   1
+
+/* ATV_INT_SENSE property, SNRHPOSEN field definition (NO TITLE)*/
+#define Si2177_ATV_INT_SENSE_PROP_SNRHPOSEN_LSB         12
+#define Si2177_ATV_INT_SENSE_PROP_SNRHPOSEN_MASK        0x01
+#define Si2177_ATV_INT_SENSE_PROP_SNRHPOSEN_DEFAULT    1
+#define Si2177_ATV_INT_SENSE_PROP_SNRHPOSEN_DISABLE  0
+#define Si2177_ATV_INT_SENSE_PROP_SNRHPOSEN_ENABLE   1
+
+/* ATV_INT_SENSE property, SNRLNEGEN field definition (NO TITLE)*/
+#define Si2177_ATV_INT_SENSE_PROP_SNRLNEGEN_LSB         3
+#define Si2177_ATV_INT_SENSE_PROP_SNRLNEGEN_MASK        0x01
+#define Si2177_ATV_INT_SENSE_PROP_SNRLNEGEN_DEFAULT    0
+#define Si2177_ATV_INT_SENSE_PROP_SNRLNEGEN_DISABLE  0
+#define Si2177_ATV_INT_SENSE_PROP_SNRLNEGEN_ENABLE   1
+
+/* ATV_INT_SENSE property, SNRLPOSEN field definition (NO TITLE)*/
+#define Si2177_ATV_INT_SENSE_PROP_SNRLPOSEN_LSB         11
+#define Si2177_ATV_INT_SENSE_PROP_SNRLPOSEN_MASK        0x01
+#define Si2177_ATV_INT_SENSE_PROP_SNRLPOSEN_DEFAULT    1
+#define Si2177_ATV_INT_SENSE_PROP_SNRLPOSEN_DISABLE  0
+#define Si2177_ATV_INT_SENSE_PROP_SNRLPOSEN_ENABLE   1
+#endif /* __SI2177__ */
+
+/* Si2158 ATV_LIF_FREQ property definition */
+#define Si2158_ATV_LIF_FREQ_PROP 0x060c
+
+#define Si2158_ATV_LIF_FREQ_PROP_CODE 0x00060c
+
+typedef struct { /* Si2158_ATV_LIF_FREQ_PROP_struct */
+	u16 offset;
+} Si2158_ATV_LIF_FREQ_PROP_struct;
+
+/* ATV_LIF_FREQ property, OFFSET field definition (NO TITLE)*/
+#define Si2158_ATV_LIF_FREQ_PROP_OFFSET_LSB         0
+#define Si2158_ATV_LIF_FREQ_PROP_OFFSET_MASK        0xffff
+#define Si2158_ATV_LIF_FREQ_PROP_OFFSET_DEFAULT    5000
+#define Si2158_ATV_LIF_FREQ_PROP_OFFSET_OFFSET_MIN  0
+#define Si2158_ATV_LIF_FREQ_PROP_OFFSET_OFFSET_MAX  7000
+
+
+/* Si2158 ATV_LIF_OUT property definition */
+#define Si2158_ATV_LIF_OUT_PROP 0x060d
+
+#define Si2158_ATV_LIF_OUT_PROP_CODE 0x00060d
+
+
+typedef struct { /* Si2158_ATV_LIF_OUT_PROP_struct */
+	u8   amp;
+	u8   offset;
+} Si2158_ATV_LIF_OUT_PROP_struct;
+
+/* ATV_LIF_OUT property, AMP field definition (NO TITLE)*/
+#define Si2158_ATV_LIF_OUT_PROP_AMP_LSB         8
+#define Si2158_ATV_LIF_OUT_PROP_AMP_MASK        0xff
+#define Si2158_ATV_LIF_OUT_PROP_AMP_DEFAULT    100
+#define Si2158_ATV_LIF_OUT_PROP_AMP_AMP_MIN  0
+#define Si2158_ATV_LIF_OUT_PROP_AMP_AMP_MAX  255
+
+/* ATV_LIF_OUT property, OFFSET field definition (NO TITLE)*/
+#define Si2158_ATV_LIF_OUT_PROP_OFFSET_LSB         0
+#define Si2158_ATV_LIF_OUT_PROP_OFFSET_MASK        0xff
+#define Si2158_ATV_LIF_OUT_PROP_OFFSET_DEFAULT    148
+#define Si2158_ATV_LIF_OUT_PROP_OFFSET_OFFSET_MIN  0
+#define Si2158_ATV_LIF_OUT_PROP_OFFSET_OFFSET_MAX  255
+
+
+/* Si2158 ATV_PGA_TARGET property definition */
+#define Si2158_ATV_PGA_TARGET_PROP 0x0617
+
+#define Si2158_ATV_PGA_TARGET_PROP_CODE 0x000617
+
+typedef struct { /* Si2158_ATV_PGA_TARGET_PROP_struct */
+	u8 override_enable;
+	s8 pga_target;
+} Si2158_ATV_PGA_TARGET_PROP_struct;
+
+/* ATV_PGA_TARGET property, OVERRIDE_ENABLE field definition (NO TITLE)*/
+#define Si2158_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_LSB         8
+#define Si2158_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_MASK        0x01
+#define Si2158_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DEFAULT    0
+#define Si2158_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DISABLE  0
+#define Si2158_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_ENABLE   1
+
+/* ATV_PGA_TARGET property, PGA_TARGET field definition (NO TITLE)*/
+#define Si2158_ATV_PGA_TARGET_PROP_PGA_TARGET_LSB         0
+#define Si2158_ATV_PGA_TARGET_PROP_PGA_TARGET_MASK        0xff
+#define Si2158_ATV_PGA_TARGET_PROP_PGA_TARGET_DEFAULT    0
+#define Si2158_ATV_PGA_TARGET_PROP_PGA_TARGET_PGA_TARGET_MIN  -13
+#define Si2158_ATV_PGA_TARGET_PROP_PGA_TARGET_PGA_TARGET_MAX  7
+
+
+/* Si2158 ATV_RF_TOP property definition */
+#define Si2158_ATV_RF_TOP_PROP 0x0612
+
+#define Si2158_ATV_RF_TOP_PROP_CODE 0x000612
+
+
+typedef struct { /* Si2158_ATV_RF_TOP_PROP_struct */
+	u8   atv_rf_top;
+} Si2158_ATV_RF_TOP_PROP_struct;
+
+/* ATV_RF_TOP property, ATV_RF_TOP field definition (NO TITLE)*/
+#define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_LSB         0
+#define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_MASK        0xff
+#define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_DEFAULT    0
+#define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_AUTO   0
+#define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_P2DB   4
+#define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_P1DB   5
+#define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_0DB    6
+#define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M1DB   7
+#define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M2DB   8
+#define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M3DB   9
+#define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M4DB   10
+#define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M5DB   11
+#define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M6DB   12
+#define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M7DB   13
+#define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M8DB   14
+#define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M9DB   15
+#define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M10DB  16
+#define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M11DB  17
+
+
+/* Si2158 ATV_RSQ_RSSI_THRESHOLD property definition */
+#define Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP 0x0605
+
+#define Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_CODE 0x000605
+
+
+typedef struct { /* Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_struct */
+	s8 hi;
+	s8 lo;
+} Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_struct;
+
+/* ATV_RSQ_RSSI_THRESHOLD property, HI field definition (NO TITLE)*/
+#define Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB         8
+#define Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK        0xff
+#define Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_DEFAULT    0
+#define Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MIN  -128
+#define Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MAX  127
+
+/* ATV_RSQ_RSSI_THRESHOLD property, LO field definition (NO TITLE)*/
+#define Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB         0
+#define Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK        0xff
+#define Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_DEFAULT    -70
+#define Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MIN  -128
+#define Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MAX  127
+
+
+#ifdef __SI2177__
+/* Si2177 ATV_RSQ_SNR_THRESHOLD property definition */
+#define Si2177_ATV_RSQ_SNR_THRESHOLD_PROP 0x0606
+
+#define Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_CODE 0x000606
+
+
+typedef struct { /* Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_struct */
+	u8   hi;
+	u8   lo;
+} Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_struct;
+
+/* ATV_RSQ_SNR_THRESHOLD property, HI field definition (NO TITLE)*/
+#define Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_LSB         8
+#define Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_MASK        0xff
+#define Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_DEFAULT    45
+#define Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_HI_MIN  0
+#define Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_HI_MAX  255
+
+/* ATV_RSQ_SNR_THRESHOLD property, LO field definition (NO TITLE)*/
+#define Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LSB         0
+#define Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_MASK        0xff
+#define Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_DEFAULT    25
+#define Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LO_MIN  0
+#define Si2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LO_MAX  255
+
+
+/* Si2177 ATV_SIF_OUT property definition */
+#define Si2177_ATV_SIF_OUT_PROP 0x060a
+
+#define Si2177_ATV_SIF_OUT_PROP_CODE 0x00060a
+
+
+typedef struct { /* Si2177_ATV_SIF_OUT_PROP_struct */
+	u8   amp;
+	u8   offset;
+} Si2177_ATV_SIF_OUT_PROP_struct;
+
+/* ATV_SIF_OUT property, AMP field definition (NO TITLE)*/
+#define Si2177_ATV_SIF_OUT_PROP_AMP_LSB         8
+#define Si2177_ATV_SIF_OUT_PROP_AMP_MASK        0xff
+#define Si2177_ATV_SIF_OUT_PROP_AMP_DEFAULT    60
+#define Si2177_ATV_SIF_OUT_PROP_AMP_AMP_MIN  0
+#define Si2177_ATV_SIF_OUT_PROP_AMP_AMP_MAX  255
+
+/* ATV_SIF_OUT property, OFFSET field definition (NO TITLE)*/
+#define Si2177_ATV_SIF_OUT_PROP_OFFSET_LSB         0
+#define Si2177_ATV_SIF_OUT_PROP_OFFSET_MASK        0xff
+#define Si2177_ATV_SIF_OUT_PROP_OFFSET_DEFAULT    135
+#define Si2177_ATV_SIF_OUT_PROP_OFFSET_OFFSET_MIN  0
+#define Si2177_ATV_SIF_OUT_PROP_OFFSET_OFFSET_MAX  255
+
+
+/* Si2177 ATV_SOUND_AGC_LIMIT property definition */
+#define Si2177_ATV_SOUND_AGC_LIMIT_PROP 0x0618
+
+#define Si2177_ATV_SOUND_AGC_LIMIT_PROP_CODE 0x000618
+
+
+typedef struct { /* Si2177_ATV_SOUND_AGC_LIMIT_PROP_struct */
+	s8 max_gain;
+	s8 min_gain;
+} Si2177_ATV_SOUND_AGC_LIMIT_PROP_struct;
+
+/* ATV_SOUND_AGC_LIMIT property, MAX_GAIN field definition (NO TITLE)*/
+#define Si2177_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_LSB         0
+#define Si2177_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MASK        0xff
+#define Si2177_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_DEFAULT    84
+#define Si2177_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MAX_GAIN_MIN  -84
+#define Si2177_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MAX_GAIN_MAX  84
+
+/* ATV_SOUND_AGC_LIMIT property, MIN_GAIN field definition (NO TITLE)*/
+#define Si2177_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_LSB         8
+#define Si2177_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MASK        0xff
+#define Si2177_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_DEFAULT    -84
+#define Si2177_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MIN_GAIN_MIN  -84
+#define Si2177_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MIN_GAIN_MAX  84
+
+
+/* Si2177 ATV_SOUND_AGC_SPEED property definition */
+#define Si2177_ATV_SOUND_AGC_SPEED_PROP 0x0619
+
+#define Si2177_ATV_SOUND_AGC_SPEED_PROP_CODE 0x000619
+
+
+typedef struct { /* Si2177_ATV_SOUND_AGC_SPEED_PROP_struct */
+	u8   other_systems;
+	u8   system_l;
+} Si2177_ATV_SOUND_AGC_SPEED_PROP_struct;
+
+/* ATV_SOUND_AGC_SPEED property, OTHER_SYSTEMS field definition (NO TITLE)*/
+#define Si2177_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_LSB         8
+#define Si2177_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_MASK        0xff
+#define Si2177_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_DEFAULT    4
+#define Si2177_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_OTHER_SYSTEMS_MIN  0
+#define Si2177_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_OTHER_SYSTEMS_MAX  15
+
+/* ATV_SOUND_AGC_SPEED property, SYSTEM_L field definition (NO TITLE)*/
+#define Si2177_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_LSB         0
+#define Si2177_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_MASK        0xff
+#define Si2177_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_DEFAULT    5
+#define Si2177_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_SYSTEM_L_MIN  0
+#define Si2177_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_SYSTEM_L_MAX  15
+
+
+/* Si2177 ATV_VIDEO_EQUALIZER property definition */
+#define Si2177_ATV_VIDEO_EQUALIZER_PROP 0x0608
+
+#define Si2177_ATV_VIDEO_EQUALIZER_PROP_CODE 0x000608
+
+
+typedef struct { /* Si2177_ATV_VIDEO_EQUALIZER_PROP_struct */
+	s8 slope;
+} Si2177_ATV_VIDEO_EQUALIZER_PROP_struct;
+
+/* ATV_VIDEO_EQUALIZER property, SLOPE field definition (NO TITLE)*/
+#define Si2177_ATV_VIDEO_EQUALIZER_PROP_SLOPE_LSB         0
+#define Si2177_ATV_VIDEO_EQUALIZER_PROP_SLOPE_MASK        0xff
+#define Si2177_ATV_VIDEO_EQUALIZER_PROP_SLOPE_DEFAULT    0
+#define Si2177_ATV_VIDEO_EQUALIZER_PROP_SLOPE_SLOPE_MIN  -8
+#define Si2177_ATV_VIDEO_EQUALIZER_PROP_SLOPE_SLOPE_MAX  7
+
+#endif /* __SI2177__ */
+
+/* Si2158 ATV_VIDEO_MODE property definition */
+#define Si2158_ATV_VIDEO_MODE_PROP 0x0604
+
+#define Si2158_ATV_VIDEO_MODE_PROP_CODE 0x000604
+
+
+typedef struct { /* Si2158_ATV_VIDEO_MODE_PROP_struct */
+	u8   color;
+	u8   invert_spectrum;
+	u8   video_sys;
+} Si2158_ATV_VIDEO_MODE_PROP_struct;
+
+/* ATV_VIDEO_MODE property, COLOR field definition (NO TITLE)*/
+#define Si2158_ATV_VIDEO_MODE_PROP_COLOR_LSB         4
+#define Si2158_ATV_VIDEO_MODE_PROP_COLOR_MASK        0x01
+#define Si2158_ATV_VIDEO_MODE_PROP_COLOR_DEFAULT    0
+#define Si2158_ATV_VIDEO_MODE_PROP_COLOR_PAL_NTSC  0
+#define Si2158_ATV_VIDEO_MODE_PROP_COLOR_SECAM     1
+
+/* ATV_VIDEO_MODE property, INVERT_SPECTRUM field definition (NO TITLE)*/
+#define Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_LSB      9
+#define Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_MASK     0x01
+#define Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_DEFAULT  1
+#define Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_NORMAL   0
+#define Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_INVERTED 1
+
+#ifdef __SI2177__ /* different definition */
+/* ATV_VIDEO_MODE property, INVERT_SIGNAL field definition (NO TITLE)*/
+#define Si2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_LSB        10
+#define Si2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_MASK       0x01
+#define Si2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_DEFAULT    0
+#define Si2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_NORMAL     0
+#define Si2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_INVERTED   1
+#endif /* __SI2177__ */
+
+/* ATV_VIDEO_MODE property, VIDEO_SYS field definition (NO TITLE)*/
+#define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LSB         0
+#define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_MASK        0x07
+#define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DEFAULT    0
+#define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_B   0
+#define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_GH  1
+#define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_M   2
+#define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_N   3
+#define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_I   4
+#define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DK  5
+#define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_L   6
+#define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LP  7
+
+
+/* Si2158 ATV_VSNR_CAP property definition */
+#define Si2158_ATV_VSNR_CAP_PROP 0x0616
+
+#define Si2158_ATV_VSNR_CAP_PROP_CODE 0x000616
+
+
+typedef struct { /* Si2158_ATV_VSNR_CAP_PROP_struct */
+	u8   atv_vsnr_cap;
+} Si2158_ATV_VSNR_CAP_PROP_struct;
+
+/* ATV_VSNR_CAP property, ATV_VSNR_CAP field definition (NO TITLE)*/
+#define Si2158_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_LSB         0
+#define Si2158_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_MASK        0xff
+#define Si2158_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_DEFAULT    0
+#define Si2158_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_ATV_VSNR_CAP_MIN  0
+#define Si2158_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_ATV_VSNR_CAP_MAX  127
+
+
+/* Si2158 CRYSTAL_TRIM property definition */
+#define Si2158_CRYSTAL_TRIM_PROP 0x0402
+
+#define Si2158_CRYSTAL_TRIM_PROP_CODE 0x000402
+
+
+typedef struct { /* Si2158_CRYSTAL_TRIM_PROP_struct */
+	u8   xo_cap;
+} Si2158_CRYSTAL_TRIM_PROP_struct;
+
+/* CRYSTAL_TRIM property, XO_CAP field definition (NO TITLE)*/
+#define Si2158_CRYSTAL_TRIM_PROP_XO_CAP_LSB         0
+#define Si2158_CRYSTAL_TRIM_PROP_XO_CAP_MASK        0x0f
+#define Si2158_CRYSTAL_TRIM_PROP_XO_CAP_DEFAULT    8
+#define Si2158_CRYSTAL_TRIM_PROP_XO_CAP_4P7PF   0
+#define Si2158_CRYSTAL_TRIM_PROP_XO_CAP_5P2PF   2
+#define Si2158_CRYSTAL_TRIM_PROP_XO_CAP_5P7PF   4
+#define Si2158_CRYSTAL_TRIM_PROP_XO_CAP_6P2PF   6
+#define Si2158_CRYSTAL_TRIM_PROP_XO_CAP_6P7PF   8
+#define Si2158_CRYSTAL_TRIM_PROP_XO_CAP_7P2PF  10
+#define Si2158_CRYSTAL_TRIM_PROP_XO_CAP_7P7PF  12
+#define Si2158_CRYSTAL_TRIM_PROP_XO_CAP_8P2PF  14
+
+
+/* Si2158 DTV_AGC_FREEZE_INPUT property definition */
+#define Si2158_DTV_AGC_FREEZE_INPUT_PROP 0x0711
+
+#define Si2158_DTV_AGC_FREEZE_INPUT_PROP_CODE 0x000711
+
+
+typedef struct { /* Si2158_DTV_AGC_FREEZE_INPUT_PROP_struct */
+	u8   level;
+	u8   pin;
+} Si2158_DTV_AGC_FREEZE_INPUT_PROP_struct;
+
+/* DTV_AGC_FREEZE_INPUT property, LEVEL field definition (NO TITLE)*/
+#define Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LSB         0
+#define Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_MASK        0x01
+#define Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_DEFAULT    0
+#define Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LOW   0
+#define Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_HIGH  1
+
+/* DTV_AGC_FREEZE_INPUT property, PIN field definition (NO TITLE)*/
+#define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_LSB         1
+#define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_MASK        0x07
+#define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_DEFAULT    0
+#define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_NONE      0
+#define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_GPIO1     1
+#define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_GPIO2     2
+#define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_RESERVED  3
+#define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_AGC1      4
+#define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_AGC2      5
+#define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_LIF1A     6
+#define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_LIF1B     7
+
+
+/* Si2158 DTV_AGC_SPEED property definition */
+#define Si2158_DTV_AGC_SPEED_PROP 0x0708
+
+#define Si2158_DTV_AGC_SPEED_PROP_CODE 0x000708
+
+
+typedef struct { /* Si2158_DTV_AGC_SPEED_PROP_struct */
+	u8   agc_decim;
+	u8   if_agc_speed;
+} Si2158_DTV_AGC_SPEED_PROP_struct;
+
+/* DTV_AGC_SPEED property, AGC_DECIM field definition (NO TITLE)*/
+#define Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_LSB         8
+#define Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_MASK        0x03
+#define Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_DEFAULT    0
+#define Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF  0
+#define Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_2    1
+#define Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_4    2
+#define Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_8    3
+
+/* DTV_AGC_SPEED property, IF_AGC_SPEED field definition (NO TITLE)*/
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB         0
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK        0xff
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_DEFAULT    0
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO  0
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_39    39
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_54    54
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_63    63
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_89    89
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_105   105
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_121   121
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_137   137
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_158   158
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_172   172
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_185   185
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_196   196
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_206   206
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_216   216
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_219   219
+#define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_222   222
+
+
+/* Si2158 DTV_CONFIG_IF_PORT property definition */
+#define Si2158_DTV_CONFIG_IF_PORT_PROP 0x0702
+
+#define Si2158_DTV_CONFIG_IF_PORT_PROP_CODE 0x000702
+
+
+typedef struct { /* Si2158_DTV_CONFIG_IF_PORT_PROP_struct */
+	u8   dtv_agc_source;
+	u8   dtv_out_type;
+} Si2158_DTV_CONFIG_IF_PORT_PROP_struct;
+
+/* DTV_CONFIG_IF_PORT property, DTV_AGC_SOURCE field definition (NO TITLE)*/
+#define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_LSB         8
+#define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_MASK        0x07
+#define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_DEFAULT    0
+#define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_INTERNAL   0
+#define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_AGC1_3DB   1
+#define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_AGC2_3DB   2
+
+/* DTV_CONFIG_IF_PORT property, DTV_OUT_TYPE field definition (NO TITLE)*/
+#define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LSB         0
+#define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_MASK        0x0f
+#define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_DEFAULT    1
+#define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF1      0
+#define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF2      1
+#define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_SE_IF1A  4
+#define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_SE_IF2A  5
+
+
+/* Si2158 DTV_EXT_AGC property definition */
+#define Si2158_DTV_EXT_AGC_PROP 0x0705
+
+#define Si2158_DTV_EXT_AGC_PROP_CODE 0x000705
+
+
+typedef struct { /* Si2158_DTV_EXT_AGC_PROP_struct */
+	u8   max_10mv;
+	u8   min_10mv;
+} Si2158_DTV_EXT_AGC_PROP_struct;
+
+/* DTV_EXT_AGC property, MAX_10MV field definition (NO TITLE)*/
+#define Si2158_DTV_EXT_AGC_PROP_MAX_10MV_LSB         8
+#define Si2158_DTV_EXT_AGC_PROP_MAX_10MV_MASK        0xff
+#define Si2158_DTV_EXT_AGC_PROP_MAX_10MV_DEFAULT    200
+#define Si2158_DTV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MIN  0
+#define Si2158_DTV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MAX  255
+
+/* DTV_EXT_AGC property, MIN_10MV field definition (NO TITLE)*/
+#define Si2158_DTV_EXT_AGC_PROP_MIN_10MV_LSB         0
+#define Si2158_DTV_EXT_AGC_PROP_MIN_10MV_MASK        0xff
+#define Si2158_DTV_EXT_AGC_PROP_MIN_10MV_DEFAULT    50
+#define Si2158_DTV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MIN  0
+#define Si2158_DTV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MAX  255
+
+
+/* Si2158 DTV_FILTER_SELECT property definition */
+#define Si2158_DTV_FILTER_SELECT_PROP 0x070c
+
+#define Si2158_DTV_FILTER_SELECT_PROP_CODE 0x00070c
+
+
+typedef struct { /* Si2158_DTV_FILTER_SELECT_PROP_struct */
+	u8   filter;
+} Si2158_DTV_FILTER_SELECT_PROP_struct;
+
+/* DTV_FILTER_SELECT property, FILTER field definition (NO TITLE)*/
+#define Si2158_DTV_FILTER_SELECT_PROP_FILTER_LSB         0
+#define Si2158_DTV_FILTER_SELECT_PROP_FILTER_MASK        0x03
+#define Si2158_DTV_FILTER_SELECT_PROP_FILTER_DEFAULT    1
+#define Si2158_DTV_FILTER_SELECT_PROP_FILTER_LEGACY   0
+#define Si2158_DTV_FILTER_SELECT_PROP_FILTER_CUSTOM1  1
+#define Si2158_DTV_FILTER_SELECT_PROP_FILTER_CUSTOM2  2
+
+
+/* Si2158 DTV_IEN property definition */
+#define Si2158_DTV_IEN_PROP 0x0701
+
+#define Si2158_DTV_IEN_PROP_CODE 0x000701
+
+
+typedef struct { /* Si2158_DTV_IEN_PROP_struct */
+	u8   chlien;
+} Si2158_DTV_IEN_PROP_struct;
+
+/* DTV_IEN property, CHLIEN field definition (NO TITLE)*/
+#define Si2158_DTV_IEN_PROP_CHLIEN_LSB         0
+#define Si2158_DTV_IEN_PROP_CHLIEN_MASK        0x01
+#define Si2158_DTV_IEN_PROP_CHLIEN_DEFAULT    1
+#define Si2158_DTV_IEN_PROP_CHLIEN_DISABLE  0
+#define Si2158_DTV_IEN_PROP_CHLIEN_ENABLE   1
+
+
+/* Si2158 DTV_INITIAL_AGC_SPEED property definition */
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP 0x070d
+
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_CODE 0x00070d
+
+
+typedef struct { /* Si2158_DTV_INITIAL_AGC_SPEED_PROP_struct */
+	u8   agc_decim;
+	u8   if_agc_speed;
+} Si2158_DTV_INITIAL_AGC_SPEED_PROP_struct;
+
+/* DTV_INITIAL_AGC_SPEED property, AGC_DECIM field definition (NO TITLE)*/
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_LSB         8
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_MASK        0x03
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_DEFAULT    0
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_OFF  0
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_2    1
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_4    2
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_8    3
+
+/* DTV_INITIAL_AGC_SPEED property, IF_AGC_SPEED field definition (NO TITLE)*/
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_LSB         0
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_MASK        0xff
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_DEFAULT    0
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO  0
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_39    39
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_54    54
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_63    63
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_89    89
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_105   105
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_121   121
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_137   137
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_158   158
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_172   172
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_185   185
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_196   196
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_206   206
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_216   216
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_219   219
+#define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_222   222
+
+
+/* Si2158 DTV_INITIAL_AGC_SPEED_PERIOD property definition */
+#define Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP 0x070e
+
+#define Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE 0x00070e
+
+
+typedef struct { /* Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_struct */
+	u16 period;
+} Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_struct;
+
+/* DTV_INITIAL_AGC_SPEED_PERIOD property, PERIOD field definition (NO TITLE)*/
+#define Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_LSB         0
+#define Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_MASK        0xffff
+#define Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_DEFAULT    0
+#define Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_PERIOD_MIN  0
+#define Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_PERIOD_MAX  65535
+
+
+/* Si2158 DTV_INTERNAL_ZIF property definition */
+#define Si2158_DTV_INTERNAL_ZIF_PROP 0x0710
+
+#define Si2158_DTV_INTERNAL_ZIF_PROP_CODE 0x000710
+
+
+typedef struct { /* Si2158_DTV_INTERNAL_ZIF_PROP_struct */
+	u8   atsc;
+	u8   dtmb;
+	u8   dvbc;
+	u8   dvbt;
+	u8   isdbc;
+	u8   isdbt;
+	u8   qam_us;
+} Si2158_DTV_INTERNAL_ZIF_PROP_struct;
+
+/* DTV_INTERNAL_ZIF property, ATSC field definition (NO TITLE)*/
+#define Si2158_DTV_INTERNAL_ZIF_PROP_ATSC_LSB         0
+#define Si2158_DTV_INTERNAL_ZIF_PROP_ATSC_MASK        0x01
+#define Si2158_DTV_INTERNAL_ZIF_PROP_ATSC_DEFAULT    0
+#define Si2158_DTV_INTERNAL_ZIF_PROP_ATSC_LIF  0
+#define Si2158_DTV_INTERNAL_ZIF_PROP_ATSC_ZIF  1
+
+/* DTV_INTERNAL_ZIF property, DTMB field definition (NO TITLE)*/
+#define Si2158_DTV_INTERNAL_ZIF_PROP_DTMB_LSB         6
+#define Si2158_DTV_INTERNAL_ZIF_PROP_DTMB_MASK        0x01
+#define Si2158_DTV_INTERNAL_ZIF_PROP_DTMB_DEFAULT    0
+#define Si2158_DTV_INTERNAL_ZIF_PROP_DTMB_LIF  0
+#define Si2158_DTV_INTERNAL_ZIF_PROP_DTMB_ZIF  1
+
+/* DTV_INTERNAL_ZIF property, DVBC field definition (NO TITLE)*/
+#define Si2158_DTV_INTERNAL_ZIF_PROP_DVBC_LSB         3
+#define Si2158_DTV_INTERNAL_ZIF_PROP_DVBC_MASK        0x01
+#define Si2158_DTV_INTERNAL_ZIF_PROP_DVBC_DEFAULT    0
+#define Si2158_DTV_INTERNAL_ZIF_PROP_DVBC_LIF  0
+#define Si2158_DTV_INTERNAL_ZIF_PROP_DVBC_ZIF  1
+
+/* DTV_INTERNAL_ZIF property, DVBT field definition (NO TITLE)*/
+#define Si2158_DTV_INTERNAL_ZIF_PROP_DVBT_LSB         2
+#define Si2158_DTV_INTERNAL_ZIF_PROP_DVBT_MASK        0x01
+#define Si2158_DTV_INTERNAL_ZIF_PROP_DVBT_DEFAULT    0
+#define Si2158_DTV_INTERNAL_ZIF_PROP_DVBT_LIF  0
+#define Si2158_DTV_INTERNAL_ZIF_PROP_DVBT_ZIF  1
+
+/* DTV_INTERNAL_ZIF property, ISDBC field definition (NO TITLE)*/
+#define Si2158_DTV_INTERNAL_ZIF_PROP_ISDBC_LSB         5
+#define Si2158_DTV_INTERNAL_ZIF_PROP_ISDBC_MASK        0x01
+#define Si2158_DTV_INTERNAL_ZIF_PROP_ISDBC_DEFAULT    0
+#define Si2158_DTV_INTERNAL_ZIF_PROP_ISDBC_LIF  0
+#define Si2158_DTV_INTERNAL_ZIF_PROP_ISDBC_ZIF  1
+
+/* DTV_INTERNAL_ZIF property, ISDBT field definition (NO TITLE)*/
+#define Si2158_DTV_INTERNAL_ZIF_PROP_ISDBT_LSB         4
+#define Si2158_DTV_INTERNAL_ZIF_PROP_ISDBT_MASK        0x01
+#define Si2158_DTV_INTERNAL_ZIF_PROP_ISDBT_DEFAULT    0
+#define Si2158_DTV_INTERNAL_ZIF_PROP_ISDBT_LIF  0
+#define Si2158_DTV_INTERNAL_ZIF_PROP_ISDBT_ZIF  1
+
+/* DTV_INTERNAL_ZIF property, QAM_US field definition (NO TITLE)*/
+#define Si2158_DTV_INTERNAL_ZIF_PROP_QAM_US_LSB         1
+#define Si2158_DTV_INTERNAL_ZIF_PROP_QAM_US_MASK        0x01
+#define Si2158_DTV_INTERNAL_ZIF_PROP_QAM_US_DEFAULT    0
+#define Si2158_DTV_INTERNAL_ZIF_PROP_QAM_US_LIF  0
+#define Si2158_DTV_INTERNAL_ZIF_PROP_QAM_US_ZIF  1
+
+
+/* Si2158 DTV_INT_SENSE property definition */
+#define Si2158_DTV_INT_SENSE_PROP 0x070a
+
+#define Si2158_DTV_INT_SENSE_PROP_CODE 0x00070a
+
+
+typedef struct { /* Si2158_DTV_INT_SENSE_PROP_struct */
+	u8   chlnegen;
+	u8   chlposen;
+} Si2158_DTV_INT_SENSE_PROP_struct;
+
+/* DTV_INT_SENSE property, CHLNEGEN field definition (NO TITLE)*/
+#define Si2158_DTV_INT_SENSE_PROP_CHLNEGEN_LSB         0
+#define Si2158_DTV_INT_SENSE_PROP_CHLNEGEN_MASK        0x01
+#define Si2158_DTV_INT_SENSE_PROP_CHLNEGEN_DEFAULT    0
+#define Si2158_DTV_INT_SENSE_PROP_CHLNEGEN_DISABLE  0
+#define Si2158_DTV_INT_SENSE_PROP_CHLNEGEN_ENABLE   1
+
+/* DTV_INT_SENSE property, CHLPOSEN field definition (NO TITLE)*/
+#define Si2158_DTV_INT_SENSE_PROP_CHLPOSEN_LSB         8
+#define Si2158_DTV_INT_SENSE_PROP_CHLPOSEN_MASK        0x01
+#define Si2158_DTV_INT_SENSE_PROP_CHLPOSEN_DEFAULT    1
+#define Si2158_DTV_INT_SENSE_PROP_CHLPOSEN_DISABLE  0
+#define Si2158_DTV_INT_SENSE_PROP_CHLPOSEN_ENABLE   1
+
+
+/* Si2158 DTV_LIF_FREQ property definition */
+#define Si2158_DTV_LIF_FREQ_PROP 0x0706
+
+#define Si2158_DTV_LIF_FREQ_PROP_CODE 0x000706
+
+
+typedef struct { /* Si2158_DTV_LIF_FREQ_PROP_struct */
+	u16 offset;
+} Si2158_DTV_LIF_FREQ_PROP_struct;
+
+/* DTV_LIF_FREQ property, OFFSET field definition (NO TITLE)*/
+#define Si2158_DTV_LIF_FREQ_PROP_OFFSET_LSB         0
+#define Si2158_DTV_LIF_FREQ_PROP_OFFSET_MASK        0xffff
+#define Si2158_DTV_LIF_FREQ_PROP_OFFSET_DEFAULT    5000
+#define Si2158_DTV_LIF_FREQ_PROP_OFFSET_OFFSET_MIN  0
+#define Si2158_DTV_LIF_FREQ_PROP_OFFSET_OFFSET_MAX  7000
+
+
+/* Si2158 DTV_LIF_OUT property definition */
+#define Si2158_DTV_LIF_OUT_PROP 0x0707
+
+#define Si2158_DTV_LIF_OUT_PROP_CODE 0x000707
+
+
+typedef struct { /* Si2158_DTV_LIF_OUT_PROP_struct */
+	u8   amp;
+	u8   offset;
+} Si2158_DTV_LIF_OUT_PROP_struct;
+
+/* DTV_LIF_OUT property, AMP field definition (NO TITLE)*/
+#define Si2158_DTV_LIF_OUT_PROP_AMP_LSB         8
+#define Si2158_DTV_LIF_OUT_PROP_AMP_MASK        0xff
+#define Si2158_DTV_LIF_OUT_PROP_AMP_DEFAULT    27
+#define Si2158_DTV_LIF_OUT_PROP_AMP_AMP_MIN  0
+#define Si2158_DTV_LIF_OUT_PROP_AMP_AMP_MAX  255
+
+/* DTV_LIF_OUT property, OFFSET field definition (NO TITLE)*/
+#define Si2158_DTV_LIF_OUT_PROP_OFFSET_LSB         0
+#define Si2158_DTV_LIF_OUT_PROP_OFFSET_MASK        0xff
+#define Si2158_DTV_LIF_OUT_PROP_OFFSET_DEFAULT    148
+#define Si2158_DTV_LIF_OUT_PROP_OFFSET_OFFSET_MIN  0
+#define Si2158_DTV_LIF_OUT_PROP_OFFSET_OFFSET_MAX  255
+
+
+/* Si2158 DTV_MODE property definition */
+#define Si2158_DTV_MODE_PROP 0x0703
+
+#define Si2158_DTV_MODE_PROP_CODE 0x000703
+
+
+typedef struct { /* Si2158_DTV_MODE_PROP_struct */
+	u8   bw;
+	u8   invert_spectrum;
+	u8   modulation;
+} Si2158_DTV_MODE_PROP_struct;
+
+/* DTV_MODE property, BW field definition (NO TITLE)*/
+#define Si2158_DTV_MODE_PROP_BW_LSB         0
+#define Si2158_DTV_MODE_PROP_BW_MASK        0x0f
+#define Si2158_DTV_MODE_PROP_BW_DEFAULT    8
+#define Si2158_DTV_MODE_PROP_BW_BW_6MHZ  6
+#define Si2158_DTV_MODE_PROP_BW_BW_7MHZ  7
+#define Si2158_DTV_MODE_PROP_BW_BW_8MHZ  8
+#ifdef __SI2157__
+#define Si2157_DTV_MODE_PROP_BW_BW_1P7MHZ  9
+#define Si2157_DTV_MODE_PROP_BW_BW_6P1MHZ  10
+#endif /* __SI2157__ */
+
+/* DTV_MODE property, INVERT_SPECTRUM field definition (NO TITLE)*/
+#define Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_LSB         8
+#define Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_MASK        0x01
+#define Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_DEFAULT    0
+#define Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_NORMAL    0
+#define Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_INVERTED  1
+
+/* DTV_MODE property, MODULATION field definition (NO TITLE)*/
+#define Si2158_DTV_MODE_PROP_MODULATION_LSB         4
+#define Si2158_DTV_MODE_PROP_MODULATION_MASK        0x0f
+#define Si2158_DTV_MODE_PROP_MODULATION_DEFAULT    2
+#define Si2158_DTV_MODE_PROP_MODULATION_ATSC    0
+#define Si2158_DTV_MODE_PROP_MODULATION_QAM_US  1
+#define Si2158_DTV_MODE_PROP_MODULATION_DVBT    2
+#define Si2158_DTV_MODE_PROP_MODULATION_DVBC    3
+#define Si2158_DTV_MODE_PROP_MODULATION_ISDBT   4
+#define Si2158_DTV_MODE_PROP_MODULATION_ISDBC   5
+#define Si2158_DTV_MODE_PROP_MODULATION_DTMB    6
+
+
+/* Si2158 DTV_PGA_LIMITS property definition */
+#define Si2158_DTV_PGA_LIMITS_PROP 0x0713
+
+#define Si2158_DTV_PGA_LIMITS_PROP_CODE 0x000713
+
+
+typedef struct { /* Si2158_DTV_PGA_LIMITS_PROP_struct */
+	s8 max;
+	s8 min;
+} Si2158_DTV_PGA_LIMITS_PROP_struct;
+
+/* DTV_PGA_LIMITS property, MAX field definition (NO TITLE)*/
+#define Si2158_DTV_PGA_LIMITS_PROP_MAX_LSB         8
+#define Si2158_DTV_PGA_LIMITS_PROP_MAX_MASK        0xff
+#define Si2158_DTV_PGA_LIMITS_PROP_MAX_DEFAULT    -1
+#define Si2158_DTV_PGA_LIMITS_PROP_MAX_MAX_MIN  -1
+#define Si2158_DTV_PGA_LIMITS_PROP_MAX_MAX_MAX  56
+
+/* DTV_PGA_LIMITS property, MIN field definition (NO TITLE)*/
+#define Si2158_DTV_PGA_LIMITS_PROP_MIN_LSB         0
+#define Si2158_DTV_PGA_LIMITS_PROP_MIN_MASK        0xff
+#define Si2158_DTV_PGA_LIMITS_PROP_MIN_DEFAULT    -1
+#define Si2158_DTV_PGA_LIMITS_PROP_MIN_MIN_MIN  -1
+#define Si2158_DTV_PGA_LIMITS_PROP_MIN_MIN_MAX  56
+
+
+/* Si2158 DTV_PGA_TARGET property definition */
+#define Si2158_DTV_PGA_TARGET_PROP 0x070f
+
+#define Si2158_DTV_PGA_TARGET_PROP_CODE 0x00070f
+
+
+typedef struct { /* Si2158_DTV_PGA_TARGET_PROP_struct */
+	u8   override_enable;
+	s8   pga_target;
+} Si2158_DTV_PGA_TARGET_PROP_struct;
+
+/* DTV_PGA_TARGET property, OVERRIDE_ENABLE field definition (NO TITLE)*/
+#define Si2158_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_LSB         8
+#define Si2158_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_MASK        0x01
+#define Si2158_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DEFAULT    0
+#define Si2158_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DISABLE  0
+#define Si2158_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_ENABLE   1
+
+/* DTV_PGA_TARGET property, PGA_TARGET field definition (NO TITLE)*/
+#define Si2158_DTV_PGA_TARGET_PROP_PGA_TARGET_LSB         0
+#define Si2158_DTV_PGA_TARGET_PROP_PGA_TARGET_MASK        0xff
+#define Si2158_DTV_PGA_TARGET_PROP_PGA_TARGET_DEFAULT    0
+#define Si2158_DTV_PGA_TARGET_PROP_PGA_TARGET_PGA_TARGET_MIN  -13
+#define Si2158_DTV_PGA_TARGET_PROP_PGA_TARGET_PGA_TARGET_MAX  7
+
+
+/* Si2158 DTV_RF_TOP property definition */
+#define Si2158_DTV_RF_TOP_PROP 0x0709
+
+#define Si2158_DTV_RF_TOP_PROP_CODE 0x000709
+
+
+typedef struct { /* Si2158_DTV_RF_TOP_PROP_struct */
+	u8   dtv_rf_top;
+} Si2158_DTV_RF_TOP_PROP_struct;
+
+/* DTV_RF_TOP property, DTV_RF_TOP field definition (NO TITLE)*/
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_LSB         0
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_MASK        0xff
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_DEFAULT    0
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_AUTO     0
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P6DB     9
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P5P5DB   10
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P5DB     11
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P4P5DB   12
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P4DB     13
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P3P5DB   14
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P3DB     15
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P2P5DB   16
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P2DB     17
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P1P5DB   18
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P1DB     19
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P0P5DB   20
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_0DB      21
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M0P5DB   22
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M1DB     23
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M1P5DB   24
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M2DB     25
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M2P5DB   26
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M3DB     27
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M3P5DB   28
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M4DB     29
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M4P5DB   30
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M5DB     31
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M5P5DB   32
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M6DB     33
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M6P5DB   34
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M7DB     35
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M7P5DB   36
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M8DB     37
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M8P5DB   38
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M9DB     39
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M9P5DB   40
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M10DB    41
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M10P5DB  42
+#define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M11DB    43
+
+
+/* Si2158 DTV_RSQ_RSSI_THRESHOLD property definition */
+#define Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP 0x0704
+
+#define Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_CODE 0x000704
+
+
+typedef struct { /* Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_struct */
+	s8   hi;
+	s8   lo;
+} Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_struct;
+
+/* DTV_RSQ_RSSI_THRESHOLD property, HI field definition (NO TITLE)*/
+#define Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB         8
+#define Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK        0xff
+#define Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_DEFAULT    0
+#define Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MIN  -128
+#define Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MAX  127
+
+/* DTV_RSQ_RSSI_THRESHOLD property, LO field definition (NO TITLE)*/
+#define Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB         0
+#define Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK        0xff
+#define Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_DEFAULT    -80
+#define Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MIN  -128
+#define Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MAX  127
+
+
+/* Si2158 DTV_ZIF_DC_CANCELLER_BW property definition */
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP 0x0712
+
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_CODE 0x000712
+
+
+typedef struct { /* Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_struct */
+	u8   bandwidth;
+} Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_struct;
+
+/* DTV_ZIF_DC_CANCELLER_BW property, BANDWIDTH field definition (NO TITLE)*/
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_LSB         0
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_MASK        0xff
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_DEFAULT    16
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_4_HZ       0
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_8_HZ       1
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_15_HZ      2
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_30_HZ      3
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_61_HZ      4
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_121_HZ     5
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_243_HZ     6
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_486_HZ     7
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_972_HZ     8
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_1943_HZ    9
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_3888_HZ    10
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_7779_HZ    11
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_15573_HZ   12
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_31207_HZ   13
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_62658_HZ   14
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_126303_HZ  15
+#define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_DEFAULT    16
+
+
+/* Si2158 MASTER_IEN property definition */
+#define Si2158_MASTER_IEN_PROP 0x0401
+
+#define Si2158_MASTER_IEN_PROP_CODE 0x000401
+
+
+typedef struct { /* Si2158_MASTER_IEN_PROP_struct */
+	u8   atvien;
+	u8   ctsien;
+	u8   dtvien;
+	u8   errien;
+	u8   tunien;
+} Si2158_MASTER_IEN_PROP_struct;
+
+/* MASTER_IEN property, ATVIEN field definition (NO TITLE)*/
+#define Si2158_MASTER_IEN_PROP_ATVIEN_LSB         1
+#define Si2158_MASTER_IEN_PROP_ATVIEN_MASK        0x01
+#define Si2158_MASTER_IEN_PROP_ATVIEN_DEFAULT    0
+#define Si2158_MASTER_IEN_PROP_ATVIEN_OFF  0
+#define Si2158_MASTER_IEN_PROP_ATVIEN_ON   1
+
+/* MASTER_IEN property, CTSIEN field definition (NO TITLE)*/
+#define Si2158_MASTER_IEN_PROP_CTSIEN_LSB         7
+#define Si2158_MASTER_IEN_PROP_CTSIEN_MASK        0x01
+#define Si2158_MASTER_IEN_PROP_CTSIEN_DEFAULT    0
+#define Si2158_MASTER_IEN_PROP_CTSIEN_OFF  0
+#define Si2158_MASTER_IEN_PROP_CTSIEN_ON   1
+
+/* MASTER_IEN property, DTVIEN field definition (NO TITLE)*/
+#define Si2158_MASTER_IEN_PROP_DTVIEN_LSB         2
+#define Si2158_MASTER_IEN_PROP_DTVIEN_MASK        0x01
+#define Si2158_MASTER_IEN_PROP_DTVIEN_DEFAULT    0
+#define Si2158_MASTER_IEN_PROP_DTVIEN_OFF  0
+#define Si2158_MASTER_IEN_PROP_DTVIEN_ON   1
+
+/* MASTER_IEN property, ERRIEN field definition (NO TITLE)*/
+#define Si2158_MASTER_IEN_PROP_ERRIEN_LSB         6
+#define Si2158_MASTER_IEN_PROP_ERRIEN_MASK        0x01
+#define Si2158_MASTER_IEN_PROP_ERRIEN_DEFAULT    0
+#define Si2158_MASTER_IEN_PROP_ERRIEN_OFF  0
+#define Si2158_MASTER_IEN_PROP_ERRIEN_ON   1
+
+/* MASTER_IEN property, TUNIEN field definition (NO TITLE)*/
+#define Si2158_MASTER_IEN_PROP_TUNIEN_LSB         0
+#define Si2158_MASTER_IEN_PROP_TUNIEN_MASK        0x01
+#define Si2158_MASTER_IEN_PROP_TUNIEN_DEFAULT    0
+#define Si2158_MASTER_IEN_PROP_TUNIEN_OFF  0
+#define Si2158_MASTER_IEN_PROP_TUNIEN_ON   1
+
+
+/* Si2158 TUNER_BLOCKED_VCO property definition */
+#define Si2158_TUNER_BLOCKED_VCO_PROP 0x0504
+
+#define Si2158_TUNER_BLOCKED_VCO_PROP_CODE 0x000504
+
+typedef struct { /* Si2158_TUNER_BLOCKED_VCO_PROP_struct */
+	s16    vco_code;
+} Si2158_TUNER_BLOCKED_VCO_PROP_struct;
+
+/* TUNER_BLOCKED_VCO property, VCO_CODE field definition (NO TITLE)*/
+#define Si2158_TUNER_BLOCKED_VCO_PROP_VCO_CODE_LSB         0
+#define Si2158_TUNER_BLOCKED_VCO_PROP_VCO_CODE_MASK        0xffff
+#define Si2158_TUNER_BLOCKED_VCO_PROP_VCO_CODE_DEFAULT    0x8000
+#define Si2158_TUNER_BLOCKED_VCO_PROP_VCO_CODE_VCO_CODE_MIN  -32768
+#define Si2158_TUNER_BLOCKED_VCO_PROP_VCO_CODE_VCO_CODE_MAX  32767
+
+
+/* Si2158 TUNER_IEN property definition */
+#define Si2158_TUNER_IEN_PROP 0x0501
+
+#define Si2158_TUNER_IEN_PROP_CODE 0x000501
+
+typedef struct { /* Si2158_TUNER_IEN_PROP_struct */
+	u8   rssihien;
+	u8   rssilien;
+	u8   tcien;
+} Si2158_TUNER_IEN_PROP_struct;
+
+/* TUNER_IEN property, RSSIHIEN field definition (NO TITLE)*/
+#define Si2158_TUNER_IEN_PROP_RSSIHIEN_LSB         2
+#define Si2158_TUNER_IEN_PROP_RSSIHIEN_MASK        0x01
+#define Si2158_TUNER_IEN_PROP_RSSIHIEN_DEFAULT    0
+#define Si2158_TUNER_IEN_PROP_RSSIHIEN_DISABLE  0
+#define Si2158_TUNER_IEN_PROP_RSSIHIEN_ENABLE   1
+
+/* TUNER_IEN property, RSSILIEN field definition (NO TITLE)*/
+#define Si2158_TUNER_IEN_PROP_RSSILIEN_LSB         1
+#define Si2158_TUNER_IEN_PROP_RSSILIEN_MASK        0x01
+#define Si2158_TUNER_IEN_PROP_RSSILIEN_DEFAULT    0
+#define Si2158_TUNER_IEN_PROP_RSSILIEN_DISABLE  0
+#define Si2158_TUNER_IEN_PROP_RSSILIEN_ENABLE   1
+
+/* TUNER_IEN property, TCIEN field definition (NO TITLE)*/
+#define Si2158_TUNER_IEN_PROP_TCIEN_LSB         0
+#define Si2158_TUNER_IEN_PROP_TCIEN_MASK        0x01
+#define Si2158_TUNER_IEN_PROP_TCIEN_DEFAULT    1
+#define Si2158_TUNER_IEN_PROP_TCIEN_DISABLE  0
+#define Si2158_TUNER_IEN_PROP_TCIEN_ENABLE   1
+
+
+/* Si2158 TUNER_INT_SENSE property definition */
+#define Si2158_TUNER_INT_SENSE_PROP 0x0505
+
+#define Si2158_TUNER_INT_SENSE_PROP_CODE 0x000505
+
+typedef struct { /* Si2158_TUNER_INT_SENSE_PROP_struct */
+	u8   rssihnegen;
+	u8   rssihposen;
+	u8   rssilnegen;
+	u8   rssilposen;
+	u8   tcnegen;
+	u8   tcposen;
+} Si2158_TUNER_INT_SENSE_PROP_struct;
+
+/* TUNER_INT_SENSE property, RSSIHNEGEN field definition (NO TITLE)*/
+#define Si2158_TUNER_INT_SENSE_PROP_RSSIHNEGEN_LSB         2
+#define Si2158_TUNER_INT_SENSE_PROP_RSSIHNEGEN_MASK        0x01
+#define Si2158_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DEFAULT    0
+#define Si2158_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DISABLE  0
+#define Si2158_TUNER_INT_SENSE_PROP_RSSIHNEGEN_ENABLE   1
+
+/* TUNER_INT_SENSE property, RSSIHPOSEN field definition (NO TITLE)*/
+#define Si2158_TUNER_INT_SENSE_PROP_RSSIHPOSEN_LSB         10
+#define Si2158_TUNER_INT_SENSE_PROP_RSSIHPOSEN_MASK        0x01
+#define Si2158_TUNER_INT_SENSE_PROP_RSSIHPOSEN_DEFAULT    1
+#define Si2158_TUNER_INT_SENSE_PROP_RSSIHPOSEN_DISABLE  0
+#define Si2158_TUNER_INT_SENSE_PROP_RSSIHPOSEN_ENABLE   1
+
+/* TUNER_INT_SENSE property, RSSILNEGEN field definition (NO TITLE)*/
+#define Si2158_TUNER_INT_SENSE_PROP_RSSILNEGEN_LSB         1
+#define Si2158_TUNER_INT_SENSE_PROP_RSSILNEGEN_MASK        0x01
+#define Si2158_TUNER_INT_SENSE_PROP_RSSILNEGEN_DEFAULT    0
+#define Si2158_TUNER_INT_SENSE_PROP_RSSILNEGEN_DISABLE  0
+#define Si2158_TUNER_INT_SENSE_PROP_RSSILNEGEN_ENABLE   1
+
+/* TUNER_INT_SENSE property, RSSILPOSEN field definition (NO TITLE)*/
+#define Si2158_TUNER_INT_SENSE_PROP_RSSILPOSEN_LSB         9
+#define Si2158_TUNER_INT_SENSE_PROP_RSSILPOSEN_MASK        0x01
+#define Si2158_TUNER_INT_SENSE_PROP_RSSILPOSEN_DEFAULT    1
+#define Si2158_TUNER_INT_SENSE_PROP_RSSILPOSEN_DISABLE  0
+#define Si2158_TUNER_INT_SENSE_PROP_RSSILPOSEN_ENABLE   1
+
+/* TUNER_INT_SENSE property, TCNEGEN field definition (NO TITLE)*/
+#define Si2158_TUNER_INT_SENSE_PROP_TCNEGEN_LSB         0
+#define Si2158_TUNER_INT_SENSE_PROP_TCNEGEN_MASK        0x01
+#define Si2158_TUNER_INT_SENSE_PROP_TCNEGEN_DEFAULT    0
+#define Si2158_TUNER_INT_SENSE_PROP_TCNEGEN_DISABLE  0
+#define Si2158_TUNER_INT_SENSE_PROP_TCNEGEN_ENABLE   1
+
+/* TUNER_INT_SENSE property, TCPOSEN field definition (NO TITLE)*/
+#define Si2158_TUNER_INT_SENSE_PROP_TCPOSEN_LSB         8
+#define Si2158_TUNER_INT_SENSE_PROP_TCPOSEN_MASK        0x01
+#define Si2158_TUNER_INT_SENSE_PROP_TCPOSEN_DEFAULT    1
+#define Si2158_TUNER_INT_SENSE_PROP_TCPOSEN_DISABLE  0
+#define Si2158_TUNER_INT_SENSE_PROP_TCPOSEN_ENABLE   1
+
+
+/* Si2158 TUNER_LO_INJECTION property definition */
+#define Si2158_TUNER_LO_INJECTION_PROP 0x0506
+
+#define Si2158_TUNER_LO_INJECTION_PROP_CODE 0x000506
+
+typedef struct { /* Si2158_TUNER_LO_INJECTION_PROP_struct */
+	u8   band_1;
+	u8   band_2;
+	u8   band_3;
+} Si2158_TUNER_LO_INJECTION_PROP_struct;
+
+/* TUNER_LO_INJECTION property, BAND_1 field definition (NO TITLE)*/
+#define Si2158_TUNER_LO_INJECTION_PROP_BAND_1_LSB         0
+#define Si2158_TUNER_LO_INJECTION_PROP_BAND_1_MASK        0x01
+#define Si2158_TUNER_LO_INJECTION_PROP_BAND_1_DEFAULT    1
+#define Si2158_TUNER_LO_INJECTION_PROP_BAND_1_LOW_SIDE   0
+#define Si2158_TUNER_LO_INJECTION_PROP_BAND_1_HIGH_SIDE  1
+
+/* TUNER_LO_INJECTION property, BAND_2 field definition (NO TITLE)*/
+#define Si2158_TUNER_LO_INJECTION_PROP_BAND_2_LSB         1
+#define Si2158_TUNER_LO_INJECTION_PROP_BAND_2_MASK        0x01
+#define Si2158_TUNER_LO_INJECTION_PROP_BAND_2_DEFAULT    0
+#define Si2158_TUNER_LO_INJECTION_PROP_BAND_2_LOW_SIDE   0
+#define Si2158_TUNER_LO_INJECTION_PROP_BAND_2_HIGH_SIDE  1
+
+/* TUNER_LO_INJECTION property, BAND_3 field definition (NO TITLE)*/
+#define Si2158_TUNER_LO_INJECTION_PROP_BAND_3_LSB         2
+#define Si2158_TUNER_LO_INJECTION_PROP_BAND_3_MASK        0x01
+#define Si2158_TUNER_LO_INJECTION_PROP_BAND_3_DEFAULT    0
+#define Si2158_TUNER_LO_INJECTION_PROP_BAND_3_LOW_SIDE   0
+#define Si2158_TUNER_LO_INJECTION_PROP_BAND_3_HIGH_SIDE  1
+
+
+/* Si2158 TUNER_RETURN_LOSS property definition */
+#define Si2158_TUNER_RETURN_LOSS_PROP 0x0507
+
+#define Si2158_TUNER_RETURN_LOSS_PROP_CODE 0x000507
+
+typedef struct { /* Si2158_TUNER_RETURN_LOSS_PROP_struct */
+	u8   config;
+	u8   mode;
+} Si2158_TUNER_RETURN_LOSS_PROP_struct;
+
+/* TUNER_RETURN_LOSS property, CONFIG field definition (NO TITLE)*/
+#define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_LSB         0
+#define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_MASK        0xff
+#define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_DEFAULT    127
+#define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_27   27
+#define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_31   31
+#define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_35   35
+#define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_39   39
+#define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_43   43
+#define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_47   47
+#define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_51   51
+#define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_59   59
+#define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_67   67
+#define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_75   75
+#ifdef __SI2157__
+#define Si2157_TUNER_RETURN_LOSS_PROP_CONFIG_83   83
+#define Si2157_TUNER_RETURN_LOSS_PROP_CONFIG_91   91
+#define Si2157_TUNER_RETURN_LOSS_PROP_CONFIG_103  103
+#define Si2157_TUNER_RETURN_LOSS_PROP_CONFIG_115  115
+#endif /* __SI2157__ */
+#define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_127  127
+
+/* TUNER_RETURN_LOSS property, MODE field definition (NO TITLE)*/
+#define Si2158_TUNER_RETURN_LOSS_PROP_MODE_LSB         8
+#define Si2158_TUNER_RETURN_LOSS_PROP_MODE_MASK        0xff
+#define Si2158_TUNER_RETURN_LOSS_PROP_MODE_DEFAULT     0
+#define Si2158_TUNER_RETURN_LOSS_PROP_MODE_TERRESTRIAL 0
+#define Si2158_TUNER_RETURN_LOSS_PROP_MODE_CABLE       1
+
+
+/* Si2158 XOUT property definition */
+#define Si2158_XOUT_PROP 0x0404
+
+#define Si2158_XOUT_PROP_CODE 0x000404
+
+typedef struct { /* Si2158_XOUT_PROP_struct */
+	u8   amp;
+} Si2158_XOUT_PROP_struct;
+
+/* XOUT property, AMP field definition (NO TITLE)*/
+#define Si2158_XOUT_PROP_AMP_LSB     0
+#define Si2158_XOUT_PROP_AMP_MASK    0x01
+#define Si2158_XOUT_PROP_AMP_DEFAULT 0
+#define Si2158_XOUT_PROP_AMP_HIGH    0
+#define Si2158_XOUT_PROP_AMP_LOW     1
+
+#if 0
+/* --------------------------------------------*/
+/* COMMANDS STRUCT                             */
+/* This is used to store all command fields    */
+/* --------------------------------------------*/
+typedef struct { /* silabs_tercab_cmd_obj struct */
+	Si2158_AGC_OVERRIDE_CMD_struct     agc_override;
+	Si2158_ATV_CW_TEST_CMD_struct      atv_cw_test;
+	Si2158_ATV_RESTART_CMD_struct      atv_restart;
+	Si2158_ATV_STATUS_CMD_struct       atv_status;
+	Si2158_CONFIG_CLOCKS_CMD_struct    config_clocks;
+	Si2177_CONFIG_I2C_CMD_struct       config_i2c;
+	Si2158_CONFIG_PINS_CMD_struct      config_pins;
+	Si2158_DTV_RESTART_CMD_struct      dtv_restart;
+	Si2158_DTV_STATUS_CMD_struct       dtv_status;
+	Si2158_EXIT_BOOTLOADER_CMD_struct  exit_bootloader;
+	Si2158_FINE_TUNE_CMD_struct        fine_tune;
+	Si2158_GET_PROPERTY_CMD_struct     get_property;
+	Si2158_GET_REV_CMD_struct          get_rev;
+	Si2158_PART_INFO_CMD_struct        part_info;
+	Si2158_POWER_DOWN_CMD_struct       power_down;
+	Si2158_POWER_DOWN_HW_CMD_struct    power_down_hw;
+	Si2158_POWER_UP_CMD_struct         power_up;
+	Si2158_RAM_CRC_CMD_struct          ram_crc;
+	Si2158_SET_PROPERTY_CMD_struct     set_property;
+	Si2158_STANDBY_CMD_struct          standby;
+	Si2158_TUNER_STATUS_CMD_struct     tuner_status;
+	Si2158_TUNER_TUNE_FREQ_CMD_struct  tuner_tune_freq;
+} silabs_tercab_cmd_obj;
+#endif
+/* --------------------------------------------*/
+/* COMMANDS REPLY STRUCT                       */
+/* This stores all command reply fields        */
+/* --------------------------------------------*/
+typedef struct { /* silabs_tercap_cmd_reply_obj struct */
+	Si2158_ATV_STATUS_CMD_REPLY_struct   atv_status;
+	Si2158_DTV_STATUS_CMD_REPLY_struct   dtv_status;
+	Si2158_PART_INFO_CMD_REPLY_struct    part_info;
+	Si2158_TUNER_STATUS_CMD_REPLY_struct tuner_status;
+} silabs_tercap_cmd_reply;
+
+typedef struct silabs_tercab_context {
+	u8 chiprev;	  /*chip rev constants for integrity checking */
+	u8 part;      /* Last 2 digits of part number */
+	u8 i2c_addr;
+	struct i2c_adapter *i2c_adap;
+	silabs_tercap_cmd_reply rsp;
+	silabs_tercab_status status;
+} silabs_tercab_context;
+
+struct silabs_tercab_priv {
+	struct list_head hybrid_tuner_instance_list;
+	struct tuner_i2c_props i2c_props;
+	struct i2c_client *client;
+	struct dvb_frontend *fe;
+	struct mutex lock;
+	silabs_tercab_context tuner;
+
+	enum silabs_tercab_mode mode;
+
+	u32 frequency;
+	u32 if_frequency;
+	u32 bandwidth;
+	u16 qam_if_khz;
+	u16 vsb_if_khz;
+	u8  clock_control;
+	u8  agc_control;
+	u8  fef_mode;
+	u8  crystal_trim_xo_cap;
+	u8  indirect_i2c_connection;
+	int silabs_tercab_init_done;
+	int firmware_started;
+
+	const struct silabs_tercab_config *config;
+};
+
+struct part_info {
+	u8  chiprev;
+	u8  romid;
+	u8  part;
+	u8  pmajor;
+	u8  pminor;
+	u8  pbuild;
+	u16 reserved;
+	u32 serial;
+};
+
+/* Layer 1 core types definitions */
+typedef enum ErrorCode
+{
+	Error_CODE_BASE                 = 2000,
+	Error_INCORRECT_NB_READ,       /* 2001 */
+	Error_INCORRECT_NB_WRITTEN,    /* 2002 */
+	Error_DLL_LOAD,                /* 2003 */
+	Error_ENUM_VAL_UNKNOWN,        /* 2004 */
+	Error_COULD_NOT_WRITE_ITEM,    /* 2005 */
+	Error_REGISTER_TYPE_UNKNOWN,   /* 2006 */
+	Error_ENUM_OUT_OF_RANGE,       /* 2007 */
+	Error_TYPE_IS_NOT_ENUMERATE,   /* 2008 */
+	Error_VALUE_NOT_IN_ENUM_LIST,  /* 2009 */
+	Error_COULD_NOT_UPDATE_ITEM,   /* 2010 */
+	Error_VALUE_OUT_OF_RANGE,      /* 2011 */
+	Error_UNKNOW_REGISTER,         /* 2012 */
+	Error_READ_TRACES_ERROR,       /* 2013 */
+	Error_WRITE_TRACES_ERROR,      /* 2014 */
+	Error_UNKNOWN_COMMAND,         /* 2015 */
+	Error_BUFFER_DOES_NOT_CONTAIN_REQUIRED_DATA         /* 2016 */
+} ErrorCode;
+
+#define Si2158_GET_PROPERTY_STRING
+
+#define NO_SILABS_TERCAB_ERROR                     0x00
+#define ERROR_SILABS_TERCAB_PARAMETER_OUT_OF_RANGE 0x01
+#define ERROR_SILABS_TERCAB_ALLOCATING_CONTEXT     0x02
+#define ERROR_SILABS_TERCAB_SENDING_COMMAND        0x03
+#define ERROR_SILABS_TERCAB_CTS_TIMEOUT            0x04
+#define ERROR_SILABS_TERCAB_ERR                    0x05
+#define ERROR_SILABS_TERCAB_POLLING_CTS            0x06
+#define ERROR_SILABS_TERCAB_POLLING_RESPONSE       0x07
+#define ERROR_SILABS_TERCAB_LOADING_FIRMWARE       0x08
+#define ERROR_SILABS_TERCAB_LOADING_BOOTBLOCK      0x09
+#define ERROR_SILABS_TERCAB_STARTING_FIRMWARE      0x0a
+#define ERROR_SILABS_TERCAB_SW_RESET               0x0b
+#define ERROR_SILABS_TERCAB_INCOMPATIBLE_PART      0x0c
+#define ERROR_SILABS_TERCAB_TUNINT_TIMEOUT         0x0d
+#define ERROR_SILABS_TERCAB_xTVINT_TIMEOUT         0x0e
+#define ERROR_SILABS_TERCAB_CRC_CHECK_ERROR        0x10
+#ifdef __SI2157__
+#define ERROR_Si2157_UNKNOWN_COMMAND               0xf0
+#define ERROR_Si2157_UNKNOWN_PROPERTY              0xf1
+#endif /* __SI2157__ */
+
+/* SI2157_FIRMWARE_3_0_BUILD_5 */
+firmware_struct Si2157_FW_3_0b5[] = {
+		{ 16 , { 0xBF,0x21,0xB1,0xF8,0x50,0xD4,0xBD,0xDA,0x05,0x05,0xEE,0xC4,0xC2,0x3D,0x38,0x3E } },
+		{ 8 , { 0x05,0x37,0x88,0x3C,0xE8,0x9D,0x8C,0x73 } },
+		{ 16 , { 0x37,0x7E,0x76,0x05,0x28,0xFF,0xE7,0x9E,0xFF,0xB2,0xAC,0xA8,0x4C,0x34,0x27,0xD5 } },
+		{ 16 , { 0x37,0x61,0x1B,0x98,0x42,0x2A,0xF4,0x94,0x3A,0x41,0x54,0x62,0xC5,0x63,0x64,0xE8 } },
+		{ 8 , { 0x0F,0x25,0x9C,0x90,0x29,0xF4,0x01,0xB9 } },
+		{ 16 , { 0x3F,0x19,0x38,0xD3,0xCF,0x93,0x28,0xE7,0x0F,0x88,0x6E,0x9A,0x63,0x9D,0xC8,0xA9 } },
+		{ 11 , { 0x3A,0xF5,0x4F,0x80,0x53,0xA7,0x3B,0x61,0x61,0xB8,0x8E } },
+		{ 11 , { 0x07,0x35,0xFD,0xB8,0x08,0x47,0xD6,0xEF,0x42,0x55,0xB3 } },
+		{ 11 , { 0x0F,0x37,0x0E,0x93,0x3C,0xC5,0x95,0x6E,0x4A,0x16,0x87 } },
+		{ 8 , { 0x07,0xE0,0x62,0xC7,0x47,0x85,0x6F,0xE4 } },
+		{ 16 , { 0x3F,0xD1,0xE5,0xEB,0x0F,0xF8,0x8F,0x2E,0x92,0xEC,0xF8,0xF5,0xF5,0x4B,0x03,0x60 } },
+		{ 14 , { 0x4A,0xA5,0xC6,0x07,0x43,0x80,0x4D,0x16,0x73,0x23,0x62,0x4A,0x40,0xC6 } },
+		{ 8 , { 0x07,0xE8,0xC4,0x65,0xF3,0xE8,0xA8,0x40 } },
+		{ 9 , { 0x38,0xC6,0xF7,0xA0,0x83,0xDE,0x0A,0x2B,0xD9 } },
+		{ 16 , { 0x0F,0x90,0x5C,0x69,0x81,0x8E,0x3B,0x10,0x0F,0x04,0xB5,0x39,0xC5,0x45,0xD1,0x30 } },
+		{ 16 , { 0x07,0x94,0xB3,0xE8,0x5A,0xCD,0x12,0x3E,0x0F,0x52,0x02,0x0B,0x4C,0xA8,0x53,0x25 } },
+		{ 11 , { 0x0F,0x74,0xE6,0x3B,0xC2,0x52,0x80,0x11,0x4A,0xD8,0xF7 } },
+		{ 14 , { 0x07,0x12,0x8F,0xAF,0x41,0xAA,0x21,0x92,0x45,0x97,0xDE,0x8C,0xDF,0x61 } },
+		{ 8 , { 0x07,0x6C,0xF5,0xD0,0x97,0x73,0x1D,0x64 } },
+		{ 9 , { 0x30,0x59,0x7F,0xD1,0xF3,0x95,0x19,0x8C,0x83 } },
+		{ 11 , { 0x0F,0xA5,0xEB,0x96,0x1A,0xF7,0xDD,0xCF,0x42,0xCF,0x67 } },
+		{ 8 , { 0x07,0xBF,0x08,0xF6,0x58,0x2B,0xE6,0xF6 } },
+		{ 16 , { 0x3F,0x7A,0x11,0xF4,0x49,0xA2,0x2B,0x77,0xAA,0xFC,0xA4,0x62,0x96,0x92,0x2E,0x2E } },
+		{ 14 , { 0x42,0x2E,0xA7,0x07,0x4D,0x77,0x36,0x86,0x14,0xA8,0xF6,0x42,0x50,0xED } },
+		{ 16 , { 0x07,0xC9,0xCC,0xF5,0x96,0x73,0x36,0x27,0x0F,0x46,0xAD,0xB8,0x42,0xBB,0x20,0x5D } },
+		{ 8 , { 0x07,0x65,0x6C,0x82,0x0F,0xD3,0x75,0x2C } },
+		{ 12 , { 0x33,0x94,0xF7,0xCA,0x9B,0x4B,0x3D,0x9D,0x60,0x6A,0xF1,0xCF } },
+		{ 11 , { 0x0F,0x32,0x3B,0x72,0xF8,0x49,0x84,0xFB,0x42,0x0F,0x42 } },
+		{ 11 , { 0x07,0x26,0x87,0x28,0x8F,0x05,0xA3,0xAD,0x4A,0x59,0xC3 } },
+		{ 16 , { 0x0A,0xBE,0xBB,0x9F,0x7D,0xE9,0x1A,0x74,0x12,0xD6,0xED,0xA3,0xB8,0x4A,0xDE,0x61 } },
+		{ 8 , { 0x0F,0xB0,0x9C,0x7C,0x83,0xAE,0x64,0x9E } },
+		{ 9 , { 0x30,0x48,0xE3,0xC4,0xDF,0xB6,0x69,0xB1,0x28 } },
+		{ 11 , { 0x0F,0x33,0xAF,0x5A,0x2A,0xCE,0xFF,0xC2,0x4A,0x91,0x28 } },
+		{ 8 , { 0x0F,0xF9,0xC1,0x42,0xA9,0x47,0x1C,0x6F } },
+		{ 15 , { 0x36,0x39,0xE5,0x7D,0x4E,0xFE,0x74,0xA9,0x56,0x6F,0xB5,0x45,0x4E,0x3B,0x11 } },
+		{ 8 , { 0x07,0x89,0xCB,0x17,0x5D,0x68,0x45,0xE4 } },
+		{ 16 , { 0x3F,0xE5,0x65,0x79,0xE1,0x2F,0x88,0xAE,0x71,0x61,0xC6,0x44,0x08,0x9A,0xEC,0xA6 } },
+		{ 8 , { 0x07,0x69,0x5C,0x05,0xA4,0x7B,0x8C,0xB8 } },
+		{ 16 , { 0x3F,0xFD,0xF6,0x55,0x1C,0xE7,0x84,0xEF,0x78,0xA2,0x15,0x4C,0x27,0x20,0xE2,0xFC } },
+		{ 9 , { 0x30,0x72,0x05,0x23,0x31,0xA9,0x3F,0x1C,0xD0 } },
+		{ 11 , { 0x07,0xF3,0xC2,0xC4,0x9E,0xD9,0xD3,0x2E,0x42,0x0A,0x09 } },
+		{ 8 , { 0x07,0x7F,0x52,0x33,0xF7,0x79,0x0C,0x79 } },
+		{ 16 , { 0x3F,0xC0,0xCC,0xD6,0x65,0xC1,0xD2,0xEC,0x6F,0xB4,0xDC,0x42,0x26,0xCC,0xDF,0x8F } },
+		{ 8 , { 0x07,0x7C,0x43,0x52,0xB1,0x44,0x70,0xDC } },
+		{ 9 , { 0x38,0x66,0xE8,0x62,0xEA,0xE4,0xBA,0xFF,0xBB } },
+		{ 8 , { 0x0F,0x22,0xFA,0xF3,0xA6,0xE9,0xDC,0xFB } },
+		{ 15 , { 0x3E,0xE3,0x1F,0x9D,0xC0,0x56,0xB9,0xDD,0x71,0xA1,0x42,0x1C,0xD4,0x7C,0x0E } },
+		{ 15 , { 0x0F,0x6A,0x56,0xB2,0x84,0x4F,0xB2,0xA9,0x4E,0x67,0x14,0x82,0x57,0x3F,0xC8 } },
+		{ 11 , { 0x0F,0x87,0xA0,0x15,0x24,0x5F,0x03,0xF9,0x4A,0x50,0xB3 } },
+		{ 8 , { 0x0F,0x5B,0x7E,0x34,0x20,0x7A,0xC3,0xCF } },
+		{ 12 , { 0x33,0x5C,0xCB,0x58,0x7F,0x83,0x83,0xF7,0xC0,0x9E,0xC0,0x89 } },
+		{ 11 , { 0x0F,0x03,0x21,0x5C,0x19,0x58,0x3B,0x1F,0x42,0xB8,0x7B } },
+		{ 11 , { 0x07,0xDA,0x87,0x66,0x4A,0x8F,0xDB,0xCE,0x4A,0x04,0xBF } },
+		{ 8 , { 0x0F,0xD1,0xA3,0x5A,0xEC,0xB0,0xE1,0xA0 } },
+		{ 12 , { 0x3B,0xF6,0x00,0xE4,0x3D,0xDD,0x51,0x25,0x27,0xD2,0x50,0xB6 } },
+		{ 8 , { 0x0F,0xA2,0x36,0x93,0x50,0xD5,0xF8,0xE1 } },
+		{ 16 , { 0x3F,0x18,0x99,0xAE,0x84,0x94,0xE4,0x94,0xDE,0x75,0x12,0xE3,0xAA,0xD2,0x3D,0x18 } },
+		{ 11 , { 0x42,0xDB,0x33,0x07,0x2B,0x3C,0x18,0x8C,0x92,0x18,0x69 } },
+		{ 16 , { 0x07,0x6C,0x85,0xAA,0x6D,0xFD,0x7A,0xBD,0x07,0xB1,0x16,0x9B,0x5B,0xBA,0x9E,0x52 } },
+		{ 16 , { 0x3F,0x96,0x5C,0x2B,0x48,0x02,0x12,0x13,0x54,0xDD,0xAA,0x3F,0x44,0x14,0x6E,0x87 } },
+		{ 14 , { 0x4D,0x4C,0xF3,0x8A,0x52,0x04,0x0F,0x23,0x9C,0x12,0x15,0xB3,0xBA,0x00 } },
+		{ 14 , { 0x4D,0x2B,0x05,0x56,0x44,0x3A,0x07,0x40,0x3A,0x70,0xDA,0x3C,0x41,0xB2 } },
+		{ 12 , { 0x33,0xFB,0xE7,0x39,0x88,0x89,0x25,0x73,0x29,0xDB,0x47,0x09 } },
+		{ 11 , { 0x0F,0x39,0x30,0x9F,0xF9,0xD5,0x7B,0xB5,0x42,0x11,0x97 } },
+		{ 16 , { 0x07,0xC2,0xCD,0xF1,0x7C,0x63,0x5B,0x26,0x07,0x04,0xDD,0x5B,0x94,0x45,0xC8,0x9C } },
+		{ 14 , { 0x07,0x0C,0x4A,0x33,0xFA,0x28,0x1D,0x6B,0x4D,0x11,0xDC,0xA2,0xA7,0x84 } },
+		{ 11 , { 0x0F,0xD1,0x46,0xE6,0x27,0xBB,0xAD,0x8D,0x42,0xCE,0x58 } },
+		{ 11 , { 0x0F,0xD5,0xE3,0x25,0x5F,0x6F,0x1E,0xFC,0x42,0x93,0x8D } },
+		{ 8 , { 0x0F,0xD9,0xAB,0xC7,0xD7,0x96,0xF8,0xBE } },
+		{ 9 , { 0x30,0xA5,0x11,0xDE,0x14,0x5E,0xA3,0x07,0xBE } },
+		{ 8 , { 0x0F,0xFF,0xB5,0x28,0x4F,0xCF,0xA7,0x3C } },
+		{ 16 , { 0x3F,0x86,0x17,0x1A,0x00,0x6C,0xBF,0x7F,0x83,0xB2,0x3F,0xE4,0xD2,0xFF,0xC2,0x18 } },
+		{ 16 , { 0x37,0x37,0x1B,0x81,0x82,0xFE,0x8C,0xC2,0x8A,0xB1,0x1C,0x4A,0x4B,0x8A,0x94,0x66 } },
+		{ 16 , { 0x37,0x80,0x53,0x9C,0x2B,0x32,0x97,0xE4,0x7A,0x5A,0xE2,0xF3,0x75,0x47,0xA6,0xF1 } },
+		{ 16 , { 0x3F,0x44,0xCF,0x82,0x2F,0xD8,0x5D,0xED,0x9F,0xC0,0x3A,0x28,0x7F,0x7C,0x21,0x53 } },
+		{ 15 , { 0x3E,0x31,0x35,0xA6,0xF3,0xC8,0xAA,0x7E,0x98,0x8E,0x60,0x80,0xE0,0xE6,0xCC } },
+		{ 8 , { 0x07,0xB8,0x98,0xC0,0xA5,0xC9,0x9E,0x6A } },
+		{ 11 , { 0x32,0xEC,0x2E,0x11,0xB6,0x4C,0x71,0xBF,0xC2,0x31,0x1C } },
+		{ 8 , { 0x0F,0x00,0x13,0x7B,0x74,0xBC,0xD8,0x8B } },
+		{ 11 , { 0x32,0x7F,0xFD,0x3D,0x1A,0x34,0x1C,0x25,0x50,0xBB,0xD3 } },
+		{ 8 , { 0x07,0x7E,0xAE,0x2A,0x43,0x25,0x07,0x9C } },
+		{ 13 , { 0x34,0x8C,0xF2,0xD5,0x5D,0x83,0xF7,0xD6,0x82,0xD4,0x12,0xB5,0x7B } },
+		{ 8 , { 0x07,0xBC,0xC7,0x76,0x7E,0xDD,0xF4,0xA2 } },
+		{ 16 , { 0x3F,0x91,0x33,0x61,0xAB,0x3A,0x7F,0x94,0x75,0x86,0xC8,0x5B,0xB6,0xE9,0x4C,0x6F } },
+		{ 16 , { 0x37,0xB4,0x2A,0x7D,0xFB,0xDD,0x19,0x38,0xA4,0x06,0xE3,0xF9,0x02,0x25,0x1D,0x5D } },
+		{ 16 , { 0x37,0x80,0xDD,0xAC,0x0A,0x35,0x44,0xC4,0xC9,0x80,0x46,0x5A,0x84,0x78,0x32,0x08 } },
+		{ 16 , { 0x37,0x2D,0xA5,0x43,0xA2,0x87,0xDC,0x80,0xE9,0xE0,0xDA,0xDD,0x7B,0xD0,0x94,0x9E } },
+		{ 16 , { 0x3F,0xD8,0x40,0x1F,0xDC,0x59,0x13,0xC3,0xEA,0x88,0x9F,0x8E,0xD5,0xB8,0x7D,0xDF } },
+		{ 16 , { 0x37,0x94,0xB8,0x51,0x44,0x90,0x8B,0x9A,0xF7,0x4C,0x51,0xCB,0x3D,0xA7,0xEC,0x49 } },
+		{ 16 , { 0x3F,0x6E,0x1D,0xD3,0xDB,0x45,0xC1,0x0C,0xA2,0x8E,0xA7,0xD4,0x32,0x7A,0x41,0x13 } },
+		{ 16 , { 0x3F,0xFA,0x54,0xF6,0xCB,0x58,0x83,0x00,0x60,0x60,0x06,0x62,0x42,0xAD,0xD2,0xD9 } },
+		{ 16 , { 0x37,0xAD,0x2E,0xDB,0x84,0xB3,0xFE,0xB6,0x7C,0xA9,0x6D,0x2D,0x40,0x30,0x10,0x15 } },
+		{ 16 , { 0x37,0x3D,0xBC,0x3F,0xA5,0xD1,0x7F,0x67,0x2F,0xEE,0x6D,0x40,0x5E,0x9C,0x27,0xCF } },
+		{ 16 , { 0x3F,0x56,0xDD,0xBE,0x1E,0xC1,0xDE,0xC4,0x2D,0xC5,0xA9,0xC1,0xF6,0x90,0xF5,0x60 } },
+		{ 16 , { 0x37,0x2E,0xCF,0x9E,0x9E,0x48,0x77,0x0A,0xEF,0x20,0x7F,0xC2,0x3D,0xF3,0x89,0x09 } },
+		{ 12 , { 0x4B,0x61,0x03,0x39,0x0F,0x42,0x5F,0x38,0xB8,0xE0,0xB1,0x6F } },
+		{ 16 , { 0x37,0xC0,0xD5,0xD8,0xEE,0xA6,0xD2,0xFA,0x1D,0x3C,0x14,0xE4,0xA8,0x46,0x39,0x81 } },
+		{ 11 , { 0x42,0xCA,0x93,0x0F,0x49,0xDE,0x8A,0xFD,0x03,0xA9,0x8D } },
+		{ 16 , { 0x3F,0x00,0x49,0x34,0x7E,0xC3,0xF5,0x0A,0x2D,0x92,0xAC,0x4D,0x5F,0x4A,0x79,0x5C } },
+		{ 14 , { 0x35,0x62,0xD2,0xB7,0xEB,0x20,0x05,0x91,0x94,0xB3,0xAA,0xC1,0x99,0x0F } },
+		{ 16 , { 0x0F,0x6A,0x19,0xA9,0x88,0x8C,0x15,0x60,0x07,0x46,0x2D,0xAF,0xAF,0x89,0x27,0x5B } },
+		{ 8 , { 0x07,0xD9,0x28,0x8D,0x41,0xEA,0x18,0x2D } },
+		{ 13 , { 0x3C,0xD9,0x32,0x17,0x25,0x6E,0x6F,0xA3,0xAB,0x11,0x31,0x68,0x94 } },
+		{ 8 , { 0x0F,0xF1,0x57,0xF0,0xA4,0x1C,0x39,0x3F } },
+		{ 16 , { 0x3F,0xF2,0xF4,0xAE,0xB6,0xD9,0xC2,0xE5,0x32,0x4C,0xCC,0xBE,0xFA,0xE0,0xF4,0xB5 } },
+		{ 12 , { 0x4B,0xB6,0xAB,0x11,0x07,0x5E,0xFD,0x85,0x07,0x12,0x00,0x4E } },
+		{ 16 , { 0x0F,0x62,0x77,0x4B,0x1C,0xE7,0xF6,0xCF,0x0F,0x6A,0x38,0xE0,0x0F,0xD3,0x38,0xF5 } },
+		{ 15 , { 0x46,0x56,0x66,0xEA,0x53,0x0F,0xB1,0x07,0xE1,0xF9,0x0F,0x5D,0x1F,0x87,0xF8 } },
+		{ 12 , { 0x43,0x78,0x82,0xAD,0x07,0xFE,0x7D,0xA3,0x16,0x91,0xDB,0xE5 } },
+		{ 16 , { 0x3F,0x6E,0x45,0x3F,0xBF,0x02,0x48,0x32,0x36,0x9C,0x4A,0xCB,0xDA,0x27,0x8B,0x1D } },
+		{ 16 , { 0x3F,0x80,0x02,0x95,0x30,0x74,0xFB,0xC6,0x4B,0x04,0xFC,0xE1,0x0B,0xCD,0x4B,0x79 } },
+		{ 16 , { 0x3F,0xB6,0x0A,0xFE,0x6C,0x99,0x59,0x3A,0xD2,0xD9,0x04,0xBF,0x7D,0x39,0xE5,0xB3 } },
+		{ 16 , { 0x3F,0x59,0x27,0x2B,0x03,0x7B,0xE3,0xE2,0xFF,0x1B,0x86,0x58,0x5D,0xDD,0xA2,0x3B } },
+		{ 16 , { 0x37,0x42,0x1B,0x79,0xAD,0x8F,0x9B,0x68,0x3A,0x81,0xFA,0x18,0x37,0xC4,0x4F,0x3D } },
+		{ 16 , { 0x3F,0x14,0x7C,0x79,0x53,0x52,0xA5,0x31,0xA3,0x19,0x57,0xC2,0xDE,0xB5,0x6A,0x14 } },
+		{ 16 , { 0x3F,0x7E,0x5E,0xB9,0xFE,0xBF,0xCD,0x3E,0xC4,0xA9,0x43,0x9A,0xF8,0xA8,0xF7,0x88 } },
+		{ 16 , { 0x37,0x99,0xEC,0xB0,0xD5,0x6C,0x71,0x8F,0x91,0x44,0x74,0x4A,0x1B,0x39,0x94,0x29 } },
+		{ 16 , { 0x3F,0x40,0x38,0x62,0xDD,0x93,0xFB,0xCB,0x05,0xD9,0x88,0x18,0x33,0xB7,0x8A,0xE3 } },
+		{ 14 , { 0x35,0xA6,0x13,0x62,0xFF,0x44,0x4C,0xF0,0x04,0xCA,0xBA,0xE6,0x5B,0x93 } },
+		{ 16 , { 0x07,0xFE,0x29,0x6D,0xAD,0x38,0xD1,0xE9,0x07,0xA3,0x64,0x82,0x18,0x5E,0x46,0x84 } },
+		{ 8 , { 0x07,0x15,0x32,0x84,0x60,0x3E,0xCA,0x70 } },
+		{ 16 , { 0x37,0x29,0x2C,0xA9,0xD8,0xD6,0x8B,0x10,0x0A,0x60,0x9C,0xA0,0x68,0x6B,0x55,0xE7 } },
+		{ 16 , { 0x37,0x8B,0x84,0xB7,0x98,0x73,0x79,0x45,0xD8,0x14,0x8F,0xFB,0x76,0x9C,0x3F,0xA0 } },
+		{ 12 , { 0x3B,0xF1,0x16,0x24,0xC8,0x0B,0x2F,0xF6,0x82,0x38,0x2B,0x04 } },
+		{ 16 , { 0x0F,0xD4,0xA4,0xF8,0x07,0x6C,0x30,0x5F,0x0F,0x2C,0xF3,0xC5,0x41,0x31,0xF2,0xC9 } },
+		{ 8 , { 0x07,0x96,0x56,0x07,0x18,0x1C,0xBA,0x48 } },
+		{ 16 , { 0x37,0x3A,0xCA,0x6D,0xB5,0xC7,0x14,0xDD,0xE5,0x68,0x63,0x10,0x70,0x7D,0xAF,0x36 } },
+		{ 12 , { 0x4B,0x20,0x19,0xE4,0x07,0x1E,0xBB,0x82,0x34,0xE1,0x73,0x30 } },
+		{ 8 , { 0x0F,0x38,0x5B,0xBA,0xBD,0x26,0xBF,0xEE } },
+		{ 16 , { 0x3F,0x57,0x0D,0x9B,0x6B,0x4A,0xD0,0x74,0xC0,0x8A,0x92,0x68,0xA0,0x3C,0xA8,0xF1 } },
+		{ 16 , { 0x37,0xE9,0x6E,0x50,0x76,0x7C,0x51,0x06,0x70,0x1B,0x06,0x6F,0x42,0xDC,0x8E,0x3E } },
+		{ 16 , { 0x37,0x2E,0xAB,0x45,0x2C,0xBE,0xDA,0x19,0xA4,0xD5,0xC9,0x66,0xB9,0x0B,0x3A,0x0B } },
+		{ 14 , { 0x35,0x68,0x6B,0xCC,0x33,0x46,0xF4,0x5F,0x17,0xE5,0x02,0xF0,0xCD,0x65 } },
+		{ 8 , { 0x07,0xBB,0xE2,0xB6,0xCF,0x13,0xD3,0x6F } },
+		{ 16 , { 0x3F,0x12,0xA4,0x99,0x1E,0x91,0x51,0x3D,0x77,0x99,0xE4,0x3C,0x7D,0xF4,0xA6,0xBB } },
+		{ 10 , { 0x31,0x9C,0x6A,0x32,0xCE,0x00,0x1E,0x36,0x59,0x25 } },
+		{ 16 , { 0x0F,0x6A,0x0B,0x4C,0x7E,0x1F,0x11,0x54,0x0F,0x24,0x71,0xA6,0xC2,0xDA,0x3B,0xBC } },
+		{ 16 , { 0x0F,0x19,0x13,0x70,0x9E,0x0A,0xF4,0xB5,0x0F,0x58,0x5E,0xC5,0xFC,0x30,0xA4,0x42 } },
+		{ 8 , { 0x07,0xBC,0xFA,0xCC,0xBD,0x2B,0x76,0xC0 } },
+		{ 12 , { 0x3B,0x72,0xF4,0xCE,0x70,0x40,0x39,0xFC,0xBA,0xD0,0xA2,0x4F } },
+		{ 16 , { 0x0F,0x3B,0x9F,0x47,0xED,0xBA,0xA7,0x72,0x0F,0x29,0x3A,0x7A,0x97,0xDA,0x12,0x9C } },
+		{ 8 , { 0x0F,0x34,0x49,0x97,0x2B,0xB6,0xD0,0x66 } },
+		{ 16 , { 0x3F,0xAD,0xFB,0xC5,0xDF,0x94,0x43,0xB3,0xE2,0x24,0x27,0x37,0xA1,0x50,0xB6,0x09 } },
+		{ 10 , { 0x39,0x1D,0x5F,0x06,0x1B,0x96,0x0D,0x48,0x22,0x67 } },
+		{ 16 , { 0x0F,0x02,0xBA,0xB1,0xDD,0xEA,0x97,0xD3,0x07,0x9E,0x8B,0xD7,0xBB,0x41,0x0A,0x72 } },
+		{ 13 , { 0x0F,0x25,0xE3,0x4D,0x16,0x55,0x16,0x3B,0x44,0x08,0xB1,0x9D,0x63 } },
+		{ 16 , { 0x0F,0xF5,0x2A,0xDF,0x2A,0xB7,0x2B,0x0B,0x0F,0xE2,0xFF,0xCC,0x0D,0x37,0x7A,0x9E } },
+		{ 14 , { 0x45,0x84,0xCE,0x77,0x29,0x6D,0x07,0x09,0x0C,0x6B,0x83,0x21,0x2C,0x15 } },
+		{ 8 , { 0x07,0x63,0xA0,0x85,0xEF,0x5A,0xD3,0x55 } },
+		{ 9 , { 0x38,0xD5,0xC5,0xC5,0x3C,0xCB,0x70,0x54,0x69 } },
+		{ 8 , { 0x07,0x7D,0xA2,0x73,0x6A,0x98,0x4D,0x27 } },
+		{ 16 , { 0x3F,0x6C,0xE6,0x12,0x77,0x30,0x22,0x34,0xBB,0x27,0xBB,0xCD,0x4E,0xD0,0xE6,0xDF } },
+		{ 16 , { 0x3F,0x10,0x54,0x9A,0x1F,0x07,0x35,0x14,0xE1,0x33,0x0A,0x9B,0x67,0x4D,0xA0,0x5D } },
+		{ 12 , { 0x3B,0x56,0x33,0x93,0xC9,0xB3,0x30,0xA1,0x23,0xC8,0xDD,0xF5 } },
+		{ 8 , { 0x07,0xB2,0x01,0x59,0x31,0xDA,0xE4,0xDF } },
+		{ 16 , { 0x37,0xA6,0x2C,0xC8,0x2C,0x67,0x87,0xE6,0x00,0x8F,0x3E,0xC7,0x52,0x90,0xBE,0xD4 } },
+		{ 11 , { 0x4A,0x72,0x20,0x07,0x61,0xFC,0x3E,0x1C,0x7F,0xF4,0x77 } },
+		{ 14 , { 0x07,0xB2,0x8A,0x78,0xE5,0xED,0x6F,0x10,0x4D,0x47,0x27,0xA0,0x3A,0x71 } },
+		{ 8 , { 0x07,0xF6,0x45,0x4E,0x76,0x6D,0x01,0xCC } },
+		{ 16 , { 0x37,0x71,0xE1,0x5E,0xAF,0x55,0x06,0x4B,0x95,0x12,0xFF,0x95,0x6B,0x49,0xC4,0x46 } },
+		{ 9 , { 0x38,0xCC,0x51,0x29,0xB5,0x81,0x39,0x55,0xB9 } },
+		{ 8 , { 0x0F,0xD8,0xB3,0xDF,0xE6,0x61,0x5B,0x03 } },
+		{ 16 , { 0x3F,0xE8,0x82,0xC6,0x1F,0x26,0xBE,0x33,0x3A,0x7A,0x1C,0xBF,0x31,0x90,0x25,0x6B } },
+		{ 16 , { 0x3F,0x75,0x0F,0xDB,0x5A,0x87,0x26,0x5E,0x67,0x24,0xC3,0xB4,0xE9,0x43,0xAE,0x95 } },
+		{ 16 , { 0x3F,0xAF,0xE1,0xC1,0x3B,0x56,0x3F,0x19,0xC5,0xE1,0xC4,0xBB,0x63,0x0A,0xC3,0x4E } },
+		{ 13 , { 0x34,0x26,0xDC,0x69,0xF4,0xA9,0xAC,0x3B,0x98,0x13,0xF6,0x4E,0xAB } },
+		{ 8 , { 0x0F,0xD4,0x90,0x19,0x0A,0xA5,0x8D,0xB8 } },
+		{ 16 , { 0x3F,0xD2,0x8D,0xC3,0xA7,0x13,0x44,0x4C,0x23,0xF6,0xD2,0xDC,0xAB,0x0F,0x55,0x82 } },
+		{ 12 , { 0x4B,0x84,0xBA,0x97,0x0F,0x79,0x49,0xDF,0x1E,0xF9,0xA1,0x48 } },
+		{ 12 , { 0x33,0xE7,0x23,0x04,0xA1,0x71,0x37,0x3C,0x99,0x5D,0xF2,0x06 } },
+		{ 8 , { 0x0F,0x27,0xDF,0xFD,0xB0,0xEA,0xD5,0xDD } },
+		{ 16 , { 0x37,0x8D,0x8A,0xDB,0xDF,0x3F,0xF7,0xCD,0xC7,0x9E,0x7F,0x05,0xFD,0x77,0x33,0x20 } },
+		{ 11 , { 0x4A,0xDA,0x04,0x0F,0x6A,0xD1,0xB2,0xAA,0x1A,0x55,0x55 } },
+		{ 16 , { 0x3F,0x39,0xCB,0x0A,0x0C,0x92,0xE1,0xDB,0xB9,0xC6,0x7D,0x11,0x04,0xC7,0x87,0x66 } },
+		{ 15 , { 0x3E,0x1D,0x65,0x83,0x25,0xCD,0xFE,0x86,0x48,0xD3,0xC1,0x7B,0x03,0x05,0x87 } },
+		{ 16 , { 0x0F,0x4A,0x31,0xF5,0x39,0x24,0xB8,0x37,0x0F,0x96,0x51,0xCE,0xC1,0xC1,0xF6,0x4B } },
+		{ 16 , { 0x3F,0xF5,0xCC,0xC2,0x04,0xFC,0x8C,0xAD,0xD6,0x20,0x76,0x08,0x85,0x63,0x2B,0xD1 } },
+		{ 16 , { 0x3F,0xC3,0x83,0x8A,0xEA,0xF7,0x89,0x94,0x3E,0xE3,0x93,0x5E,0xEC,0xDF,0x40,0x01 } },
+		{ 12 , { 0x3B,0x1C,0x23,0x40,0xF6,0xD5,0x01,0xF6,0x2A,0x93,0xE4,0x1D } },
+		{ 8 , { 0x0F,0x0F,0x83,0xE8,0x76,0x50,0x92,0xFA } },
+		{ 16 , { 0x37,0x82,0x47,0x45,0x7E,0xE2,0x0F,0x32,0x49,0xCD,0x37,0x38,0x2B,0x4B,0x9A,0x8A } },
+		{ 12 , { 0x43,0x05,0xC8,0x40,0x0F,0x02,0xE3,0x6D,0x30,0x61,0xF1,0x98 } },
+		{ 16 , { 0x37,0x91,0x37,0xCB,0x68,0x81,0x9A,0xA8,0x61,0xCE,0xBF,0x67,0xC2,0x06,0xE8,0x09 } },
+		{ 16 , { 0x37,0x12,0xA4,0x7A,0xE4,0x73,0x20,0x90,0xAA,0x78,0x49,0xD0,0xD9,0xE1,0x18,0x47 } },
+		{ 16 , { 0x3F,0x52,0x80,0x43,0x40,0x41,0x19,0xFA,0xE5,0x06,0x64,0x39,0x94,0x2A,0xB1,0xA4 } },
+		{ 16 , { 0x37,0xB5,0xDD,0x62,0x66,0x1E,0x0B,0x00,0x0E,0x81,0x73,0x44,0xDB,0xDC,0xC5,0x37 } },
+		{ 16 , { 0x37,0xF1,0x6B,0x04,0xA6,0xFD,0x2E,0xD3,0x03,0x6B,0x8E,0xAA,0x9F,0x76,0xC5,0xA4 } },
+		{ 16 , { 0x3F,0x0E,0xAA,0x91,0x72,0xC3,0xFC,0xCD,0x1B,0xD2,0xA3,0x74,0x29,0xF8,0x3F,0xE3 } },
+		{ 16 , { 0x37,0x24,0xD1,0x29,0xAF,0x44,0xB2,0x93,0x93,0x91,0x69,0xC9,0xE3,0x9D,0x56,0x93 } },
+		{ 16 , { 0x37,0x2F,0x93,0xAC,0x2F,0x95,0x12,0x32,0x7E,0x48,0x21,0xC5,0xE1,0xBC,0xA7,0xAD } },
+		{ 9 , { 0x38,0x9C,0xD0,0x3C,0x03,0x8B,0x7E,0x43,0x07 } },
+		{ 16 , { 0x07,0xC3,0xE2,0x9B,0x18,0x67,0x79,0xE0,0x0F,0xEF,0x99,0xF4,0x9C,0xF2,0xFE,0xF7 } },
+		{ 8 , { 0x0F,0x52,0xB4,0x2B,0xEA,0xDE,0x46,0xCE } },
+		{ 9 , { 0x30,0x3B,0x55,0x5E,0x2C,0x34,0x56,0xD4,0x0C } },
+		{ 8 , { 0x07,0xC7,0x87,0xE0,0x46,0x48,0xD1,0x1B } },
+		{ 15 , { 0x36,0xDD,0x84,0xBA,0x2B,0x8C,0x84,0x56,0xA1,0x62,0x14,0x49,0x06,0xDA,0x5F } },
+		{ 8 , { 0x0F,0xB6,0x5B,0xF3,0x92,0xFC,0x8D,0xAA } },
+		{ 11 , { 0x3A,0xC6,0xAD,0x54,0x97,0x23,0x5A,0x03,0x17,0xDD,0x64 } },
+		{ 12 , { 0x07,0xB2,0x2B,0x95,0x16,0x06,0x37,0xB1,0x4B,0xFA,0x31,0x04 } },
+		{ 8 , { 0x07,0xF0,0x84,0xFA,0x66,0xED,0x51,0xCD } },
+		{ 16 , { 0x3F,0xDF,0x05,0x91,0xCC,0xE7,0x9D,0x26,0x0F,0x01,0xA9,0x2F,0x1B,0xB8,0x0A,0xBB } },
+		{ 16 , { 0x3F,0xF1,0x49,0xCE,0x04,0x53,0xA9,0x9F,0xA1,0xAC,0x0E,0x58,0x01,0x7C,0x67,0x35 } },
+		{ 10 , { 0x49,0x4C,0x0F,0x9C,0xB0,0xCD,0x55,0xD9,0xF6,0x70 } },
+		{ 16 , { 0x3F,0xDE,0x13,0xB5,0x3B,0xDE,0x4E,0x47,0x0B,0x5F,0xB4,0x18,0x04,0xDE,0xE0,0xD2 } },
+		{ 14 , { 0x3D,0x85,0x5E,0xE1,0x71,0x69,0xCD,0x41,0xF0,0x5B,0x96,0xD4,0x29,0x72 } },
+		{ 8 , { 0x07,0x8E,0xCC,0xDB,0xD8,0x27,0x78,0x0B } },
+		{ 16 , { 0x37,0x38,0x08,0x9E,0xC7,0xE3,0x95,0xF2,0xCD,0x5D,0xCA,0xC9,0x47,0xBB,0xE0,0x04 } },
+		{ 14 , { 0x4D,0x11,0x72,0x0F,0x5E,0x1D,0x07,0xAD,0x6B,0x91,0x10,0x83,0x73,0xF5 } },
+		{ 16 , { 0x3F,0x12,0x72,0xA8,0x60,0x89,0xA3,0xB0,0xED,0xBE,0x1D,0x50,0x40,0x53,0x68,0x05 } },
+		{ 10 , { 0x49,0x23,0x07,0x4B,0xB2,0x11,0x36,0x62,0xDB,0x95 } },
+		{ 12 , { 0x3B,0x5D,0xBD,0xB1,0xEC,0x89,0x9C,0x14,0x04,0xA7,0xCF,0x91 } },
+		{ 8 , { 0x07,0xF6,0xB7,0xC4,0xF5,0xDB,0xD6,0x63 } },
+		{ 11 , { 0x32,0x85,0x4A,0x56,0x1E,0x4B,0xAA,0xC6,0xD3,0xC8,0xED } },
+		{ 8 , { 0x0F,0x06,0x72,0x2F,0x17,0xE1,0xCA,0x13 } },
+		{ 16 , { 0x37,0x52,0x65,0xC2,0xC7,0xFB,0x89,0xFF,0xC0,0x3F,0xFC,0x71,0x9D,0x25,0x78,0xA0 } },
+		{ 11 , { 0x42,0xF2,0x84,0x0F,0x27,0x44,0x0C,0x66,0x46,0xDA,0x5C } },
+		{ 16 , { 0x37,0x22,0x51,0x61,0x14,0x17,0xBF,0x7F,0x9F,0x66,0x66,0x5E,0xA9,0xDC,0x8D,0xDB } },
+		{ 16 , { 0x3F,0xFE,0xE5,0x71,0x5C,0x57,0xE1,0x45,0x8C,0xBF,0x9B,0x64,0xA3,0xFB,0xF8,0x70 } },
+		{ 16 , { 0x37,0x3C,0x21,0x70,0x1E,0xB8,0x7F,0x67,0x87,0xB7,0xAF,0x60,0xB8,0xC3,0x90,0xAE } },
+		{ 12 , { 0x43,0xC1,0x59,0xF0,0x0F,0x1B,0x98,0x95,0x23,0x1F,0x78,0xF8 } },
+		{ 16 , { 0x07,0xC4,0x9F,0x90,0x47,0x00,0x75,0xAB,0x07,0x98,0xD5,0xE6,0xCE,0x04,0x38,0x1E } },
+		{ 13 , { 0x0F,0xD5,0x47,0x57,0xDC,0xE1,0xE1,0xFF,0x4C,0x51,0xFC,0xD4,0x87 } },
+		{ 8 , { 0x0F,0xCE,0x8A,0x5C,0xFA,0xDD,0x0E,0x91 } },
+		{ 16 , { 0x3F,0x0C,0xE7,0x71,0x60,0x3E,0x73,0x63,0x7C,0x5C,0xD0,0x7C,0xB0,0xD3,0x12,0x07 } },
+		{ 16 , { 0x3F,0x48,0xB6,0x42,0x9D,0xA2,0x2E,0x0F,0x84,0xA6,0x63,0xCF,0x3D,0xBA,0x70,0xBA } },
+		{ 13 , { 0x44,0x4B,0x8D,0xBB,0x82,0x07,0xED,0xB2,0xDB,0x83,0x50,0xEC,0xB9 } },
+		{ 16 , { 0x47,0x58,0x73,0xE5,0x80,0x68,0x3A,0x05,0x0F,0x4F,0x8C,0xCB,0xB0,0x41,0x9D,0x55 } },
+		{ 9 , { 0x38,0xDE,0x4B,0x78,0xD8,0x07,0x9F,0x91,0xA7 } },
+		{ 16 , { 0x0F,0xDD,0x11,0xF5,0xEA,0xCB,0x86,0x31,0x0F,0xBB,0xE2,0x90,0x54,0x2A,0xF5,0x72 } },
+		{ 16 , { 0x07,0x16,0x1A,0x60,0xFE,0x8D,0xBB,0xEE,0x0F,0x82,0xCD,0x90,0xE1,0x7E,0x7A,0x66 } },
+		{ 16 , { 0x4F,0x1E,0xBB,0xA1,0xAB,0x6E,0xA9,0x6E,0x0F,0x57,0xCD,0x9B,0x84,0x4C,0x79,0xBA } },
+		{ 8 , { 0x07,0xFA,0xD6,0x7D,0xA2,0x3A,0x39,0x5D } },
+		{ 16 , { 0x3F,0xB8,0x9E,0xD7,0x7A,0xEA,0x9E,0x94,0xC3,0x09,0x07,0x81,0x77,0xB0,0xFB,0xBC } },
+		{ 16 , { 0x37,0x08,0x37,0x2A,0x6F,0xBE,0x2D,0x2D,0x27,0x41,0x41,0x23,0xAA,0x33,0xE4,0x22 } },
+		{ 14 , { 0x3D,0x82,0x43,0x9B,0xCA,0x91,0x6C,0x3E,0xBD,0x6E,0xDF,0x30,0x4B,0x30 } },
+		{ 8 , { 0x07,0xDB,0x20,0xD6,0xF6,0x82,0x22,0x6A } },
+		{ 10 , { 0x39,0x8B,0x3F,0x89,0xD8,0x3A,0x93,0x6B,0x9E,0xC7 } },
+		{ 11 , { 0x0F,0xB8,0x7C,0xB1,0x17,0xBD,0x12,0xE4,0x42,0xEF,0xFF } },
+		{ 16 , { 0x0F,0x60,0x65,0x98,0x8B,0xA1,0x3F,0x68,0x07,0x6F,0x7D,0xB5,0x1F,0x50,0xE4,0x8C } },
+		{ 16 , { 0x3F,0x1A,0x52,0x7B,0x5A,0x8C,0x21,0x96,0xBE,0xEC,0x41,0xCA,0x41,0x4D,0xB3,0x40 } },
+		{ 15 , { 0x36,0x19,0xEA,0x24,0x82,0x68,0xF4,0x94,0xD9,0x32,0x88,0x08,0x80,0xD8,0xA8 } },
+		{ 15 , { 0x0F,0xC2,0xA8,0x88,0x1A,0x13,0xE9,0x71,0x4E,0xC9,0x44,0x2B,0xF7,0xA7,0xC2 } },
+		{ 8 , { 0x07,0xDF,0x40,0x91,0x36,0x50,0x67,0x54 } },
+		{ 16 , { 0x3F,0xFC,0x1A,0x13,0xB3,0xC5,0x79,0xE2,0x3C,0x41,0x25,0x51,0x11,0x22,0xE1,0x8E } },
+		{ 10 , { 0x49,0xEB,0x07,0x52,0x3D,0x83,0x21,0xE1,0xC6,0xC3 } },
+		{ 16 , { 0x37,0x38,0x99,0xD0,0x79,0xBE,0x79,0x36,0x35,0x74,0x36,0x2C,0x35,0x8F,0x68,0x95 } },
+		{ 16 , { 0x37,0xB9,0x7E,0x02,0x7D,0xA8,0xD5,0xF7,0x88,0x78,0x5D,0x84,0x12,0x6C,0x61,0x79 } },
+		{ 14 , { 0x3D,0xEE,0x31,0xFB,0x94,0x3E,0x12,0xF2,0x48,0x69,0x0B,0x45,0xD0,0xF2 } },
+		{ 8 , { 0x07,0x58,0x12,0x06,0xA9,0x9C,0x4E,0xB8 } },
+		{ 16 , { 0x3F,0x43,0x49,0x56,0x87,0x35,0x32,0xD9,0xD7,0xF8,0x6A,0x4D,0xD5,0x0D,0xAB,0x41 } },
+		{ 8 , { 0x07,0xF2,0x3E,0x03,0x8A,0xCD,0x9A,0x33 } },
+		{ 16 , { 0x37,0x2F,0x03,0x02,0xBA,0x6A,0x1D,0xBB,0x04,0x41,0x9A,0x2D,0xFC,0x3D,0x2E,0x8B } },
+		{ 11 , { 0x32,0xA9,0x46,0xBA,0x15,0xEB,0x89,0xD9,0x31,0xD9,0x3B } },
+		{ 11 , { 0x0F,0xC1,0xBA,0x17,0x15,0xD7,0x5D,0xF2,0x4A,0xF0,0x9A } },
+		{ 16 , { 0x0F,0xD6,0x67,0x39,0x57,0xFA,0xA9,0xF4,0x07,0xAA,0x67,0x94,0x43,0x80,0x9F,0x92 } },
+		{ 15 , { 0x3E,0xF1,0xD0,0x74,0xAB,0x8C,0x65,0x3C,0x6B,0x9D,0x52,0x4A,0x32,0x85,0xE2 } },
+		{ 13 , { 0x0F,0xEC,0x54,0xAB,0x98,0xB4,0xC3,0x60,0x44,0xB1,0x0A,0xFF,0xCC } },
+		{ 8 , { 0x0F,0x06,0x90,0x91,0x8F,0xE6,0xB9,0xB0 } },
+		{ 16 , { 0x37,0xFE,0x8D,0xDC,0xF0,0xEE,0x13,0xCE,0x52,0xF0,0xCF,0x8E,0xC1,0x0F,0x50,0x53 } },
+		{ 16 , { 0x3F,0xDA,0xA8,0xA3,0x0E,0xB0,0xD1,0xF9,0x5B,0x84,0xF3,0xA9,0xF4,0x53,0x30,0x9F } },
+		{ 16 , { 0x37,0xD1,0x96,0xCE,0x04,0xB2,0x00,0xB3,0xED,0x9D,0x0B,0xF6,0xC5,0x0C,0x8D,0x11 } },
+		{ 13 , { 0x4C,0x3E,0x02,0x0A,0xD3,0x0F,0xF4,0x07,0x05,0x8C,0xB2,0x35,0x58 } },
+		{ 8 , { 0x07,0xA8,0xF2,0xC2,0x8D,0x4E,0x09,0x17 } },
+		{ 16 , { 0x3F,0xB8,0xF0,0x39,0x43,0x6B,0x99,0x0E,0xF9,0xB5,0x8B,0x4B,0xAB,0xF4,0x89,0x9B } },
+		{ 15 , { 0x46,0xDC,0x23,0x96,0xFF,0xDA,0x67,0x07,0x43,0x32,0x86,0x98,0xF4,0x16,0xD8 } },
+		{ 16 , { 0x37,0x7E,0x89,0xCC,0x0A,0x11,0x5C,0x15,0x44,0xE0,0x7F,0x07,0xD2,0x84,0xD0,0x89 } },
+		{ 8 , { 0x07,0x58,0x0B,0xFB,0x86,0x8A,0x15,0x5B } },
+		{ 16 , { 0x37,0xE8,0xC7,0xA5,0xFB,0xCA,0x15,0xA3,0x73,0x21,0x48,0xA5,0x01,0xF8,0x02,0x6D } },
+		{ 16 , { 0x47,0x90,0xAD,0xAB,0x23,0x9F,0x1C,0xD1,0x07,0xA5,0x2D,0xDA,0x7D,0xD8,0x1A,0x93 } },
+		{ 16 , { 0x3F,0x6C,0x78,0xD0,0x93,0x51,0x32,0x13,0xF5,0x31,0x5B,0x81,0x0A,0xC9,0x7D,0x78 } },
+		{ 8 , { 0x07,0x1E,0x5E,0xCA,0x94,0xD5,0xAC,0x36 } },
+		{ 16 , { 0x37,0x81,0x62,0x6E,0xF0,0x57,0x7B,0xBD,0xA1,0xC6,0x27,0x43,0xFA,0x94,0x60,0x51 } },
+		{ 14 , { 0x45,0xC2,0x9B,0xC0,0x3B,0xC3,0x0F,0xAD,0x27,0x05,0x30,0x42,0x8B,0xB5 } },
+		{ 16 , { 0x37,0x41,0xB3,0x68,0x5D,0x45,0x9D,0xF6,0x1B,0xA0,0xA8,0xF8,0xE0,0x3C,0x3B,0xE2 } },
+		{ 16 , { 0x4F,0x3B,0xC5,0xDD,0x66,0x4E,0x34,0x4D,0x07,0x1B,0xB7,0xB7,0x91,0x0A,0x16,0x02 } },
+		{ 8 , { 0x07,0x4E,0xCA,0xA6,0xC9,0xBB,0xED,0x13 } },
+		{ 14 , { 0x35,0x6B,0x54,0x76,0xAF,0xAE,0x99,0x31,0x50,0xA1,0xF6,0xCD,0xD8,0x09 } },
+		{ 8 , { 0x07,0x0B,0x8E,0x8D,0x4E,0x76,0x43,0xC3 } },
+		{ 9 , { 0x38,0xA0,0xDC,0x85,0x10,0x36,0xAF,0x08,0xCF } },
+		{ 16 , { 0x0F,0x2C,0xE0,0x87,0x76,0xF5,0x35,0xE6,0x07,0x36,0x11,0xD5,0x54,0xDE,0x1B,0x5F } },
+		{ 8 , { 0x07,0xFD,0xE5,0x38,0x62,0xEB,0x5B,0x3A } },
+		{ 12 , { 0x3B,0x8D,0x13,0x42,0xDA,0x9C,0xF7,0x44,0xFA,0xF2,0x36,0x63 } },
+		{ 12 , { 0x07,0x81,0x52,0xA9,0x09,0x16,0x1C,0x59,0x43,0xA2,0x94,0x52 } },
+		{ 8 , { 0x0F,0x03,0x28,0x69,0x47,0xFD,0x3D,0x02 } },
+		{ 16 , { 0x3F,0xE6,0x7D,0x07,0x0B,0xF0,0xAA,0xB6,0xCA,0x0D,0x18,0x55,0x53,0xA0,0x56,0x56 } },
+		{ 13 , { 0x3C,0x65,0x7D,0xC0,0x23,0x85,0xDD,0x21,0x69,0x7B,0xFF,0x44,0x9E } },
+		{ 8 , { 0x0F,0xCD,0x81,0x71,0x90,0x1B,0x42,0x2B } },
+		{ 16 , { 0x3F,0x5E,0x33,0x19,0x91,0xD0,0xA2,0x17,0xA6,0xED,0x02,0x84,0x6F,0x4F,0xC0,0x67 } },
+		{ 14 , { 0x45,0x60,0x88,0x51,0xD8,0x54,0x07,0xD5,0xD9,0xC3,0x29,0xF0,0x85,0x98 } },
+		{ 16 , { 0x07,0x11,0xED,0x7E,0x4A,0xB5,0x85,0x55,0x0F,0xBA,0xCA,0x55,0xBB,0x39,0x2A,0xA6 } },
+		{ 16 , { 0x37,0x11,0x18,0xDE,0x57,0xFE,0x66,0x70,0x2D,0x6C,0x56,0x18,0x7F,0x10,0xDF,0xB6 } },
+		{ 10 , { 0x39,0xF8,0x7F,0x56,0xE2,0x3A,0x7B,0x55,0x6A,0xEC } },
+		{ 8 , { 0x0F,0x0E,0xAD,0x4D,0x8E,0x00,0x06,0xCB } },
+		{ 16 , { 0x37,0xAE,0x90,0xE3,0x86,0xA5,0x5C,0x0F,0x2E,0x20,0x78,0x90,0xED,0x54,0x1F,0x18 } },
+		{ 15 , { 0x3E,0x61,0x60,0x83,0x21,0xBE,0xCF,0x2E,0x04,0x91,0x4F,0xB4,0xE3,0x60,0xF3 } },
+		{ 16 , { 0x0F,0xA6,0x1F,0x08,0x4F,0x81,0x29,0xEC,0x0F,0x18,0x70,0x0D,0x34,0xE9,0x73,0x64 } },
+		{ 8 , { 0x0F,0x79,0x96,0x0D,0x78,0xB1,0x0A,0x32 } },
+		{ 16 , { 0x37,0x27,0xB5,0x9E,0xEC,0xCD,0xA0,0xD5,0x36,0x15,0xB1,0x77,0x3A,0x71,0x15,0x70 } },
+		{ 15 , { 0x36,0xDA,0xD0,0xF9,0xF8,0xB3,0x39,0x6B,0x2D,0xC4,0xD5,0x4B,0xCC,0xAD,0x27 } },
+		{ 16 , { 0x07,0xF0,0x92,0x1C,0x74,0x87,0xB9,0x1E,0x07,0xB0,0x9F,0xB5,0x42,0xC6,0x8E,0x0E } },
+		{ 12 , { 0x33,0xBE,0x5E,0x78,0xB1,0x9A,0xD7,0xBE,0x8D,0x8E,0x47,0x8E } },
+		{ 16 , { 0x0F,0xD1,0x61,0x6F,0x32,0x27,0x55,0xB0,0x47,0x84,0xDB,0xF3,0x19,0xD7,0xCF,0xA0 } },
+		{ 16 , { 0x0F,0x4C,0x5E,0xC6,0xAB,0x62,0xB9,0x1C,0x07,0x23,0xA4,0x04,0xBB,0xB7,0xE8,0x3E } },
+		{ 16 , { 0x07,0xB9,0x1D,0xEC,0xDA,0x51,0x7C,0xEE,0x07,0xEF,0x36,0x6F,0x99,0xA7,0x60,0xEE } },
+		{ 10 , { 0x31,0xF1,0xA1,0xB0,0x7E,0xF4,0xF0,0xFB,0xD7,0x03 } },
+		{ 11 , { 0x07,0xA5,0xD3,0x30,0x8B,0x9E,0x18,0xCA,0x4A,0xFE,0xF8 } },
+		{ 8 , { 0x0F,0x3C,0x2C,0x93,0xDE,0xDD,0x4D,0x7D } },
+		{ 10 , { 0x31,0x3D,0x04,0x75,0x1D,0xD7,0x88,0xCF,0x79,0x47 } },
+		{ 14 , { 0x07,0xB0,0x2F,0x40,0xB4,0xBB,0xCD,0xF8,0x45,0x04,0x36,0xAE,0xDD,0x1E } },
+		{ 12 , { 0x07,0x20,0x97,0x04,0xCB,0xCD,0x75,0xF6,0x4B,0xF0,0x67,0xFD } },
+		{ 8 , { 0x07,0x63,0x8D,0x9E,0xA6,0x73,0x6C,0x66 } },
+		{ 16 , { 0x37,0xDD,0xEE,0x63,0xFB,0x69,0xD9,0x97,0x29,0xCD,0x9C,0x28,0xCB,0xF5,0x84,0x14 } },
+		{ 14 , { 0x4D,0x6E,0xC5,0x07,0xD3,0xF9,0x07,0x93,0xD9,0xC3,0xA8,0x73,0xCE,0x2D } },
+		{ 16 , { 0x0F,0x50,0xA5,0x8D,0xA4,0x37,0x28,0x5F,0x0F,0x52,0xCD,0xA7,0xDC,0xD4,0x65,0xE2 } },
+		{ 15 , { 0x4E,0x8C,0xEF,0x15,0x9C,0xBF,0x86,0x07,0x2E,0x1F,0x32,0xA7,0x2F,0x6B,0x57 } },
+		{ 16 , { 0x0F,0x91,0x68,0xD0,0x0B,0x9C,0xD5,0xE4,0x0F,0xFF,0x25,0x1C,0x00,0xF7,0xAB,0xFD } },
+		{ 16 , { 0x3F,0x13,0x90,0x4A,0x31,0xAA,0x30,0xFD,0x23,0x42,0x47,0x48,0x93,0x6A,0x67,0xE1 } },
+		{ 16 , { 0x37,0x18,0x15,0x7E,0xC8,0x54,0xB6,0x4E,0x2A,0xC6,0x5E,0x7B,0x10,0x33,0x6E,0x4A } },
+		{ 16 , { 0x3F,0x1F,0x68,0xD6,0xE9,0xC4,0x67,0x0A,0x85,0x73,0x8F,0x2C,0xED,0xBF,0x28,0x05 } },
+		{ 10 , { 0x49,0xC3,0x07,0x50,0x3B,0x78,0xBE,0x7A,0xEC,0x55 } },
+		{ 16 , { 0x37,0xA6,0x01,0x77,0x03,0x70,0xA6,0xAF,0x1D,0x20,0x64,0xB5,0xD1,0x65,0xAA,0xAF } },
+		{ 12 , { 0x3B,0x66,0x4A,0x9E,0x1C,0x9B,0xBF,0xC2,0xBD,0xE1,0x2D,0xC8 } },
+		{ 8 , { 0x07,0xE8,0xD1,0x66,0x37,0x01,0x14,0xB8 } },
+		{ 9 , { 0x30,0xA6,0xD6,0xD4,0x63,0x39,0x57,0x59,0x07 } },
+		{ 16 , { 0x0F,0xDF,0x1B,0xDB,0xE2,0xBA,0x2B,0x24,0x0F,0x7B,0xBB,0x49,0x89,0xC8,0x66,0x1F } },
+		{ 8 , { 0x07,0x9E,0x4E,0x3E,0x1A,0x84,0xC2,0x54 } },
+		{ 16 , { 0x37,0xD7,0x37,0x60,0x62,0xC9,0x78,0x31,0x90,0xC7,0xA2,0x94,0xF0,0x52,0xC4,0xF9 } },
+		{ 16 , { 0x3F,0x05,0x4D,0xE0,0xE2,0x40,0xA7,0x92,0x03,0x1C,0xB0,0x0B,0xED,0xFF,0x7D,0xE9 } },
+		{ 10 , { 0x39,0xDE,0xA0,0x71,0x01,0x82,0xA7,0x55,0x2A,0x84 } },
+		{ 8 , { 0x0F,0x15,0x60,0xBF,0xAE,0x55,0xDF,0xE3 } },
+		{ 16 , { 0x3F,0x75,0xB1,0x9F,0x82,0x1A,0x65,0x0D,0x59,0x65,0x2F,0x10,0x51,0xA8,0x95,0x7D } },
+		{ 10 , { 0x41,0xD2,0x0F,0x44,0x8F,0x80,0x6C,0xF0,0x4B,0x43 } },
+		{ 12 , { 0x0F,0x28,0x34,0xC5,0x8D,0x81,0xD1,0xBE,0x43,0x77,0x0A,0x5D } },
+		{ 8 , { 0x07,0xD9,0xBA,0x5C,0xE1,0xD0,0x70,0x8E } },
+		{ 16 , { 0x3F,0x93,0xDC,0x98,0x4F,0x52,0xBC,0x9E,0x11,0x1A,0x45,0x53,0x67,0xE4,0x49,0x3F } },
+		{ 13 , { 0x4C,0xA0,0xA1,0x4B,0xD1,0x07,0x25,0x20,0xC2,0x6E,0x39,0x89,0x4C } },
+		{ 16 , { 0x07,0x87,0x44,0xBF,0x88,0x9A,0x36,0x6D,0x07,0xB4,0x0A,0x8E,0xAD,0x38,0x07,0xA2 } },
+		{ 15 , { 0x4E,0x41,0x05,0xA4,0x52,0x84,0x93,0x07,0x50,0xDD,0x56,0x01,0x5A,0x8B,0xAE } },
+		{ 16 , { 0x3F,0x5F,0x20,0xA9,0xC3,0x5E,0x96,0xE1,0xAD,0x1F,0x47,0x05,0x73,0xBA,0x67,0x30 } },
+		{ 16 , { 0x3F,0x8B,0x9C,0x55,0x2E,0x6A,0x7F,0x88,0x87,0x61,0xDA,0x61,0x85,0xE1,0x6D,0xD4 } },
+		{ 16 , { 0x3F,0xA1,0x4B,0xD7,0x69,0xD3,0xF0,0xB5,0x84,0x23,0xFF,0x2E,0x75,0x1C,0x3D,0x29 } },
+		{ 9 , { 0x30,0x39,0x00,0xC9,0xFA,0x81,0x8D,0xEC,0x39 } },
+		{ 8 , { 0x0F,0x2E,0x6E,0x74,0x4A,0x61,0xCF,0x65 } },
+		{ 16 , { 0x3F,0x47,0x90,0xE3,0x6B,0x9D,0x69,0x94,0xF6,0x41,0x74,0xD4,0xA8,0x6E,0xFF,0x1A } },
+		{ 11 , { 0x3A,0x51,0xCA,0xC7,0xFB,0x0F,0x80,0x84,0x69,0xA5,0x77 } },
+		{ 16 , { 0x0F,0x02,0x65,0xA8,0x3C,0x56,0x34,0x5A,0x07,0x1D,0xFB,0xB0,0x28,0x1C,0xF2,0x46 } },
+		{ 14 , { 0x45,0x3E,0x3B,0xCD,0xB4,0x0D,0x07,0x19,0x55,0x8D,0x5C,0x47,0x5C,0xEE } },
+		{ 12 , { 0x43,0x40,0x9A,0xA5,0x0F,0x85,0x9F,0x44,0xD6,0x13,0x96,0x52 } },
+		{ 16 , { 0x3F,0x4A,0x42,0x0D,0xEA,0x94,0x6F,0xF2,0x71,0xE0,0xF4,0xCE,0xE8,0x06,0xB9,0x70 } },
+		{ 16 , { 0x37,0x42,0x01,0x45,0xFB,0x15,0x97,0xB9,0xDB,0x1D,0x6F,0x85,0x2E,0xCF,0xFB,0x46 } },
+		{ 16 , { 0x3F,0xB0,0x3F,0x54,0xAE,0x7B,0xD1,0xCB,0xB9,0xE3,0x61,0x66,0x45,0xAD,0x8A,0xD4 } },
+		{ 13 , { 0x44,0x77,0x86,0x5D,0x20,0x07,0x55,0xD0,0xB1,0xE4,0x79,0x66,0xC5 } },
+		{ 8 , { 0x07,0x97,0xBB,0x36,0xC6,0xCA,0x63,0x7B } },
+		{ 14 , { 0x35,0xFE,0x06,0x3A,0xB5,0x7A,0x96,0x81,0x71,0x20,0xB7,0x92,0x02,0xA4 } },
+		{ 8 , { 0x07,0x4C,0xED,0x96,0x46,0x61,0xEE,0x30 } },
+		{ 16 , { 0x3F,0xFF,0x0D,0x10,0xE7,0x39,0x25,0xC2,0xCA,0xBC,0x8B,0x3D,0x5A,0x44,0xA4,0xF8 } },
+		{ 15 , { 0x46,0xEB,0xAA,0x98,0xE9,0x2C,0xBD,0x07,0x01,0x63,0x82,0x19,0x65,0x31,0x84 } },
+		{ 16 , { 0x3F,0x58,0xFA,0x1E,0x5D,0x4E,0x9A,0xCF,0x1C,0x51,0x7B,0xE2,0x8D,0xE6,0xA2,0x10 } },
+		{ 16 , { 0x37,0x94,0x7B,0x52,0x03,0xC5,0x18,0x86,0xB6,0xD1,0x44,0x3B,0xBD,0x69,0xDC,0x21 } },
+		{ 16 , { 0x3F,0xB9,0x57,0xEA,0xA5,0x13,0xBE,0x6B,0xF3,0x0A,0x54,0x85,0x8D,0x77,0x44,0x69 } },
+		{ 16 , { 0x37,0x29,0xB7,0xE1,0xAD,0xC0,0x47,0x53,0xB2,0x3F,0x10,0x9E,0xDC,0x70,0x71,0x22 } },
+		{ 16 , { 0x3F,0x14,0xCA,0x0D,0x42,0x9B,0x02,0x25,0xD5,0x43,0xBD,0xB4,0xB4,0xF4,0x0E,0x8A } },
+		{ 14 , { 0x4D,0xE6,0xF8,0xC8,0x36,0x22,0x07,0x67,0xC0,0x28,0x4F,0xB4,0xF0,0xBF } },
+		{ 13 , { 0x44,0xB0,0x86,0x2E,0x98,0x07,0x5A,0x2B,0x23,0x14,0x75,0x08,0x85 } },
+		{ 12 , { 0x4B,0x37,0x90,0x92,0x0F,0x69,0x7F,0x43,0xE5,0x5E,0x1D,0xBA } },
+		{ 16 , { 0x37,0x6F,0xED,0x83,0x81,0x1B,0x11,0x4C,0x27,0x82,0x22,0x32,0x74,0xCB,0xBF,0xB4 } },
+		{ 16 , { 0x37,0x8E,0xFC,0xDC,0x2D,0x93,0xA8,0x19,0x58,0x86,0x3B,0x74,0xB0,0xB7,0x79,0x5C } },
+		{ 16 , { 0x47,0x0E,0xA6,0xEF,0xBF,0x9B,0xAF,0x73,0x07,0xAB,0xDE,0xF0,0x70,0x07,0xBA,0xCB } },
+		{ 11 , { 0x4A,0x43,0xCC,0x07,0x69,0x9B,0xED,0x59,0x5C,0x91,0xED } },
+		{ 9 , { 0x30,0xEB,0xA0,0xA2,0x75,0xD2,0x2B,0xA3,0x52 } },
+		{ 16 , { 0x07,0xF3,0xB4,0xA9,0x75,0x4C,0x97,0xC6,0x07,0x33,0x44,0x76,0x7A,0xD1,0xF2,0x4E } },
+		{ 16 , { 0x07,0x65,0x1C,0xAB,0xE1,0x9E,0x83,0xCC,0x0F,0x77,0x0B,0xB9,0x11,0x65,0x59,0x4A } },
+		{ 15 , { 0x0F,0x45,0xDD,0xE8,0x58,0x2B,0x7B,0xB0,0x46,0x55,0x36,0x83,0x02,0xC7,0xED } },
+		{ 16 , { 0x0F,0x8F,0xB9,0x0D,0xB4,0xA1,0x23,0x21,0x0F,0x35,0x51,0x00,0xD1,0xC9,0x1C,0x59 } },
+		{ 13 , { 0x3C,0x89,0x2D,0x0D,0x45,0x36,0x2F,0x46,0x28,0xDC,0x43,0x95,0xE1 } },
+		{ 8 , { 0x0F,0x77,0x09,0x07,0x56,0xBC,0x50,0xD4 } },
+		{ 16 , { 0x37,0x9C,0x70,0x02,0xEE,0x41,0xB2,0x36,0xA7,0x99,0x6E,0x5E,0xAD,0xAB,0x1B,0x01 } },
+		{ 16 , { 0x3F,0x8A,0xA8,0xBD,0x6E,0x6A,0x74,0x37,0xF7,0x2A,0x89,0x47,0x91,0x75,0x4C,0xFB } },
+		{ 14 , { 0x45,0xE5,0x74,0xB2,0xBB,0x6E,0x0F,0x3B,0xC4,0x2E,0x57,0xDA,0x90,0x9B } },
+		{ 12 , { 0x3B,0xD1,0xB0,0xFC,0x79,0xBD,0xF5,0xB8,0xA4,0x63,0x37,0x97 } },
+		{ 16 , { 0x0F,0x54,0xEA,0x19,0x33,0x1F,0x43,0x1E,0x0F,0xE7,0x32,0x43,0xAE,0x27,0xFB,0xD2 } },
+		{ 8 , { 0x0F,0x3A,0x48,0x55,0x48,0x5A,0x16,0x0E } },
+		{ 11 , { 0x3A,0xBF,0xA9,0x8D,0x02,0x34,0x58,0x6D,0xE0,0x89,0x6A } },
+		{ 8 , { 0x0F,0x84,0xDF,0xCA,0xFD,0x33,0x0C,0xFF } },
+		{ 12 , { 0x3B,0x6D,0x30,0x86,0x93,0x33,0x8B,0xBD,0x86,0xFE,0x86,0xDB } },
+		{ 8 , { 0x07,0x98,0x0C,0x52,0x0F,0xC3,0x23,0x6A } },
+		{ 10 , { 0x39,0x89,0xF5,0x34,0x03,0xF0,0xAE,0x70,0xA0,0x33 } },
+		{ 11 , { 0x0F,0x12,0x47,0x09,0x2D,0x0F,0xBC,0xF8,0x42,0x67,0xAE } },
+		{ 14 , { 0x07,0xED,0x76,0x41,0xC2,0xD3,0x39,0xDE,0x45,0x4F,0x2B,0x2E,0x2C,0x89 } },
+		{ 14 , { 0x07,0xFB,0xBA,0x30,0xC0,0xDD,0xF5,0x06,0x45,0x10,0x62,0x58,0x63,0xA0 } },
+		{ 8 , { 0x07,0xED,0xA3,0x2A,0xAE,0x0F,0x91,0xDB } },
+		{ 16 , { 0x3F,0xB1,0xC1,0xF6,0xEF,0x12,0x9B,0x3E,0x65,0xF7,0x4F,0x21,0x31,0xB8,0x2E,0x23 } },
+		{ 12 , { 0x3B,0x9C,0xD2,0xE4,0x4C,0xAD,0x3F,0xF1,0x3D,0xF7,0xBD,0x56 } },
+		{ 12 , { 0x07,0x01,0xEA,0x75,0xF4,0x2A,0xD3,0xC6,0x4B,0xDC,0x4C,0x6A } },
+		{ 16 , { 0x0F,0xA2,0x38,0xE3,0xBF,0x4E,0x78,0x83,0x0F,0xCC,0x5A,0x4E,0x96,0xB0,0x2E,0xFA } },
+		{ 8 , { 0x07,0xE8,0x5A,0x55,0x26,0x2C,0xB5,0x1D } },
+		{ 16 , { 0x3F,0x26,0xEF,0x93,0x95,0x13,0x6A,0x36,0xE3,0x81,0x81,0x9A,0x6C,0x00,0x21,0x60 } },
+		{ 16 , { 0x3F,0x6D,0xF1,0x70,0x5F,0x19,0xDD,0xB9,0x28,0xB1,0xE8,0x06,0xF1,0x35,0x7F,0x14 } },
+		{ 16 , { 0x37,0xAE,0x87,0x10,0xD7,0xCF,0x8F,0xD6,0xBF,0x53,0x76,0x3A,0xD4,0x94,0x1A,0xEC } },
+		{ 16 , { 0x37,0xC5,0x41,0xC5,0x2A,0x32,0x72,0x9A,0x4A,0x62,0x88,0xD3,0x1E,0x58,0xED,0x5A } },
+		{ 16 , { 0x37,0x41,0x33,0xA6,0xB2,0x4C,0xF2,0x01,0x92,0x14,0xBD,0x7D,0xB2,0x3F,0xEF,0xE1 } },
+		{ 16 , { 0x3F,0xEC,0x09,0xF1,0x3D,0x09,0xFE,0x0B,0xA9,0xEA,0xAB,0x45,0x72,0xA4,0x1F,0x43 } },
+		{ 15 , { 0x3E,0x3D,0xD0,0x37,0xBA,0xE9,0xB6,0xDE,0xE4,0xAF,0x22,0x7A,0x18,0x48,0xEE } },
+		{ 8 , { 0x0F,0x05,0xF1,0x64,0x74,0x28,0x1B,0x93 } },
+		{ 16 , { 0x37,0x47,0x68,0xA8,0x7F,0x0E,0x0A,0xD4,0x6C,0xC0,0x0D,0xF0,0x82,0x86,0x83,0x1E } },
+		{ 16 , { 0x37,0xBD,0x51,0x92,0x8E,0xCE,0x04,0x83,0x95,0xBC,0xAB,0x2A,0x2B,0x5D,0x5D,0x85 } },
+		{ 16 , { 0x3F,0x39,0x1C,0x2C,0x62,0x37,0x74,0xF4,0xBF,0xB1,0x96,0x75,0xBC,0x6B,0x81,0xFD } },
+		{ 16 , { 0x37,0x24,0xC9,0xFA,0x39,0xD8,0xC1,0x40,0x49,0x78,0x4A,0x0A,0xAB,0x0E,0x6F,0x34 } },
+		{ 16 , { 0x3F,0xB0,0x13,0xBA,0x55,0x70,0x67,0x51,0x34,0x87,0xA9,0x8C,0x5B,0x4F,0x6A,0x14 } },
+		{ 16 , { 0x37,0xC9,0x85,0xCD,0xFB,0xF9,0x87,0x68,0x1B,0xB6,0xB6,0xED,0x4A,0x03,0xC5,0xE3 } },
+		{ 16 , { 0x37,0xA8,0x1D,0xFA,0x88,0xBA,0x0E,0x45,0x98,0x9C,0xCC,0x15,0xCC,0x6C,0x34,0xC6 } },
+		{ 16 , { 0x37,0x12,0x71,0x87,0x21,0xD8,0x35,0x81,0xFE,0x50,0xEB,0x70,0x9B,0x3D,0x0F,0x24 } },
+		{ 16 , { 0x37,0x48,0x21,0xC0,0x54,0xEB,0x80,0xBE,0x58,0x2C,0x7A,0xBF,0xE1,0x55,0xAC,0x0A } },
+		{ 16 , { 0x3F,0xAC,0xE6,0x81,0x16,0xE1,0x94,0x35,0x9E,0x3F,0x44,0x01,0xD9,0x39,0xF6,0x96 } },
+		{ 16 , { 0x3F,0x87,0x2E,0xC2,0x20,0x44,0x09,0x82,0xD5,0x5A,0xF0,0x5C,0x4F,0x4A,0x24,0xE4 } },
+		{ 16 , { 0x37,0x58,0x7B,0x6F,0x8C,0xF9,0x84,0x6A,0x60,0xDB,0xB7,0xBB,0x2C,0x13,0xBF,0x2B } },
+		{ 16 , { 0x37,0xD8,0x21,0x0F,0x40,0x35,0x0E,0x46,0x72,0x27,0x4A,0x4E,0x88,0x8E,0x27,0xF8 } },
+		{ 10 , { 0x39,0x8C,0x56,0x15,0xF5,0xE2,0xAA,0x99,0x98,0x80 } },
+		{ 8 , { 0x0F,0x5A,0x04,0xD3,0x73,0x75,0x7D,0x5A } },
+		{ 14 , { 0x35,0xC7,0x99,0x87,0xBC,0xC8,0x19,0xF8,0xC0,0xFA,0xAD,0x03,0xF7,0xE5 } },
+		{ 8 , { 0x07,0x7F,0xA5,0xD1,0xCC,0x2F,0xA2,0x83 } },
+		{ 16 , { 0x3F,0x53,0xD7,0xC5,0xE9,0xD5,0xC2,0x72,0xAC,0x4F,0xF9,0xE1,0x13,0x0E,0x8B,0x76 } },
+		{ 16 , { 0x3F,0x9C,0xFD,0xFC,0x8B,0x2A,0x8C,0x58,0x20,0xC5,0x4B,0x79,0x5A,0x7A,0xC8,0x35 } },
+		{ 16 , { 0x37,0x52,0x61,0x5D,0x2C,0x37,0x3C,0x7C,0x27,0x2B,0x56,0x28,0xA4,0x29,0x89,0x0E } },
+		{ 16 , { 0x3F,0xDE,0x96,0x85,0x21,0x5B,0x42,0x0E,0x23,0xD3,0xBF,0xDC,0x3C,0x36,0x55,0xE5 } },
+		{ 16 , { 0x3F,0xE6,0x7E,0x72,0x37,0x4E,0x37,0xEB,0x3E,0x80,0xEE,0x8F,0xED,0x4C,0xBE,0xE0 } },
+		{ 11 , { 0x3A,0xF7,0xAD,0xD0,0x67,0x3F,0xFA,0x83,0xD9,0x46,0xC5 } },
+		{ 8 , { 0x07,0x41,0xDB,0x56,0x6C,0xEF,0xDF,0xA9 } },
+		{ 16 , { 0x3F,0x7B,0x59,0xE3,0x57,0x3A,0x43,0x46,0xA3,0xFB,0x1B,0xC4,0xCD,0x40,0x5B,0xBB } },
+		{ 16 , { 0x3F,0x3D,0x37,0x62,0xE9,0x61,0x90,0x2C,0xAA,0x1C,0x53,0xCD,0x16,0x3D,0xEA,0xE9 } },
+		{ 16 , { 0x37,0x5E,0xAC,0xDC,0x22,0xD4,0x48,0xE1,0x0E,0x2E,0x46,0xB4,0xFC,0xD7,0x92,0xB9 } },
+		{ 16 , { 0x37,0x00,0x45,0xE4,0x2C,0x11,0xB7,0x3A,0x79,0x67,0x7F,0x45,0x86,0xB2,0xE5,0xD8 } },
+		{ 10 , { 0x41,0x4F,0x07,0x91,0x17,0x0B,0xDD,0x28,0xDE,0x9F } },
+		{ 16 , { 0x3F,0x9B,0x06,0x46,0x87,0xF1,0x83,0x1F,0xDD,0xE4,0x4D,0xD4,0xAB,0x0F,0x51,0x8E } },
+		{ 16 , { 0x37,0x01,0x73,0x10,0x44,0x79,0xF4,0x00,0x00,0x55,0x5D,0x87,0x88,0xFD,0x11,0x5D } },
+		{ 11 , { 0x32,0x78,0x0B,0xA8,0x77,0x42,0x2B,0xD6,0xB5,0xFC,0x55 } },
+		{ 8 , { 0x0F,0x8D,0x29,0x21,0xFD,0x22,0xCA,0xB7 } },
+		{ 16 , { 0x37,0x08,0x2C,0x76,0xDA,0x2B,0xDC,0x12,0xAB,0xC0,0x94,0xC5,0x1D,0x6D,0x7F,0x0B } },
+		{ 16 , { 0x37,0xB6,0x4A,0xC6,0xE0,0x36,0xC6,0x51,0x27,0x90,0x3B,0xAA,0xDD,0x85,0x62,0xBC } },
+		{ 16 , { 0x3F,0xA0,0x29,0x29,0x43,0xB0,0x96,0x14,0xF9,0x6B,0x86,0xBD,0xBD,0xAD,0x99,0x85 } },
+		{ 16 , { 0x3F,0xB0,0x4F,0x3B,0x70,0x33,0xB4,0x4D,0x51,0xA8,0x61,0xAA,0xDF,0x6F,0xDC,0x4B } },
+		{ 16 , { 0x37,0x1C,0x91,0x82,0xCC,0xF8,0x51,0x02,0xE3,0x2C,0x29,0x76,0x02,0x2E,0x48,0x3D } },
+		{ 16 , { 0x4F,0x93,0x5F,0x26,0xA3,0xA8,0x6A,0x4B,0x07,0xEA,0x6C,0x7C,0xED,0x1A,0x18,0x89 } },
+		{ 13 , { 0x3C,0x35,0xDE,0xE4,0xF2,0x10,0xC7,0x6B,0xF3,0x4A,0x92,0x71,0xFC } },
+		{ 16 , { 0x07,0xAC,0xD9,0x0E,0xBB,0x10,0xFA,0xF4,0x07,0xB6,0x10,0x48,0x8B,0x75,0x88,0x08 } },
+		{ 8 , { 0x0F,0x48,0xCC,0x6D,0xC4,0x40,0x1F,0xAD } },
+		{ 9 , { 0x38,0x46,0x81,0xAD,0x86,0x94,0x7F,0x98,0xFA } },
+		{ 8 , { 0x07,0x9C,0xEB,0x03,0x7C,0x62,0xB9,0x25 } },
+		{ 16 , { 0x3F,0x8D,0xC0,0x24,0xF9,0x4E,0xB5,0xE0,0x05,0x37,0xBE,0x8A,0x8A,0xCC,0xE1,0x9B } },
+		{ 16 , { 0x3F,0xED,0xD6,0x84,0x39,0x2D,0xAD,0xF2,0xD1,0xC9,0x98,0x58,0xD3,0xBB,0x7D,0x4A } },
+		{ 16 , { 0x47,0x6D,0x97,0x3E,0x93,0xF7,0x16,0xFE,0x07,0x82,0xA5,0xD2,0x9A,0xF0,0x19,0x3C } },
+		{ 16 , { 0x3F,0x68,0x5C,0x5A,0x3F,0xA7,0xE7,0x42,0xC6,0x2A,0x6C,0x3B,0xE7,0xC7,0x7B,0xE1 } },
+		{ 11 , { 0x42,0xCB,0x39,0x07,0x59,0x5C,0x8C,0xF3,0xB1,0x46,0x37 } },
+		{ 16 , { 0x3F,0x3B,0xC2,0x98,0xBD,0x94,0x10,0x15,0xBC,0x76,0xA0,0x98,0x8E,0x6F,0x09,0xEA } },
+		{ 12 , { 0x4B,0x9E,0x75,0x9C,0x0F,0x2E,0xED,0xEE,0x09,0x3B,0x0F,0xDF } },
+		{ 16 , { 0x0F,0x70,0x5B,0x7D,0x1A,0x36,0x09,0x14,0x0F,0x18,0xDD,0x9D,0x72,0x99,0x10,0x51 } },
+		{ 16 , { 0x37,0x46,0x82,0x0C,0xF3,0xF5,0xA7,0x33,0xFD,0xD3,0x54,0xDE,0xC0,0x97,0xEF,0x49 } },
+		{ 11 , { 0x4A,0x61,0xE7,0x07,0xE6,0x7F,0x70,0xB9,0xC2,0xBC,0x1B } },
+		{ 16 , { 0x07,0xCC,0x93,0x86,0xE0,0x2B,0x4D,0x3D,0x07,0x23,0x8A,0x2F,0xD7,0x49,0x9A,0x6D } },
+		{ 8 , { 0x07,0x0A,0xCF,0x3A,0x24,0x67,0x2A,0x63 } },
+		{ 11 , { 0x3A,0xC2,0xC9,0x06,0x90,0xBD,0x45,0x5D,0xAB,0xFC,0x7C } },
+		{ 13 , { 0x0F,0x5C,0x63,0xB6,0xE8,0xF8,0x4C,0x03,0x4C,0x13,0xC5,0x44,0x45 } },
+		{ 16 , { 0x0F,0xB5,0x7F,0xFF,0xF8,0x2C,0xA7,0x7A,0x4F,0xD1,0xAA,0x18,0x7A,0x42,0xE7,0x6A } },
+		{ 8 , { 0x07,0x56,0xFD,0xCA,0x84,0x27,0x09,0xA0 } },
+		{ 15 , { 0x36,0x5F,0x77,0x76,0x77,0x10,0xEE,0x1D,0x1B,0x5D,0x32,0xCB,0xC5,0x1F,0x1E } },
+		{ 15 , { 0x07,0x49,0x7D,0x86,0xE2,0x53,0x2A,0x36,0x46,0xC3,0xC2,0x2D,0xCB,0xBB,0xC4 } },
+		{ 16 , { 0x0F,0xDC,0x74,0x41,0xCA,0xC6,0x87,0xC5,0x07,0x24,0x52,0x58,0x1B,0x73,0xE3,0xDF } },
+		{ 15 , { 0x46,0x69,0x5B,0xFF,0x46,0xA8,0xD0,0x07,0xE3,0x46,0x2C,0x1B,0xA6,0x12,0x30 } },
+		{ 16 , { 0x37,0xD4,0xE0,0xD1,0xDA,0x09,0xE6,0x65,0x3B,0xC6,0x2C,0xA9,0x8A,0x5B,0x59,0xF8 } },
+		{ 16 , { 0x37,0x6A,0x6D,0x61,0x48,0x58,0x13,0xB1,0x48,0xE9,0xD9,0x0F,0x8E,0x22,0x30,0x9D } },
+		{ 16 , { 0x37,0x84,0xE6,0x21,0xFD,0x23,0xA9,0x85,0x23,0x52,0x68,0x2C,0xDE,0x07,0x9F,0x06 } },
+		{ 16 , { 0x37,0xBF,0x16,0xA5,0x7E,0x14,0x45,0xE2,0x20,0xDC,0x77,0x5E,0xF1,0xF8,0xB8,0xB2 } },
+		{ 16 , { 0x3F,0x0D,0x41,0x9B,0x88,0x55,0x39,0x4A,0x33,0xA9,0x0F,0x26,0x8B,0xFC,0x70,0xAC } },
+		{ 10 , { 0x41,0x70,0x0F,0x76,0xBD,0x5A,0xED,0x08,0x09,0x04 } },
+		{ 16 , { 0x0F,0xEA,0x6E,0x20,0xC8,0xD3,0x19,0xA3,0x07,0x60,0x16,0x50,0x6C,0xC9,0x4B,0x6F } },
+		{ 11 , { 0x32,0x97,0x0F,0x94,0x24,0x6C,0x5F,0x97,0xC2,0xE2,0x55 } },
+		{ 13 , { 0x0F,0x7C,0x3E,0xA8,0x8C,0xC4,0xF4,0x83,0x44,0x24,0x5A,0x1B,0xF2 } },
+		{ 8 , { 0x07,0x01,0xC5,0x03,0x17,0x44,0xB9,0x97 } },
+		{ 16 , { 0x37,0x75,0x9A,0xD9,0x9C,0x26,0x49,0x09,0xDF,0xCB,0x23,0x2E,0xF6,0xBD,0xB3,0x92 } },
+		{ 11 , { 0x32,0xE5,0xCF,0x57,0x9C,0xF4,0x13,0x27,0xC8,0xD8,0xD9 } },
+		{ 11 , { 0x0F,0xCE,0xF0,0x4A,0x6C,0xDF,0x4F,0xF5,0x4A,0xB2,0x1D } },
+		{ 8 , { 0x0F,0x32,0xC1,0x9A,0xAC,0x00,0xB0,0x79 } },
+		{ 16 , { 0x3F,0xEB,0x6B,0x6A,0x75,0xE5,0x01,0x4A,0x73,0x44,0x54,0x49,0x34,0xA9,0x9A,0x1A } },
+		{ 16 , { 0x4F,0x7D,0xBE,0x96,0xC1,0x63,0x46,0x61,0x07,0xAC,0x09,0x7D,0x47,0xDC,0x62,0xB3 } },
+		{ 14 , { 0x35,0x6F,0x4E,0x24,0xCB,0x25,0x62,0xA6,0xAB,0x37,0xE2,0xAC,0xE3,0x13 } },
+		{ 16 , { 0x07,0x93,0x60,0x60,0xB1,0x8D,0xC6,0xBB,0x07,0x29,0xBC,0x5C,0x13,0x8D,0x39,0xF4 } },
+		{ 8 , { 0x0F,0xAF,0x57,0xC7,0xB8,0x9E,0x72,0x0F } },
+		{ 16 , { 0x37,0xF0,0xC3,0x26,0xAA,0x26,0x48,0x7C,0x42,0xCA,0xB8,0x23,0x1B,0xC4,0xE8,0xB3 } },
+		{ 15 , { 0x46,0x67,0xC8,0xF8,0x0A,0x70,0x94,0x07,0x3C,0xF5,0xC8,0x66,0xE9,0x14,0x0C } },
+		{ 15 , { 0x36,0xA5,0x8E,0x38,0x1A,0xED,0x60,0x56,0x31,0x78,0xDE,0x6A,0x96,0xE3,0xEE } },
+		{ 16 , { 0x0F,0xAC,0x49,0xAD,0xBB,0x3B,0xCA,0x70,0x07,0xF7,0x4E,0xFC,0xE8,0x34,0x3E,0x7E } },
+		{ 8 , { 0x0F,0xE4,0xAE,0xEE,0x2B,0x08,0xEE,0xD0 } },
+		{ 16 , { 0x3F,0xE7,0x40,0x35,0x54,0xDF,0x0F,0x71,0x4A,0x92,0xC3,0xDF,0x8B,0x52,0x72,0xE7 } },
+		{ 12 , { 0x33,0x3C,0x92,0x3B,0xA2,0x2F,0x2D,0xD5,0x38,0xBB,0xF4,0xC1 } },
+		{ 8 , { 0x0F,0x07,0xFC,0x05,0xBB,0x58,0x06,0x5A } },
+		{ 9 , { 0x38,0x37,0x9A,0x45,0x6F,0x99,0xCE,0xC9,0xF6 } },
+		{ 16 , { 0x0F,0x72,0x45,0xC8,0x00,0x0D,0x68,0xAA,0x07,0xDE,0xDF,0x82,0x69,0x0E,0x32,0xE9 } },
+		{ 16 , { 0x07,0x78,0xC1,0x67,0x9E,0x54,0x8A,0x2B,0x07,0xEA,0xA7,0x77,0xD4,0x9E,0xE5,0xE3 } },
+		{ 8 , { 0x07,0xB6,0xB9,0xFE,0xBE,0xD9,0x74,0x8A } },
+		{ 12 , { 0x33,0x88,0x98,0xA2,0xC2,0x9F,0x73,0x68,0x12,0xAB,0xC5,0x1C } },
+		{ 8 , { 0x07,0xBB,0xD3,0x37,0x63,0x4C,0x82,0x3F } },
+		{ 16 , { 0x3F,0xD3,0xD1,0xD6,0x5A,0xED,0x66,0xB7,0xAB,0x9F,0x84,0xE6,0xE5,0x0F,0x1E,0x93 } },
+		{ 16 , { 0x37,0xFB,0x70,0x41,0x8C,0xD8,0x54,0x2A,0x99,0xD0,0x57,0x8F,0xE7,0x09,0x91,0x3C } },
+		{ 16 , { 0x37,0x5B,0x65,0x7A,0x89,0x19,0xF8,0xAD,0x6E,0x25,0x02,0x48,0xA4,0xBE,0xE2,0xD2 } },
+		{ 16 , { 0x3F,0x2C,0x56,0x91,0xB0,0xFA,0x21,0x6E,0x88,0xC0,0x24,0x84,0x93,0xBA,0xC7,0x6E } },
+		{ 16 , { 0x3F,0xD6,0x00,0x15,0x3F,0x12,0x31,0x6D,0x12,0x53,0x27,0xDC,0xAC,0x8C,0x77,0xED } },
+		{ 13 , { 0x44,0xD3,0x8E,0xEF,0xE2,0x0F,0x81,0xD6,0xCB,0xBA,0xA0,0x64,0x40 } },
+		{ 16 , { 0x37,0xDC,0x24,0xEA,0x2D,0xCB,0x61,0xA7,0x1A,0x97,0xFF,0x6B,0xA0,0x5C,0xB8,0xF9 } },
+		{ 16 , { 0x37,0x30,0x53,0x4C,0x24,0x5D,0x31,0x12,0x57,0x02,0x7C,0x0E,0x41,0x80,0x79,0xC1 } },
+		{ 10 , { 0x49,0xC8,0x0F,0x23,0x35,0xC5,0xD2,0x8A,0xC9,0x16 } },
+		{ 16 , { 0x37,0x3C,0xED,0x06,0x89,0xCA,0x5C,0xE6,0x02,0x2E,0x09,0xA2,0xC3,0xF0,0x64,0x32 } },
+		{ 16 , { 0x0F,0xF2,0x4F,0x8F,0xDE,0x9F,0xBA,0x5C,0x0F,0x67,0xB2,0xC5,0xB9,0x28,0xCC,0x2E } },
+		{ 16 , { 0x07,0xF8,0xE1,0xF2,0x5E,0xFF,0xCE,0xC6,0x07,0x9F,0x9D,0x23,0x64,0xAC,0x9B,0x67 } },
+		{ 16 , { 0x07,0x2A,0x4C,0x3D,0x14,0xBB,0xD4,0x31,0x0F,0x0C,0x24,0xD2,0x12,0x8C,0xD1,0x65 } },
+		{ 16 , { 0x37,0x12,0x02,0x1B,0xEC,0x92,0xEF,0x9E,0x56,0xA7,0x96,0x6E,0xB2,0x8D,0x12,0x2F } },
+		{ 16 , { 0x37,0xAB,0x09,0x10,0x3C,0x5C,0x1C,0xE5,0x4A,0x38,0x19,0xC8,0x7A,0xA9,0x7C,0x60 } },
+		{ 16 , { 0x3F,0x05,0xDE,0x7F,0x76,0x75,0x33,0x73,0x43,0x68,0xB4,0xC2,0xD0,0xA8,0x47,0xAC } },
+		{ 16 , { 0x3F,0x40,0xE3,0xB5,0x09,0xF4,0xF0,0x07,0x1A,0x4E,0x61,0x25,0x0D,0x25,0x34,0x28 } },
+		{ 16 , { 0x3F,0x77,0xA1,0xA0,0xC2,0x84,0x9F,0x70,0xF0,0x5F,0x71,0x0E,0x1F,0x68,0xA7,0x3F } },
+		{ 16 , { 0x3F,0x3A,0x52,0x96,0x83,0x9A,0x02,0x06,0x35,0x2A,0x1C,0x3A,0x75,0xBA,0x65,0xD8 } },
+		{ 12 , { 0x43,0x34,0x82,0x22,0x07,0xDE,0x9A,0xE0,0xE3,0x0C,0x23,0x86 } },
+		{ 16 , { 0x37,0x1F,0x51,0x23,0xD9,0x7B,0x66,0x1C,0x8C,0xE0,0xA5,0xB6,0xA8,0x89,0xA3,0x4C } },
+		{ 16 , { 0x37,0xB2,0xC7,0x45,0x42,0xCA,0x16,0xE9,0x86,0xEA,0xA9,0x8A,0x22,0xEF,0xB4,0xCA } },
+		{ 16 , { 0x37,0xD7,0xD1,0x5F,0x7B,0x33,0x07,0x21,0x52,0x59,0x61,0x89,0xF3,0x90,0xF8,0xEA } },
+		{ 14 , { 0x4D,0xC3,0x87,0xBB,0x9D,0xAF,0x0F,0xBC,0x66,0x33,0xBE,0x92,0x62,0xEF } },
+		{ 16 , { 0x3F,0x62,0xA8,0xCE,0xF1,0xB2,0x3D,0x16,0xCF,0xD6,0x21,0x1F,0xA3,0x48,0x26,0xC8 } },
+		{ 10 , { 0x41,0x43,0x07,0xC2,0x55,0x4B,0x1D,0xEA,0x49,0x68 } },
+		{ 13 , { 0x3C,0xD4,0xE5,0xA3,0x20,0xCB,0x42,0x9D,0xC4,0xFC,0x7E,0xAB,0xCA } },
+		{ 8 , { 0x07,0xB1,0x04,0xB5,0x51,0xE4,0xDF,0x9F } },
+		{ 16 , { 0x37,0x1F,0x5E,0xEB,0xAC,0x9C,0x8C,0xE9,0xF9,0xA1,0xBB,0x8A,0x68,0x47,0x61,0xA2 } },
+		{ 16 , { 0x37,0x04,0x7B,0xC4,0xE1,0x7F,0x2B,0xBE,0x2A,0x60,0x13,0xC7,0x50,0xA1,0xB8,0x36 } },
+		{ 10 , { 0x39,0x35,0xAE,0x58,0xAA,0x84,0xEA,0x76,0x52,0xCC } },
+		{ 8 , { 0x07,0x69,0x40,0x3F,0x04,0x60,0x17,0x2C } },
+		{ 16 , { 0x37,0xD4,0x50,0x3E,0x2E,0xCE,0x73,0xF2,0xED,0x7E,0x12,0x5A,0xF1,0x21,0xFA,0xEC } },
+		{ 8 , { 0x0F,0x54,0x0A,0x35,0x46,0xF8,0xA4,0x34 } },
+		{ 12 , { 0x3B,0x1A,0x6B,0x4D,0x95,0xCE,0x02,0x0D,0x54,0x48,0x11,0x49 } },
+		{ 16 , { 0x07,0xE2,0x68,0x94,0x50,0x03,0x14,0xD5,0x07,0x1E,0x04,0xD6,0x66,0x5B,0xF0,0x8B } },
+		{ 8 , { 0x07,0xD8,0xD1,0x2F,0x35,0x9C,0x42,0x9F } },
+		{ 16 , { 0x3F,0xD1,0xDA,0x9A,0xF7,0x0E,0x1D,0xAD,0xD2,0x16,0xD7,0x2B,0xD3,0x74,0x89,0x92 } },
+		{ 16 , { 0x3F,0xBA,0x99,0xBA,0x03,0x40,0xB0,0xE5,0x21,0x57,0x3A,0x4C,0x91,0x9F,0x8B,0x73 } },
+		{ 15 , { 0x49,0x68,0x07,0x9F,0xCE,0xC6,0xE1,0xFE,0xB7,0xC8,0x44,0xD0,0xAC,0x97,0x5E } },
+		{ 8 , { 0x0F,0x86,0xF1,0xFE,0x3B,0x83,0x5B,0x71 } },
+		{ 10 , { 0x39,0x5C,0xEE,0xC6,0xAB,0xA2,0x32,0xB6,0xCD,0x1E } },
+		{ 16 , { 0x0F,0xDB,0xD5,0x00,0x80,0xE5,0x8F,0xF4,0x07,0x9F,0xCE,0x1A,0x6D,0x00,0x91,0x8F } },
+		{ 8 , { 0x0F,0xDC,0x4B,0xE8,0x37,0xAC,0x80,0xE7 } },
+		{ 9 , { 0x38,0x0D,0x16,0xF8,0x22,0x6D,0x54,0xB5,0x72 } },
+		{ 11 , { 0x0F,0x3F,0xCB,0x62,0x48,0xA7,0xB9,0x92,0x4A,0x85,0x17 } },
+		{ 8 , { 0x07,0xCA,0x4B,0x40,0x47,0xA0,0x82,0xF6 } },
+		{ 16 , { 0x3F,0x01,0xC0,0x03,0x69,0x3F,0x89,0x4A,0xAA,0x24,0xC2,0x3C,0x24,0xA4,0x0A,0x12 } },
+		{ 16 , { 0x37,0xD8,0x01,0x02,0x77,0xAB,0xB4,0xC1,0xC9,0xB4,0x04,0x68,0x15,0xBE,0x6A,0xEC } },
+		{ 10 , { 0x39,0x2C,0x13,0x17,0x37,0xE1,0xF9,0xF6,0xEE,0x00 } },
+		{ 15 , { 0x0F,0x06,0x30,0x10,0x12,0x3B,0x7C,0xDB,0x4E,0x33,0xB6,0xAF,0xEF,0x95,0x0E } },
+		{ 16 , { 0x0F,0xE0,0xF5,0xE4,0xFA,0xEA,0x82,0x32,0x0F,0xA6,0x8D,0x92,0x58,0x06,0xDF,0x08 } },
+		{ 16 , { 0x37,0x52,0x3C,0xA9,0x93,0xE8,0xFC,0x3F,0x1A,0x44,0x67,0x10,0xEE,0x0C,0xBF,0x23 } },
+		{ 10 , { 0x41,0x20,0x07,0xE8,0xA2,0xB8,0x53,0x92,0x44,0x14 } },
+		{ 16 , { 0x3F,0x15,0xA4,0xE8,0x4B,0x85,0x0C,0x9D,0xC4,0x9C,0x60,0x2F,0x42,0x5E,0xF6,0xEE } },
+		{ 16 , { 0x3F,0x55,0x5A,0xAD,0x27,0x5F,0xDC,0x07,0xEF,0x32,0x7E,0x58,0xD2,0xFA,0x2A,0x4A } },
+		{ 8 , { 0x07,0xBD,0xD5,0x42,0x09,0x21,0x5E,0xD5 } },
+		{ 12 , { 0x3B,0x18,0x38,0x33,0x0B,0x23,0x35,0x69,0xB1,0x65,0x91,0x0C } },
+		{ 16 , { 0x0F,0x81,0xA7,0xDA,0x78,0x40,0xE2,0x71,0x07,0x2C,0x50,0x4E,0x27,0xB3,0x61,0xE6 } },
+		{ 15 , { 0x3E,0x83,0xCC,0xDB,0xCF,0x1F,0xC7,0x07,0x06,0xB3,0x98,0xF7,0x51,0x18,0x91 } },
+		{ 16 , { 0x0F,0x8C,0x4F,0xEF,0x7E,0x6A,0x7D,0x58,0x07,0xFC,0xCD,0xCC,0xF6,0x1C,0xB9,0x73 } },
+		{ 16 , { 0x07,0xF3,0x72,0xCC,0x1E,0x9E,0x11,0xCC,0x07,0x2C,0x65,0xF1,0x73,0xDB,0xFE,0x79 } },
+		{ 8 , { 0x07,0xFB,0x7F,0x9D,0x8C,0x26,0x05,0x5A } },
+		{ 9 , { 0x38,0xCE,0xD2,0x5A,0x36,0xC6,0x18,0x62,0xC9 } },
+		{ 11 , { 0x0F,0xE4,0x9C,0xEA,0x55,0x57,0x84,0x37,0x4A,0x8A,0x90 } },
+		{ 8 , { 0x07,0x6D,0xC9,0xA9,0x20,0xFC,0x83,0xF8 } },
+		{ 15 , { 0x36,0xCB,0x14,0x43,0x10,0x8C,0x98,0x38,0x76,0x25,0x4E,0xBA,0x68,0x79,0xB7 } },
+		{ 8 , { 0x0F,0x99,0x87,0xAB,0x3D,0x0D,0x21,0x82 } },
+		{ 15 , { 0x36,0x82,0xB5,0xAA,0xF8,0xB2,0xBC,0xDD,0x00,0xD7,0xE1,0x42,0x38,0xB2,0x7D } },
+		{ 8 , { 0x07,0x40,0x3D,0x78,0xDB,0x54,0x66,0xCA } },
+		{ 13 , { 0x34,0xAF,0x5F,0x79,0x9B,0xF9,0x60,0x55,0x75,0xE0,0x6B,0x94,0x3C } },
+		{ 16 , { 0x0F,0x81,0xAE,0x7E,0x06,0xC7,0x27,0x9F,0x07,0xD2,0x33,0xC1,0x0E,0x97,0x51,0xED } },
+		{ 16 , { 0x0F,0x23,0x3C,0xCA,0x98,0x51,0x36,0xFC,0x47,0x5D,0x47,0x14,0x9C,0x43,0xBB,0x42 } },
+		{ 16 , { 0x07,0x5A,0xE1,0x01,0xEF,0xE4,0x77,0xCA,0x07,0xC4,0xF9,0x29,0x20,0x13,0xA5,0xC1 } },
+		{ 13 , { 0x07,0x8B,0xB8,0xD3,0xA3,0xC9,0xA4,0xEE,0x4C,0xCB,0xCB,0x74,0x0E } },
+		{ 8 , { 0x0F,0x94,0x40,0xDC,0x4A,0xA9,0x1A,0x30 } },
+		{ 16 , { 0x37,0x06,0x49,0xC5,0xA7,0xF4,0x91,0x9C,0xB6,0x9E,0x0F,0x83,0xFD,0x8B,0xF9,0x67 } },
+		{ 16 , { 0x37,0x85,0x94,0x0A,0x41,0x14,0x42,0xA8,0x68,0x1F,0xAB,0xC1,0x8D,0xA0,0xD0,0x54 } },
+		{ 16 , { 0x37,0x2F,0x03,0xEF,0xEA,0x78,0x16,0xC3,0xB6,0xEF,0xA5,0xE2,0x8C,0xC2,0x5D,0xB6 } },
+		{ 12 , { 0x43,0xAF,0x0C,0x94,0x0F,0xC7,0xD1,0x32,0x5A,0x52,0xC6,0x5A } },
+		{ 8 , { 0x07,0x91,0x72,0x13,0x08,0x57,0x30,0xB6 } },
+		{ 16 , { 0x37,0x6D,0x6F,0x19,0xEE,0xB4,0x6F,0x00,0x1B,0x49,0xA2,0xD8,0xE1,0x3A,0x9E,0x47 } },
+		{ 14 , { 0x45,0xD5,0xFB,0x6D,0x44,0x21,0x07,0xD8,0x13,0xF5,0x21,0x6B,0xDC,0x60 } },
+		{ 8 , { 0x07,0x6B,0x70,0xE2,0xBB,0xB0,0x57,0xC1 } },
+		{ 9 , { 0x38,0xB9,0x67,0x42,0x0E,0xDB,0x02,0xD6,0xC9 } },
+		{ 8 , { 0x07,0x11,0xF6,0x9D,0x3B,0xC8,0x66,0xC1 } },
+		{ 16 , { 0x37,0x91,0xA4,0x40,0x6D,0xC7,0x10,0x5F,0xB6,0xC8,0x59,0x55,0x59,0x6C,0x66,0x92 } },
+		{ 16 , { 0x3F,0x0B,0xF7,0x08,0x80,0x30,0xE9,0x19,0x64,0x69,0xE1,0xCE,0x90,0x03,0x88,0xE5 } },
+		{ 12 , { 0x43,0xF9,0xEB,0x0D,0x07,0xB3,0xAC,0x79,0x50,0x7A,0x71,0x81 } },
+		{ 16 , { 0x37,0xAD,0x92,0x83,0x55,0x86,0x1A,0xA2,0x9C,0xA7,0xBC,0x6E,0x62,0xD1,0x13,0x09 } },
+		{ 16 , { 0x3F,0x69,0x5C,0x04,0x2A,0x3E,0x2B,0xBC,0xDC,0x0F,0x31,0x71,0xDD,0x45,0xFD,0xE3 } },
+		{ 16 , { 0x37,0x01,0xA3,0x13,0xAD,0xEB,0xEF,0x95,0x59,0xA7,0xF8,0x1B,0x8E,0x7E,0xE2,0xB5 } },
+		{ 16 , { 0x3F,0x8D,0xCA,0x8A,0x62,0x0F,0xF9,0xDA,0xC2,0xAB,0x30,0x94,0x89,0x13,0x3F,0xB5 } },
+		{ 13 , { 0x44,0x13,0x19,0x74,0x65,0x05,0x10,0x80,0xE7,0x42,0x88,0x82,0xEC } },
+		{ 16 , { 0x37,0xC4,0x35,0x3F,0x16,0x05,0x58,0x44,0x79,0x75,0xE6,0x97,0x11,0x0F,0x7F,0xEE } },
+		{ 16 , { 0x37,0x33,0x82,0x31,0x49,0x1E,0x56,0x05,0x82,0xF2,0xB0,0xD2,0x8F,0x3B,0x56,0xF8 } },
+		{ 16 , { 0x37,0x74,0x0C,0xE0,0xC0,0x2B,0xC5,0xCD,0xFD,0x9B,0x30,0x34,0x08,0xFA,0xAA,0xDF } },
+		{ 16 , { 0x3F,0xD8,0x1D,0xD5,0xCF,0x32,0x6D,0xF2,0xF2,0x90,0xEF,0x51,0x16,0x89,0x2D,0x75 } },
+		{ 16 , { 0x37,0xE5,0x67,0xA4,0xF4,0x90,0xFF,0x5B,0x52,0x0B,0x4E,0xF1,0xF7,0xE9,0x0C,0x98 } },
+		{ 16 , { 0x37,0xB9,0x2B,0x9A,0x6D,0xB8,0x02,0x03,0xD4,0x6C,0x58,0x2C,0xE7,0x97,0xF7,0x8A } },
+		{ 16 , { 0x3F,0x65,0x61,0x93,0xDA,0x29,0x88,0xE9,0x85,0x0F,0xEE,0xD4,0x5E,0x18,0x82,0x5E } },
+		{ 16 , { 0x3F,0x01,0x83,0xB0,0x32,0x5C,0x76,0xBA,0x30,0x2D,0x6C,0xE0,0x2F,0x96,0x04,0x25 } },
+		{ 16 , { 0x37,0x17,0x4E,0x91,0x10,0xD2,0xB9,0x9F,0x9B,0x68,0x5F,0x84,0xB7,0xF6,0x3F,0x9F } },
+		{ 16 , { 0x3F,0x4F,0x0B,0xDD,0x28,0x52,0xF3,0x6E,0x8A,0x6C,0x07,0xD1,0x7A,0x52,0xE6,0xFC } },
+		{ 13 , { 0x3C,0x2C,0x7E,0x6D,0xAE,0xFD,0x2B,0xC1,0x21,0xB4,0x4C,0x78,0x89 } },
+		{ 16 , { 0x07,0x16,0x9A,0xEC,0xA4,0xF3,0xEB,0xD3,0x07,0xA4,0x56,0xDE,0xDF,0x04,0x05,0xCB } },
+		{ 16 , { 0x37,0xDD,0xFB,0x88,0x60,0x7F,0x6D,0x5F,0x1A,0xCF,0x0C,0xC8,0x94,0x82,0x63,0x1F } },
+		{ 16 , { 0x3F,0x94,0x23,0x91,0xFB,0xDB,0xC1,0x02,0x5C,0x69,0xBA,0x49,0xE4,0xFD,0x90,0x6C } },
+		{ 16 , { 0x3F,0x1C,0xF5,0x74,0x3A,0xAA,0x02,0xA3,0x4A,0x69,0x8E,0x2A,0xFF,0x30,0xFA,0x71 } },
+		{ 16 , { 0x3F,0x0E,0x07,0x8C,0xEC,0x21,0x9F,0x9A,0xF2,0xBD,0x30,0xA5,0x6C,0xB9,0x2A,0xD5 } },
+		{ 16 , { 0x3F,0x21,0x1D,0xC7,0x0D,0xF4,0xE0,0x71,0x14,0xFE,0x88,0xD0,0xB3,0x90,0x30,0x77 } },
+		{ 16 , { 0x37,0x3D,0x55,0x05,0x42,0x07,0x3F,0xC1,0x5E,0x45,0xA2,0x6D,0xA2,0xF4,0x1E,0xDC } },
+		{ 16 , { 0x3F,0xA1,0x5B,0xB5,0x6A,0x9C,0x8F,0x22,0x4D,0x0F,0x8A,0xBE,0x4A,0xF8,0x8D,0xB8 } },
+		{ 16 , { 0x3F,0xC0,0xD7,0x2C,0x97,0xB5,0x96,0xF6,0x37,0x13,0xB7,0x70,0x3B,0xC7,0xCE,0x3B } },
+		{ 16 , { 0x37,0x2E,0x7D,0x7B,0x5E,0xEA,0x83,0x72,0x62,0x01,0xDC,0x5E,0x8E,0xCF,0x44,0x52 } },
+		{ 16 , { 0x3F,0x54,0x59,0xB7,0x0A,0x69,0x37,0x51,0xB9,0x72,0x50,0xB0,0xC8,0xF3,0xDF,0x0F } },
+		{ 16 , { 0x37,0x9C,0x35,0xB1,0x3B,0x93,0x84,0x5F,0xF4,0xB0,0x2F,0xA0,0xB9,0xC9,0x1C,0x09 } },
+		{ 16 , { 0x37,0xC4,0x03,0xB8,0x6A,0xDD,0xC3,0x7F,0x3D,0x88,0xFA,0x9E,0x46,0xBF,0x67,0x3C } },
+		{ 11 , { 0x42,0x92,0x5D,0x07,0x16,0x24,0x54,0x46,0x48,0x3D,0xDA } },
+		{ 16 , { 0x37,0x29,0x6B,0x4B,0x22,0xCA,0x10,0x55,0x0C,0xF3,0x94,0x4F,0x39,0x45,0x57,0xC1 } },
+		{ 15 , { 0x36,0xF8,0x9F,0xED,0xB2,0x9D,0xA0,0x92,0xFC,0x09,0x42,0xFF,0x51,0xD8,0x70 } },
+		{ 14 , { 0x07,0x2A,0x9F,0xD6,0x5F,0x90,0x8C,0x27,0x45,0xD7,0x7C,0xA1,0x3C,0x27 } },
+		{ 8 , { 0x0F,0x39,0x9A,0x9A,0x63,0x03,0xFA,0x94 } },
+		{ 16 , { 0x37,0x47,0xF1,0x16,0xC3,0xD6,0x7B,0x88,0x6D,0x8B,0x15,0x30,0xD5,0xEB,0x25,0x22 } },
+		{ 16 , { 0x37,0xD1,0xD7,0x78,0xBC,0xF7,0xC4,0xDD,0xA0,0x45,0x89,0x08,0x54,0x95,0xA8,0x12 } },
+		{ 16 , { 0x37,0x24,0x55,0x7F,0xA5,0x20,0xE2,0x51,0x06,0xEE,0x40,0x98,0xF1,0x47,0xA1,0x9E } },
+		{ 11 , { 0x32,0x4C,0x65,0xB2,0x97,0x7D,0x88,0x13,0xCE,0x17,0x4E } },
+		{ 8 , { 0x07,0xA9,0x71,0x73,0xE8,0x0E,0x03,0x8B } },
+		{ 16 , { 0x3F,0xF1,0x11,0x00,0x5B,0xCA,0xE8,0x92,0xDE,0xCB,0x25,0xB5,0xBA,0x2C,0x61,0x02 } },
+		{ 16 , { 0x37,0x7B,0xA5,0x54,0x4D,0xDA,0x95,0xC1,0x3B,0xB3,0x80,0xAE,0xAC,0x03,0xEA,0xF2 } },
+		{ 16 , { 0x37,0xB2,0xCE,0x77,0x35,0x7C,0x20,0x57,0x05,0x35,0xFA,0x5E,0x8A,0xD9,0x09,0x65 } },
+		{ 16 , { 0x3F,0xA6,0x89,0xF1,0xCB,0x7F,0xD3,0x1D,0x0C,0x97,0x6E,0x7F,0x31,0x7B,0x67,0xDF } },
+		{ 10 , { 0x41,0x78,0x0F,0xF8,0xB9,0xD0,0x37,0xBD,0xB4,0x92 } },
+		{ 16 , { 0x07,0x22,0x23,0x00,0xB7,0xA1,0x75,0xEE,0x07,0x40,0x28,0x63,0x9D,0x45,0x68,0x4B } },
+		{ 16 , { 0x37,0xB7,0xA3,0x6D,0xFB,0x16,0xC4,0x23,0x1D,0x7E,0xB8,0x87,0x45,0x9D,0x6E,0x03 } },
+		{ 16 , { 0x37,0xF1,0x0D,0x4E,0xAB,0xA0,0xF0,0x47,0xE8,0x6E,0xB4,0x68,0xAD,0xC6,0x38,0x20 } },
+		{ 16 , { 0x37,0x6E,0xF5,0x4E,0xC2,0xE6,0x51,0x6D,0xD2,0xC1,0x63,0x01,0xB5,0x6D,0x5F,0xFD } },
+		{ 9 , { 0x30,0x72,0xCE,0xAE,0xFE,0x96,0xC4,0x20,0x70 } },
+		{ 11 , { 0x07,0x39,0xCC,0xFB,0x91,0xB9,0xA7,0x66,0x4A,0xF6,0xB8 } },
+		{ 8 , { 0x07,0xA1,0xE8,0x8D,0x69,0xE2,0x04,0xA2 } },
+		{ 16 , { 0x37,0x06,0x3F,0x8C,0x15,0x4A,0x5D,0xF6,0x6F,0xD6,0x25,0x35,0x20,0x3C,0x9F,0x9D } },
+		{ 16 , { 0x3F,0x52,0x8D,0xFC,0x2A,0x47,0x00,0x6C,0xC6,0x3D,0x1E,0x8B,0xFE,0x65,0xC7,0x31 } },
+		{ 16 , { 0x3F,0xC9,0x13,0x38,0xE8,0x26,0xDE,0x16,0xD9,0xBD,0x16,0x06,0xD8,0x5A,0x26,0x36 } },
+		{ 16 , { 0x3F,0x31,0xAC,0x7E,0xA8,0x90,0xF6,0x3A,0x02,0x59,0x6B,0xF1,0x1E,0x02,0x1B,0xD1 } },
+		{ 10 , { 0x41,0x8D,0x0F,0x60,0xD8,0x95,0xC9,0x3C,0x0B,0x2A } },
+		{ 16 , { 0x0F,0x17,0xA0,0xDA,0x40,0x72,0x9A,0x78,0x07,0x4C,0x6B,0x32,0xAD,0x21,0x9C,0xB0 } },
+		{ 8 , { 0x0F,0x6A,0x23,0x4C,0x65,0x56,0x33,0x0D } },
+		{ 12 , { 0x33,0x7F,0xA0,0x9C,0xC7,0x08,0x60,0xCB,0x35,0x59,0x22,0xAA } },
+		{ 16 , { 0x07,0x3B,0xDB,0xFF,0x14,0x24,0xCB,0x64,0x0F,0xF5,0x60,0xE6,0x68,0x48,0xF3,0x43 } },
+		{ 16 , { 0x07,0x78,0x60,0x84,0x3F,0xC7,0x43,0xEE,0x0F,0xA8,0xA1,0x0F,0xCF,0xE1,0x3F,0x86 } },
+		{ 16 , { 0x0F,0xC0,0x67,0x53,0xC3,0x8E,0x5E,0x0A,0x07,0x7C,0x30,0xDA,0x6C,0x6A,0xCA,0xAA } },
+		{ 16 , { 0x0F,0x07,0x88,0x95,0x22,0xB7,0x88,0xBC,0x07,0x4A,0x2C,0xB3,0x7A,0xB9,0x75,0x22 } },
+		{ 11 , { 0x07,0x2A,0x62,0x95,0x87,0x61,0x93,0x59,0x42,0xEA,0x8F } },
+		{ 16 , { 0x0F,0x62,0x4C,0xC9,0x92,0xA0,0x43,0x96,0x0F,0x7C,0xD1,0x8B,0x51,0x25,0x67,0xC4 } },
+		{ 16 , { 0x07,0x39,0x88,0x93,0xDE,0x93,0x29,0x80,0x07,0xA7,0xAE,0x2A,0xE0,0xB1,0xB4,0x79 } },
+		{ 16 , { 0x0F,0x1C,0xDE,0x1C,0xEB,0x0F,0x9C,0x74,0x0F,0xC5,0xC2,0x09,0x0A,0xED,0x50,0x79 } },
+		{ 8 , { 0x07,0x0B,0x1A,0x05,0x6D,0x49,0xE0,0xFB } },
+		{ 16 , { 0x37,0x2A,0xBA,0x74,0x71,0xA9,0x88,0xCB,0x42,0x3E,0x0D,0x5F,0x1A,0xD2,0xAA,0xE1 } },
+		{ 11 , { 0x32,0x02,0x90,0xE7,0xD3,0x09,0xFA,0x1A,0xC8,0x33,0x65 } },
+		{ 15 , { 0x05,0xA6,0x9F,0x84,0x95,0x2F,0x16,0x7B,0x4E,0xCD,0xEA,0xBD,0x84,0xB1,0xC0 } },
+		{ 16 , { 0x07,0xF4,0x5F,0x53,0xA9,0x9D,0xC2,0x2F,0x0F,0x86,0xA5,0x30,0x58,0x55,0x79,0xF4 } },
+		{ 16 , { 0x0F,0xAF,0x6F,0x5D,0x7D,0xD5,0x5E,0xB2,0x07,0x4C,0x26,0x58,0xA7,0x42,0xBC,0x88 } },
+		{ 16 , { 0x0F,0x66,0xF8,0xAE,0xA1,0x28,0x54,0x49,0x07,0x77,0x84,0x7E,0xF5,0xD6,0xF2,0x1C } },
+		{ 8 , { 0x07,0x2E,0xFD,0xAD,0xB8,0x75,0xFE,0xE1 } },
+		{ 9 , { 0x38,0x8B,0x53,0xED,0xF4,0x54,0x51,0x36,0xFC } },
+		{ 16 , { 0x0F,0xCD,0x55,0xD1,0x59,0xC8,0xFB,0xF0,0x0F,0xFB,0x6D,0x1D,0xFE,0x5B,0xEE,0x2E } },
+		{ 16 , { 0x0F,0xF9,0xA0,0xF7,0xCB,0x23,0x7D,0x43,0x0F,0x3D,0xB8,0x0B,0x82,0x66,0xC8,0xB1 } },
+		{ 9 , { 0x38,0x9E,0xDD,0xDE,0xDD,0x88,0xC2,0xD1,0x83 } },
+		{ 16 , { 0x0F,0xE9,0xCA,0xB0,0xF9,0x8B,0x10,0xB0,0x0F,0xEE,0x0C,0x59,0x94,0x87,0x00,0xAF } },
+		{ 16 , { 0x37,0x17,0x34,0x12,0xB6,0xB0,0xAB,0xEA,0xD9,0xB7,0x7B,0x4C,0x85,0xA1,0xE3,0x99 } },
+		{ 10 , { 0x49,0x96,0x0F,0xE1,0xAD,0xB7,0xA8,0xDE,0xF5,0x51 } },
+		{ 16 , { 0x07,0xFD,0x04,0xDE,0xB1,0x80,0xFA,0x56,0x0F,0x56,0xCC,0xDB,0xF2,0x2B,0x38,0xE3 } },
+		{ 16 , { 0x0F,0xC6,0x2F,0x42,0x67,0x15,0x5F,0xDB,0x07,0x21,0xF4,0x54,0x8E,0x31,0x45,0x44 } },
+		{ 15 , { 0x0F,0x54,0xD7,0xEC,0x08,0x9A,0x13,0xD3,0x4E,0xE7,0xDC,0x69,0xA9,0xEC,0x98 } },
+		{ 16 , { 0x0F,0xAB,0x2F,0x3F,0x45,0x7A,0xD1,0x61,0x05,0xFE,0x24,0x54,0x46,0x54,0x61,0x1F } },
+		{ 13 , { 0x3C,0x1C,0x56,0x93,0xC7,0x68,0xF5,0x2A,0x4B,0xA1,0x29,0x84,0x25 } },
+		{ 16 , { 0x0F,0xDB,0x0F,0x14,0x77,0xAC,0xC5,0xC8,0x07,0xCA,0xCA,0x31,0x22,0x97,0x36,0x40 } },
+		{ 11 , { 0x07,0xD3,0x2C,0x22,0x69,0x8E,0xEC,0xD9,0x42,0x1C,0x11 } },
+		{ 16 , { 0x0F,0xE6,0x96,0x1E,0xA9,0x3C,0x25,0x8A,0x07,0x49,0x16,0x97,0xE8,0x2B,0xA1,0xCA } },
+		{ 8 , { 0x0F,0xD8,0x78,0xF7,0x58,0x40,0xA0,0x0A } },
+		{ 16 , { 0x3F,0x77,0x26,0x27,0xEF,0x07,0xBE,0xB1,0x17,0xF7,0x21,0x48,0x15,0x63,0x02,0xAB } },
+		{ 10 , { 0x39,0xF0,0x01,0x60,0x65,0xD7,0xC2,0x23,0x19,0xDC } },
+		{ 12 , { 0x07,0x01,0xB1,0x42,0xEE,0x5D,0x1B,0xDB,0x4B,0xA0,0xD3,0xD7 } },
+		{ 16 , { 0x07,0xF0,0xD1,0x0F,0x00,0x04,0x54,0xF5,0x05,0x34,0x94,0x2F,0xDC,0xAA,0x34,0xEB } }
+};
+
+#define FIRMWARE_LINES_3_0b5 (sizeof(Si2157_FW_3_0b5)/(sizeof(firmware_struct)))
+#define RAM_SIG_3_0b5 0xDABDD450
+#define RAM_CRC_3_0b5 0x1F4E
+
+/* SI2158_FIRMWARE_0_E_BUILD_15 */
+u8 Si2158_FW_0_Eb15[] = {
+		0x04,0x01,0x80,0x00,0xCC,0x58,0x98,0xD7,
+		0x05,0xD3,0x99,0xC6,0xB2,0xBD,0x68,0x8B,
+		0x05,0xDF,0xB3,0x1B,0x73,0x9E,0xAA,0x51,
+		0x27,0xCF,0xF6,0x6C,0xCD,0xDD,0x5E,0x64,
+		0x22,0xEB,0x8D,0x75,0xC2,0x4A,0xA8,0xFB,
+		0x0F,0x04,0x3A,0x48,0x7C,0xCF,0x5A,0x5A,
+		0x27,0x4B,0x3E,0x35,0x0D,0xBA,0xE9,0x2A,
+		0x29,0x50,0x14,0x34,0xC1,0xD7,0x08,0x8B,
+		0x07,0x1F,0xA0,0x69,0xFB,0xBD,0xA5,0x46,
+		0x2E,0xF3,0xF8,0xBB,0xFD,0xC9,0x64,0xCB,
+		0x0F,0x7E,0x43,0xA7,0xAA,0x87,0x5E,0x3B,
+		0x2F,0x41,0xAB,0xE6,0xB5,0x5D,0xF0,0x86,
+		0x2B,0x16,0x7D,0x1A,0x4C,0x72,0x68,0xFB,
+		0x07,0x17,0x87,0x60,0x3C,0x6D,0x0C,0x60,
+		0x26,0x8C,0xCD,0xE5,0x90,0x80,0x5C,0x53,
+		0x07,0x6E,0xA1,0x0F,0x6A,0xBE,0x0D,0x3B,
+		0x2F,0x15,0xB8,0x23,0xED,0x6D,0x1A,0xDE,
+		0x24,0x6F,0xE7,0x95,0x1E,0x6F,0x9A,0x85,
+		0x0F,0xE4,0x4F,0x35,0xA8,0xE6,0x37,0xBF,
+		0x22,0x76,0xD4,0x39,0x4C,0xFA,0x73,0x59,
+		0x0F,0xD6,0xB4,0xF1,0x43,0x6B,0xCE,0xF1,
+		0x2A,0xE2,0xF6,0xC6,0x39,0x39,0x82,0x2A,
+		0x0F,0xB9,0xF6,0x5D,0xD6,0x3C,0x25,0x17,
+		0x2F,0x0C,0x63,0x24,0xC6,0xF1,0xB1,0x37,
+		0x2F,0xF9,0xA4,0xED,0x41,0xD0,0xCA,0xED,
+		0x23,0xD4,0x9D,0x4A,0xAB,0xF1,0x81,0x3C,
+		0x07,0x79,0xF8,0xA4,0xB4,0x71,0x25,0xCE,
+		0x2F,0xCC,0x0A,0x0C,0x1D,0x0F,0x79,0x1F,
+		0x2F,0x2A,0xB8,0x84,0xE2,0x43,0x4E,0x1B,
+		0x26,0xAA,0x6B,0x06,0x2B,0xB1,0x6F,0xB2,
+		0x0F,0x12,0x4F,0xCB,0x29,0x04,0xFB,0xD0,
+		0x25,0x3E,0xE7,0x17,0x64,0xF1,0x47,0xC0,
+		0x0F,0x8F,0x43,0x9F,0x23,0x2A,0x50,0x36,
+		0x2A,0x6C,0x03,0xD7,0x29,0x87,0xA5,0x99,
+		0x07,0xC3,0x49,0x0D,0x73,0x77,0x0C,0xC6,
+		0x07,0x3A,0x8E,0x3D,0x75,0xB8,0x48,0x55,
+		0x0F,0xAB,0x62,0x72,0x46,0x0D,0xD6,0x80,
+		0x27,0x75,0x1F,0x93,0x37,0x7A,0x0D,0x41,
+		0x21,0xCB,0xD3,0x31,0x0E,0x28,0x7B,0x26,
+		0x0F,0xBA,0x8F,0x86,0xC0,0xE7,0xE1,0x26,
+		0x22,0xCD,0xE0,0x65,0x94,0x2F,0xBC,0x19,
+		0x07,0x6E,0xDA,0xCB,0x11,0xFE,0x04,0x3B,
+		0x22,0xE6,0x08,0x94,0xBC,0x66,0x71,0x25,
+		0x07,0x1B,0x30,0xE8,0x18,0xA4,0xAD,0x50,
+		0x2D,0xA7,0x33,0x7F,0xD8,0x5B,0xC1,0xFD,
+		0x0F,0x5E,0xC5,0x85,0x19,0x54,0xE3,0x7F,
+		0x22,0xEA,0x90,0xBB,0xB7,0x7C,0xFB,0xFF,
+		0x07,0xE4,0x01,0x5A,0x01,0x51,0x1A,0x47,
+		0x27,0xEC,0x3C,0x1D,0x21,0x79,0x16,0x9A,
+		0x2C,0xE6,0x0B,0x70,0xDD,0xCC,0x12,0x8A,
+		0x0F,0x1D,0x5C,0x4D,0x07,0x1A,0x95,0xE2,
+		0x25,0x3C,0x22,0x25,0x82,0xC4,0x59,0xB7,
+		0x07,0xDE,0xB8,0xE2,0xF4,0x47,0x47,0xFF,
+		0x25,0xDD,0x02,0x19,0x2A,0x45,0xD2,0x31,
+		0x0F,0xE3,0xF4,0xAA,0x14,0xEB,0x9D,0xF2,
+		0x2F,0x74,0xF7,0x2B,0xD1,0xB6,0x18,0xFF,
+		0x2F,0xDD,0x9C,0x99,0x0A,0x21,0x99,0x8E,
+		0x23,0x3C,0x04,0x20,0xAC,0x1A,0xC5,0xCD,
+		0x07,0x73,0xF1,0x31,0x2C,0x44,0x58,0x74,
+		0x2F,0xEC,0x1B,0xB1,0x7B,0xAD,0x76,0x32,
+		0x29,0x35,0xAF,0xE2,0x21,0x09,0xB4,0x79,
+		0x07,0x66,0xC5,0xA6,0x16,0xCB,0xE9,0x5C,
+		0x27,0xB5,0x4F,0xE6,0xE9,0x19,0x5E,0x25,
+		0x27,0x72,0x69,0x1C,0xFB,0x30,0xE6,0xB3,
+		0x0F,0xFB,0xA9,0x53,0x94,0x2A,0x75,0x61,
+		0x25,0x66,0x1E,0xE7,0xC9,0x9D,0x79,0xF5,
+		0x0F,0x73,0x01,0x7F,0xE9,0x0C,0x7E,0xED,
+		0x2A,0xDF,0x41,0x2E,0x2D,0x50,0x72,0xC3,
+		0x0F,0x49,0xDE,0xAB,0xBC,0xF8,0x8D,0x55,
+		0x27,0xE6,0x18,0xE6,0x07,0xF1,0x84,0xE2,
+		0x29,0x7B,0xA1,0x1E,0x13,0x4E,0xE7,0x3C,
+		0x07,0xA3,0x01,0xEB,0x93,0xB2,0x36,0x16,
+		0x0F,0xD3,0x86,0x31,0x67,0x4A,0xB0,0x79,
+		0x07,0x01,0xD4,0x98,0x17,0x16,0xF3,0xB4,
+		0x25,0xFD,0x6F,0xF1,0xDA,0x9A,0xBA,0x06,
+		0x07,0x8D,0xD3,0xD6,0xFC,0xD9,0xD6,0x02,
+		0x2A,0xF1,0x24,0x79,0xC5,0x25,0xBD,0xE1,
+		0x07,0xB5,0xA7,0x60,0xBB,0xD5,0x39,0x5A,
+		0x0F,0x08,0xA1,0x96,0xCB,0x4F,0x93,0x52,
+		0x0F,0x6C,0x82,0xC2,0xE0,0x02,0x04,0x70,
+		0x2A,0xB5,0x75,0x46,0x6E,0xDF,0x04,0x40,
+		0x0F,0xF3,0xF7,0xD4,0xFB,0x54,0x68,0x5C,
+		0x27,0x97,0xCB,0x54,0x5C,0x63,0x88,0xDF,
+		0x27,0xF0,0x16,0x41,0x54,0xE0,0xF6,0xFC,
+		0x27,0x1B,0x1D,0x50,0xE8,0x99,0x3C,0x0E,
+		0x22,0x48,0xCB,0x3F,0xC2,0x7B,0x1E,0xF7,
+		0x07,0x78,0xDA,0x29,0x4D,0xB9,0xBE,0x4C,
+		0x2F,0x62,0x65,0x80,0x4B,0x86,0x44,0xC4,
+		0x29,0x38,0x47,0x9D,0xEF,0x1D,0xC7,0x7C,
+		0x07,0xB6,0x36,0x2D,0x07,0x57,0x4F,0x32,
+		0x07,0x1F,0xB4,0xC3,0x7E,0xC3,0xD3,0xB0,
+		0x0F,0x8E,0x90,0x8D,0xC1,0x1E,0x05,0x05,
+		0x2F,0xFC,0x8C,0x2A,0x7E,0x9B,0x7E,0x72,
+		0x2C,0xAB,0xE9,0xEF,0x08,0xF6,0x5B,0x24,
+		0x07,0x48,0x19,0xA9,0x76,0x95,0x8A,0x75,
+		0x2A,0x1F,0x74,0x4C,0xE6,0x81,0x61,0x4B,
+		0x0F,0xA5,0xFF,0x5F,0x77,0x1C,0x7A,0x05,
+		0x2A,0x47,0xAF,0x53,0x84,0x9B,0xDA,0x3D,
+		0x0F,0xC9,0x90,0x35,0xDE,0xE3,0xFB,0xCA,
+		0x27,0x99,0x88,0x5F,0xF6,0x47,0x3F,0x26,
+		0x2F,0x32,0x4B,0x93,0x94,0x9C,0x6D,0x9A,
+		0x0F,0x3E,0xE0,0x43,0x9B,0x46,0x55,0x0C,
+		0x2A,0x57,0xF5,0x67,0x7B,0x16,0xC7,0x91,
+		0x0F,0x2D,0xA7,0x3A,0x1F,0xE5,0x9C,0x84,
+		0x25,0xE9,0x7F,0xC0,0xD4,0xE6,0xAA,0xA2,
+		0x07,0x51,0xC0,0x9F,0x11,0xD9,0x05,0x50,
+		0x07,0x58,0xC8,0x3A,0x83,0xFB,0x65,0x7D,
+		0x07,0x8B,0xB2,0xE4,0x8B,0x39,0xFB,0xA4,
+		0x2D,0x4B,0x48,0xC4,0x6B,0xF6,0xAC,0x0E,
+		0x0F,0x46,0x87,0x58,0x0F,0xFB,0xA1,0x3A,
+		0x27,0x8D,0xFF,0x73,0xBF,0xE9,0x1D,0x16,
+		0x24,0x18,0xDD,0x33,0x35,0x60,0x5E,0x94,
+		0x0F,0xF9,0xC4,0x00,0x32,0xBB,0x04,0x17,
+		0x27,0xB6,0x18,0x19,0x23,0xB6,0xA8,0xBB,
+		0x27,0xFF,0x27,0x44,0xBC,0x42,0x1B,0x78,
+		0x07,0x6B,0x39,0x5D,0x45,0xB4,0x99,0xDC,
+		0x22,0x02,0xF2,0x0C,0x5B,0x86,0x2E,0x0B,
+		0x0F,0x82,0xB4,0xE3,0x91,0x47,0xE0,0x47,
+		0x2A,0x02,0x13,0x80,0x76,0x73,0x28,0x9F,
+		0x0F,0x87,0x3E,0xC7,0x4A,0x1D,0x7F,0x21,
+		0x27,0xD7,0x2F,0xA5,0x7B,0xDF,0xFD,0x46,
+		0x2C,0x5C,0x60,0xE9,0x8B,0x8B,0x1E,0xF4,
+		0x07,0xDB,0x26,0x02,0x2F,0x35,0x81,0x69,
+		0x22,0x56,0x17,0x3C,0xCB,0x13,0xAF,0x71,
+		0x0F,0x9E,0x4A,0xAB,0x85,0x80,0x02,0x3B,
+		0x2A,0xFC,0xE2,0x0D,0x2F,0x81,0xC3,0xD9,
+		0x07,0x2A,0x59,0xF2,0x81,0x2C,0x6B,0xED,
+		0x2F,0x17,0x1F,0x1B,0xE3,0x8A,0x3A,0x8D,
+		0x2C,0xE8,0x24,0x30,0x5D,0x2E,0x79,0xFE,
+		0x0F,0x8C,0x0E,0xC7,0xB7,0x8D,0x24,0xC0,
+		0x07,0xEB,0xB0,0x26,0xE6,0xF0,0x46,0xB5,
+		0x0F,0x4F,0xD0,0xF8,0x1F,0xBD,0x70,0x55,
+		0x2A,0xF3,0x7E,0xD6,0x1B,0x12,0x69,0x5D,
+		0x0F,0x8F,0x1A,0x10,0x2B,0x88,0x30,0xA9,
+		0x2F,0xB8,0xF3,0xA4,0x06,0x07,0x29,0xFF,
+		0x2F,0x01,0x43,0xD6,0xB0,0xC4,0x3B,0xEC,
+		0x0F,0x27,0x05,0x37,0x3A,0x70,0x03,0x61,
+		0x22,0xF4,0xBE,0xC4,0x2C,0x24,0xEC,0xF7,
+		0x0F,0xA6,0x55,0x01,0x56,0x83,0xA9,0x0C,
+		0x2F,0x6D,0x58,0xF4,0xCE,0x3F,0xEE,0xEB,
+		0x27,0x36,0xDB,0x2E,0xDB,0xA1,0x19,0x15,
+		0x2B,0xF0,0xC1,0x61,0xEB,0x69,0x33,0xFC,
+		0x0F,0xF2,0x3F,0xCF,0xE7,0xB8,0x7A,0x36,
+		0x27,0x8D,0x3C,0xF0,0x2B,0x96,0x53,0x87,
+		0x27,0xC4,0x34,0xD0,0x97,0xCF,0x09,0x6D,
+		0x27,0x80,0x27,0xF4,0x16,0x02,0xC6,0x68,
+		0x22,0x59,0x26,0x8B,0xCD,0x33,0x5B,0x33,
+		0x07,0x7F,0x1A,0x77,0x2E,0xAD,0xA6,0x73,
+		0x2F,0xF4,0x63,0x96,0xD2,0xC7,0x82,0x50,
+		0x2F,0x2D,0xA5,0x04,0xF7,0xD3,0x95,0x52,
+		0x2F,0x72,0x8D,0x25,0xCC,0xDA,0x7D,0x15,
+		0x27,0xD3,0xA9,0x03,0x1A,0xAC,0xE1,0x1B,
+		0x2F,0xD4,0x0B,0x66,0x6A,0xBB,0xD1,0xDB,
+		0x27,0xDE,0x79,0xC3,0x56,0x99,0x90,0x74,
+		0x27,0xF1,0x5E,0x6B,0xFD,0x9A,0x55,0xD0,
+		0x27,0xD0,0x78,0xF9,0x49,0x29,0x87,0xCD,
+		0x2F,0x02,0x98,0xC9,0x89,0x58,0x3B,0x6C,
+		0x27,0xC7,0x35,0x07,0x08,0x8B,0x12,0xE4,
+		0x2F,0x41,0x54,0x4A,0xBB,0x0D,0x53,0x13,
+		0x2F,0x37,0xC7,0x6D,0x6C,0x0A,0xE6,0xE0,
+		0x2F,0x68,0x30,0x30,0xD6,0x96,0x51,0x09,
+		0x2F,0x31,0x8A,0x38,0x0D,0xA6,0xFE,0x4C,
+		0x2F,0x6E,0x44,0x89,0x42,0x4C,0x2D,0x62,
+		0x27,0xED,0x16,0x32,0x0F,0x43,0x91,0xF2,
+		0x2F,0x06,0x9B,0xBC,0x98,0x0F,0xA4,0xFC,
+		0x2F,0x81,0x46,0x60,0x37,0x7F,0xBA,0xB2,
+		0x21,0x64,0x93,0x15,0xFE,0x15,0x6B,0x4D,
+		0x0F,0xC8,0x53,0xAF,0x7D,0x4A,0x0F,0xAE,
+		0x2F,0x03,0xFD,0x13,0x13,0xFD,0xB9,0xB5,
+		0x27,0xB5,0x5C,0x7E,0x14,0xD4,0x31,0xB1,
+		0x2F,0x56,0xF3,0x70,0xA0,0xE3,0x20,0xD2,
+		0x2F,0xB8,0xA8,0x39,0x36,0x23,0x9F,0x8E,
+		0x27,0x01,0x83,0xB8,0x38,0x6B,0x54,0x59,
+		0x2F,0xFC,0x27,0xF8,0xB6,0x5C,0xF5,0x1C,
+		0x2F,0x6D,0xD1,0x4D,0x3D,0x57,0x1F,0x63,
+		0x27,0xBA,0xDD,0x2E,0x43,0xA6,0xB3,0x8F,
+		0x2F,0x8B,0x7A,0x9E,0xF6,0xFD,0x69,0xC2,
+		0x26,0x5B,0x45,0x2F,0xA2,0xDA,0x5B,0x5B,
+		0x07,0xDE,0xD3,0xDA,0xCB,0x6B,0xD3,0xB3,
+		0x07,0xA6,0x63,0xC2,0x67,0x78,0xAC,0xC4,
+		0x2F,0xE3,0x75,0xB2,0xC9,0x88,0xB2,0x8E,
+		0x27,0x3C,0x34,0x26,0xDE,0x91,0x2C,0xD5,
+		0x2F,0xC0,0x91,0x75,0x7D,0xBF,0xEF,0xDF,
+		0x27,0x4A,0x25,0x4B,0xB1,0x59,0x2C,0xF7,
+		0x27,0xF5,0xFB,0xFD,0x95,0xAD,0x12,0xF2,
+		0x27,0xA1,0x6D,0xD6,0xFD,0x80,0x91,0xF6,
+		0x27,0x03,0x6F,0xE0,0x8B,0x36,0x58,0xBC,
+		0x2F,0x98,0xF2,0x0B,0xE1,0xD1,0x65,0x11,
+		0x2F,0x77,0xA5,0x32,0x8E,0x29,0x3D,0x76,
+		0x2F,0x90,0x17,0xDA,0x3A,0x62,0xFC,0x57,
+		0x27,0x80,0xD9,0x58,0x03,0xAF,0x1A,0xDE,
+		0x2F,0xBC,0x01,0xD2,0x74,0xB0,0x3C,0x5A,
+		0x2F,0x8A,0x13,0x1D,0x29,0x77,0xBB,0x59,
+		0x2F,0x28,0xD9,0xA2,0x28,0xDA,0xBC,0x14,
+		0x2F,0xFD,0x1D,0x3B,0xA1,0x58,0xF5,0xCA,
+		0x2F,0xE1,0xEA,0x52,0x38,0x8F,0xF0,0x5F,
+		0x2F,0xD6,0x2F,0xD2,0x0E,0xB4,0xDF,0x33,
+		0x27,0xC8,0x6E,0x63,0x64,0x42,0x28,0x32,
+		0x27,0x96,0x44,0xF9,0x47,0x6B,0xC7,0xC7,
+		0x22,0xA4,0xF9,0x54,0x66,0x87,0x6A,0xCF,
+		0x07,0x8C,0xFF,0x74,0xC5,0x29,0xFF,0xB9,
+		0x0F,0x14,0x12,0xD0,0x19,0x2B,0xCF,0x6F,
+		0x07,0x8D,0xA1,0x1A,0x4E,0xCC,0xF9,0x79,
+		0x0F,0x69,0x19,0x4B,0x70,0x95,0xE0,0x38,
+		0x07,0x70,0x85,0x50,0x32,0x42,0xA6,0x38,
+		0x07,0xF4,0xE6,0xE4,0x2E,0x17,0xF0,0x51,
+		0x0F,0x5B,0x0E,0xE6,0x51,0x3A,0x5E,0x8B,
+		0x27,0x0A,0xC1,0x97,0x47,0x25,0x9C,0x11,
+		0x27,0x43,0x28,0xCC,0xFD,0xBB,0xD2,0xD9,
+		0x27,0xA9,0x84,0x32,0x5A,0x74,0xBA,0xA6,
+		0x27,0x65,0x77,0xAD,0x35,0x2D,0xE4,0xCC,
+		0x2D,0x1F,0x3F,0xB8,0x31,0x18,0x42,0x99,
+		0x0F,0xA7,0x88,0x12,0x1E,0x68,0x48,0x70,
+		0x2F,0x12,0x22,0x4F,0x63,0x39,0x19,0x25,
+		0x27,0x07,0xCE,0xBF,0x8D,0x8A,0x58,0x55,
+		0x27,0x93,0xCF,0x3E,0xB2,0xF1,0xC5,0x0C,
+		0x26,0x62,0xD0,0x69,0x81,0x07,0xE1,0xFD,
+		0x07,0x21,0x5A,0x26,0x9F,0xCA,0x93,0x31,
+		0x2F,0x34,0xFB,0xEB,0xBF,0x07,0xBD,0xF3,
+		0x27,0x8C,0x0D,0xE9,0xE4,0xF3,0xAD,0xBB,
+		0x25,0xC7,0x5A,0xA0,0xB3,0x09,0xCC,0x9F,
+		0x0F,0xDA,0xC1,0xE3,0xCD,0xED,0x60,0xC5,
+		0x2E,0xF4,0xC5,0x03,0x26,0xAC,0x7E,0xE0,
+		0x0F,0x50,0x8B,0x90,0xF1,0xFB,0x6E,0x58,
+		0x0F,0x3C,0x53,0x76,0xFB,0xAA,0x44,0xAD,
+		0x0F,0x4B,0xA4,0x5D,0x17,0xC8,0x88,0xE9,
+		0x2F,0x9F,0x61,0x47,0x83,0xC9,0x5D,0x95,
+		0x2F,0x18,0xA7,0x74,0x2D,0x5D,0x09,0xC4,
+		0x27,0x83,0xB7,0xC1,0x23,0xE5,0x9D,0x0B,
+		0x2F,0xF2,0x68,0xAF,0xA2,0x10,0xEF,0xC2,
+		0x2F,0x96,0xFB,0x85,0x89,0x3D,0xAD,0x09,
+		0x27,0xBA,0xF3,0x7B,0xEA,0x0E,0xB7,0xC4,
+		0x27,0x36,0xBD,0xC2,0x05,0x47,0xDD,0x23,
+		0x2F,0x17,0x09,0x79,0x6E,0xB0,0x69,0x58,
+		0x2F,0x13,0xB1,0xFC,0x4D,0x12,0x57,0x30,
+		0x2F,0xA8,0x02,0x53,0x7A,0xD8,0x05,0x60,
+		0x25,0x98,0xC5,0xAD,0xAF,0x2B,0x9B,0x0E,
+		0x07,0x07,0xEB,0xC9,0x7B,0x20,0x62,0xB4,
+		0x27,0x68,0xB4,0x0C,0x3C,0x6C,0xB8,0xEC,
+		0x0F,0xCF,0x24,0xBF,0xDA,0xC7,0xBE,0x93,
+		0x27,0x8D,0xAE,0xA3,0xD0,0x58,0x99,0x3D,
+		0x2F,0x50,0x54,0x87,0xFC,0xC5,0xB4,0xF8,
+		0x2F,0x68,0xE4,0xD4,0xF3,0x5A,0x3C,0x93,
+		0x2F,0xAA,0xE2,0xCD,0xC7,0xCB,0x5D,0xCC,
+		0x2F,0x6D,0x0F,0xFA,0xA6,0x26,0xDF,0xBD,
+		0x2F,0x55,0x0E,0xAC,0xDF,0x8E,0x4A,0xFF,
+		0x27,0xB2,0x31,0xA5,0xEB,0x9E,0x7F,0x5C,
+		0x27,0x38,0x96,0x01,0xFE,0x95,0xF2,0xBA,
+		0x2D,0xC3,0x24,0xCE,0x2E,0xE6,0xB9,0x9D,
+		0x07,0xDF,0xB6,0x66,0xC7,0xC7,0xF0,0xBA,
+		0x2F,0x30,0x29,0x65,0xDE,0x39,0x22,0x22,
+		0x27,0x6F,0xA4,0x35,0xA1,0x0C,0x80,0x5D,
+		0x27,0x8F,0x21,0x3C,0xC1,0x21,0x83,0x0E,
+		0x27,0xE1,0x4B,0xC3,0x70,0xA0,0x34,0x0D,
+		0x27,0x62,0xF1,0x80,0x17,0x8B,0x88,0xE7,
+		0x2F,0x96,0x84,0x5E,0x1A,0xFA,0x32,0x7A,
+		0x2F,0xBA,0xF8,0x30,0x2E,0x28,0x29,0x93,
+		0x27,0xD8,0x01,0x42,0x89,0x1E,0x59,0xC8,
+		0x2F,0xC4,0x8B,0x8D,0x0C,0x2B,0x63,0x6C,
+		0x27,0x9F,0xC0,0xFC,0xB3,0xB6,0x6D,0xFF,
+		0x2F,0x69,0xC4,0xD7,0xA2,0xD6,0xB6,0x58,
+		0x27,0x3E,0x7E,0x81,0x59,0xD9,0x39,0x03,
+		0x2F,0x0D,0xFD,0x6C,0x1F,0x69,0x9A,0x4F,
+		0x27,0xBB,0x4B,0xD3,0x27,0x83,0x9A,0x82,
+		0x2F,0x6C,0x35,0x3E,0xAA,0x42,0xE0,0x83,
+		0x27,0xD7,0xE3,0x9C,0x3A,0xBD,0x63,0x1B,
+		0x27,0x5F,0x62,0xE9,0x97,0x06,0x7C,0xAF,
+		0x2F,0xB1,0x6A,0xAB,0x56,0x8F,0xF5,0x37,
+		0x2F,0xD8,0xC2,0x84,0x22,0x37,0xC3,0x68,
+		0x2F,0xCE,0x69,0x3E,0x93,0x92,0x25,0x0A,
+		0x2F,0x82,0x9B,0x04,0x16,0x62,0x38,0x0D,
+		0x2F,0xA5,0x9B,0x08,0xD6,0xD5,0x1A,0xE2,
+		0x27,0x58,0x2F,0x61,0xE0,0x3F,0xB3,0x5F,
+		0x2F,0x44,0x1F,0x53,0x54,0xB3,0xF0,0x0B,
+		0x27,0xC5,0x61,0xD4,0x10,0x23,0x8E,0x53,
+		0x27,0x6D,0x70,0xB6,0x8F,0xAB,0xF7,0xF0,
+		0x2F,0xF5,0x44,0x86,0x10,0x72,0xB5,0x41,
+		0x27,0x86,0xE6,0x0E,0x07,0x44,0xAF,0x42,
+		0x27,0x25,0x29,0x60,0x59,0x78,0x39,0xB6,
+		0x27,0xC2,0xE2,0x16,0xDD,0xC5,0x4C,0x0E,
+		0x27,0x5D,0x77,0x9C,0xA4,0x77,0xC6,0xD3,
+		0x27,0x56,0x7A,0xB0,0x94,0x36,0x94,0x71,
+		0x27,0xA1,0x00,0x37,0x28,0x8C,0x7E,0x5A,
+		0x27,0xFB,0x7B,0x7A,0x2E,0x0C,0x74,0x94,
+		0x27,0x98,0x96,0xC0,0x93,0x44,0xC0,0x0E,
+		0x2F,0xA2,0x9E,0x73,0xDB,0x28,0x30,0x67,
+		0x2B,0x54,0x99,0xA0,0x36,0xFA,0xE0,0x0E,
+		0x27,0xA6,0xC7,0x09,0x05,0xF3,0xF6,0x79,
+		0x2F,0xE6,0x31,0xFB,0x3B,0xFD,0xC7,0x19,
+		0x2F,0x74,0x34,0x09,0x0B,0xCB,0x23,0x0D,
+		0x27,0xA1,0xD1,0xE5,0x15,0x2C,0x28,0x1A,
+		0x27,0xFF,0x6D,0xF4,0x8A,0xD1,0xBB,0x2F,
+		0x2F,0x7C,0x9F,0x73,0x05,0x5A,0xBD,0x6F,
+		0x27,0x70,0xFF,0xAA,0xA9,0x5F,0xD8,0xBF,
+		0x23,0x11,0xF8,0xEC,0x09,0x7B,0xA3,0xB4,
+		0x0F,0x2B,0xCC,0x07,0x26,0x3E,0xAA,0x85,
+		0x0F,0x0C,0xD6,0x7F,0x56,0x59,0xA4,0x80,
+		0x07,0xD3,0xDB,0x8A,0x83,0x71,0x0B,0xC6,
+		0x07,0x9C,0xA8,0x42,0x7C,0x52,0xF7,0x7A,
+		0x0F,0x3F,0xC6,0xF6,0x2C,0x76,0xD6,0xF7,
+		0x27,0x26,0x93,0x83,0x9F,0xA8,0x19,0x9D,
+		0x22,0x4A,0x2E,0x56,0x0C,0x05,0x6A,0xDD,
+		0x0F,0x67,0xAC,0xCF,0x70,0x7A,0x99,0x70,
+		0x27,0x6A,0x5C,0x33,0xE2,0xFF,0x69,0x1A,
+		0x27,0x0A,0xC6,0xED,0x2A,0xEE,0x1E,0xA9,
+		0x2F,0x3E,0x76,0xB1,0x0D,0x1F,0xC1,0x09,
+		0x27,0x98,0xA7,0xC3,0xB4,0x73,0xD3,0x8C,
+		0x2F,0x8D,0x61,0xA8,0xFC,0x20,0x9C,0x71,
+		0x2F,0x1E,0xDA,0xC7,0xFD,0x83,0x75,0x34,
+		0x27,0x17,0x6F,0x90,0x8C,0x18,0x25,0x1A,
+		0x2F,0xCF,0xC6,0x8E,0x96,0xF2,0xDC,0xEA,
+		0x2F,0x05,0xC9,0x10,0x99,0xD6,0x99,0x59,
+		0x2F,0x1A,0x2D,0x82,0xCF,0xCA,0xE2,0x65,
+		0x27,0x3B,0xC2,0x9F,0x09,0x3B,0x8F,0xF4,
+		0x27,0x7B,0x26,0x24,0x46,0xDE,0x7B,0x7F,
+		0x27,0x6E,0xF2,0xF8,0x68,0xFC,0x68,0xAB,
+		0x27,0x1C,0x74,0xA7,0x48,0xB4,0xDE,0x59,
+		0x27,0xC2,0xE7,0x18,0x14,0x33,0xAB,0x02,
+		0x07,0x01,0x89,0xE7,0x85,0xAB,0xD1,0x19,
+		0x2F,0x5A,0x73,0x10,0x0A,0xE1,0x9F,0xF8,
+		0x2F,0x33,0x2D,0xC4,0x51,0x73,0x07,0xFC,
+		0x2F,0x78,0xFA,0x10,0x5E,0xDA,0x83,0xB8,
+		0x27,0x29,0x53,0xC3,0x9B,0x02,0x3B,0x07,
+		0x27,0x09,0x7A,0xF4,0xB6,0xFF,0xEC,0x9F,
+		0x2F,0x21,0x49,0x40,0x49,0x74,0x99,0xA9,
+		0x2F,0x42,0x51,0xFC,0x11,0x11,0x58,0x17,
+		0x27,0x5A,0xD1,0x69,0xE9,0xC7,0xC0,0x32,
+		0x07,0x70,0x28,0x7C,0x89,0x1F,0x74,0x9E,
+		0x2F,0x06,0x06,0x08,0x49,0xD7,0x13,0x4F,
+		0x2F,0xD5,0x71,0x5D,0x6F,0x66,0xB4,0x70,
+		0x27,0x52,0x6E,0x78,0xB6,0x0C,0x59,0xB8,
+		0x2F,0x94,0x84,0x3F,0xEC,0xAE,0x59,0xEC,
+		0x2F,0x00,0x66,0x02,0x64,0x73,0xD1,0x86,
+		0x27,0x30,0x52,0x96,0x42,0x9E,0x9A,0xD7,
+		0x2F,0xDC,0x52,0x87,0x6E,0x56,0x3D,0x9C,
+		0x27,0x8F,0x4D,0x09,0xC6,0x80,0xB9,0x70,
+		0x26,0x3F,0x89,0x6A,0xCA,0xCC,0x8E,0x15,
+		0x0F,0xC3,0x42,0xEF,0x5D,0x46,0xBA,0xC0,
+		0x2F,0xAB,0xE2,0x2C,0x22,0xE8,0xAA,0x77,
+		0x2F,0x9F,0xF2,0x5A,0x22,0x7C,0x5F,0x59,
+		0x2B,0xDC,0x4A,0x8B,0x8D,0x9E,0xCC,0xA5,
+		0x0F,0xB6,0x22,0xC3,0xC7,0xE1,0x44,0x93,
+		0x27,0x38,0xE4,0x24,0x4B,0x1C,0x32,0xB0,
+		0x2F,0xCB,0x77,0xD9,0x75,0x98,0xFE,0x93,
+		0x2A,0x19,0xC5,0x04,0x48,0x26,0x97,0x86,
+		0x07,0x3F,0x57,0xCA,0xDE,0xB6,0xB6,0xFC,
+		0x27,0x12,0x36,0x5A,0xC7,0xE2,0xA5,0x83,
+		0x2F,0x3F,0x91,0x6D,0xCF,0x8E,0x8D,0x30,
+		0x27,0x3B,0x20,0x62,0x2B,0x38,0xC0,0x19,
+		0x27,0xBA,0x2D,0x92,0xE4,0xD7,0x21,0x54,
+		0x2F,0x62,0x09,0x70,0x89,0x4A,0xEE,0x40,
+		0x07,0xBE,0x30,0xF1,0x4F,0x56,0xA8,0x6E,
+		0x2F,0x5D,0x82,0xC5,0x24,0x87,0xA5,0xA2,
+		0x2F,0x96,0xF0,0xD2,0x74,0x43,0x26,0x34,
+		0x2F,0xAA,0x22,0x1F,0x93,0x87,0x56,0x2C,
+		0x07,0x1F,0xBD,0x7B,0x6C,0xE6,0x19,0x82,
+		0x27,0x36,0x85,0x50,0x38,0xCC,0x2C,0x39,
+		0x2F,0xE2,0xE7,0xB3,0x67,0x08,0x07,0xE2,
+		0x27,0xE6,0xF0,0xED,0x6D,0x23,0x1F,0xA9,
+		0x27,0x85,0xA5,0xF6,0x20,0x3B,0xC7,0x18,
+		0x27,0xC6,0x1D,0xB2,0xAC,0x2C,0xB1,0x53,
+		0x2B,0x06,0xB8,0x47,0xC8,0x3A,0xDA,0xFF,
+		0x0F,0x5A,0x6E,0x4A,0xD9,0x87,0xA6,0xAC,
+		0x27,0x44,0xF4,0x69,0xC9,0x45,0x1B,0xF3,
+		0x2F,0x95,0x35,0x58,0xB8,0x21,0x34,0x8D,
+		0x27,0x7A,0x8B,0xCD,0x94,0xD3,0x6B,0x0A,
+		0x2F,0x47,0x55,0x74,0x10,0x7D,0x91,0xF8,
+		0x2F,0xC0,0xAA,0x3A,0xD1,0x4C,0xA6,0xE2,
+		0x22,0x87,0xCA,0xBF,0xE2,0xFA,0x5C,0xFF,
+		0x0F,0x76,0xBA,0xAD,0x5F,0xBC,0x79,0x55,
+		0x27,0xF8,0xC1,0x39,0x8E,0x04,0x66,0x48,
+		0x27,0xC8,0x9D,0xC4,0x74,0xC3,0x30,0x72,
+		0x2F,0x6D,0xCB,0x9A,0xBF,0x91,0x44,0x16,
+		0x27,0xF3,0x10,0x5A,0xCC,0x2B,0x09,0x40,
+		0x27,0x60,0xFA,0x25,0xFF,0x71,0x02,0xC9,
+		0x2F,0x69,0x9D,0xA7,0x08,0xA1,0x4B,0xA0,
+		0x27,0x8D,0x5C,0x1B,0x7C,0xBD,0xC7,0x2A,
+		0x27,0xD9,0x2F,0x58,0xE3,0x27,0xCA,0x59,
+		0x27,0x12,0x5C,0x91,0x96,0x14,0xC3,0x50,
+		0x2F,0x6C,0x6F,0x83,0xA7,0x0A,0x8E,0x8E,
+		0x2F,0x4E,0x37,0x7F,0xB8,0x1A,0x8E,0x83,
+		0x27,0x5A,0x40,0xA0,0xFE,0xC3,0xDE,0xE9,
+		0x27,0xD0,0xE5,0xA6,0xE5,0x28,0x11,0x46,
+		0x27,0xE0,0x6B,0x3E,0xBC,0x5A,0x8C,0xDB,
+		0x27,0xAA,0x8F,0x45,0x4E,0x7E,0xC4,0xEC,
+		0x24,0x2E,0x5E,0x4B,0x44,0xB6,0x45,0x0C,
+		0x07,0x78,0x54,0xB3,0x24,0xEE,0xB9,0x6A,
+		0x27,0x5C,0xDF,0xEC,0x63,0x54,0x69,0x24,
+		0x2F,0x89,0x9A,0x4D,0x80,0x3F,0x8F,0xB1,
+		0x27,0x86,0x4C,0x02,0x07,0x7E,0x13,0x7E,
+		0x2F,0x4D,0x0E,0xFA,0x6B,0xEE,0xE3,0x4E,
+		0x2F,0x9A,0x51,0x1D,0x18,0x1D,0xA2,0x5B,
+		0x27,0x47,0xF9,0x76,0x79,0x17,0x81,0x3F,
+		0x2F,0x7E,0x24,0xD7,0xA6,0x14,0xA5,0x3B,
+		0x2F,0x53,0xAA,0x09,0xF7,0x65,0xC8,0xEE,
+		0x27,0x4A,0xFC,0x61,0x5F,0x7B,0xAB,0xFB,
+		0x26,0x49,0xA5,0x7C,0xC8,0xAA,0x4B,0xDD,
+		0x07,0x15,0x2E,0x15,0x14,0xA7,0xE7,0xC4,
+		0x07,0x1C,0x68,0xD8,0x61,0x8D,0xB6,0x9B,
+		0x27,0x07,0x18,0x32,0xBA,0x4E,0x93,0xD1,
+		0x27,0x53,0xF0,0xD1,0x94,0xA3,0x80,0x06,
+		0x22,0x95,0x51,0x30,0x4D,0x6F,0x16,0x52,
+		0x07,0xDD,0xDC,0x2D,0xF5,0x6A,0x0A,0xFE,
+		0x2F,0xFD,0x00,0x06,0x6E,0xC2,0x7F,0x31,
+		0x2F,0x96,0x74,0xB6,0xDE,0x9C,0xD3,0xDD,
+		0x2F,0x16,0x59,0xB0,0x6D,0xFC,0xA6,0x76,
+		0x29,0xF4,0xDD,0x3D,0xE6,0x68,0x21,0xC4,
+		0x07,0x10,0x8E,0x65,0x84,0x3F,0xC8,0x6E,
+		0x2F,0xB5,0x9B,0x84,0x0B,0x86,0xD6,0x5E,
+		0x2F,0x25,0x80,0xF3,0xC4,0xF5,0x21,0x66,
+		0x27,0x12,0xCF,0x43,0x77,0xB8,0xED,0x45,
+		0x27,0x55,0x48,0xD3,0x7D,0x1F,0x95,0x6C,
+		0x2D,0x34,0xD7,0x8B,0x3F,0x10,0xA3,0x47,
+		0x0F,0x96,0xD4,0x5C,0x81,0xB2,0x84,0x25,
+		0x2F,0xBA,0x9B,0xB2,0x8D,0x79,0xB8,0x3E,
+		0x27,0x04,0xA7,0x4C,0x7A,0x45,0x92,0x66,
+		0x27,0x3F,0x7B,0x39,0xA5,0x67,0x21,0xC2,
+		0x27,0xA1,0x3E,0x67,0x17,0x7B,0x0F,0x11,
+		0x27,0xB1,0x55,0x7B,0x24,0x80,0x1C,0x36,
+		0x2F,0xAE,0x40,0x86,0xCA,0xA8,0xA6,0x13,
+		0x27,0xC7,0xE0,0x9A,0x79,0x9C,0xF2,0xC8,
+		0x2F,0x96,0x66,0x20,0xCF,0x41,0x82,0x09,
+		0x2F,0x3F,0xC4,0x25,0x41,0xEC,0x7B,0xEA,
+		0x2F,0x3B,0xE6,0xB4,0x99,0xED,0x42,0xCF,
+		0x2F,0x0A,0x9F,0x49,0x5A,0xD9,0x0A,0xC6,
+		0x07,0xEF,0x47,0xE4,0x0E,0x69,0xF7,0xF6,
+		0x0F,0x57,0xEE,0x7E,0xD5,0x18,0xCD,0x17,
+		0x0F,0x5E,0x2E,0x58,0xF1,0x14,0x0D,0x99,
+		0x0F,0x2B,0xD2,0x01,0x16,0x81,0x7E,0xFF,
+		0x2F,0x42,0x0F,0xC4,0x97,0xFF,0x94,0x91,
+		0x2F,0x2F,0x1E,0x65,0xD4,0xCA,0x10,0x4B,
+		0x25,0x96,0x7F,0xC3,0x25,0xFD,0xE0,0x9E,
+		0x0F,0x77,0x27,0xE4,0x13,0xC0,0xBB,0x3C,
+		0x27,0x0E,0xBB,0x60,0xFF,0xC0,0x88,0xA4,
+		0x27,0x42,0xCC,0x24,0x2A,0xCB,0xA5,0xFF,
+		0x27,0x74,0xD9,0xE9,0xFD,0x6D,0x30,0xFC,
+		0x27,0x3B,0x39,0xCC,0x41,0x8D,0x01,0xCA,
+		0x2F,0x70,0xBD,0xF1,0x38,0xEF,0x22,0x63,
+		0x24,0x5E,0x54,0xB3,0x79,0xBA,0x7B,0xBA,
+		0x07,0x3A,0xC5,0xBA,0x83,0x85,0x61,0xB9,
+		0x0F,0x8A,0x97,0x6A,0x93,0x08,0x72,0x4A,
+		0x07,0xAF,0x46,0x26,0x27,0xBE,0x5F,0x30,
+		0x0F,0x79,0x53,0xFA,0xEC,0xDD,0xF5,0xDF,
+		0x2F,0xA1,0xBF,0x3B,0x6B,0xF6,0x65,0xF5,
+		0x2F,0xC3,0xC3,0xC3,0x63,0xD0,0x2E,0x56,
+		0x2F,0xD2,0xE0,0x1C,0xAC,0xA9,0x37,0x5F,
+		0x27,0x9B,0xC5,0x5C,0x8F,0xC7,0x7A,0x3C,
+		0x2B,0x9E,0x00,0x31,0x2F,0x62,0x83,0x17,
+		0x0F,0x66,0x40,0x34,0xAE,0x82,0x56,0x07,
+		0x27,0x09,0xA8,0x95,0x20,0x26,0x09,0xFC,
+		0x2A,0x16,0xA0,0xED,0x5C,0xE6,0xB9,0x80,
+		0x0F,0x5A,0x6C,0x1A,0x09,0x2F,0x35,0xCD,
+		0x27,0x50,0x2E,0xBB,0x6C,0x51,0x14,0xB5,
+		0x27,0x70,0x54,0x56,0x07,0x7C,0x1B,0x61,
+		0x2F,0x29,0x81,0x08,0x41,0xCA,0x3D,0xCD,
+		0x2F,0xC5,0x37,0x1E,0xCA,0x96,0x0A,0x82,
+		0x27,0x21,0x0D,0xD8,0xD7,0x4C,0xF7,0x4B,
+		0x2F,0xD3,0x35,0xF0,0x84,0xFD,0xCF,0xB4,
+		0x27,0xD1,0x5C,0xD3,0x8A,0xB4,0x1E,0xD6,
+		0x2F,0x04,0xFA,0x28,0x48,0x05,0xC2,0x94,
+		0x2F,0xC9,0x66,0xCD,0x2D,0x77,0xBC,0x58,
+		0x2F,0x63,0x20,0x0F,0x8E,0x18,0x99,0x74,
+		0x27,0xF2,0x78,0x1A,0x5E,0x17,0x43,0x61,
+		0x2F,0x26,0xA5,0x5B,0x14,0x9B,0x6C,0x4C,
+		0x2F,0xBA,0xC4,0x03,0x3E,0xE5,0xAC,0xEC,
+		0x27,0x5E,0x8D,0x0D,0xAF,0x0F,0x44,0x77,
+		0x27,0x29,0x3C,0xC4,0xFC,0x64,0x6B,0x4C,
+		0x2F,0x4B,0x8C,0xE0,0x06,0x31,0x93,0xCB,
+		0x27,0xF4,0x4D,0x38,0x7F,0x98,0x3D,0xB4,
+		0x27,0xEB,0x1A,0xB4,0x2F,0x15,0x1E,0xEA,
+		0x27,0x6B,0xED,0xE0,0xA3,0x13,0x4C,0xC5,
+		0x2F,0x77,0xAA,0x58,0x31,0x0C,0xAB,0xF5,
+		0x23,0x05,0xA1,0x61,0x4A,0xEC,0xDB,0xE1,
+		0x0F,0x67,0x02,0xC2,0xAA,0x83,0x51,0x5F,
+		0x2F,0x02,0xE4,0x30,0x84,0x05,0x10,0xEB,
+		0x2A,0xCF,0x84,0x1A,0xD0,0x10,0x6D,0x7B,
+		0x07,0x09,0x53,0xAB,0xBE,0xC4,0x91,0x33,
+		0x2F,0x7D,0xF4,0xED,0x7F,0xBC,0x84,0x7F,
+		0x27,0x49,0xB2,0xCE,0xB1,0xF2,0xFD,0x27,
+		0x27,0x9C,0xB5,0xB8,0x91,0xDF,0xD1,0xE7,
+		0x27,0x5E,0x32,0x21,0xC4,0x4B,0x64,0x91,
+		0x27,0x42,0xD5,0x8A,0x5C,0xC5,0xC7,0x42,
+		0x27,0xAD,0x05,0x97,0xAF,0xDB,0x74,0x5A,
+		0x27,0x8D,0xB8,0x82,0x0D,0xFD,0x57,0x82,
+		0x27,0x66,0x4E,0xC5,0x0E,0x7B,0xFE,0xED,
+		0x0F,0xAC,0x4C,0x29,0x56,0xCB,0x36,0xA6,
+		0x0F,0xDB,0x09,0x8B,0x3D,0x71,0x85,0x45,
+		0x0F,0x32,0xC5,0x4B,0x1D,0x3B,0x08,0xB7,
+		0x07,0x49,0xF4,0x32,0x1C,0x0E,0x75,0xC1,
+		0x27,0x5F,0x11,0xDC,0x0B,0x76,0x9D,0xB4,
+		0x2E,0xB0,0x17,0xAD,0x6E,0x6A,0x89,0x9B,
+		0x0F,0xAF,0x1B,0x5C,0x92,0xE3,0xCE,0x17,
+		0x0F,0x85,0x55,0x70,0x25,0xE7,0xF5,0x33,
+		0x25,0x42,0xF3,0x1F,0xF7,0x69,0xAF,0xEE,
+		0x0F,0xD5,0x85,0xBE,0x6C,0xD9,0x60,0xBD,
+		0x07,0xE4,0xA0,0x9C,0x20,0x2E,0xAD,0xE6,
+		0x07,0x09,0x04,0x83,0xD1,0xF5,0xA9,0xFF,
+		0x27,0x72,0x86,0xBD,0xFE,0x36,0xF6,0xC2,
+		0x2F,0x99,0x79,0xD4,0x09,0xDE,0x0E,0x9E,
+		0x2F,0xD0,0x57,0x2E,0x51,0x89,0x0A,0xA7,
+		0x27,0x91,0x76,0x58,0x66,0xA2,0x6B,0x6F,
+		0x24,0x4F,0x09,0x68,0xAA,0x8C,0xAA,0x40,
+		0x07,0x70,0x93,0x6B,0x23,0x8B,0xEC,0x2A,
+		0x0F,0x20,0xE4,0x4A,0xC8,0x26,0x78,0x28,
+		0x2A,0x92,0x35,0x37,0xD5,0xB4,0xC1,0xE3,
+		0x07,0xBC,0x34,0x5C,0xA0,0x5B,0x6F,0x52,
+		0x25,0xC3,0x39,0xD8,0x7E,0x44,0xBD,0x7C,
+		0x0F,0xC4,0x52,0x72,0xB9,0xC0,0x99,0xF6,
+		0x27,0xEB,0xFC,0x6B,0x09,0x5F,0xE5,0x06,
+		0x27,0xE0,0x05,0xA2,0x27,0x32,0x7F,0xB7,
+		0x27,0xB1,0xCF,0x4D,0x11,0x0A,0xCA,0xBB,
+		0x23,0x12,0xA5,0x18,0x01,0xBE,0x6C,0x8D,
+		0x0F,0xF0,0x14,0xA9,0xF2,0x94,0xFD,0x5A,
+		0x2F,0xD1,0x32,0x70,0xCC,0xA0,0x99,0xD6,
+		0x27,0x4A,0xD8,0x57,0xD0,0x49,0x99,0x2A,
+		0x2F,0x4F,0x93,0xC1,0xDB,0x54,0xEE,0x29,
+		0x2F,0x4B,0x25,0x9A,0xFC,0xED,0x87,0x52,
+		0x27,0x64,0x9F,0x82,0xE0,0xC3,0x8C,0x84,
+		0x2F,0x90,0x91,0xAB,0x03,0x42,0x74,0x12,
+		0x2F,0x60,0x53,0x89,0xF5,0xAF,0xC9,0x89,
+		0x2F,0x47,0xBE,0xEF,0x42,0xE8,0xA4,0x51,
+		0x27,0x39,0x05,0x38,0xE5,0x79,0x78,0xE5,
+		0x27,0x5D,0x2C,0x62,0x28,0xDF,0xB4,0x5F,
+		0x27,0xE2,0x9A,0x7E,0x28,0xEB,0x21,0xC3,
+		0x2D,0xDB,0x43,0x0D,0x55,0x18,0x74,0x46,
+		0x0F,0xCF,0x0F,0x90,0x21,0xC5,0x32,0x0C,
+		0x2F,0x13,0xB4,0x48,0x3B,0x35,0xFD,0x66,
+		0x2F,0x27,0x92,0x64,0xE8,0xC0,0xF1,0xB1,
+		0x2F,0x38,0xCD,0xCA,0xDF,0x48,0x66,0x7D,
+		0x2F,0x36,0x80,0x2F,0x2A,0xDA,0x68,0xDC,
+		0x27,0xB4,0x9C,0xF3,0xAC,0xC7,0x70,0x64,
+		0x2F,0x16,0x69,0xF0,0x33,0xF3,0x42,0x7A,
+		0x27,0x90,0x0C,0xB5,0x6E,0xDB,0xD3,0x6B,
+		0x2F,0xEE,0x4E,0xD5,0xEB,0x22,0x69,0xD2,
+		0x2F,0x44,0x9F,0xF2,0x60,0xA9,0xC2,0xB6,
+		0x2F,0x4D,0x44,0xB6,0x86,0x1D,0x6E,0xD1,
+		0x27,0xD3,0x19,0x67,0x29,0x8C,0xC5,0x74,
+		0x2F,0x7D,0x4C,0x0C,0x7F,0x3F,0x9E,0xE8,
+		0x27,0x0A,0x7C,0x47,0xE0,0x58,0x46,0xF5,
+		0x23,0x67,0x71,0x1B,0x71,0xF5,0x2B,0x63,
+		0x07,0x9C,0x65,0x3C,0xB9,0x3F,0x9C,0x98,
+		0x2F,0x22,0x40,0xAB,0x08,0xB6,0xAE,0xED,
+		0x2F,0xC0,0xAE,0x06,0x5B,0x2D,0x19,0x43,
+		0x27,0xD1,0xE4,0xAA,0x4C,0xAD,0xD5,0x80,
+		0x27,0xE1,0x7F,0x7C,0xFC,0x8A,0xC6,0xCC,
+		0x27,0x84,0x4C,0x37,0xB5,0x32,0x60,0x67,
+		0x27,0xCC,0xE7,0x44,0x99,0xE0,0x25,0x92,
+		0x2F,0x34,0x5E,0xBA,0x0F,0x90,0x1C,0xC0,
+		0x27,0x0C,0x07,0xF8,0x47,0xA6,0xF1,0x95,
+		0x2F,0x52,0xF9,0x84,0x82,0x4D,0xB4,0x6B,
+		0x2F,0x91,0x3A,0xA3,0xB4,0x8E,0xD3,0x1D,
+		0x2F,0x5D,0xC7,0x5B,0x3D,0x3E,0x4F,0x11,
+		0x2E,0x23,0x91,0xA8,0x4D,0x31,0xDC,0x06,
+		0x07,0x45,0xB3,0x91,0x45,0x24,0x65,0x0F,
+		0x27,0x74,0xCF,0x30,0xAE,0x89,0xE1,0xAB,
+		0x0F,0x0F,0xC2,0xB5,0xD4,0xCA,0xB4,0x98,
+		0x2F,0x4A,0xB0,0x1D,0x7C,0xBF,0x1F,0x76,
+		0x2F,0xB4,0x14,0xFC,0x16,0x85,0x5A,0xC5,
+		0x2F,0x82,0xAA,0xE4,0xF4,0x12,0x0F,0x64,
+		0x27,0x1F,0x40,0xAC,0x00,0x89,0xF4,0x9D,
+		0x0F,0x00,0x73,0xF2,0xC6,0x20,0xBF,0xEF,
+		0x2F,0x07,0x1A,0x8C,0x7C,0x49,0x84,0x1C,
+		0x21,0x13,0x08,0x30,0x44,0xDB,0xB5,0xED,
+		0x07,0x1B,0x88,0xDE,0xB1,0x8E,0xA0,0xED,
+		0x2F,0x60,0x10,0x40,0x40,0xE7,0x7F,0x8B,
+		0x2F,0x27,0x51,0x4F,0xC3,0x18,0xB2,0x14,
+		0x2D,0x0E,0xBD,0x51,0x11,0x20,0x2D,0x20,
+		0x0F,0xB6,0x74,0xB4,0xB8,0x33,0x7B,0xA1,
+		0x2A,0x21,0xC7,0x3C,0x7A,0xCD,0x07,0x09,
+		0x07,0xA2,0x85,0x93,0xE5,0x07,0x00,0x9A,
+		0x25,0xAB,0x10,0x72,0xEE,0x95,0xD4,0xD4,
+		0x0F,0xA1,0x3E,0x1E,0xF3,0x09,0x3D,0x15,
+		0x2F,0x08,0xB4,0x2D,0xD6,0x95,0xD9,0x14,
+		0x27,0xA2,0x3E,0xAA,0x79,0x4E,0x78,0x5F,
+		0x2F,0x53,0xD2,0x3D,0xE6,0x6B,0x93,0x27,
+		0x27,0x7B,0xD9,0xC1,0xE5,0x08,0x9C,0xF1,
+		0x2F,0xAA,0x20,0x6B,0x6C,0xBD,0x1E,0x9D,
+		0x2F,0x7B,0x3A,0x39,0x52,0x51,0x83,0xED,
+		0x27,0x92,0xB7,0x38,0x75,0x0E,0xB1,0x2B,
+		0x27,0x9A,0x40,0x11,0xDC,0x06,0x2B,0x1E,
+		0x27,0xFE,0x34,0xBC,0x59,0x6E,0x31,0xF3,
+		0x2F,0x8D,0xFC,0xB5,0x4F,0x4C,0xB5,0x52,
+		0x27,0xA0,0x4A,0x70,0x02,0xFB,0xD7,0xD1,
+		0x27,0xEA,0x01,0x87,0xBE,0x8D,0x29,0xC6,
+		0x2F,0x39,0xC3,0x8B,0xB7,0x96,0xC2,0x56,
+		0x2F,0x50,0xE6,0xF4,0x50,0x03,0xBA,0x61,
+		0x27,0x02,0xCC,0x03,0xAF,0x2F,0x3F,0xAC,
+		0x27,0xAB,0x69,0xD0,0xCF,0xA7,0x4B,0x76,
+		0x27,0xDF,0x31,0x4B,0xDE,0x55,0x54,0x19,
+		0x2F,0x98,0xCB,0x8A,0x7F,0x1F,0xE3,0x62,
+		0x2F,0x45,0x33,0x58,0xAD,0x03,0x57,0x81,
+		0x2F,0x6D,0xC9,0xAA,0xDF,0x20,0x6E,0xF0,
+		0x27,0xBC,0x1F,0x99,0xF3,0xDC,0x86,0xB5,
+		0x27,0x19,0xE3,0x17,0x86,0x74,0xB8,0xFE,
+		0x2F,0xED,0xCC,0x7F,0x97,0x47,0xFA,0xBB,
+		0x27,0xB5,0xD9,0xC0,0xD1,0x7B,0x5E,0x9C,
+		0x27,0xDA,0x1F,0x04,0xD9,0x0B,0xE2,0xB4,
+		0x27,0xFF,0x8B,0xEF,0x7E,0x3A,0x4E,0xB9,
+		0x2B,0xB0,0x49,0x12,0xA0,0x7E,0x02,0x5B,
+		0x07,0x7D,0xAF,0x99,0x07,0xCC,0x75,0xF7,
+		0x26,0x7C,0x3B,0xDC,0xBC,0xFC,0x49,0xCA,
+		0x0F,0x8A,0x20,0x87,0x5D,0x14,0xF8,0xA6,
+		0x27,0xB0,0xD5,0x65,0xFA,0xD1,0x0A,0xD7,
+		0x27,0x3C,0x1A,0x67,0xE4,0x22,0x02,0xC8,
+		0x27,0xA9,0x1B,0x72,0x33,0x88,0xAA,0x85,
+		0x27,0x0E,0xCD,0x9D,0x2B,0x7F,0x2D,0xD7,
+		0x27,0x78,0xA1,0xA1,0xF3,0x7C,0x03,0x6F,
+		0x2F,0x1B,0x8D,0x6C,0xD7,0xF4,0xB1,0x05,
+		0x2F,0x70,0x87,0x41,0xA8,0x8C,0x10,0xA6,
+		0x2C,0x35,0x20,0x16,0x97,0x0B,0x8A,0xED,
+		0x0F,0x15,0x1D,0xA2,0x5E,0x45,0xD3,0xC5,
+		0x27,0x2C,0x0F,0xBD,0x38,0x35,0xC6,0x5F,
+		0x2F,0x57,0x2A,0x4E,0x04,0xEB,0x1D,0x7C,
+		0x27,0xBE,0x8B,0x7C,0x95,0x61,0xE8,0xCB,
+		0x2F,0xBC,0xD4,0xC3,0xE3,0x0D,0x7A,0x30,
+		0x27,0xC4,0x21,0x3B,0x73,0x01,0x99,0xDE,
+		0x25,0x34,0x18,0xBB,0x31,0xC5,0x15,0x08,
+		0x0F,0x50,0x89,0x4D,0x52,0x71,0x92,0xE3,
+		0x2B,0x74,0xF0,0x5D,0xE7,0x28,0x74,0x47,
+		0x0F,0x9B,0x52,0x53,0x3D,0x32,0x1F,0x7E,
+		0x27,0x38,0x66,0xA1,0x48,0x1E,0x0E,0xD0,
+		0x2F,0x13,0xF7,0x78,0x24,0xE7,0x4C,0xB6,
+		0x29,0x11,0x9F,0xBA,0xA8,0x82,0x76,0x88,
+		0x0F,0xC5,0x68,0x52,0xA8,0x98,0x41,0x7B,
+		0x27,0xF4,0x5D,0x97,0x5B,0x2A,0xB5,0x9E,
+		0x2F,0xF4,0x8A,0xE9,0x82,0xED,0x88,0x0F,
+		0x27,0xC0,0x5B,0xB8,0xF8,0x53,0xC0,0x78,
+		0x22,0x96,0x2E,0x0C,0x35,0xD3,0x60,0xB6,
+		0x07,0x8F,0xDD,0x53,0xEE,0x41,0x75,0xC7,
+		0x23,0xFB,0xC4,0xEB,0x71,0x45,0x70,0xCA,
+		0x07,0x55,0x30,0xCF,0xEB,0xD0,0x69,0x85,
+		0x2F,0x19,0xB4,0xB2,0xE0,0x96,0x3D,0x7D,
+		0x2F,0xD4,0xDE,0x25,0xFF,0xCD,0x9B,0xAD,
+		0x29,0xD9,0x0F,0x39,0xF5,0xCF,0x6C,0xF5,
+		0x07,0x16,0xAA,0x3E,0x5D,0xE8,0xDC,0xE5,
+		0x0F,0xFA,0x0B,0xA3,0xA6,0xC1,0x28,0x24,
+		0x07,0x4E,0x25,0xA6,0x64,0x41,0xE4,0xDD,
+		0x2C,0xED,0x9B,0x2D,0x69,0x43,0x68,0x8B,
+		0x0F,0x2C,0xB0,0x8D,0x2F,0x87,0x58,0x82,
+		0x2F,0xCF,0xA3,0xA6,0x34,0x85,0x77,0x3F,
+		0x2F,0x9F,0x74,0x2E,0x81,0x54,0x64,0x40,
+		0x2A,0xA6,0xEA,0xC1,0xDE,0xF0,0x4F,0xFC,
+		0x07,0x09,0x4E,0x1E,0xD1,0x2D,0x91,0x04,
+		0x07,0x81,0x03,0xE9,0x60,0x92,0x34,0xC8,
+		0x07,0x56,0xD8,0x69,0xCA,0xD0,0x9C,0x50,
+		0x2F,0x24,0x86,0x22,0x65,0xC2,0x00,0xB6,
+		0x27,0xA9,0x07,0x54,0x03,0x61,0x4D,0x31,
+		0x2F,0x26,0x00,0x6F,0x75,0x5E,0x60,0x5D,
+		0x27,0xB2,0xA8,0xD5,0x5A,0xEE,0xE7,0xC5,
+		0x22,0x43,0x1E,0x8E,0xB1,0x9A,0x9F,0x5C,
+		0x0F,0x0B,0xD5,0x21,0x6A,0x6B,0xA2,0xF7,
+		0x27,0x84,0xC6,0x1F,0x77,0xCF,0x40,0xBF,
+		0x2F,0x1D,0xAA,0x6E,0x17,0x04,0x91,0x12,
+		0x25,0xE6,0x94,0xB8,0x4B,0x56,0xAC,0xAB,
+		0x07,0x43,0x87,0xC3,0xA1,0xE1,0xF5,0x35,
+		0x2F,0x82,0xEC,0x75,0xEE,0x18,0x86,0xC8,
+		0x2F,0xD4,0x89,0xB1,0x05,0x1C,0x87,0x1E,
+		0x2F,0xA0,0xC9,0x6D,0x82,0x88,0x91,0xBE,
+		0x2F,0x11,0xB4,0x4D,0x77,0xC0,0x1B,0x51,
+		0x27,0x94,0x19,0xBE,0xB9,0x4B,0xAF,0x8A,
+		0x27,0x20,0x2B,0xA5,0xB0,0xCB,0x00,0x53,
+		0x2F,0x3F,0x77,0xD8,0xF1,0x9F,0xE3,0x5A,
+		0x27,0xF6,0x3D,0x86,0xCA,0x8C,0x1A,0xD0,
+		0x2D,0xD4,0x5E,0x18,0xAE,0x72,0x4D,0x60,
+		0x0F,0xC4,0x8F,0xFB,0x7B,0xBB,0xDC,0x6B,
+		0x2F,0x66,0x6D,0x58,0x1B,0x72,0xD1,0x84,
+		0x27,0x31,0x44,0x6C,0x2A,0x18,0xDB,0x48,
+		0x24,0x52,0xE5,0x00,0x0A,0x04,0xA7,0xDD,
+		0x0F,0xA9,0xCC,0x71,0x35,0x7B,0xC0,0xDB,
+		0x22,0x05,0xB3,0x25,0xAE,0x4F,0x1D,0x7C,
+		0x07,0x23,0x9A,0x73,0x0F,0x3A,0xE6,0x6C,
+		0x07,0xA3,0x4D,0xE1,0x80,0x1F,0xBF,0xC8,
+		0x07,0x40,0x8D,0x7C,0x63,0xB9,0x6A,0x67,
+		0x27,0x94,0x3C,0xB2,0x77,0x08,0x74,0x7B,
+		0x27,0xD0,0xB6,0x69,0x26,0xAE,0x0F,0x80,
+		0x2F,0x08,0x05,0x93,0xF3,0xB5,0x72,0x58,
+		0x2F,0x90,0x96,0x7B,0xFD,0x27,0x09,0x6C,
+		0x2F,0xEC,0xE4,0x48,0x31,0x65,0x93,0x1B,
+		0x27,0x4F,0xB0,0xA9,0xD7,0xF6,0xC0,0xB2,
+		0x27,0x62,0x89,0x87,0xD8,0xFA,0x05,0x02,
+		0x27,0x65,0xAE,0xDE,0xBB,0x4D,0x24,0x8D,
+		0x2B,0xD7,0x1A,0xE7,0x6E,0x85,0x07,0xF1,
+		0x0F,0x32,0x40,0xA9,0x86,0xB4,0x46,0x81,
+		0x2F,0x6D,0x19,0x7C,0xC8,0x15,0x81,0xC2,
+		0x2C,0xC6,0x93,0x32,0x55,0xA0,0x4F,0xBC,
+		0x07,0x63,0x01,0x3A,0xF7,0x3B,0x3A,0x59,
+		0x26,0x66,0xBC,0xDB,0xD5,0xFE,0xBE,0x4B,
+		0x07,0xCF,0xC8,0x2C,0x5D,0x60,0xF5,0x97,
+		0x26,0xDF,0xF9,0x7C,0x9E,0xCC,0xB1,0xAA,
+		0x07,0x3D,0xAA,0x99,0x80,0x8D,0x52,0xA5,
+		0x27,0x12,0x8D,0x24,0xE8,0xAB,0xC8,0xA0,
+		0x22,0xD1,0x1D,0xD7,0x21,0xC5,0xAB,0x4E,
+		0x0F,0x61,0x23,0x71,0xB5,0xEF,0x60,0x59,
+		0x2F,0xFC,0xF7,0x8A,0xE8,0x40,0x06,0x44,
+		0x27,0xC2,0x4F,0x73,0xAE,0xC4,0x91,0x8E,
+		0x2F,0xD7,0xC3,0x42,0x62,0x20,0x89,0x66,
+		0x27,0xAE,0xEB,0x79,0x23,0x35,0xC3,0x6B,
+		0x2A,0xB0,0x72,0x3E,0x71,0xA8,0xC8,0x30,
+		0x07,0x44,0x80,0xE0,0xD8,0x3D,0x79,0x93,
+		0x2F,0xA1,0x23,0x1E,0xCB,0x35,0x35,0x66,
+		0x2F,0xA6,0xC1,0xC4,0x31,0x10,0x17,0xAD,
+		0x27,0x8A,0xC1,0x1E,0xD6,0xA2,0x9B,0x31,
+		0x27,0xA8,0x78,0xC6,0x36,0xEF,0x7A,0x2A,
+		0x2F,0x48,0xCF,0xBB,0x3D,0xFF,0x05,0x5F,
+		0x27,0xBB,0x68,0x9A,0xB2,0xDD,0xA4,0x64,
+		0x27,0x82,0x2C,0x7D,0x2F,0x8D,0x51,0xBF,
+		0x2F,0xEA,0x36,0xA6,0xEE,0x18,0x66,0x2F,
+		0x2F,0x44,0xBA,0xB1,0xBD,0x2A,0x2B,0x45,
+		0x25,0xD8,0xCB,0x36,0x86,0xF6,0x09,0xFC,
+		0x07,0x20,0xAE,0x4B,0xD2,0xB5,0x1D,0x79,
+		0x27,0xE7,0x9D,0xB3,0xA1,0xB5,0x5D,0xBE,
+		0x2F,0xB3,0x64,0xFC,0xC5,0x56,0xE7,0xED,
+		0x2F,0x1C,0x4C,0xBA,0x51,0x70,0x0A,0xEB,
+		0x2F,0x3E,0x68,0xA5,0x6E,0xF0,0x2A,0xCF,
+		0x22,0xB7,0x97,0x9B,0x8C,0x1B,0x51,0x79,
+		0x07,0x76,0x72,0x71,0xA3,0xA4,0xFD,0x7C,
+		0x27,0x02,0xC8,0x5F,0x35,0x96,0xDF,0xAA,
+		0x2F,0xF8,0x13,0x5D,0x35,0x2D,0x44,0x88,
+		0x27,0x6D,0x1C,0xBE,0x74,0xC5,0x3D,0xF8,
+		0x27,0x84,0xBF,0x3D,0x01,0x88,0xC4,0x6A,
+		0x27,0x47,0xE1,0x6D,0x99,0x9E,0x7A,0x93,
+		0x27,0x83,0xCA,0xF0,0x90,0x88,0xEC,0xEB,
+		0x2F,0x22,0x89,0x70,0x18,0xF1,0x01,0x9E,
+		0x27,0x8A,0x3B,0x8D,0x03,0xC0,0x4E,0x6B,
+		0x27,0xF0,0x3B,0x24,0x67,0xB8,0x0A,0xCD,
+		0x27,0x7D,0x85,0x3C,0x2F,0x18,0xB9,0x83,
+		0x27,0xB1,0x41,0xDD,0x7D,0x11,0xD4,0x27,
+		0x2F,0xE3,0xBE,0x5E,0x32,0x71,0xDB,0x59,
+		0x27,0x73,0xDD,0xE1,0xB0,0x9A,0xA2,0x0A,
+		0x27,0xB3,0x05,0xE9,0x25,0x74,0xB2,0x54,
+		0x27,0x5B,0xAD,0xF4,0x3C,0x36,0xA4,0xF7,
+		0x2F,0x5C,0xA3,0x0C,0x91,0xC6,0x8F,0x9D,
+		0x27,0xB7,0x23,0x4B,0x3F,0xBC,0x54,0xD2,
+		0x27,0x6D,0x77,0x19,0x5B,0x7A,0x58,0x36,
+		0x2F,0x66,0x04,0xDE,0x62,0xCE,0xFB,0xFF,
+		0x2F,0xA9,0xD2,0x06,0xBC,0x93,0xE9,0xA3,
+		0x27,0x94,0x2A,0xA5,0xF9,0x38,0x21,0xEA,
+		0x2F,0x87,0x8E,0x3E,0x7C,0x87,0x96,0xAB,
+		0x27,0xAB,0x89,0x5F,0x6F,0xA7,0xB1,0x1C,
+		0x2F,0x71,0xB5,0x90,0x2E,0xD6,0xA2,0xC4,
+		0x2F,0x0B,0x1F,0xFC,0x60,0x4B,0x20,0xC3,
+		0x2F,0x6A,0x36,0xA5,0xC4,0xE0,0x6C,0xD7,
+		0x23,0x18,0xC1,0x26,0x30,0x42,0xEA,0x7C,
+		0x07,0x26,0x5F,0x0B,0xA2,0xA2,0x5E,0x0F,
+		0x2F,0xA4,0x1D,0x41,0x4C,0xA8,0xFF,0x60,
+		0x22,0xB3,0x40,0x69,0x6B,0x2D,0x6A,0x0C,
+		0x07,0x85,0x63,0xF2,0x37,0x0E,0xE1,0xAD,
+		0x07,0x65,0x0F,0x17,0xAF,0x05,0x10,0xF4,
+		0x2D,0x1C,0xFE,0xFE,0xCB,0x8A,0xD0,0x41,
+		0x0F,0xB5,0x42,0x10,0x22,0x74,0x40,0x48,
+		0x27,0x2F,0x6A,0x9F,0x55,0xBE,0x0D,0x2D,
+		0x2F,0xB5,0xDE,0xD6,0x02,0x3A,0x28,0x49,
+		0x2F,0xFD,0x1D,0x5D,0x69,0xB6,0xEC,0x23,
+		0x2F,0xC9,0x5F,0x89,0x13,0xC3,0x14,0xDB,
+		0x27,0xE2,0xC9,0x07,0x8C,0xA2,0x40,0xA7,
+		0x27,0x53,0x06,0xCB,0xEB,0xCE,0x1E,0x40,
+		0x2A,0xA6,0x21,0x81,0x1A,0xD4,0x7E,0x39,
+		0x0F,0xCE,0x0A,0xCD,0x7F,0x2B,0x83,0x36,
+		0x27,0xBE,0xB8,0x80,0x33,0x67,0x55,0x33,
+		0x27,0xB6,0xC8,0x4C,0x25,0x1B,0x5F,0xCA,
+		0x2F,0x65,0x1B,0x22,0xF6,0x29,0x9D,0xF1,
+		0x27,0x7A,0xE7,0x46,0x25,0x2E,0xC1,0x6D,
+		0x0F,0x50,0x4E,0x47,0x9F,0x3F,0x99,0xE7,
+		0x07,0xDE,0xA2,0x39,0xF7,0x48,0x24,0x2B,
+		0x25,0x77,0x68,0x1A,0xF6,0xF7,0x5C,0x55,
+		0x0F,0x04,0xA0,0x1F,0x15,0xD8,0xDF,0x26,
+		0x27,0x7B,0x6E,0xBA,0x24,0x7B,0xB9,0xE0,
+		0x27,0x11,0x99,0xAD,0xF8,0xB3,0x6E,0x04,
+		0x2F,0xE5,0x26,0x2B,0x70,0xE3,0xDF,0xF7,
+		0x27,0xF8,0x7A,0xCB,0x99,0x91,0x4B,0x54,
+		0x27,0xA9,0x68,0x25,0x0D,0xEE,0x28,0x3B,
+		0x27,0xFD,0xE4,0xB8,0x1C,0x74,0x88,0x0A,
+		0x2F,0x57,0x01,0xCE,0xB1,0xEE,0x36,0xCF,
+		0x21,0x41,0xDA,0x5B,0x24,0x66,0x8F,0x19,
+		0x0F,0x93,0xD7,0x88,0x22,0x93,0xAC,0x34,
+		0x2F,0xD1,0x30,0x86,0x0F,0x5F,0xF1,0x1D,
+		0x27,0x28,0x4A,0xF0,0x44,0xBE,0xC7,0xBE,
+		0x26,0x98,0xC4,0x0E,0xDB,0x11,0x39,0xCA,
+		0x07,0x3A,0x15,0x01,0x3E,0xA0,0x4E,0x1B,
+		0x0F,0xFF,0xE0,0xC5,0xA0,0x22,0x66,0xF5,
+		0x2F,0x04,0xEF,0x2B,0x6A,0xFE,0xE7,0xB8,
+		0x2E,0x1D,0x61,0xEC,0xDD,0x66,0x22,0xB5,
+		0x07,0x0E,0x87,0x8D,0x6B,0x70,0xBA,0x75,
+		0x2F,0x55,0xDB,0x50,0xEA,0x37,0xD0,0xD2,
+		0x21,0x96,0xFC,0x00,0xC2,0x5A,0x07,0xBB,
+		0x07,0xC5,0x30,0xD6,0x7B,0x9F,0xC7,0x46,
+		0x2E,0x5C,0x6F,0x0B,0x2C,0x9D,0x97,0x86,
+		0x0F,0xC3,0xB6,0x94,0x98,0x38,0x67,0x4E,
+		0x27,0xDC,0x9A,0x2B,0x74,0x50,0x37,0x8F,
+		0x27,0x40,0xF8,0x7F,0x38,0xA1,0x88,0x22,
+		0x21,0xEF,0x32,0x74,0x59,0xAB,0x3E,0xB7,
+		0x07,0xEF,0x73,0xA1,0xE5,0x52,0x6F,0xD9,
+		0x2F,0x3B,0x5C,0xA2,0xFE,0x57,0x71,0x3D,
+		0x27,0x71,0xD6,0xD2,0x6F,0xA1,0x57,0xAF,
+		0x29,0x80,0x58,0xA6,0xC2,0x3B,0x79,0x07,
+		0x07,0x87,0x89,0xB8,0x58,0xC4,0xE1,0xEF,
+		0x2F,0x42,0xC8,0x29,0x21,0x3B,0xA5,0x4D,
+		0x27,0x70,0xBE,0xCB,0x27,0xFF,0xA8,0x32,
+		0x27,0x15,0x20,0x00,0xBE,0x53,0x17,0x3C,
+		0x24,0x74,0x9F,0xCC,0xB8,0x3C,0x0B,0xC0,
+		0x07,0xC3,0x7B,0x30,0x31,0xBD,0xCC,0x71,
+		0x27,0x54,0x84,0x7F,0x44,0x70,0x5C,0xDF,
+		0x2E,0x3C,0x44,0x61,0x84,0x31,0x45,0x33,
+		0x07,0x89,0xF4,0x7C,0xFD,0x29,0xDF,0x6B,
+		0x0F,0xB7,0xC6,0x9A,0xAE,0xA0,0x7F,0xA7,
+		0x07,0xB3,0x2B,0x76,0x10,0x6C,0x4D,0xB5,
+		0x0F,0x4E,0x2D,0xA4,0xBD,0x9B,0x28,0x11,
+		0x27,0xDC,0xE5,0xCA,0xD1,0x38,0x9C,0xED,
+		0x21,0xD0,0x50,0x3E,0xD6,0xEE,0x51,0xD6,
+		0x07,0xC9,0x09,0xEB,0x81,0x08,0xCD,0xD5,
+		0x0F,0x3D,0x95,0xCA,0xD0,0xCB,0xB7,0x1D,
+		0x24,0x85,0x36,0xFE,0x13,0xE2,0xA3,0xB0,
+		0x0F,0x7A,0xEE,0xF6,0x31,0xB3,0xED,0x5A,
+		0x2F,0x08,0xE6,0x8D,0x1A,0x33,0x46,0x6A,
+		0x2A,0x28,0x7C,0x3A,0x09,0x17,0xB9,0xF6,
+		0x0F,0xF6,0x76,0x59,0xB4,0x34,0x85,0x04,
+		0x0F,0x8F,0xF4,0x4D,0x53,0xFE,0xB0,0xAC,
+		0x07,0xB8,0x8B,0x7A,0xFC,0xDA,0xB9,0xB3,
+		0x2F,0xCB,0x49,0x90,0x3E,0x4F,0xB7,0xC2,
+		0x2F,0x96,0x4D,0x2B,0xD0,0xD5,0x0C,0xCD,
+		0x24,0x6C,0x76,0xCB,0xFE,0xAA,0xE8,0x19,
+		0x07,0xC5,0xFA,0x8E,0x11,0x27,0x44,0x7E,
+		0x07,0x23,0x6A,0x88,0x96,0x3C,0x0E,0x99,
+		0x2F,0x88,0xFE,0xD8,0xC3,0xA9,0xFE,0xBF,
+		0x2F,0x1B,0xC0,0xA6,0xAC,0x46,0x26,0xA5,
+		0x27,0x04,0x76,0x3B,0xAD,0x58,0x86,0x97,
+		0x27,0x90,0x32,0xA1,0x0C,0x71,0x6A,0x71,
+		0x2F,0x15,0xC0,0x9F,0xAC,0xF8,0x1D,0x7A,
+		0x2F,0x55,0x31,0x69,0x4F,0x65,0x84,0xC2,
+		0x27,0x71,0x7E,0xBF,0x94,0x3D,0xD9,0x2E,
+		0x27,0x9C,0x0A,0xD7,0x84,0x50,0x49,0x47,
+		0x2A,0xE6,0xB1,0xE9,0x90,0xEA,0xCF,0xE0,
+		0x0F,0xDD,0x1F,0x02,0x0D,0x4D,0x52,0x96,
+		0x2F,0x50,0x33,0x58,0x7F,0xAB,0x25,0xF7,
+		0x2A,0xD6,0x8B,0x4B,0x18,0xEB,0xF0,0x73,
+		0x07,0xC2,0x19,0x96,0x72,0x18,0x83,0xA9,
+		0x27,0x34,0x62,0x63,0x13,0x17,0x0E,0xBA,
+		0x2F,0x23,0x22,0x98,0xC3,0xBB,0x1D,0x7E,
+		0x2F,0x55,0x82,0xC1,0x7A,0x77,0x1F,0xBB,
+		0x2D,0xA2,0x0A,0xF7,0xDF,0xE6,0x39,0xEC,
+		0x07,0xC2,0x9B,0xD4,0x8F,0xFF,0x76,0x3A,
+		0x27,0xDF,0xDC,0xB1,0xAE,0xD2,0x9C,0x8D,
+		0x2F,0x38,0x4E,0x60,0x4B,0xDC,0x4A,0x47,
+		0x27,0x1C,0xDE,0x42,0x96,0x3F,0xD1,0x78,
+		0x2F,0x64,0x3B,0x73,0xCC,0x59,0x5D,0xD6,
+		0x2F,0xB1,0x49,0x96,0xA2,0xC8,0x07,0xE6,
+		0x23,0x42,0x4A,0x75,0x20,0x70,0xBA,0x34,
+		0x07,0x07,0xA9,0xF7,0x72,0xE4,0xF9,0x3B,
+		0x2F,0x8A,0xB3,0x65,0xC7,0x1D,0x21,0xF2,
+		0x27,0xBF,0x6B,0x3F,0x40,0x34,0x35,0x9D,
+		0x27,0xAD,0x1D,0x70,0x70,0xB0,0x4B,0xBD,
+		0x27,0xC8,0xED,0x1A,0x70,0xD9,0x88,0x2E,
+		0x2A,0xC8,0xE2,0x87,0x53,0xD0,0xB3,0xC6,
+		0x07,0x47,0x08,0xAE,0xEE,0x6D,0x5A,0x4F,
+		0x2F,0x34,0x6C,0xF2,0x4E,0x54,0x08,0x05,
+		0x25,0xAC,0xEB,0x95,0x91,0xF4,0x7E,0x30,
+		0x0F,0x41,0xD9,0xB5,0xD3,0x6C,0xAB,0x40,
+		0x2F,0x0C,0xCF,0x3F,0xD8,0x2A,0xEA,0x62,
+		0x2F,0x83,0xC8,0x69,0xF8,0xF4,0x7A,0x3F,
+		0x2F,0x5D,0xBA,0xF4,0x05,0xFD,0x64,0x85,
+		0x22,0x7E,0x70,0x08,0xDF,0xE2,0x65,0x68,
+		0x07,0x3B,0xC2,0xA4,0xDF,0x52,0xFA,0xAD,
+		0x2F,0xE4,0x44,0xDD,0x33,0x8D,0x2C,0x65,
+		0x27,0x9B,0x7A,0xF9,0x6C,0xBF,0x3E,0x6A,
+		0x27,0xE7,0xF2,0xBD,0xC4,0xD7,0x7D,0x72,
+		0x2F,0x06,0x22,0x2F,0x8C,0x99,0x74,0x76,
+		0x27,0x8F,0x7E,0xFE,0x72,0x85,0xCC,0xF2,
+		0x27,0xA7,0x8D,0xFD,0x42,0x8F,0x7A,0xC4,
+		0x21,0x08,0x47,0x9B,0x35,0x0B,0xCB,0x6F,
+		0x0F,0x79,0xC5,0xFD,0x27,0xE5,0xAE,0x6F,
+		0x27,0x75,0x1E,0x56,0x9E,0xB7,0x03,0x35,
+		0x2C,0x6A,0x8B,0x09,0x76,0xA5,0x32,0xF1,
+		0x07,0x58,0xD3,0x55,0x9D,0x35,0x7A,0x2E,
+		0x2F,0x74,0x2B,0xE0,0xFA,0x4C,0xF0,0x94,
+		0x27,0xB9,0xAD,0xA5,0x57,0x6B,0x73,0x85,
+		0x27,0xDF,0xE2,0x48,0x95,0x82,0x06,0x9E,
+		0x21,0x09,0x8F,0x08,0x33,0xD2,0x44,0xAE,
+		0x0F,0x01,0x09,0x0E,0xE8,0xCE,0x55,0xAF,
+		0x2F,0x06,0xC3,0x3C,0x45,0x3D,0x6F,0x47,
+		0x2B,0x78,0x42,0xB5,0xCB,0xFB,0xE9,0xB4,
+		0x0F,0xDC,0x5D,0xCD,0x54,0x5E,0x2A,0x87,
+		0x07,0xDD,0x50,0x14,0xC4,0x10,0x65,0xF9,
+		0x0F,0xCA,0x75,0x48,0xFA,0x62,0x1B,0x5A,
+		0x07,0x46,0x26,0xB8,0x91,0x94,0xC4,0x4D,
+		0x07,0xDB,0xB4,0x18,0x8B,0x72,0xD9,0x29,
+		0x0F,0xBC,0x66,0x4D,0x47,0xD6,0x49,0xEE,
+		0x0F,0x0A,0xA3,0x8C,0x98,0xA7,0xE3,0x53,
+		0x27,0xB5,0x26,0xD7,0x2E,0x6E,0xB4,0x74,
+		0x22,0x3A,0x81,0xF3,0xF2,0xBF,0x01,0x7D,
+		0x07,0xCB,0xF6,0x19,0xDA,0xC8,0x29,0xF0,
+		0x26,0x0C,0x37,0x76,0xA6,0x20,0x6E,0x11,
+		0x07,0x7E,0xE4,0x92,0x02,0x37,0x81,0xB4,
+		0x27,0x02,0x82,0x4D,0xD6,0x53,0x10,0x6C,
+		0x26,0xB7,0x93,0x39,0x03,0x73,0x2D,0xC9,
+		0x0F,0x61,0xA8,0x64,0x31,0xFF,0xA6,0x3B,
+		0x27,0xEF,0x92,0x83,0xB0,0xC9,0x91,0x8A,
+		0x27,0x36,0x10,0x8C,0x0F,0x7B,0xA2,0x6F,
+		0x2C,0x2B,0xBB,0xAC,0xA2,0x2F,0x41,0x7D,
+		0x0F,0x96,0x06,0x2F,0x0E,0x9C,0xE5,0xC4,
+		0x07,0xC7,0x0D,0xA3,0x73,0x83,0x5B,0xFE,
+		0x07,0xCC,0x4A,0x0E,0x31,0x2F,0xA4,0x5E,
+		0x2F,0xBC,0xAA,0x4F,0x6C,0x86,0x20,0x5C,
+		0x27,0xF3,0x9B,0x22,0xFF,0x0C,0x5C,0x77,
+		0x2F,0xA1,0x3E,0x50,0xB8,0x06,0xE3,0x50,
+		0x2F,0x5E,0x79,0xDA,0xA3,0x7B,0xAB,0x3B,
+		0x2F,0xD7,0x17,0x68,0xCD,0x39,0xF4,0x4D,
+		0x2F,0x2C,0xE1,0xF9,0x0B,0x1F,0x77,0xD4,
+		0x2F,0xD0,0x4C,0x8A,0x1F,0x90,0x56,0x31,
+		0x2F,0x60,0x11,0xE1,0x0F,0xD5,0x91,0x8D,
+		0x2F,0x78,0xCF,0xCA,0x9E,0xFF,0x68,0x5C,
+		0x27,0xE5,0x03,0xC2,0x8B,0x5B,0xBE,0xC2,
+		0x27,0xBC,0x12,0x48,0x79,0xDE,0x24,0x2E,
+		0x27,0x6F,0x36,0xA9,0x5E,0xCC,0x2F,0xEE,
+		0x2F,0x57,0x89,0xD4,0x7C,0xCB,0xC2,0xCF,
+		0x27,0x1B,0xCF,0x7E,0x10,0xF0,0xDB,0x1D,
+		0x27,0xC8,0x14,0x51,0x41,0x22,0xCD,0xCE,
+		0x27,0x86,0x90,0xBB,0xA4,0x60,0xB5,0x38,
+		0x2F,0xFC,0x26,0x6D,0x26,0x4F,0x07,0xA5,
+		0x26,0x8B,0xBE,0x3A,0x86,0x4C,0x1E,0xFD,
+		0x07,0xC2,0xA7,0xDE,0x06,0x63,0x17,0xCF,
+		0x27,0x97,0x06,0x66,0x20,0x78,0xBE,0x49,
+		0x2F,0x92,0x39,0x99,0x02,0x45,0x50,0x43,
+		0x22,0x6A,0xAC,0x8E,0x09,0x48,0x5E,0xDE,
+		0x0F,0x4F,0xC4,0xF8,0xAF,0x1E,0x68,0x3D,
+		0x27,0x82,0x99,0x89,0x6F,0x92,0x52,0xFD,
+		0x22,0xEE,0xBD,0xE7,0xBE,0x1B,0x3D,0x93,
+		0x0F,0x11,0x2C,0x9F,0xC0,0x70,0x29,0xD9,
+		0x0F,0xD7,0x2C,0x5C,0x0E,0x47,0xDF,0xFF,
+		0x2F,0x14,0xA3,0xCA,0xE5,0x12,0xFB,0xEA,
+		0x29,0x26,0x89,0x15,0xAE,0xCE,0xD0,0x68,
+		0x0F,0xCF,0x38,0x06,0x11,0xD6,0x88,0x9C,
+		0x2F,0x4A,0x16,0xF0,0xAB,0xF8,0x24,0x6C,
+		0x27,0xD1,0xF4,0xEA,0x80,0x49,0xA5,0x2B,
+		0x27,0x5F,0x4A,0x55,0xB8,0x43,0x5B,0xF5,
+		0x23,0xFE,0x16,0x7A,0x7A,0x8E,0x22,0x9A,
+		0x0F,0xE3,0xE5,0xA4,0xD9,0x3D,0xE5,0xF1,
+		0x2F,0x02,0x3D,0xC8,0x77,0xC0,0xD9,0x36,
+		0x2F,0x36,0x25,0x73,0xBF,0xA0,0x18,0x1C,
+		0x2E,0x10,0x99,0x23,0x6A,0x34,0x59,0xB6,
+		0x07,0x94,0x68,0xA5,0xEB,0xE8,0xFB,0x57,
+		0x26,0x20,0x37,0x97,0x5B,0xF3,0xAD,0x91,
+		0x07,0x34,0xD2,0x2C,0xAC,0xB4,0xF1,0x2D,
+		0x2A,0xC0,0xEF,0x25,0x8C,0xF4,0xBA,0x35,
+		0x0F,0x9B,0x27,0xD8,0x42,0x16,0x2F,0xB3,
+		0x27,0x84,0x62,0x19,0x07,0xB8,0x4A,0xC4,
+		0x27,0x2E,0x24,0x74,0x74,0x5C,0xF6,0xA2,
+		0x2F,0xA8,0x2C,0x00,0x99,0xA9,0xAE,0xB8,
+		0x27,0x51,0x5F,0x89,0x1F,0xC5,0xEB,0xF2,
+		0x2F,0x9F,0x6E,0xFF,0x1C,0xE8,0xD5,0x12,
+		0x2A,0xB5,0xCE,0x4F,0xEE,0x62,0x6B,0x01,
+		0x07,0xF4,0x0E,0x27,0xD7,0xFE,0x60,0x50,
+		0x27,0x6B,0x5F,0x4C,0x13,0x17,0xDB,0x4E,
+		0x07,0x6B,0xA6,0xD6,0x64,0xE6,0x40,0xB4,
+		0x27,0xAB,0xC3,0x98,0xB5,0x90,0x35,0xDA,
+		0x27,0x1D,0xAA,0x49,0x00,0x9D,0x13,0xD4,
+		0x2E,0x48,0x6E,0xFA,0x0A,0xC6,0xF3,0x49,
+		0x07,0xCD,0x91,0x26,0x0E,0x77,0x69,0xEC,
+		0x2F,0x31,0x38,0xCA,0x7F,0x0D,0xB3,0x60,
+		0x27,0xF0,0x6E,0x1B,0xBF,0x2E,0x81,0x8C,
+		0x27,0x49,0xAB,0xBB,0x8E,0x42,0x55,0x44,
+		0x2F,0xB1,0x03,0x87,0x75,0xBC,0x77,0xD5,
+		0x2F,0x5F,0x8F,0x62,0x5E,0xE3,0x89,0xB6,
+		0x2F,0x99,0xFD,0xC3,0x01,0x2D,0xE7,0xB9,
+		0x27,0x7C,0xBF,0xE9,0xBA,0x81,0x97,0xC4,
+		0x2F,0x5A,0x5E,0xB2,0xBD,0x2E,0x82,0xC0,
+		0x27,0xB7,0xC3,0x11,0xAA,0xFB,0x86,0xE4,
+		0x2F,0x60,0x28,0x66,0xA8,0x87,0x56,0xE3,
+		0x27,0xCC,0x5A,0x8F,0x5E,0xF3,0x83,0x1B,
+		0x2F,0xC1,0x82,0x20,0x82,0x1D,0x4C,0x36,
+		0x27,0x00,0x03,0x04,0xC5,0x86,0x5B,0x30,
+		0x2F,0xFA,0xBD,0x6B,0xB8,0xAB,0xDB,0x0C,
+		0x27,0x09,0x03,0xBC,0xED,0xBC,0xBD,0xF7,
+		0x2F,0xE2,0xBA,0xD1,0x90,0x52,0xFB,0xD3,
+		0x2F,0x5F,0x84,0x71,0x32,0x2C,0xDC,0xE4,
+		0x27,0xA1,0x2A,0x6E,0xEF,0x09,0x67,0xC7,
+		0x2F,0x64,0x7E,0xCC,0x3B,0xDF,0x85,0xCC,
+		0x2F,0x2C,0x9C,0xC8,0xEE,0x7E,0xB9,0x16,
+		0x2F,0x20,0xFF,0x70,0x65,0xC5,0x2E,0x72,
+		0x2F,0x86,0x13,0x7B,0xCB,0x99,0xE2,0x21,
+		0x2B,0xF8,0x5A,0x7E,0x9B,0x61,0xCF,0x56,
+		0x07,0x2C,0x23,0xE2,0x86,0x26,0x20,0x6C,
+		0x2F,0x5A,0x6B,0x8E,0xA6,0x99,0x79,0xAC,
+		0x2F,0x6B,0x5D,0x84,0x10,0xF8,0x1A,0x10,
+		0x27,0x6D,0xA8,0x8D,0x49,0x1B,0x71,0x06,
+		0x27,0x2E,0x4C,0xA2,0xAC,0x10,0xD5,0x44,
+		0x2F,0xF0,0xFF,0x21,0x4B,0x36,0x47,0xAE,
+		0x2F,0xFF,0x33,0x5F,0x59,0xF4,0xB9,0x00,
+		0x27,0x1F,0x4D,0x9B,0x07,0x13,0x85,0x73,
+		0x27,0x95,0x8E,0xA3,0x6E,0x1E,0x83,0x78,
+		0x27,0xB7,0xF7,0x33,0x2E,0xE0,0x0E,0x8A,
+		0x27,0xB9,0xBB,0xA8,0xE3,0x9F,0xE4,0xB8,
+		0x2F,0x1D,0x2A,0xFF,0x63,0x32,0x54,0xDA,
+		0x2F,0x3B,0x50,0x74,0x42,0x35,0x60,0x9A,
+		0x2F,0xEC,0xF8,0x4D,0xC2,0x9B,0x46,0x77,
+		0x2F,0x68,0x74,0xF7,0xD6,0x10,0x92,0x27,
+		0x2F,0x18,0x72,0xBF,0x52,0x4C,0x6E,0xB4,
+		0x2F,0x1C,0xE9,0x82,0x82,0x56,0x48,0xAE,
+		0x27,0xE2,0xC1,0xB4,0x76,0x9E,0x0F,0x16,
+		0x2F,0x61,0x36,0x92,0x14,0x1E,0x8B,0x4E,
+		0x2F,0xE9,0x70,0xBA,0xB2,0x9D,0x93,0x4F,
+		0x29,0x5D,0xD7,0x3C,0x6C,0xF1,0xDF,0x3E,
+		0x07,0xEC,0xAE,0xF0,0x46,0x07,0x9D,0xF8,
+		0x27,0x84,0xE6,0x80,0x83,0xCA,0x1D,0x73,
+		0x2D,0x22,0x93,0x89,0x54,0xCE,0xF0,0xC8,
+		0x0F,0x46,0x7B,0x6A,0x3C,0x40,0xCE,0x1E,
+		0x27,0x8C,0x25,0xE5,0x9B,0x12,0x2C,0x07,
+		0x2F,0xE6,0x74,0xBE,0xD2,0x28,0xAE,0xD3,
+		0x2F,0xB2,0xEB,0xDF,0xC9,0x59,0xC0,0x03,
+		0x27,0x1D,0x1F,0x95,0x1F,0x5E,0xA6,0x15,
+		0x2B,0x32,0x13,0xCD,0x8F,0xC8,0x77,0x61,
+		0x0F,0xD6,0x5B,0x3A,0x6E,0xF3,0x60,0xDA,
+		0x2F,0x0C,0x9A,0x06,0x4B,0x4B,0x1F,0x87,
+		0x22,0xD1,0x0B,0x11,0x16,0x8C,0xA4,0xFD,
+		0x07,0x8F,0x8A,0xFB,0x7D,0x94,0xAC,0xFE,
+		0x2A,0xC1,0x1C,0x44,0xEB,0xE6,0x1F,0x60,
+		0x0F,0xBB,0xB0,0xB4,0x83,0x61,0x4D,0xE6,
+		0x27,0x28,0xA9,0xB8,0xF6,0xA8,0xCD,0x43,
+		0x27,0x89,0xAA,0x8B,0x29,0x8A,0x7A,0x4D,
+		0x2F,0xB1,0x0B,0x76,0xA1,0x33,0x87,0x99,
+		0x27,0x0B,0xD9,0x56,0x14,0x2E,0x10,0xEC,
+		0x27,0xED,0x2E,0x28,0xD1,0x51,0x67,0x38,
+		0x27,0xEB,0xA2,0xBF,0xC8,0x6C,0x2B,0xAD,
+		0x2F,0x68,0x26,0x16,0xFE,0xDD,0x74,0xFA,
+		0x27,0x88,0xC5,0x35,0x9E,0x2D,0x1D,0x30,
+		0x2F,0xAC,0xED,0x64,0x43,0x23,0x05,0x79,
+		0x27,0x57,0x0B,0x26,0x32,0xFC,0x83,0x2D,
+		0x2F,0xBC,0x7F,0x66,0x05,0xCB,0x6C,0xCC,
+		0x2F,0xEC,0xDD,0x1E,0x44,0x3E,0x20,0x1E,
+		0x2F,0x21,0x64,0x7D,0xEC,0xDB,0xA4,0x76,
+		0x2F,0x58,0x18,0xA2,0xB6,0xA8,0x2B,0x33,
+		0x24,0xB2,0x6A,0x10,0xA7,0xDD,0x6F,0xB4,
+		0x07,0x0B,0x54,0xE7,0x88,0xCC,0x20,0x6B,
+		0x2F,0x65,0x91,0xAD,0xD9,0xB3,0x19,0x51,
+		0x29,0xE1,0x74,0x79,0xE1,0xF7,0xB2,0x98,
+		0x0F,0x16,0xAD,0x9C,0xBC,0x51,0x5B,0xDE,
+		0x2F,0x43,0x4C,0x92,0x39,0x2D,0x33,0x55,
+		0x2B,0x7A,0x65,0xF8,0x5E,0x67,0x86,0x32,
+		0x07,0x9F,0x96,0xFC,0x28,0xD1,0x20,0xA5,
+		0x0F,0x7B,0xFD,0x4C,0x75,0xD8,0x69,0x9F,
+		0x27,0x38,0x8A,0x4D,0xD6,0x50,0xBB,0xA5,
+		0x2C,0xD6,0x5F,0x8E,0xEA,0xB3,0x67,0x68,
+		0x07,0x86,0x77,0xD3,0x65,0xF9,0x3A,0xD9,
+		0x27,0x00,0x0E,0x3F,0x45,0x48,0x20,0xFD,
+		0x29,0x9C,0x6A,0xEC,0x96,0xAE,0x32,0x51,
+		0x07,0x3B,0xF0,0x38,0xE7,0xBB,0x06,0x07,
+		0x2F,0x16,0x10,0x2F,0x3F,0x5B,0xA5,0x82,
+		0x2E,0x5D,0xDF,0x02,0x7C,0x30,0x5B,0xFD,
+		0x0F,0x41,0x93,0xA5,0xD2,0xD8,0x32,0x28,
+		0x2F,0xA0,0xBC,0x6D,0x47,0x12,0x41,0x53,
+		0x0F,0x59,0x00,0xB0,0xF8,0xE0,0x59,0x2B,
+		0x2F,0x95,0x18,0xBF,0xDA,0xFF,0xBF,0x26,
+		0x24,0x94,0x29,0xA6,0x5C,0xA9,0x6E,0x85,
+		0x0F,0xC6,0xD5,0x71,0x62,0xAE,0xF4,0xF8,
+		0x07,0xF2,0x12,0x15,0xB3,0x84,0x5B,0x53,
+		0x0F,0x8D,0xF3,0x42,0xE8,0xEE,0xB4,0xB1,
+		0x27,0x62,0x1A,0x8C,0xF2,0xD0,0xF9,0x35,
+		0x27,0xC3,0x49,0x39,0xBA,0xEF,0x7D,0xD5,
+		0x2F,0x96,0x8F,0x22,0xCB,0x19,0x08,0x76,
+		0x2F,0x58,0x37,0xBD,0x96,0x3A,0x0B,0xBF,
+		0x2F,0xC2,0x57,0xA1,0x5E,0xB5,0x6B,0xFC,
+		0x2C,0xE0,0x77,0x20,0xE6,0x93,0xDE,0x89,
+		0x07,0x0E,0x3C,0xD9,0xA8,0x0C,0x0E,0xEE,
+		0x27,0x1A,0xFF,0xAB,0x16,0xCE,0xE9,0x4D,
+		0x0F,0x5E,0x49,0xA5,0x70,0x6B,0x74,0x98,
+		0x0F,0xD8,0x35,0xB2,0x21,0xC8,0xAA,0x75,
+		0x27,0xFF,0xC2,0x41,0xED,0x83,0xE3,0x63,
+		0x2F,0x0C,0x8F,0x40,0x81,0x22,0x31,0x47,
+		0x2F,0x00,0x41,0xEB,0x9F,0x99,0x32,0x2E,
+		0x27,0xA0,0x44,0x11,0xAF,0xE0,0x03,0xAD,
+		0x2F,0xE6,0x17,0x58,0x9E,0xD9,0x9B,0x6E,
+		0x25,0xA0,0x8D,0xF0,0x8A,0x48,0x5B,0xBD,
+		0x0F,0x83,0xA9,0xE1,0xDC,0x46,0x62,0x86,
+		0x0F,0xA8,0xAB,0xF2,0x07,0xBB,0x87,0xA6,
+		0x07,0x1B,0xAF,0x1E,0xCC,0xD2,0x34,0x5D,
+		0x27,0x34,0xD3,0x5A,0xC7,0x6A,0x40,0x4E,
+		0x27,0x65,0x3D,0xF2,0xA4,0xEA,0x4C,0xFB,
+		0x07,0x18,0xAE,0xE6,0x58,0xE3,0xF9,0xD4,
+		0x27,0x13,0x1B,0x85,0x8C,0xF1,0xC1,0x9C,
+		0x22,0xBF,0xF7,0xB8,0x53,0xE8,0x97,0xCF,
+		0x07,0x4B,0xE5,0xA0,0x84,0x67,0xA8,0xA1,
+		0x2F,0x84,0xD2,0x6E,0x57,0x23,0x89,0x3E,
+		0x2F,0x19,0xE5,0xB7,0xF0,0xB6,0x36,0x3C,
+		0x27,0xD2,0x97,0x3F,0x47,0x74,0xF0,0x13,
+		0x22,0xA8,0xEA,0x8E,0x31,0xA4,0xF4,0xA5,
+		0x07,0x4D,0x6E,0x59,0x3E,0x99,0x31,0x3D,
+		0x07,0x37,0x6F,0x83,0x06,0x76,0xC1,0x44,
+		0x07,0x67,0x2B,0x91,0x3D,0xC7,0x1A,0xE5,
+		0x27,0xBC,0xBC,0x76,0xA0,0x3D,0x6F,0x69,
+		0x2F,0x41,0xBF,0xC7,0xB5,0x1E,0x13,0x0D,
+		0x07,0xC8,0x82,0xA0,0xFD,0xE8,0xD1,0xF1,
+		0x0F,0x8F,0x3C,0x44,0xD0,0x6B,0xD9,0xAE,
+		0x2F,0xA7,0x21,0x1E,0xDE,0x3F,0x3A,0x74,
+		0x27,0x79,0xBD,0x5C,0xAC,0xDC,0x44,0xDF,
+		0x27,0x89,0x5A,0xC9,0x99,0xBE,0x07,0xF8,
+		0x2A,0x9B,0x11,0x8D,0xCD,0x9B,0x99,0x82,
+		0x07,0x5D,0xFE,0xC5,0xF0,0x36,0xB5,0x2B,
+		0x2F,0x82,0x40,0xA3,0xED,0x4F,0x2E,0xA1,
+		0x2F,0x83,0xDC,0xB0,0x88,0xAC,0x15,0x2C,
+		0x27,0xAF,0x43,0x4A,0x42,0x9F,0x5A,0x50,
+		0x2A,0xE6,0x3F,0x0E,0x35,0xA5,0xFC,0x28,
+		0x0F,0xF0,0x2B,0x7A,0x3D,0x4E,0xC8,0x8A,
+		0x27,0x1D,0x72,0xD7,0x9A,0x40,0x98,0xEA,
+		0x27,0x3D,0x1F,0xA8,0xD6,0xC4,0x03,0x88,
+		0x27,0x4F,0x48,0xE9,0x82,0x03,0x57,0x19,
+		0x29,0x4E,0xC4,0xE2,0x9B,0x96,0x18,0x06,
+		0x07,0x1E,0xDE,0x8C,0xD9,0xF5,0xB6,0x48,
+		0x2D,0x46,0x36,0xCD,0xDB,0x96,0x2D,0x6E,
+		0x07,0xB6,0xF1,0x40,0xE9,0x23,0x71,0xAE,
+		0x07,0x52,0x9C,0x83,0x0E,0x8D,0x47,0x40,
+		0x07,0x71,0x98,0x49,0xD6,0xF1,0x88,0x51,
+		0x07,0x1F,0x22,0x63,0x56,0x41,0xCD,0x4C,
+		0x2F,0xA3,0xF3,0x02,0xF0,0x87,0xF3,0x05,
+		0x2F,0xFD,0x4A,0x64,0x4C,0xA5,0x55,0x19,
+		0x27,0xB0,0x8B,0x10,0x5F,0x65,0x68,0xC2,
+		0x27,0xB3,0x21,0x8B,0xCB,0xF4,0xE3,0x0E,
+		0x27,0x47,0x75,0x5E,0xB7,0x1E,0x9F,0xF8,
+		0x2E,0x01,0xC9,0x0F,0x26,0xB7,0xA6,0x9C,
+		0x07,0x0B,0xAD,0x07,0xA6,0xF6,0xC3,0xAD,
+		0x22,0x19,0xB7,0x88,0x85,0x95,0x44,0x10,
+		0x0F,0x5C,0xFD,0xCB,0x1B,0x66,0xCD,0xA7,
+		0x07,0x42,0xAD,0xC2,0xD3,0xE6,0xE0,0x9D,
+		0x07,0xA0,0x9B,0x44,0x03,0x54,0xAB,0x1C,
+		0x07,0x55,0x55,0x65,0x32,0x9D,0xC9,0xF4,
+		0x27,0x33,0xE4,0xED,0x63,0xFF,0x61,0x6D,
+		0x2A,0xB9,0x32,0x31,0x75,0x20,0xAE,0x1E,
+		0x0F,0xBB,0xEF,0xCE,0xAF,0x23,0x79,0xEB,
+		0x2B,0x6B,0xA3,0xF8,0xAB,0x35,0x49,0xA2,
+		0x0F,0x42,0xEA,0x72,0x5B,0xC0,0x65,0xA6,
+		0x25,0xDA,0x6C,0x31,0x6B,0xC2,0x60,0x92,
+		0x07,0xA5,0xCE,0x5C,0xB1,0xD7,0x95,0x2E,
+		0x27,0x41,0xCC,0x30,0x61,0x48,0xB0,0xBB,
+		0x2F,0xD7,0x5A,0x16,0x0D,0xAD,0x83,0xD1,
+		0x2F,0x53,0x85,0x0B,0x54,0x37,0xB5,0x9D,
+		0x27,0x47,0xA2,0xF5,0x48,0x09,0x1F,0x4F,
+		0x2F,0xA4,0xCE,0x27,0xA1,0x67,0x49,0x06,
+		0x27,0x8B,0x3B,0x0D,0x36,0x51,0x5F,0xB4,
+		0x27,0x71,0xE4,0xCE,0x7E,0x2D,0xAF,0x84,
+		0x2D,0x17,0x74,0x8D,0x47,0x11,0x60,0x77,
+		0x0F,0xAC,0xED,0x36,0x16,0x91,0x86,0x1A,
+		0x27,0x2F,0x1F,0x4B,0x91,0x40,0xD0,0xA8,
+		0x2F,0xD9,0x65,0x9F,0x4F,0x07,0x34,0xD8,
+		0x2F,0x0B,0xDA,0x25,0x46,0xC4,0xC0,0x8D,
+		0x27,0x86,0xBE,0x26,0x4F,0xD0,0xB4,0x3C,
+		0x29,0x05,0xE4,0x55,0x9E,0x2F,0xEE,0x12,
+		0x07,0xD1,0x35,0xBC,0x90,0x8C,0x89,0x96,
+		0x0F,0x82,0xA3,0xCE,0x30,0xFE,0x3B,0x84,
+		0x0F,0xC3,0x13,0x33,0xBB,0x0D,0x43,0x84,
+		0x07,0xE9,0x69,0xD1,0xCA,0xF5,0x56,0xD7,
+		0x0F,0x60,0x19,0xE8,0x41,0xE2,0xA3,0x70,
+		0x27,0xBE,0xD8,0x29,0x29,0x9B,0x63,0x4B,
+		0x2F,0xA0,0x91,0xD7,0x54,0xC8,0x4A,0xB9,
+		0x07,0x4C,0x89,0x15,0x1C,0x20,0x25,0x8A,
+		0x07,0xA4,0x4F,0x42,0x59,0xC1,0x58,0x6B,
+		0x07,0x41,0x62,0x28,0x73,0x87,0xEF,0x5A,
+		0x27,0x42,0x72,0x1C,0xE3,0xBA,0xFB,0x27,
+		0x2F,0x83,0x5C,0x8D,0x3F,0x2B,0xC7,0xF2,
+		0x2F,0x0C,0xBB,0x85,0x96,0x1A,0xCF,0x3B,
+		0x27,0xE1,0xB8,0x39,0xFE,0x30,0xDC,0x68,
+		0x27,0xBD,0x90,0x8E,0x94,0x78,0xEA,0x6C,
+		0x2F,0x9A,0xFE,0x85,0x9D,0xF2,0xC6,0x2D,
+		0x27,0x71,0x36,0xFF,0x15,0x75,0x4A,0x36,
+		0x27,0xDC,0x70,0x3C,0xAF,0xFD,0x6E,0x54,
+		0x27,0x96,0x07,0x2E,0x50,0x9E,0xE5,0xFE,
+		0x2F,0xBC,0x7E,0xCB,0x7B,0xB8,0xA9,0x9A,
+		0x2F,0x26,0x82,0x68,0x6A,0x82,0xF7,0xD9,
+		0x27,0x02,0xD5,0x79,0x01,0xE0,0x97,0x13,
+		0x27,0xC8,0xFD,0x78,0xB3,0xF2,0xF2,0xDB,
+		0x2F,0x09,0x03,0x67,0x8E,0xB7,0x9F,0x15,
+		0x2F,0xCD,0xD1,0xCC,0x36,0x2D,0xDD,0xB1,
+		0x27,0x3E,0x42,0xC2,0xB4,0xEE,0x8B,0xEC,
+		0x2F,0x08,0x87,0x07,0x03,0xC7,0xFF,0x84,
+		0x27,0xBC,0x71,0x93,0xD9,0xAB,0xC6,0xE4,
+		0x2F,0x84,0x15,0xA1,0xF0,0x46,0xAA,0xB1,
+		0x2F,0xDD,0x3D,0xDB,0xDC,0x70,0x2E,0xDE,
+		0x2F,0x28,0x3A,0x17,0x2A,0xE1,0xCB,0x60,
+		0x27,0x61,0x3C,0xCF,0x2F,0x21,0xD7,0x96,
+		0x2F,0xB9,0x56,0x60,0xCF,0x0B,0xF2,0xCB,
+		0x07,0xD3,0xA6,0xF9,0xCC,0xDD,0xC5,0xAC,
+		0x07,0xC7,0xA6,0x5F,0x5D,0x32,0xBE,0x91,
+		0x27,0x55,0x54,0x1F,0x91,0x85,0x76,0xFF,
+		0x27,0xB2,0x9F,0x8F,0x9D,0x71,0xBA,0x9E,
+		0x27,0xAF,0x0D,0xCE,0x7C,0xA9,0x83,0xD3,
+		0x27,0x1D,0x1B,0x81,0x60,0x1A,0xEE,0x9A,
+		0x2F,0xF4,0x4C,0x29,0xE2,0x22,0x4A,0x6E,
+		0x27,0x52,0x8C,0xFE,0xE7,0x98,0xF7,0xF6,
+		0x24,0x06,0xB4,0xDA,0x51,0x87,0x8F,0x43,
+		0x07,0xA6,0x4C,0xB5,0x78,0xE0,0x9D,0xB8,
+		0x27,0xAC,0x24,0x74,0x88,0xF0,0x02,0x73,
+		0x2F,0x51,0xD3,0x63,0x2E,0xC0,0xC8,0x8F,
+		0x27,0x5E,0xB1,0x90,0xA6,0x9E,0xA1,0xD6,
+		0x27,0x5F,0x8F,0xBD,0xEC,0x2F,0xDE,0x6F,
+		0x27,0x40,0x46,0x2C,0xED,0x29,0xD8,0xC7,
+		0x2F,0x8C,0x53,0xE4,0x5E,0xC9,0xD6,0x62,
+		0x2F,0x7B,0x5A,0x08,0x67,0x80,0x4B,0x17,
+		0x2F,0x31,0x21,0x06,0x58,0x3E,0xC4,0x35,
+		0x2F,0x5F,0xCB,0x13,0xB6,0xBD,0x89,0xAE,
+		0x23,0xAA,0x75,0xDC,0x5B,0xBA,0xC4,0x63,
+		0x07,0x6C,0xE8,0x2F,0x00,0xD6,0x14,0x74,
+		0x2F,0x65,0x42,0x40,0x55,0x36,0x8C,0x79,
+		0x2F,0xA2,0x2F,0x2F,0xDD,0xB7,0x4C,0x91,
+		0x2A,0x20,0xF1,0xE9,0xAC,0xE1,0xE5,0xA2,
+		0x07,0x1D,0xBD,0x68,0x65,0xE7,0xFE,0x54,
+		0x05,0xC9,0x72,0xB8,0x85,0x42,0x17,0x93,
+		0x2D,0xB8,0xAD,0xAF,0x93,0x9B,0xE6,0x65,
+		0x0F,0xEC,0x5A,0x0A,0x08,0x3B,0x38,0xFD,
+		0x27,0x33,0x56,0xB5,0xEA,0xE5,0xC8,0x12,
+		0x2F,0x42,0x93,0x5C,0xDB,0x0C,0xFC,0x87,
+		0x27,0xA3,0x46,0xED,0x25,0x93,0xF3,0xA8,
+		0x27,0x25,0xEB,0x58,0xD1,0x38,0xEF,0x48,
+		0x2F,0x19,0xCA,0x26,0x15,0x60,0x73,0x6E,
+		0x27,0x5C,0x7A,0x54,0xC3,0x92,0xD2,0x7C,
+		0x27,0x6F,0x36,0xE1,0xD4,0xCB,0xF0,0xA0,
+		0x27,0xE6,0x68,0xB3,0x8C,0x1F,0x09,0x7F,
+		0x27,0x5B,0xAD,0x4B,0x1E,0x90,0x18,0x8F,
+		0x27,0xDE,0xD8,0x4A,0x0C,0xCC,0xBF,0x78,
+		0x2F,0x4A,0x8B,0xB9,0xA4,0xCD,0x5F,0xF9,
+		0x2F,0x8F,0x4F,0x37,0x5E,0x02,0x50,0xFF,
+		0x2F,0xF3,0xE6,0xC6,0xA9,0x6D,0xB4,0xBE,
+		0x2F,0x54,0x13,0x9A,0x7E,0xB1,0xDF,0xC9,
+		0x2F,0x32,0xAA,0x5A,0x88,0x86,0x1F,0x17,
+		0x27,0x71,0xD5,0xB8,0x42,0xF1,0xAC,0xB0,
+		0x2F,0x50,0x9B,0x8F,0x99,0xBD,0x15,0x70,
+		0x2F,0xBA,0x18,0xE8,0x71,0xCA,0x51,0xA2,
+		0x27,0xE2,0xF7,0xB5,0xF7,0x45,0x23,0x97,
+		0x2F,0x7E,0xC7,0x5C,0x9F,0x8A,0x25,0x40,
+		0x27,0x15,0xE2,0x81,0x05,0x2D,0x46,0xD6,
+		0x27,0x44,0xAD,0xA0,0xDB,0x83,0x83,0x2F,
+		0x27,0xD8,0x41,0x1C,0x3B,0xBE,0xF9,0x9B,
+		0x27,0xB5,0x16,0xEC,0x2E,0x29,0x5E,0x08,
+		0x2F,0x40,0x96,0x7A,0xD8,0x95,0xE6,0xC0,
+		0x27,0x38,0xE7,0xFE,0x9C,0xC9,0x57,0x26,
+		0x27,0x97,0x19,0x8B,0x8E,0x54,0x3F,0xBB,
+		0x27,0x4E,0x18,0xB4,0xE0,0x60,0x11,0x9B,
+		0x2F,0x67,0xF4,0xFE,0xE7,0x03,0xBD,0x19,
+		0x2F,0x4D,0x78,0x06,0xBC,0xD3,0xC4,0x11,
+		0x27,0x34,0xF0,0x24,0x88,0x9D,0x5A,0xCB,
+		0x2F,0xEF,0xD7,0x93,0x32,0xE1,0x18,0x07,
+		0x27,0x87,0xAF,0x51,0x01,0xE1,0x95,0x7C,
+		0x27,0x4A,0xE1,0x39,0xDC,0xF9,0xF0,0xC8,
+		0x27,0x18,0x65,0x5C,0x1A,0xA4,0x8C,0x5B,
+		0x2F,0xE4,0xE2,0xD2,0xC4,0xF5,0x9E,0x58,
+		0x23,0x3F,0x4E,0x68,0xD8,0x35,0xC9,0x90,
+		0x27,0x3D,0x43,0x65,0xEE,0xA7,0xD2,0x8C,
+		0x2F,0x1E,0x50,0x2C,0x54,0x0D,0x8A,0xEA,
+		0x27,0xE5,0xE8,0xCE,0xC4,0x56,0xF3,0xF2,
+		0x27,0x51,0x42,0xB0,0x9D,0x96,0xFC,0x3E,
+		0x2F,0x2F,0xAA,0x4E,0xA0,0xF6,0x4B,0xD3,
+		0x2F,0x7D,0xE9,0x47,0x60,0x63,0xC9,0x21,
+		0x27,0x36,0x31,0xAB,0x7A,0x89,0xA4,0x51,
+		0x2F,0xC9,0x16,0x05,0x9D,0x0E,0xEB,0xC7,
+		0x2F,0x4C,0x14,0x23,0x1E,0x8E,0x76,0x4F,
+		0x2F,0x01,0x71,0xA1,0xFE,0x88,0xCD,0x3B,
+		0x27,0x2C,0x71,0xAA,0x8F,0xCA,0x71,0x20,
+		0x27,0xB9,0x5E,0x57,0xED,0x5F,0xBF,0x93,
+		0x2F,0x33,0xB1,0xFF,0x1C,0xDA,0x6F,0x7A,
+		0x2F,0x4A,0xC1,0x9E,0x84,0x87,0xB5,0x32,
+		0x2F,0x4E,0xF8,0x25,0xDF,0x69,0xCA,0xAF,
+		0x27,0x05,0x75,0x0F,0xDC,0xD3,0xD7,0x18,
+		0x2F,0x37,0xCA,0x47,0xD8,0x9E,0xD3,0xAD,
+		0x27,0x73,0xCE,0x0C,0xEC,0xF9,0xAC,0x79,
+		0x27,0x1E,0x02,0xB1,0x21,0xF3,0xC0,0xFA,
+		0x2F,0xCA,0x6E,0x29,0x6D,0xD1,0xD3,0xB6,
+		0x27,0x7B,0x0B,0x11,0x9E,0xED,0x8F,0x02,
+		0x27,0xD5,0x29,0x1A,0xE3,0xB7,0x7C,0x47,
+		0x2F,0xC7,0x5D,0x86,0x7E,0xDC,0xB4,0x09,
+		0x2F,0x29,0x08,0xC0,0x57,0x17,0x2F,0x3A,
+		0x2F,0x0B,0x14,0xCB,0xB5,0xF7,0xC2,0xA2,
+		0x2F,0x20,0x17,0x0A,0x80,0x98,0x56,0xBB,
+		0x2F,0xA6,0x1A,0x8E,0x43,0xCA,0x20,0xE7,
+		0x2F,0xE5,0xCE,0xA7,0xC3,0xA6,0x74,0xFC,
+		0x27,0x4B,0xF2,0x16,0x88,0xA3,0x67,0xCE,
+		0x2F,0xD6,0x0C,0xC7,0x39,0x88,0x87,0xBB,
+		0x27,0x57,0x64,0xCF,0xDD,0x45,0x69,0x1E,
+		0x27,0xE2,0xF5,0x2F,0x79,0x58,0x4B,0x95,
+		0x27,0xD9,0x6A,0x7A,0x05,0x11,0x68,0x6E,
+		0x27,0xDF,0x9B,0xDF,0xD8,0x89,0xDF,0x7B,
+		0x27,0x55,0x47,0xA4,0x4D,0x1C,0xBD,0xC9,
+		0x27,0x43,0x0A,0x75,0xC3,0xF9,0x59,0xBD,
+		0x2B,0x30,0x1A,0x70,0x07,0xD7,0x3D,0xA5,
+		0x27,0x84,0xA2,0x33,0xBC,0xE1,0x70,0x75,
+		0x27,0x79,0x87,0xD8,0x4F,0x3F,0xEB,0x8C,
+		0x27,0x76,0xCA,0xD2,0xA2,0x3B,0x35,0xD3,
+		0x27,0x2D,0x06,0x13,0x76,0x7E,0xE3,0x57,
+		0x27,0x90,0x99,0xE9,0x06,0x2A,0x71,0xF6,
+		0x2F,0x70,0xB5,0x04,0x80,0x4B,0x07,0xCF,
+		0x22,0x77,0x70,0x3F,0x96,0x4A,0x08,0xB7,
+		0x07,0x6E,0x62,0xBA,0x1E,0x92,0xA1,0xE6,
+		0x2F,0x31,0xB6,0x1D,0x0F,0x07,0x49,0x1B,
+		0x2A,0xBC,0x52,0x35,0xAF,0x0E,0x17,0xE7,
+		0x07,0x03,0xEB,0x38,0x38,0xBB,0x5B,0x08,
+		0x26,0x2C,0x1F,0xEA,0x14,0xEB,0xB0,0x07,
+		0x07,0xA6,0xAA,0x2C,0x3F,0x9C,0x1A,0x5C,
+		0x07,0x7D,0x4F,0xDC,0x14,0x19,0x66,0x48,
+		0x27,0xA3,0x39,0x90,0xE1,0xEE,0x81,0x90,
+		0x21,0x73,0x87,0x44,0x11,0x85,0x49,0x25,
+		0x0F,0xBA,0xAF,0x40,0x4D,0x9E,0x10,0x0F,
+		0x27,0x90,0x52,0x55,0x09,0x8E,0x4A,0x5F,
+		0x21,0xAA,0x3B,0x01,0xE8,0xC6,0x5E,0xDC,
+		0x0F,0xC2,0xA5,0x37,0x21,0x06,0x94,0x69,
+		0x0F,0x5F,0xCD,0x94,0xDB,0xF0,0x21,0x4C,
+		0x27,0x69,0x34,0x86,0x82,0x8F,0xBD,0xB1,
+		0x29,0x37,0xD2,0x8E,0x66,0x28,0x38,0x1A,
+		0x0F,0x77,0xE4,0x2D,0xCC,0x34,0x01,0xC8,
+		0x0F,0xC0,0x3A,0x74,0x78,0xC3,0x33,0xA9,
+		0x2F,0x8D,0xB3,0x1D,0x0C,0x57,0xC2,0x5D,
+		0x29,0x8E,0xC2,0xB5,0x31,0x34,0x12,0xB5,
+		0x07,0x38,0xD7,0xF8,0x38,0x3A,0x6E,0xF0,
+		0x27,0x8D,0x74,0xA2,0x55,0x38,0x5A,0xB9,
+		0x29,0x21,0x4B,0x99,0xE7,0xFF,0xE2,0xCB,
+		0x0F,0xA9,0xA2,0x82,0xC3,0xF1,0x07,0x74,
+		0x27,0x98,0x2A,0xD3,0xE3,0x5E,0x22,0x98,
+		0x21,0x0A,0x00,0x1A,0x44,0x72,0x8B,0x05,
+		0x07,0xEA,0xEE,0xFA,0x3F,0xD3,0x17,0xBA,
+		0x27,0xB1,0x89,0x44,0xB3,0x5F,0x88,0x5D,
+		0x29,0x03,0x37,0x09,0x99,0xEC,0x8E,0xA0,
+		0x07,0x38,0xE2,0x39,0x11,0x4C,0x80,0x2E,
+		0x27,0x98,0x4E,0x18,0x70,0xA0,0x6E,0x8D,
+		0x2A,0x24,0x82,0x6D,0xC9,0x5A,0x67,0x4D,
+		0x07,0x34,0xAA,0x51,0xB5,0x4F,0x3C,0xE4,
+		0x27,0x28,0xFD,0x15,0xFC,0x45,0x8A,0x03,
+		0x21,0xE7,0x0E,0xD4,0x7B,0xDE,0x72,0x94,
+		0x07,0xB6,0xE8,0xBD,0x35,0x8B,0x1B,0x64,
+		0x2F,0x27,0x42,0x9B,0x7B,0xFA,0x51,0x1A,
+		0x2A,0x5F,0x58,0xE1,0x84,0xB9,0x69,0xC3,
+		0x0F,0xE2,0x1C,0xE3,0xB5,0xFD,0xEA,0xF3,
+		0x27,0x6C,0x54,0x14,0x6B,0x39,0xEA,0xDC,
+		0x22,0xA5,0xB0,0xBF,0x99,0xD7,0xBA,0x84,
+		0x0F,0x13,0x40,0x0F,0x79,0x46,0xAD,0x4A,
+		0x27,0xFD,0xF1,0xED,0x39,0x93,0x95,0xCE,
+		0x22,0xAF,0xC3,0x8F,0x60,0xD7,0xB2,0x58,
+		0x07,0x86,0xE6,0x0E,0x7C,0x1F,0x0B,0x80,
+		0x27,0x05,0x0B,0xBA,0xDA,0xD9,0x03,0x13,
+		0x2B,0x9F,0x2D,0x9E,0xC0,0x46,0x4C,0x59,
+		0x07,0x6E,0x77,0x67,0x4C,0xAA,0xDE,0xBA,
+		0x2F,0x24,0x45,0x78,0x63,0x12,0x6D,0x25,
+		0x07,0x61,0x67,0x20,0xCE,0xA3,0xCC,0x1E,
+		0x2F,0x92,0xCE,0x1A,0x19,0x01,0x9D,0x19,
+		0x23,0xDD,0xF4,0x07,0x66,0x58,0xC2,0x12,
+		0x07,0x90,0x94,0x02,0x67,0xAE,0x89,0xE6,
+		0x2F,0x05,0xEF,0x23,0x1E,0x45,0x73,0xD9,
+		0x22,0x55,0x57,0xAD,0xA0,0xEF,0x2C,0x65,
+		0x0F,0x6B,0x35,0x28,0xBA,0xD8,0xA3,0x78,
+		0x27,0xAF,0x24,0x92,0x35,0x57,0xA6,0x1A,
+		0x22,0x81,0xB3,0x5D,0x1F,0x8C,0x94,0x00,
+		0x07,0xE0,0xFF,0x89,0x43,0xB1,0x05,0x4C,
+		0x27,0x92,0x16,0xFB,0x7E,0xE0,0xC4,0x6D,
+		0x29,0xA9,0x2D,0x73,0xEB,0xD7,0x2E,0xC1,
+		0x07,0x4D,0x86,0x93,0xF8,0xAD,0xAC,0x8C,
+		0x2F,0xE7,0x47,0xDA,0xE6,0x47,0xEA,0xC8,
+		0x2A,0x4A,0x0B,0xA4,0xF8,0x15,0x9A,0x70,
+		0x07,0x96,0xB7,0x90,0x05,0x25,0xFE,0xFA,
+		0x27,0x7C,0xB1,0xF3,0x81,0x6D,0xCA,0x96,
+		0x22,0xC2,0x5F,0x96,0x8B,0x5F,0x96,0x86,
+		0x07,0x6E,0xE8,0xEE,0xE9,0xC0,0xC7,0xBB,
+		0x27,0xFF,0x8C,0x64,0xDC,0x9A,0xE2,0xAF,
+		0x2A,0xA2,0xBF,0xE0,0x70,0x83,0xFF,0xDD,
+		0x0F,0x5A,0xC2,0x91,0x0A,0x32,0x5C,0xA9,
+		0x27,0xD8,0x1F,0x43,0x7C,0x93,0x0F,0xC6,
+		0x22,0x0E,0x19,0x88,0x9F,0xAE,0xB0,0x86,
+		0x0F,0x40,0xB2,0x76,0x77,0x64,0xD7,0x63,
+		0x2F,0x52,0x03,0xFF,0xF6,0x05,0x4A,0x65,
+		0x2A,0xE0,0xC0,0xEB,0xE4,0x0F,0x4C,0xCB,
+		0x0F,0x55,0xC8,0xA7,0x01,0x72,0x78,0xF8,
+		0x2F,0xC5,0x2A,0xD2,0x81,0x53,0x40,0xBC,
+		0x21,0x52,0x1D,0xA4,0xB7,0x6D,0xC1,0xE6,
+		0x07,0xF2,0x49,0x60,0x4E,0x77,0x27,0x8C,
+		0x27,0x58,0x1B,0xFF,0x51,0xEF,0xA7,0xAA,
+		0x22,0x32,0x08,0xEB,0x27,0x95,0x8D,0x28,
+		0x0F,0x07,0x2C,0xFA,0x76,0xCB,0xC0,0xBE,
+		0x2F,0x40,0xC8,0x89,0x62,0xCD,0xC3,0x2E,
+		0x2A,0x2E,0xFE,0x62,0x40,0xA0,0x91,0x79,
+		0x07,0xF1,0xFF,0xEF,0x77,0xEB,0x81,0x5B,
+		0x2D,0x22,0x33,0xC0,0xE8,0x86,0xCA,0xD8,
+		0x0F,0x6D,0xF8,0x2E,0x72,0xBA,0x29,0x56,
+		0x2F,0x6F,0x81,0x79,0x57,0x24,0x42,0xC0,
+		0x2A,0xC4,0xF3,0x1E,0x5B,0x3A,0x98,0x82,
+		0x0F,0x49,0x64,0xE1,0x4A,0x1E,0x6A,0x05,
+		0x2F,0x27,0xED,0x72,0xFD,0x1A,0x58,0xDC,
+		0x22,0x9B,0x50,0xAA,0xFD,0x4F,0xA1,0x8E,
+		0x0F,0xE9,0x5C,0xA9,0xB3,0x94,0xF0,0x68,
+		0x27,0x1C,0x13,0x06,0xE1,0xC1,0xC3,0x12,
+		0x22,0x70,0x8F,0xDA,0xC4,0x43,0x98,0xAF,
+		0x0F,0x9B,0x10,0xAC,0x80,0x56,0xD7,0xD2,
+		0x25,0xB1,0x56,0x71,0xC7,0x7A,0x35,0x91,
+		0x07,0x21,0xE4,0x7D,0xE0,0xBA,0x73,0x2E,
+		0x27,0x73,0x75,0xFE,0x9D,0xE6,0x1F,0x6D,
+		0x2A,0x7B,0x5F,0x96,0x09,0x58,0x7F,0xC2,
+		0x07,0x91,0xEB,0x89,0x43,0x58,0x2C,0x7F,
+		0x2F,0xDE,0x00,0x58,0xC3,0xDE,0x74,0x0C,
+		0x2A,0x94,0x21,0x74,0x45,0x2C,0x8A,0xC2,
+		0x0F,0x01,0x39,0xC4,0xC6,0x64,0x79,0xFC,
+		0x27,0xB5,0x64,0x24,0xFD,0xA6,0xE9,0x46,
+		0x0F,0xD0,0x98,0x52,0xFF,0xDE,0x21,0xDC,
+		0x27,0xCC,0x40,0x70,0xBD,0x24,0xB2,0x40,
+		0x2A,0xFE,0x20,0x77,0xBC,0x73,0x6E,0x36,
+		0x0F,0xC8,0x03,0xF3,0x3B,0x64,0x2E,0xC9,
+		0x27,0x46,0x0F,0x46,0x8E,0x57,0x83,0xC4,
+		0x2A,0x24,0xCD,0xCB,0x45,0xED,0xD1,0x23,
+		0x07,0x2A,0x38,0x14,0xE8,0x9D,0x13,0x49,
+		0x0F,0xDD,0xEF,0x67,0x1E,0x1E,0x83,0xAF,
+		0x27,0x30,0x26,0xD9,0xD8,0x18,0x5A,0xA3,
+		0x2B,0x3D,0x70,0xCC,0xFB,0xE2,0xDA,0x5D,
+		0x0F,0xAF,0x77,0x5A,0x46,0x32,0x3B,0x28,
+		0x2F,0x67,0x02,0xFA,0x0E,0x27,0x70,0x8A,
+		0x23,0x62,0x15,0xFB,0xCE,0xD0,0xC6,0x4D,
+		0x0F,0xA8,0xBF,0xEB,0x17,0xD2,0x6C,0xCC,
+		0x2F,0xC1,0xE0,0x39,0xFE,0x3C,0x09,0x10,
+		0x2B,0xC0,0xBE,0xDF,0x7E,0x61,0x6D,0xC5,
+		0x0F,0x97,0x3F,0x8F,0xEE,0x9E,0x80,0xB2,
+		0x2F,0x89,0x28,0xB5,0xCE,0x93,0x65,0x13,
+		0x22,0x27,0x88,0x4D,0x02,0xDE,0x04,0x7D,
+		0x0F,0x1A,0xA6,0x41,0x94,0x67,0xCA,0x79,
+		0x27,0xFE,0x53,0xA1,0xBC,0xB2,0xC5,0x7D,
+		0x23,0x4B,0xFF,0xF3,0x88,0x21,0x27,0x58,
+		0x07,0xEB,0xAB,0x49,0x69,0x85,0xE8,0x2D,
+		0x2F,0x1D,0xFE,0x8C,0x1B,0x08,0x7D,0x57,
+		0x23,0xDF,0xD6,0x43,0xC7,0xD2,0x2A,0x3C,
+		0x0F,0x59,0x85,0xAE,0x5E,0xBE,0xF1,0xE9,
+		0x2F,0x4C,0x06,0x7A,0x2F,0xFC,0x8E,0x9F,
+		0x07,0x13,0x4B,0x58,0x7C,0x7C,0xC7,0x70,
+		0x2F,0x11,0x2A,0xF5,0xF3,0xF6,0x77,0x9C,
+		0x22,0x1C,0xC9,0x3C,0x16,0xBA,0x17,0x4C,
+		0x0F,0xF4,0xD5,0x22,0x81,0xAA,0xD4,0x13,
+		0x27,0xF5,0x58,0x06,0xDB,0x06,0xD6,0x90,
+		0x2D,0x10,0x92,0x8F,0x6D,0xB4,0x57,0x75,
+		0x0F,0x20,0x11,0x86,0xB5,0x2A,0x68,0xF2,
+		0x27,0x6E,0xFA,0x08,0xD6,0xEB,0xE7,0x9D,
+		0x24,0x66,0x95,0xAC,0x68,0xF3,0xE0,0x03,
+		0x07,0x78,0x8D,0xD1,0xD8,0x7A,0x4D,0x72,
+		0x27,0x50,0xD3,0x8D,0xB3,0x58,0x04,0x26,
+		0x27,0x9E,0xEF,0x7A,0xE5,0x40,0xF1,0x43,
+		0x07,0x8E,0x8D,0xED,0xEA,0xCF,0xC7,0x3B,
+		0x27,0xC3,0x59,0x7B,0xAB,0x73,0xC5,0x7C,
+		0x27,0xC0,0xF2,0x8F,0xF7,0x07,0xFF,0x0D,
+		0x07,0xCE,0x74,0x6C,0x2C,0xDD,0x68,0x6D,
+		0x2F,0x69,0x21,0x1F,0xEF,0x9A,0xEE,0xF9,
+		0x2F,0xEE,0x69,0x55,0xB3,0x15,0x58,0x35,
+		0x07,0xF1,0x17,0x33,0x20,0xE8,0x41,0x80,
+		0x2F,0x7D,0x4E,0x68,0x4E,0xA2,0x50,0x94,
+		0x2F,0x31,0xB2,0x9A,0x37,0xF3,0xBB,0x05,
+		0x07,0xBC,0x11,0xB1,0x3C,0xED,0xFF,0x44,
+		0x27,0x93,0x2D,0x61,0x43,0x38,0x6B,0xC2,
+		0x2F,0x1F,0x3E,0xEE,0x05,0xF2,0xCA,0x91,
+		0x07,0x05,0x9A,0xFF,0x85,0xD3,0x21,0x17,
+		0x27,0x22,0x3C,0x60,0x1C,0xBA,0xA2,0xD6,
+		0x2F,0x07,0xFF,0x12,0xEE,0x5E,0x1C,0x1C,
+		0x07,0x2F,0x39,0xA3,0x8E,0xDC,0x29,0xED,
+		0x0F,0x78,0x1C,0x7E,0xF3,0x9B,0x8A,0xE5,
+		0x0F,0xB3,0x57,0xCA,0xA5,0xC6,0x70,0x94,
+		0x07,0x3F,0x54,0x83,0xF1,0x1D,0xEB,0x1C,
+		0x0F,0x71,0xCB,0xCB,0x35,0x16,0x70,0xCF,
+		0x07,0x9B,0x6C,0x52,0xBE,0xDC,0xE9,0x53,
+		0x07,0x1E,0xA5,0xB4,0xE5,0xDB,0x90,0xC8,
+		0x07,0x09,0x8A,0xC3,0xD0,0x44,0xA3,0xC2,
+		0x27,0x88,0x28,0x62,0xFD,0x5D,0x04,0x32,
+		0x23,0xE6,0xBE,0xD2,0x75,0x3D,0xF2,0x31,
+		0x0F,0x24,0x16,0xFE,0x9F,0x59,0x7F,0xF6,
+		0x0F,0x9D,0x27,0xEF,0x9B,0x9D,0x73,0x37,
+		0x05,0xDC,0x6B,0xF9,0xA2,0xC7,0xD9,0x10,
+		0x27,0x78,0x0D,0x95,0x0C,0x68,0xF1,0x1E,
+		0x29,0x73,0x97,0x66,0x65,0xD2,0x5F,0xE3,
+		0x07,0x6E,0xF8,0x1F,0xAA,0x15,0xA1,0x2D,
+		0x0F,0xB3,0x8F,0x2C,0x08,0x51,0x96,0xE3,
+		0x07,0xDF,0x6E,0x4A,0x2F,0x82,0x86,0x2D,
+		0x0F,0x72,0xAA,0x0B,0xF3,0x22,0xF1,0x8E,
+		0x07,0x84,0x6C,0x74,0xD3,0x32,0x80,0xE5,
+		0x0F,0x62,0xC0,0x47,0xD5,0xF6,0xAB,0xDE,
+		0x0F,0xBF,0xC1,0x20,0x97,0x19,0xBF,0x96,
+		0x07,0x56,0x96,0xC3,0x74,0x0A,0x44,0x5A,
+		0x26,0x93,0x78,0x0F,0x1F,0xF3,0x8B,0xC0,
+		0x07,0xCC,0x52,0x10,0x0B,0x36,0x2E,0x4A,
+		0x07,0x13,0x9D,0x25,0x52,0x95,0x90,0xE0,
+		0x07,0xEF,0x65,0xC1,0x0E,0x43,0x18,0x49,
+		0x05,0x19,0x6E,0xD4,0x67,0xBE,0x84,0xE9,
+		0x27,0x7C,0x05,0xEA,0x57,0xBA,0x1E,0xEF,
+		0x29,0x5A,0x88,0x54,0x89,0x9F,0x69,0x00,
+		0x0F,0xE9,0xF6,0x6F,0x62,0xA0,0xA9,0x81,
+		0x07,0x59,0xE1,0x41,0xBD,0x9B,0xAB,0x04,
+		0x07,0xE4,0xD1,0x8E,0x35,0x9E,0xCD,0xD0,
+		0x07,0x63,0x61,0x1A,0xD5,0x0B,0xED,0x8D,
+		0x05,0xFA,0x25,0x5E,0x79,0x75,0x93,0x40,
+		0x2D,0x56,0x6B,0x14,0x24,0x4F,0x62,0xCA,
+		0x07,0x2F,0x0D,0x7D,0xB2,0xBA,0xD6,0xCC,
+		0x0F,0x25,0xBA,0xD6,0x20,0x15,0xA2,0x8C,
+		0x05,0x82,0x31,0x96,0x3A,0xD0,0x48,0x95,
+		0x27,0xBD,0x4A,0x80,0x4C,0xD1,0x93,0x61,
+		0x27,0x8A,0xD7,0x55,0xC2,0x82,0xBF,0x82,
+		0x2F,0x34,0x42,0x4C,0x4F,0xAF,0x7C,0x57,
+		0x27,0xB5,0x5B,0xE6,0x5B,0xA0,0x4D,0xFE,
+		0x2C,0x1F,0x8E,0x76,0xB2,0xCF,0xD5,0xED,
+		0x07,0x72,0x0F,0x0E,0x29,0x1C,0xD9,0xB0,
+		0x2B,0xDC,0x0B,0x98,0xFA,0x34,0xD5,0x69,
+		0x07,0x5F,0x24,0xAD,0x22,0xF9,0x90,0x2D,
+		0x07,0xE3,0x21,0x4B,0xDF,0x46,0x09,0x62,
+		0x07,0xF1,0x8A,0x19,0x92,0xF3,0x4C,0xAF,
+		0x0F,0xBB,0xFA,0x83,0x0C,0x3F,0x49,0x79,
+		0x07,0x16,0xF4,0xA4,0x4D,0x82,0x5C,0xF2,
+		0x24,0x4B,0xE4,0x69,0xB1,0xD2,0x0D,0xDF,
+		0x0F,0x21,0x9D,0xC8,0xCF,0xE2,0xB5,0x58,
+		0x0F,0x2F,0xD6,0x94,0xCD,0x52,0x1E,0x5F,
+		0x0F,0xFC,0xA6,0xC8,0x3C,0x20,0xAD,0x07,
+		0x07,0x6A,0x13,0x7B,0xAD,0x5C,0x57,0x42,
+		0x07,0xEC,0x4E,0x2A,0x3A,0x04,0xD3,0x86,
+		0x27,0x72,0x2A,0x4D,0xC0,0xDA,0x3F,0xA5,
+		0x24,0x32,0x26,0x8D,0xA2,0x66,0xDB,0x69,
+		0x0F,0x58,0x83,0x18,0x14,0xFB,0x88,0x0C,
+		0x0F,0x8A,0xE6,0x04,0x2C,0x71,0x0C,0x54,
+		0x2F,0x34,0xC3,0xD8,0x00,0x1C,0x38,0xDD,
+		0x21,0x1D,0x44,0x05,0x28,0xF8,0xC5,0x85,
+		0x07,0xA3,0x17,0x50,0x3A,0x03,0x6A,0xF0,
+		0x07,0x40,0xA7,0xFC,0x81,0x15,0x58,0x9E,
+		0x0F,0xB2,0x91,0x6B,0xB9,0x17,0xCE,0xE2,
+		0x0F,0xE5,0x50,0xDD,0x47,0xE6,0xEE,0x6D,
+		0x07,0x84,0x20,0xD6,0xA9,0x5A,0x8C,0x02,
+		0x0F,0xEE,0xA5,0x18,0xD6,0x38,0xD5,0x46,
+		0x0F,0xBE,0xB4,0x03,0xE7,0x04,0x10,0x04,
+		0x05,0x53,0xF1,0x43,0xCC,0xD1,0xCA,0x3E,
+		0x2E,0x87,0xD9,0xD1,0x9A,0x54,0x46,0x77,
+		0x05,0xB7,0xF5,0x3D,0x7C,0xE4,0x58,0xA3,
+		0x27,0xE7,0xA3,0x7B,0xB8,0x2C,0xCC,0xB3,
+		0x2A,0x8D,0x21,0xD6,0xC6,0xCF,0x99,0x7A,
+		0x0F,0x27,0x92,0xE1,0x4A,0x9C,0x02,0x9D,
+		0x07,0x52,0x8E,0x05,0xCC,0xC9,0xC3,0xFA,
+		0x22,0x05,0xC3,0x5A,0x3D,0x72,0x70,0x0D,
+		0x0F,0x52,0xEE,0x30,0x16,0xC0,0x8F,0xE7,
+		0x0F,0x44,0x3E,0x46,0xE7,0xF6,0xD0,0x64,
+		0x07,0x06,0xDD,0xCC,0xF8,0x4E,0x23,0x82,
+		0x0F,0x9F,0x05,0xC0,0xA9,0x91,0x9E,0x0B,
+		0x2F,0x60,0xD8,0x39,0x2B,0x95,0x38,0x22,
+		0x22,0x9C,0x32,0xAC,0x8A,0x8F,0x89,0xCF,
+		0x05,0xD2,0x48,0x9C,0x7A,0x99,0x9C,0xAC,
+		0x2A,0xCD,0x32,0x74,0xED,0xF8,0x63,0xBA,
+		0x0F,0xB2,0xFE,0x1B,0x00,0x53,0x0F,0x3A,
+		0x24,0xAB,0xA2,0xC1,0x5B,0x1D,0xAD,0x83,
+		0x07,0xDB,0x87,0x28,0x0E,0x1E,0x5A,0xEC,
+		0x05,0x93,0x50,0x53,0x13,0x2C,0x0C,0xAD
+};
+
+#define FIRMWARE_LINES_0_Eb15 (sizeof(Si2158_FW_0_Eb15)/(8*sizeof(u8)))
+
+/* SI2158_FIRMWARE_2_1_BUILD_9 */
+firmware_struct Si2158_FW_2_1b9[] = {
+		{ 8 , { 0x04,0x01,0x00,0x00,0x08,0x05,0xC0,0xC9 } },
+		{ 8 , { 0x05,0x59,0x32,0xCC,0x7E,0xC3,0x44,0x59 } },
+		{ 9 , { 0x30,0xF7,0x1A,0x64,0x2B,0x5D,0x3C,0xDC,0x31 } },
+		{ 8 , { 0x05,0xED,0x7F,0xD4,0x82,0x46,0x77,0x2B } },
+		{ 3 , { 0x4A,0xB1,0x1F } },
+		{ 8 , { 0x05,0xFF,0x6D,0x48,0x94,0x99,0xDE,0x3C } },
+		{ 3 , { 0x4A,0xAE,0x22 } },
+		{ 8 , { 0x05,0x82,0xE1,0xEA,0x8D,0xBF,0xC5,0x60 } },
+		{ 3 , { 0x42,0x5C,0x7B } },
+		{ 8 , { 0x05,0x57,0x5C,0xB6,0x05,0x14,0x3F,0xB3 } },
+		{ 16 , { 0x3F,0xA8,0xA8,0xFC,0xEE,0xA8,0x80,0xD9,0x0B,0x5C,0x1B,0xE9,0x79,0x2F,0xEF,0x47 } },
+		{ 3 , { 0x4A,0x00,0x19 } },
+		{ 8 , { 0x05,0x04,0x18,0x06,0xF0,0xAD,0x25,0xF8 } },
+		{ 3 , { 0x42,0x71,0xBE } },
+		{ 8 , { 0x05,0x57,0x16,0xEA,0x42,0xC3,0x42,0x59 } },
+		{ 3 , { 0x42,0xD9,0x8D } },
+		{ 8 , { 0x05,0x95,0xFA,0x37,0x21,0x80,0x85,0x77 } },
+		{ 3 , { 0x42,0xE2,0x90 } },
+		{ 8 , { 0x0F,0x49,0x8C,0x27,0xE9,0xD6,0x90,0xF2 } },
+		{ 8 , { 0x07,0x78,0xF5,0x29,0x13,0x23,0x7A,0xF6 } },
+		{ 8 , { 0x05,0xFF,0xDA,0xAF,0x0E,0x74,0x59,0xFB } },
+		{ 3 , { 0x4A,0x3E,0x98 } },
+		{ 8 , { 0x05,0xD8,0x18,0x5F,0x5A,0xEC,0x31,0xC0 } },
+		{ 12 , { 0x33,0x5D,0xD6,0xFE,0x3C,0x39,0x21,0x69,0x1C,0x1A,0x3B,0x0F } },
+		{ 8 , { 0x05,0x2A,0x3D,0x38,0x56,0xD6,0x2E,0x0B } },
+		{ 3 , { 0x4A,0x23,0x4B } },
+		{ 8 , { 0x05,0x7A,0x89,0x27,0x18,0x15,0x58,0xAA } },
+		{ 6 , { 0x45,0x32,0x93,0x16,0xB2,0xB9 } },
+		{ 8 , { 0x05,0x9B,0xEB,0x36,0x7E,0x4F,0x32,0x37 } },
+		{ 3 , { 0x42,0x06,0x1F } },
+		{ 8 , { 0x05,0xDB,0xEF,0x38,0xA7,0x63,0x6D,0x4E } },
+		{ 6 , { 0x4D,0x72,0x68,0x95,0x2B,0xB0 } },
+		{ 8 , { 0x05,0x93,0x29,0xC2,0x99,0xD1,0xB3,0x71 } },
+		{ 6 , { 0x4D,0xFA,0xC2,0xDC,0xF3,0x60 } },
+		{ 8 , { 0x05,0x6F,0x9A,0x59,0x5E,0x5C,0x38,0xF9 } },
+		{ 3 , { 0x42,0xEE,0x30 } },
+		{ 8 , { 0x07,0xFF,0x5B,0x93,0xA5,0xDF,0xBA,0xCA } },
+		{ 8 , { 0x05,0xC1,0x43,0xB7,0xB6,0x4A,0x74,0xDF } },
+		{ 3 , { 0x42,0x4E,0xF9 } },
+		{ 8 , { 0x05,0x7A,0xF6,0xDF,0x17,0xED,0x5E,0x4D } },
+		{ 3 , { 0x4A,0xD3,0xA5 } },
+		{ 8 , { 0x05,0x08,0xA5,0xBE,0x9F,0x84,0xC2,0x9D } },
+		{ 3 , { 0x4A,0x0C,0x97 } },
+		{ 8 , { 0x05,0x1B,0xB3,0x3C,0x0E,0x65,0x0D,0x5C } },
+		{ 12 , { 0x3B,0xC6,0xF3,0x1F,0x65,0xF2,0x7D,0x3D,0x0D,0xD9,0xA4,0x25 } },
+		{ 8 , { 0x05,0x56,0x10,0x31,0x77,0xDC,0x0C,0xAB } },
+		{ 3 , { 0x4A,0xAB,0x42 } },
+		{ 8 , { 0x05,0xB6,0x64,0x3B,0x81,0xFA,0x98,0xB2 } },
+		{ 3 , { 0x4A,0x54,0x52 } },
+		{ 8 , { 0x0F,0xAF,0x20,0xE1,0xEB,0x09,0xC7,0x88 } },
+		{ 16 , { 0x37,0x55,0x1C,0x23,0xF6,0xA8,0x09,0x99,0xA2,0x36,0xD9,0x6C,0xBC,0xE6,0xB3,0xBC } },
+		{ 16 , { 0x37,0x8A,0xCF,0x6A,0x73,0xA7,0xF5,0x6E,0x7E,0x53,0xC5,0xF7,0x97,0x79,0x05,0xF3 } },
+		{ 16 , { 0x3F,0x9B,0x16,0xF7,0xDE,0x7D,0xFD,0x7F,0xD6,0xA7,0x0A,0x28,0xCC,0x88,0xE0,0x4E } },
+		{ 7 , { 0x46,0x7F,0xD9,0xA2,0x28,0xA9,0x40 } },
+		{ 8 , { 0x0F,0x00,0xAB,0xD2,0xAC,0xAF,0x9C,0x12 } },
+		{ 8 , { 0x07,0x08,0x66,0x92,0xE7,0x63,0xA0,0x77 } },
+		{ 8 , { 0x07,0x0A,0x29,0x92,0x84,0x59,0x90,0x7C } },
+		{ 16 , { 0x37,0x2B,0x17,0xC6,0xB6,0x17,0x58,0x21,0x98,0xB9,0x41,0xC8,0xBF,0x7D,0x7C,0x65 } },
+		{ 16 , { 0x3F,0xDD,0x21,0x88,0x43,0x62,0x85,0x0A,0x99,0x69,0xD5,0x3F,0x06,0xFF,0x5A,0x7B } },
+		{ 12 , { 0x33,0x10,0xE2,0x87,0x96,0xB9,0x26,0x78,0xF3,0x79,0x73,0xB6 } },
+		{ 8 , { 0x07,0x0D,0x76,0xB0,0x4F,0xAD,0x99,0x59 } },
+		{ 16 , { 0x3F,0x20,0x79,0xB8,0x2F,0x46,0x60,0x66,0x00,0x7C,0xE2,0x92,0x12,0x14,0x36,0xEE } },
+		{ 16 , { 0x37,0xDF,0xBF,0x96,0x35,0xED,0xC5,0x62,0x20,0xE1,0xB9,0xB6,0xCE,0xDC,0x4E,0x71 } },
+		{ 16 , { 0x3F,0xE9,0x1C,0x63,0xBE,0xE2,0x71,0xB4,0xC3,0xE4,0x1D,0xC6,0xA2,0xB3,0xAB,0xC8 } },
+		{ 16 , { 0x37,0x02,0x54,0x92,0x51,0x8A,0x20,0xD2,0xD5,0x66,0xF0,0x17,0x72,0x9E,0x5D,0x3A } },
+		{ 16 , { 0x37,0xDF,0x3E,0x72,0x35,0x31,0xA5,0x1C,0x81,0x6F,0xF9,0x93,0xF3,0x99,0xB2,0xE2 } },
+		{ 16 , { 0x37,0x4D,0x18,0xA1,0xCE,0xD0,0x05,0x43,0x96,0x55,0x7A,0x62,0xF6,0xB6,0xBB,0x55 } },
+		{ 16 , { 0x3F,0xF5,0xFD,0x0D,0x3D,0x5F,0xE4,0xFE,0x5F,0x8A,0xC4,0x7B,0x96,0xA9,0xE1,0xD4 } },
+		{ 8 , { 0x07,0x91,0x26,0x16,0x6D,0x15,0x18,0xB6 } },
+		{ 12 , { 0x3B,0x09,0x7A,0xB4,0x74,0x5E,0x73,0x35,0xCE,0x52,0xC0,0xD5 } },
+		{ 8 , { 0x07,0xD3,0xA3,0x50,0xE8,0x7A,0xEE,0xCB } },
+		{ 10 , { 0x31,0xFB,0xF8,0x05,0xA5,0x5D,0x46,0xEB,0xB2,0xC5 } },
+		{ 8 , { 0x0F,0xD7,0xAE,0xE2,0x18,0x26,0x1C,0x84 } },
+		{ 3 , { 0x42,0x96,0xC2 } },
+		{ 8 , { 0x0F,0x6B,0xB4,0xA7,0xB2,0x2C,0x56,0xE3 } },
+		{ 8 , { 0x0F,0xC1,0xAF,0xB7,0xAC,0xB3,0x47,0x02 } },
+		{ 8 , { 0x0F,0x75,0x59,0xD9,0xB0,0x1F,0xD8,0xFE } },
+		{ 15 , { 0x36,0xED,0x5A,0x41,0xC2,0xB1,0x1E,0xF7,0x21,0x05,0xA2,0x44,0xF6,0x34,0x97 } },
+		{ 8 , { 0x07,0x2D,0xAB,0x62,0xD9,0x1E,0x8C,0x5E } },
+		{ 16 , { 0x3F,0x44,0x2C,0xE8,0x20,0xC7,0x20,0x8C,0x05,0x89,0xBC,0xA7,0x20,0xDE,0xBB,0xA3 } },
+		{ 12 , { 0x3B,0x6E,0x7B,0x57,0x4E,0xF8,0x00,0xAB,0x2E,0xB3,0xB9,0x17 } },
+		{ 8 , { 0x0F,0x5E,0x5B,0x43,0x88,0x57,0xA3,0x93 } },
+		{ 16 , { 0x37,0xDA,0xD7,0xC0,0x3A,0xE0,0x63,0x35,0x32,0x67,0x4D,0x27,0x7D,0x23,0x50,0x4A } },
+		{ 3 , { 0x42,0xB8,0xCC } },
+		{ 8 , { 0x0F,0x7D,0x55,0xDB,0x19,0x4B,0x63,0x53 } },
+		{ 8 , { 0x0F,0xB3,0x50,0xE5,0x34,0xD5,0x99,0x5F } },
+		{ 9 , { 0x30,0x7B,0xE5,0xDB,0x63,0xA8,0xAD,0xEE,0x27 } },
+		{ 8 , { 0x0F,0xCE,0xD5,0x78,0x5B,0xAF,0xFE,0x43 } },
+		{ 8 , { 0x0F,0x32,0x32,0x7C,0xFA,0x38,0xED,0x1C } },
+		{ 8 , { 0x0F,0x99,0x8A,0x79,0x24,0xE4,0xFC,0xE4 } },
+		{ 8 , { 0x07,0x7D,0xE3,0x78,0x64,0x19,0xD2,0x63 } },
+		{ 16 , { 0x3F,0xD9,0xE8,0x39,0x61,0x0D,0xC1,0x4A,0x47,0x9A,0x0B,0xEE,0xCF,0xC4,0xB9,0xB0 } },
+		{ 3 , { 0x4A,0x4B,0x42 } },
+		{ 8 , { 0x07,0x00,0x0A,0x54,0xAD,0x5B,0x3B,0xDD } },
+		{ 16 , { 0x3F,0xF8,0x79,0xD7,0xE8,0xF7,0xD8,0xC1,0xA9,0x78,0xED,0x03,0xAD,0x8F,0x09,0xC1 } },
+		{ 9 , { 0x30,0x0B,0x4B,0x0E,0x27,0xAE,0x5B,0x01,0x5E } },
+		{ 8 , { 0x0F,0xC4,0x6F,0x0A,0xC5,0x6C,0x7F,0x18 } },
+		{ 16 , { 0x3F,0xC5,0x7F,0xAA,0x23,0x11,0xB2,0xDA,0x20,0xD7,0x1E,0x3B,0xF2,0x67,0x62,0x43 } },
+		{ 16 , { 0x37,0xA7,0x7B,0x4F,0x8E,0x2D,0xC7,0x9F,0x66,0x4B,0x6F,0xC2,0x72,0x4F,0xAB,0x1B } },
+		{ 16 , { 0x37,0x80,0x9B,0x79,0xB2,0xE8,0x00,0x0D,0xCB,0x7F,0xD4,0x01,0x32,0xAC,0x03,0xA0 } },
+		{ 16 , { 0x37,0x14,0x0E,0x27,0x29,0x16,0x5D,0x97,0x9F,0x48,0x83,0x66,0x37,0x0D,0x6D,0xCB } },
+		{ 16 , { 0x3F,0x7F,0xEE,0xC5,0x93,0x7C,0xF9,0xAE,0xA5,0x17,0xA0,0xB4,0x31,0x5C,0xBD,0x7C } },
+		{ 16 , { 0x37,0xF0,0x48,0xCE,0xB7,0xB2,0x20,0x7C,0x58,0x7E,0xAA,0x36,0x50,0xA3,0x36,0x8B } },
+		{ 9 , { 0x38,0x5E,0x8A,0xAC,0x3F,0x65,0x82,0xA8,0xD6 } },
+		{ 8 , { 0x0F,0x9B,0x94,0x3C,0x30,0x23,0x73,0x79 } },
+		{ 16 , { 0x37,0x02,0xEB,0xC2,0x5E,0xF9,0xB2,0x3D,0xED,0xAD,0xDC,0x28,0x15,0x02,0x4E,0x2B } },
+		{ 16 , { 0x37,0x35,0xC0,0xD5,0xA9,0x5F,0x1D,0xFD,0x16,0xEF,0xF6,0x92,0x46,0xEB,0x08,0x4C } },
+		{ 10 , { 0x39,0xE1,0x0B,0xF4,0xC4,0x90,0x76,0xE2,0x57,0x4B } },
+		{ 8 , { 0x07,0x2B,0x61,0x0B,0xAB,0x49,0x56,0x7F } },
+		{ 16 , { 0x37,0xED,0x94,0xCB,0x5A,0x80,0x7C,0x35,0x1C,0xA2,0xE9,0x20,0xAD,0xAB,0x40,0x09 } },
+		{ 16 , { 0x37,0x04,0x38,0x28,0x6D,0xCF,0x96,0x1E,0x3A,0x0F,0x42,0xF8,0x19,0xC2,0x89,0x2E } },
+		{ 16 , { 0x3F,0x70,0x87,0x81,0xB3,0xA9,0x68,0x5C,0x23,0xDB,0x06,0x58,0x54,0xAC,0xF5,0x45 } },
+		{ 16 , { 0x3F,0xDD,0x6C,0x6D,0xF0,0xDB,0x03,0x18,0x59,0x4F,0xFC,0x3C,0x13,0x91,0x57,0x20 } },
+		{ 16 , { 0x3F,0xAD,0xDA,0xD9,0xD2,0xBB,0xF3,0x2D,0xF6,0x04,0xA5,0xBB,0x8C,0x80,0xF1,0xC9 } },
+		{ 16 , { 0x37,0x70,0xF0,0xC6,0xD3,0xD3,0xA7,0x31,0x42,0xF3,0xB3,0x16,0xD1,0x86,0x24,0xFE } },
+		{ 16 , { 0x3F,0xB8,0x07,0xEC,0xEA,0x3E,0x4D,0xEF,0x93,0xB2,0xD7,0x52,0xD2,0xA9,0x4D,0xF4 } },
+		{ 16 , { 0x3F,0x97,0x07,0x2E,0xE9,0xD3,0x53,0x8D,0xF0,0xF7,0xBD,0x65,0x7F,0xAE,0x82,0xAD } },
+		{ 10 , { 0x39,0xF3,0x0E,0xD4,0x4A,0xE3,0x88,0x36,0x3F,0xB3 } },
+		{ 8 , { 0x07,0xBC,0x8A,0x76,0xEA,0x6E,0x16,0x55 } },
+		{ 16 , { 0x37,0xD6,0xE1,0x5A,0xFE,0x2D,0x0F,0x07,0x26,0x2E,0x30,0xA1,0x02,0xFD,0xD9,0xCC } },
+		{ 16 , { 0x3F,0xDC,0x2E,0xE1,0xA4,0x8D,0x91,0x56,0xC2,0xF7,0xAB,0xEF,0x50,0x3F,0x71,0xEF } },
+		{ 4 , { 0x4B,0x7F,0x97,0x0A } },
+		{ 8 , { 0x0F,0x7B,0x28,0x01,0x3B,0xA0,0x15,0xAA } },
+		{ 16 , { 0x37,0xAB,0x0A,0xD2,0x4E,0x5D,0x71,0xC3,0x65,0xA5,0x4B,0x1D,0xFF,0xF2,0x67,0x58 } },
+		{ 6 , { 0x45,0x0E,0x64,0xB4,0x06,0xA4 } },
+		{ 8 , { 0x07,0x92,0xA7,0x51,0x55,0x92,0xF0,0xF4 } },
+		{ 8 , { 0x0F,0x0F,0x14,0x76,0x79,0x5C,0x1D,0xE7 } },
+		{ 8 , { 0x0F,0x2E,0xDC,0xEB,0x45,0x2A,0xA1,0xAF } },
+		{ 9 , { 0x30,0xC0,0xDA,0xA2,0x98,0xAE,0x47,0xD7,0x1E } },
+		{ 8 , { 0x0F,0xAF,0x3B,0xFE,0x7A,0xD8,0x27,0x45 } },
+		{ 13 , { 0x34,0x85,0x34,0x05,0x7A,0xDA,0x80,0xE0,0x1B,0x03,0x46,0xF1,0x91 } },
+		{ 8 , { 0x0F,0x87,0xB3,0xE8,0x64,0xF0,0x3F,0x6C } },
+		{ 8 , { 0x07,0x48,0xA9,0x0B,0xBB,0xDB,0x96,0xC4 } },
+		{ 8 , { 0x07,0xCD,0x13,0x81,0xDA,0xAF,0x30,0x57 } },
+		{ 8 , { 0x0F,0xA8,0xC5,0x94,0xCC,0x87,0xD6,0xF0 } },
+		{ 8 , { 0x0F,0x93,0xAA,0x67,0xC2,0x6D,0x41,0x07 } },
+		{ 8 , { 0x07,0x74,0x00,0x38,0xBD,0x3C,0x36,0xEB } },
+		{ 8 , { 0x07,0xB1,0x1D,0x97,0x83,0x96,0xCC,0xBC } },
+		{ 16 , { 0x37,0xD7,0xCC,0xCD,0x2B,0x64,0x65,0x0E,0x4F,0x17,0x63,0xDE,0x8A,0xBD,0xB8,0xEF } },
+		{ 16 , { 0x3F,0x60,0x84,0x7E,0x13,0x7E,0xFB,0xCC,0xBF,0x1D,0x64,0x07,0x01,0xE9,0x2C,0xFF } },
+		{ 16 , { 0x3F,0xE9,0x51,0x42,0x62,0x9E,0xBC,0xD7,0x4D,0xD1,0xF6,0x83,0x3E,0xA7,0x77,0xA7 } },
+		{ 3 , { 0x42,0x54,0xB2 } },
+		{ 8 , { 0x0F,0x86,0xB5,0x33,0xCD,0x1A,0xAB,0x1C } },
+		{ 8 , { 0x07,0x83,0xBA,0xAC,0xCE,0xC0,0xCC,0xF7 } },
+		{ 8 , { 0x0F,0x89,0x1B,0x32,0xA4,0x56,0x8E,0x09 } },
+		{ 16 , { 0x3F,0x11,0xFE,0xC2,0x5D,0x6B,0xD3,0x98,0xEC,0xB7,0x7B,0x93,0x49,0x6C,0x6A,0x34 } },
+		{ 16 , { 0x37,0xCC,0x63,0xA8,0x32,0x4C,0xCE,0x8B,0xD9,0x68,0xDD,0xB3,0xBB,0x33,0xFB,0x67 } },
+		{ 16 , { 0x3F,0x31,0x5C,0x89,0x74,0x6B,0xAC,0xBE,0xA6,0xAF,0xBD,0xC7,0x65,0x5C,0x67,0x65 } },
+		{ 2 , { 0x41,0x55 } },
+		{ 8 , { 0x0F,0xE7,0xF0,0xD9,0xFC,0xB7,0xC9,0xC5 } },
+		{ 16 , { 0x3F,0x70,0xB5,0x33,0x10,0xDF,0xAE,0x71,0x6A,0xBF,0x2D,0x7A,0xAC,0xC0,0xC2,0x38 } },
+		{ 16 , { 0x37,0x44,0x81,0xE0,0xD2,0x7D,0xB6,0xF9,0xB3,0x94,0x7A,0x95,0xBE,0x91,0x00,0x92 } },
+		{ 6 , { 0x45,0x2C,0xA4,0x61,0xF8,0x79 } },
+		{ 8 , { 0x0F,0xC2,0x7C,0x4C,0x82,0xFB,0x57,0x63 } },
+		{ 8 , { 0x07,0xEB,0x27,0xB7,0x95,0x55,0x22,0x02 } },
+		{ 8 , { 0x07,0x1F,0xEA,0xD4,0x5F,0x5A,0x3D,0xE5 } },
+		{ 8 , { 0x4F,0xD8,0xBC,0x2C,0x62,0xC2,0xC7,0x1D } },
+		{ 8 , { 0x07,0x55,0x7A,0xD3,0xA8,0x31,0x9A,0x92 } },
+		{ 11 , { 0x32,0x95,0x47,0x7E,0x9D,0x12,0xC4,0xFE,0x5E,0x2B,0x5D } },
+		{ 8 , { 0x0F,0x7A,0xA6,0x31,0xC2,0xC2,0x52,0x63 } },
+		{ 16 , { 0x3F,0xCB,0xC6,0x22,0xE7,0xC3,0xCA,0xCA,0xA2,0x33,0xEA,0xC0,0xFD,0x40,0xCE,0x76 } },
+		{ 16 , { 0x3F,0x60,0x2B,0x04,0x87,0xD1,0x17,0x3E,0x57,0xE1,0x28,0xCC,0x7E,0x5D,0x5E,0xEE } },
+		{ 16 , { 0x3F,0xEE,0xCC,0x45,0xED,0x18,0x92,0x8E,0xE7,0xDC,0x1D,0x1F,0xFB,0xF5,0x23,0x44 } },
+		{ 4 , { 0x4B,0x8E,0x7C,0xA3 } },
+		{ 8 , { 0x07,0x23,0x2F,0xA5,0x62,0xB1,0xD3,0x85 } },
+		{ 8 , { 0x07,0x6F,0xAE,0x2E,0xED,0x4E,0xC5,0x51 } },
+		{ 16 , { 0x37,0xF2,0x33,0x90,0x26,0xE1,0x48,0x1C,0x4D,0x77,0xAD,0x41,0x72,0x2E,0x80,0x06 } },
+		{ 16 , { 0x37,0xD9,0x7E,0xDC,0x74,0xBC,0xC1,0xFC,0xFE,0xF3,0x12,0x3C,0x2B,0xF5,0x7E,0x21 } },
+		{ 12 , { 0x33,0xD2,0xDA,0x26,0x98,0x28,0x95,0x23,0x7C,0x85,0x3F,0xD3 } },
+		{ 8 , { 0x0F,0x5B,0x43,0xFF,0x3C,0x0A,0x38,0x24 } },
+		{ 8 , { 0x07,0x9C,0xC0,0x34,0x66,0x43,0x2D,0x26 } },
+		{ 12 , { 0x3B,0x84,0xCC,0xF9,0x4F,0x03,0xC3,0x79,0xDB,0x56,0x3E,0x23 } },
+		{ 8 , { 0x07,0x3D,0xE8,0x69,0x5F,0x05,0x8D,0x2D } },
+		{ 16 , { 0x37,0x5C,0xD7,0x1A,0xEA,0x7C,0xE8,0x98,0x7B,0xDA,0x93,0x68,0x00,0xAA,0xCC,0x4D } },
+		{ 6 , { 0x4D,0x54,0x4D,0xDC,0x5A,0x72 } },
+		{ 8 , { 0x0F,0x5A,0x8B,0x3B,0xD4,0xDD,0x23,0x1E } },
+		{ 8 , { 0x0F,0xE0,0xEB,0x8F,0x29,0x1D,0x59,0x8B } },
+		{ 16 , { 0x37,0xB7,0x0E,0x77,0xFC,0xAC,0x44,0x58,0xA1,0xC7,0x8A,0xE0,0x69,0x1E,0x42,0xD6 } },
+		{ 16 , { 0x3F,0x92,0xD4,0x52,0xBB,0x2B,0xA3,0xD0,0xEB,0x09,0x7B,0xD4,0x50,0xD5,0x65,0xEA } },
+		{ 16 , { 0x3F,0x2F,0xC9,0x00,0x87,0xD8,0x52,0xC3,0x56,0x9E,0x4B,0xD5,0xE3,0xF9,0x44,0x63 } },
+		{ 5 , { 0x44,0x55,0x2A,0x42,0x85 } },
+		{ 8 , { 0x07,0xA4,0xAA,0x4F,0xAA,0x8F,0xE2,0x55 } },
+		{ 16 , { 0x3F,0x8C,0x80,0x2D,0x17,0x7C,0x9F,0x28,0xA4,0x02,0x78,0x20,0x10,0xC4,0x2F,0x37 } },
+		{ 8 , { 0x4F,0x64,0x61,0x54,0x6D,0x01,0xB5,0x03 } },
+		{ 8 , { 0x07,0xC4,0xDB,0x5D,0x0D,0x38,0x9E,0x9A } },
+		{ 8 , { 0x07,0x54,0xC6,0xA9,0x5A,0x9A,0xFA,0xDB } },
+		{ 8 , { 0x07,0x65,0xC4,0xC3,0xDE,0xDB,0x48,0xEE } },
+		{ 8 , { 0x07,0xBE,0x09,0x79,0x96,0x93,0x88,0x2C } },
+		{ 8 , { 0x0F,0x6B,0xC2,0xF7,0x6B,0x03,0xEE,0x62 } },
+		{ 8 , { 0x07,0x97,0x44,0x7A,0x49,0x06,0xE5,0x29 } },
+		{ 16 , { 0x3F,0x9F,0x17,0xBD,0xEC,0x56,0x21,0x32,0x74,0xBA,0x2E,0xE1,0x23,0x4A,0x90,0x06 } },
+		{ 3 , { 0x4A,0xD3,0xF0 } },
+		{ 8 , { 0x0F,0x84,0x98,0xC8,0x34,0x61,0x8D,0xC4 } },
+		{ 7 , { 0x46,0x7E,0x08,0xD7,0x14,0x64,0xD9 } },
+		{ 8 , { 0x07,0xBF,0x74,0xC3,0xA3,0x8D,0xEF,0xC5 } },
+		{ 16 , { 0x3F,0x05,0x3D,0x45,0x36,0xB1,0xEF,0x45,0x06,0xCF,0x28,0xE4,0x0F,0xB3,0x6E,0x84 } },
+		{ 16 , { 0x37,0x89,0xB5,0x8F,0x8C,0x33,0x8E,0x47,0x24,0x56,0xC0,0x96,0x2C,0x05,0x77,0x68 } },
+		{ 4 , { 0x4B,0x60,0x96,0xD6 } },
+		{ 8 , { 0x0F,0x76,0xBB,0x4D,0xAE,0x16,0xB4,0xCC } },
+		{ 16 , { 0x3F,0x7A,0x5E,0x8D,0x26,0x07,0x70,0xB8,0x20,0xB0,0x70,0xB7,0x8D,0x67,0x08,0xEE } },
+		{ 16 , { 0x3F,0x96,0x11,0x7D,0x07,0x4B,0xB7,0xAB,0xB9,0xA1,0x5D,0x71,0x91,0x2F,0xD8,0x45 } },
+		{ 16 , { 0x3F,0xBF,0x43,0x9A,0xC9,0x6F,0x59,0xA8,0x42,0x8D,0xB7,0x03,0x7F,0xCC,0x10,0xEF } },
+		{ 8 , { 0x0F,0x08,0xB2,0xB3,0x2D,0xE0,0x4B,0x03 } },
+		{ 16 , { 0x37,0xFB,0x41,0x38,0x34,0xF1,0x67,0x80,0x51,0x74,0xEE,0x95,0x9C,0xF2,0x5C,0x83 } },
+		{ 16 , { 0x37,0x2F,0xDC,0x23,0x04,0x18,0xDB,0x5E,0x45,0xD9,0x82,0x52,0x44,0x84,0xA8,0x52 } },
+		{ 16 , { 0x3F,0xFE,0x4A,0xA1,0xC7,0x55,0xEB,0x52,0xB9,0xA2,0xF3,0xFC,0xD2,0xFF,0x68,0xDD } },
+		{ 16 , { 0x3F,0xDB,0x99,0xB0,0x4C,0x7A,0xC3,0x2C,0xDD,0xE1,0x98,0x4E,0x1A,0x11,0xC4,0x5C } },
+		{ 16 , { 0x37,0x05,0xF2,0x5C,0x8C,0x7D,0x3D,0x42,0x1A,0xBF,0x6A,0xAE,0x9B,0xB6,0x25,0xF0 } },
+		{ 7 , { 0x4E,0xCD,0x41,0x82,0xBA,0x1B,0xBA } },
+		{ 8 , { 0x07,0x04,0xE8,0xFB,0x55,0xFE,0x6A,0x55 } },
+		{ 12 , { 0x33,0x2A,0x4A,0xF1,0xE7,0xC5,0x57,0xBC,0xD2,0x91,0x95,0xF6 } },
+		{ 8 , { 0x0F,0x04,0x90,0xC5,0x1A,0xC8,0x16,0xC1 } },
+		{ 15 , { 0x36,0x3A,0x76,0x53,0x18,0x92,0x0B,0xAB,0x8F,0xB7,0x7F,0x29,0xC8,0xB0,0x7F } },
+		{ 8 , { 0x07,0x6D,0xD7,0x8B,0xD8,0xB3,0x0D,0xAE } },
+		{ 8 , { 0x0F,0x72,0xA3,0xDE,0x53,0x0D,0x04,0x91 } },
+		{ 16 , { 0x37,0x36,0xB9,0xEC,0x73,0x12,0xB2,0x78,0xC4,0x4C,0x57,0xDA,0x05,0xE1,0x4F,0xA4 } },
+		{ 16 , { 0x3F,0x12,0x5F,0x23,0xFC,0x93,0x7C,0x1D,0x13,0xF5,0x74,0xFC,0x88,0x9F,0x35,0x4E } },
+		{ 16 , { 0x37,0xD7,0xAA,0x39,0xD0,0x73,0xFB,0x1F,0xB7,0xF3,0x45,0x0C,0x69,0x42,0x20,0x35 } },
+		{ 16 , { 0x37,0x6C,0x9E,0xED,0x31,0x9E,0x8C,0xE5,0x22,0x4B,0x08,0x4D,0x0C,0xA3,0x7D,0xCF } },
+		{ 16 , { 0x37,0x24,0xF7,0x9D,0xEE,0xCA,0xCE,0x02,0x9A,0xA2,0x53,0xAF,0x96,0x0E,0xBB,0x7E } },
+		{ 16 , { 0x3F,0xDF,0xE0,0xE9,0xA7,0x54,0xB8,0x79,0x19,0xB2,0x05,0x30,0x7A,0x36,0x4A,0xF5 } },
+		{ 16 , { 0x3F,0xB8,0x24,0x96,0x76,0xF9,0x55,0x0C,0x1D,0xCA,0x9E,0xD2,0x6F,0xD5,0xBB,0xEF } },
+		{ 16 , { 0x37,0x00,0xC5,0xB5,0x31,0xB4,0x1C,0x1D,0xAD,0xE8,0x62,0xEA,0x04,0x66,0x19,0x35 } },
+		{ 16 , { 0x3F,0xF0,0x6F,0x48,0x7A,0xE9,0x89,0xB9,0xB8,0x8B,0x36,0x1F,0xC9,0x36,0xC6,0x4C } },
+		{ 12 , { 0x33,0xA7,0x21,0x01,0x2E,0x0E,0xAE,0x0F,0xCB,0xEF,0x4C,0x1C } },
+		{ 8 , { 0x0F,0x0A,0x61,0x64,0x6E,0xB5,0x87,0xEA } },
+		{ 16 , { 0x3F,0x48,0x99,0x69,0xB0,0x30,0x44,0xCA,0xF3,0x64,0x46,0x4A,0xD8,0x0A,0xA9,0xBA } },
+		{ 3 , { 0x42,0x89,0x21 } },
+		{ 8 , { 0x0F,0x30,0x66,0x77,0x60,0x58,0x89,0x2E } },
+		{ 9 , { 0x30,0x4E,0x53,0xDA,0xD5,0x3C,0x1C,0xD4,0xD1 } },
+		{ 8 , { 0x07,0xF9,0x3A,0x4B,0x50,0x92,0x63,0x2E } },
+		{ 16 , { 0x3F,0x0F,0x1A,0x48,0x7C,0x81,0x60,0x76,0xEA,0x3F,0x64,0xF5,0x81,0xD5,0x02,0x1D } },
+		{ 16 , { 0x37,0x45,0x0C,0xAD,0x74,0x7C,0x34,0x4C,0x33,0x42,0xCC,0xC1,0xBC,0x93,0x3A,0xC2 } },
+		{ 16 , { 0x3F,0xED,0x96,0x5A,0x20,0x7A,0x04,0x41,0xD3,0x16,0x61,0x46,0xD7,0xEF,0xF8,0x6C } },
+		{ 8 , { 0x47,0xBB,0x80,0x07,0x48,0x7F,0x26,0xBA } },
+		{ 8 , { 0x0F,0x3D,0xDF,0x9C,0x27,0x6B,0x13,0x14 } },
+		{ 16 , { 0x3F,0x6B,0xBA,0x51,0xB6,0xA1,0xD6,0x9D,0xA9,0x49,0x85,0x2C,0xF6,0x17,0xAD,0xF6 } },
+		{ 16 , { 0x37,0x1F,0x00,0x69,0xC5,0x3C,0xD7,0xA1,0xF3,0x45,0x4E,0x72,0xFE,0x86,0x3E,0x2A } },
+		{ 15 , { 0x3E,0x85,0x16,0x3F,0xE3,0xE5,0xE4,0xB0,0xD7,0xB0,0xB5,0x41,0x62,0x66,0x3E } },
+		{ 8 , { 0x07,0xCC,0xBA,0xDA,0xE6,0xEF,0xAC,0x96 } },
+		{ 16 , { 0x3F,0x24,0x1D,0xBE,0xE5,0xF8,0xB4,0x88,0x63,0xBE,0x1E,0xCC,0xD7,0x17,0x21,0xEB } },
+		{ 5 , { 0x44,0x9C,0x91,0x1A,0x0A } },
+		{ 8 , { 0x0F,0x17,0x67,0x37,0xBF,0x99,0xA8,0x7E } },
+		{ 8 , { 0x07,0xF7,0x1C,0x25,0x05,0x0F,0x66,0xE5 } },
+		{ 11 , { 0x3A,0xD9,0xA1,0x29,0x9A,0x4E,0xCB,0xC5,0xF9,0x04,0xA9 } },
+		{ 8 , { 0x07,0x04,0x2E,0x50,0xD3,0x86,0x71,0xFB } },
+		{ 8 , { 0x07,0x47,0xB0,0xC1,0x3D,0x76,0x30,0xFA } },
+		{ 10 , { 0x39,0xEA,0xD0,0xAE,0xBC,0x00,0x7D,0x09,0x0D,0x3B } },
+		{ 8 , { 0x0F,0x2D,0x39,0x28,0x73,0xB9,0x70,0x02 } },
+		{ 8 , { 0x07,0x59,0x65,0x65,0x56,0x52,0x86,0xAD } },
+		{ 8 , { 0x07,0x73,0xFA,0xF9,0x93,0x24,0x5B,0x05 } },
+		{ 8 , { 0x07,0x6E,0x23,0xDC,0x21,0xC8,0x71,0x29 } },
+		{ 8 , { 0x07,0x51,0x32,0x7A,0x79,0x60,0x2A,0xD7 } },
+		{ 8 , { 0x07,0x15,0x45,0xCE,0x84,0xB1,0x5C,0x3D } },
+		{ 8 , { 0x0F,0x91,0x48,0xCA,0x5F,0xFB,0x50,0xAE } },
+		{ 8 , { 0x0F,0xB0,0xCB,0xD6,0x4C,0xB4,0x13,0xCE } },
+		{ 8 , { 0x0F,0x21,0xED,0x0A,0x49,0xC0,0x81,0xC9 } },
+		{ 8 , { 0x07,0x2D,0x97,0x99,0x2F,0x65,0xC3,0x9A } },
+		{ 8 , { 0x05,0xC3,0xB3,0x23,0x81,0x31,0x79,0x84 } },
+		{ 16 , { 0x37,0x86,0xDD,0x4B,0x34,0x71,0x62,0x4B,0xD5,0x26,0x5A,0xD9,0x5A,0x7D,0xDC,0x6B } },
+		{ 16 , { 0x37,0x9B,0x88,0xDA,0xD9,0x62,0x3B,0xBA,0x02,0x4C,0x60,0xCB,0x46,0x31,0x2E,0x6B } },
+		{ 16 , { 0x3F,0x33,0x45,0x16,0xD9,0xB2,0x21,0x3A,0x37,0x2A,0x8F,0x77,0x01,0x46,0xC1,0xE5 } },
+		{ 16 , { 0x37,0xCC,0xF7,0x27,0x47,0x9B,0xF5,0x62,0x31,0xDF,0x30,0xC3,0x79,0x69,0x50,0xDF } },
+		{ 16 , { 0x37,0x94,0x9E,0x56,0x65,0x1E,0x42,0xD3,0xE1,0x21,0x5C,0xEB,0x7D,0xD4,0x3F,0x10 } },
+		{ 16 , { 0x3F,0x32,0x8B,0xBA,0xB6,0xAF,0x76,0xCC,0x13,0xD4,0xE7,0x32,0x3B,0x1E,0xAF,0xA0 } },
+		{ 5 , { 0x4C,0x8B,0x97,0x95,0x3A } },
+		{ 8 , { 0x0F,0x6A,0x37,0xDD,0x72,0x2C,0x3B,0x34 } },
+		{ 16 , { 0x3F,0xAC,0xA0,0x8F,0x8B,0x02,0x16,0x77,0x6A,0xD6,0x31,0x5A,0x2A,0x9A,0xFA,0x7F } },
+		{ 2 , { 0x41,0xA3 } },
+		{ 8 , { 0x07,0xB7,0x7A,0xDB,0x23,0x6A,0x87,0xCF } },
+		{ 8 , { 0x4F,0xB6,0xD9,0x2F,0x8A,0xDD,0x57,0x97 } },
+		{ 8 , { 0x07,0xFD,0x54,0x4A,0x13,0x07,0x46,0xEA } },
+		{ 8 , { 0x0F,0x05,0x4F,0x89,0xB2,0xDD,0xC8,0xA4 } },
+		{ 16 , { 0x37,0xE4,0x8C,0xB2,0x7E,0x33,0x42,0x3A,0x69,0x75,0xB2,0xA3,0x4D,0x67,0x0F,0x38 } },
+		{ 11 , { 0x3A,0x03,0xD7,0xA8,0x84,0xB3,0x82,0x94,0xA5,0x67,0xD9 } },
+		{ 8 , { 0x05,0xD7,0xE7,0x4F,0x86,0x59,0x2E,0x5C } },
+		{ 5 , { 0x44,0xF9,0xDF,0xCF,0x34 } },
+		{ 8 , { 0x07,0x32,0x60,0x69,0xF9,0xA1,0xA4,0x36 } },
+		{ 8 , { 0x05,0x38,0xB2,0xB2,0x87,0xE6,0xEF,0x0D } },
+		{ 3 , { 0x4A,0x7F,0x84 } },
+		{ 8 , { 0x07,0xB4,0xB0,0xA1,0xDD,0xED,0xAD,0x9E } },
+		{ 8 , { 0x0F,0x28,0xA0,0xA7,0x2A,0xA5,0x91,0x03 } },
+		{ 8 , { 0x0F,0xC1,0x6B,0x5C,0xB1,0x38,0x12,0x92 } },
+		{ 8 , { 0x07,0x05,0x68,0x27,0x1D,0xED,0x33,0x4D } },
+		{ 8 , { 0x05,0xAF,0x64,0x15,0x9B,0x1B,0x92,0x56 } },
+		{ 3 , { 0x42,0x49,0x6A } },
+		{ 8 , { 0x07,0x29,0x89,0x48,0xD7,0xD1,0x07,0x0D } },
+		{ 8 , { 0x05,0x34,0x2E,0x9E,0xFF,0x87,0x0C,0xDE } },
+		{ 3 , { 0x42,0xC6,0xCA } },
+		{ 8 , { 0x05,0xF3,0xD2,0xBD,0xE6,0xEF,0x3B,0x23 } },
+		{ 3 , { 0x4A,0xFE,0xB0 } },
+		{ 8 , { 0x05,0x84,0x37,0xAF,0x14,0x4D,0x11,0x6F } },
+		{ 4 , { 0x4B,0x09,0xD5,0x2D } },
+		{ 8 , { 0x07,0xF8,0x5F,0xAD,0x4F,0x58,0x6B,0xC6 } },
+		{ 8 , { 0x05,0x57,0x0A,0x23,0xD6,0x3F,0x5B,0x14 } }
+};
+
+#define FIRMWARE_LINES_2_1b9 (sizeof(Si2158_FW_2_1b9)/(sizeof(firmware_struct)))
+#define RAM_CRC_2_1b9 0x16F7
+
+/***************************************************************************************
+                  Silicon Laboratories Broadcast Si2157  API
+   FILE: Si2177_firmware_3_0_build_x.h
+   Supported IC : Si2157
+   Date: August 22 2013
+   (C) Copyright 2012, Silicon Laboratories, Inc. All rights reserved.
+
+   This is a dummy firmware patch for Si2177-A30 devices.
+   When a new patch becomes available,  replace this file and all calls to it with the new patch.
+   This patch is formatted in the new 16 byte download format.  The future patches will match this structure.
+ ****************************************************************************************/
+/* Si2177_FIRMWARE_3_0_BUILD_X */
+
+firmware_struct Si2177_FW_3_0bx[] = {
+		{ 0 , { 0x00} }
+};
+
+#define FIRMWARE_LINES_3_0bx (sizeof(Si2177_FW_3_0bx)/(sizeof(firmware_struct)))
+
+#endif /* __SILABS_TERCAB_PRIV_H__ */
--- linux-4.15/drivers/media/tuners/tuner-types.c.0140~	2018-01-28 22:20:33.000000000 +0100
+++ linux-4.15/drivers/media/tuners/tuner-types.c	2018-02-12 11:32:52.773582217 +0100
@@ -1433,6 +1433,16 @@ static struct tuner_params tuner_sony_bt
 	},
 };
 
+/* ------------ TUNER_SILABS_TERCAB - Si2157 NTSC ------------ */
+
+static struct tuner_params tuner_silabs_tercab_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_DIGITAL,
+		.ranges = tuner_fm1236_mk3_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_fm1236_mk3_ntsc_ranges),
+	},
+};
+
 /* --------------------------------------------------------------------- */
 
 struct tunertype tuners[] = {
@@ -1941,6 +1951,11 @@ struct tunertype tuners[] = {
 		.params = tuner_sony_btf_pg463z_params,
 		.count  = ARRAY_SIZE(tuner_sony_btf_pg463z_params),
 	},
+	[TUNER_SILABS_TERCAB] = {
+		.name   = "Silicon Labs terrestrial/cable multistandard",
+		.params = tuner_silabs_tercab_params,
+		.count  = ARRAY_SIZE(tuner_silabs_tercab_params),
+	},
 };
 EXPORT_SYMBOL(tuners);
 
--- linux-4.15/drivers/media/usb/cx231xx/cx231xx-avcore.c.0140~	2018-02-12 11:32:52.017576679 +0100
+++ linux-4.15/drivers/media/usb/cx231xx/cx231xx-avcore.c	2018-02-12 11:32:52.774582224 +0100
@@ -355,6 +355,9 @@ int cx231xx_afe_update_power_control(str
 	case CX231XX_BOARD_CNXT_VIDEO_GRABBER:
 	case CX231XX_BOARD_HAUPPAUGE_EXETER:
 	case CX231XX_BOARD_HAUPPAUGE_930C_HD_1113xx:
+	case CX231XX_BOARD_HAUPPAUGE_EXETER_955Q:
+	case CX231XX_BOARD_HAUPPAUGE_935C:
+	case CX231XX_BOARD_HAUPPAUGE_975:
 	case CX231XX_BOARD_HAUPPAUGE_USBLIVE2:
 	case CX231XX_BOARD_PV_PLAYTV_USB_HYBRID:
 	case CX231XX_BOARD_HAUPPAUGE_USB2_FM_PAL:
@@ -599,7 +602,7 @@ int cx231xx_set_video_input_mux(struct c
 				return status;
 			}
 		}
-		if (dev->tuner_type == TUNER_NXP_TDA18271)
+		if (dev->tuner_type == TUNER_NXP_TDA18271 || dev->tuner_type == TUNER_SILABS_TERCAB)
 			status = cx231xx_set_decoder_video_input(dev,
 							CX231XX_VMUX_TELEVISION,
 							INPUT(input)->vmux);
@@ -1209,7 +1212,8 @@ int cx231xx_set_audio_decoder_input(stru
 			   new boards in case they use a tuner type we don't
 			   currently know about */
 			dev_info(dev->dev,
-				 "Unknown tuner type configuring SIF");
+				 "Unknown tuner type %d configuring SIF",
+				 dev->board.tuner_type);
 			break;
 		}
 		break;
@@ -1750,6 +1754,9 @@ int cx231xx_dif_set_standard(struct cx23
 	case CX231XX_BOARD_CNXT_RDU_250:
 	case CX231XX_BOARD_CNXT_VIDEO_GRABBER:
 	case CX231XX_BOARD_HAUPPAUGE_EXETER:
+	case CX231XX_BOARD_HAUPPAUGE_EXETER_955Q:
+	case CX231XX_BOARD_HAUPPAUGE_935C:
+	case CX231XX_BOARD_HAUPPAUGE_975:
 	case CX231XX_BOARD_OTG102:
 		func_mode = 0x03;
 		break;
--- linux-4.15/drivers/media/usb/cx231xx/cx231xx-cards.c.0140~	2018-02-12 11:32:52.017576679 +0100
+++ linux-4.15/drivers/media/usb/cx231xx/cx231xx-cards.c	2018-02-12 11:34:46.081381342 +0100
@@ -34,6 +34,7 @@
 #include <media/dvb-usb-ids.h>
 #include "xc5000.h"
 #include "tda18271.h"
+#include "si2157.h"
 
 
 static int tuner = -1;
@@ -376,6 +377,123 @@ struct cx231xx_board cx231xx_boards[] =
 			.gpio = NULL,
 		} },
 	},
+	[CX231XX_BOARD_HAUPPAUGE_EXETER_955Q] = {
+		.name = "Hauppauge EXETER 955Q",
+		.tuner_type = TUNER_SILABS_TERCAB,
+		.tuner_addr = 0x60,
+		.tuner_gpio = RDE250_XCV_TUNER,
+		.tuner_sif_gpio = -1, //0x05,
+		.tuner_scl_gpio = -1, //0x1a,
+		.tuner_sda_gpio = -1, //0x1b,
+		.decoder = CX231XX_AVDECODER,
+		.output_mode = OUT_MODE_VIP11,
+		.demod_xfer_mode = 0,
+		.ctl_pin_status_mask = 0xFFFFFFC4,
+		.agc_analog_digital_select_gpio = 0x0c,
+		.gpio_pin_status_mask = 0x4001000,
+		.tuner_i2c_master = I2C_1_MUX_3,
+		.demod_i2c_master = I2C_2,
+		.has_dvb = 1,
+		.demod_addr = 0xB2 >> 1,
+		.norm = V4L2_STD_NTSC,
+
+		.input = {{
+			.type = CX231XX_VMUX_TELEVISION,
+			.vmux = CX231XX_VIN_3_1,
+			.amux = CX231XX_AMUX_VIDEO,
+			.gpio = NULL,
+		}, {
+			.type = CX231XX_VMUX_COMPOSITE1,
+			.vmux = CX231XX_VIN_2_1,
+			.amux = CX231XX_AMUX_LINE_IN,
+			.gpio = NULL,
+		}, {
+			.type = CX231XX_VMUX_SVIDEO,
+			.vmux = CX231XX_VIN_1_1 |
+				(CX231XX_VIN_1_2 << 8) |
+				CX25840_SVIDEO_ON,
+			.amux = CX231XX_AMUX_LINE_IN,
+			.gpio = NULL,
+		} },
+	},
+	[CX231XX_BOARD_HAUPPAUGE_935C] = {
+		.name = "Hauppauge WinTV 935C",
+		.tuner_type = TUNER_SILABS_TERCAB,
+		.tuner_addr = 0x60,
+		.tuner_gpio = RDE250_XCV_TUNER,
+		.tuner_sif_gpio = -1, //0x05,
+		.tuner_scl_gpio = -1, //0x1a,
+		.tuner_sda_gpio = -1, //0x1b,
+		.decoder = CX231XX_AVDECODER,
+		.output_mode = OUT_MODE_VIP11,
+		.demod_xfer_mode = 0,
+		.ctl_pin_status_mask = 0xFFFFFFC4,
+		.agc_analog_digital_select_gpio = 0x0c,
+		.gpio_pin_status_mask = 0x4001000,
+		.tuner_i2c_master = I2C_1_MUX_3,
+		.demod_i2c_master = I2C_2,
+		.has_dvb = 1,
+		.demod_addr = 0xC8 >> 1,
+		.norm = V4L2_STD_PAL,
+
+		.input = {{
+			.type = CX231XX_VMUX_TELEVISION,
+			.vmux = CX231XX_VIN_3_1,
+			.amux = CX231XX_AMUX_VIDEO,
+			.gpio = NULL,
+		}, {
+			.type = CX231XX_VMUX_COMPOSITE1,
+			.vmux = CX231XX_VIN_2_1,
+			.amux = CX231XX_AMUX_LINE_IN,
+			.gpio = NULL,
+		}, {
+			.type = CX231XX_VMUX_SVIDEO,
+			.vmux = CX231XX_VIN_1_1 |
+				(CX231XX_VIN_1_2 << 8) |
+				CX25840_SVIDEO_ON,
+			.amux = CX231XX_AMUX_LINE_IN,
+			.gpio = NULL,
+		} },
+	},
+	[CX231XX_BOARD_HAUPPAUGE_975] = {
+		.name = "Hauppauge WinTV 975",
+		.tuner_type = TUNER_SILABS_TERCAB,
+		.tuner_addr = 0x60,
+		.tuner_gpio = RDE250_XCV_TUNER,
+		.tuner_sif_gpio = -1, //0x05,
+		.tuner_scl_gpio = -1, //0x1a,
+		.tuner_sda_gpio = -1, //0x1b,
+		.decoder = CX231XX_AVDECODER,
+		.output_mode = OUT_MODE_VIP11,
+		.demod_xfer_mode = 0,
+		.ctl_pin_status_mask = 0xFFFFFFC4,
+		.agc_analog_digital_select_gpio = 0x0c,
+		.gpio_pin_status_mask = 0x4001000,
+		.tuner_i2c_master = I2C_1_MUX_3,
+		.demod_i2c_master = I2C_2,
+		.has_dvb = 1,
+		.demod_addr = -1,
+		.norm = V4L2_STD_PAL,
+
+		.input = {{
+			.type = CX231XX_VMUX_TELEVISION,
+			.vmux = CX231XX_VIN_3_1,
+			.amux = CX231XX_AMUX_VIDEO,
+			.gpio = NULL,
+		}, {
+			.type = CX231XX_VMUX_COMPOSITE1,
+			.vmux = CX231XX_VIN_2_1,
+			.amux = CX231XX_AMUX_LINE_IN,
+			.gpio = NULL,
+		}, {
+			.type = CX231XX_VMUX_SVIDEO,
+			.vmux = CX231XX_VIN_1_1 |
+				(CX231XX_VIN_1_2 << 8) |
+				CX25840_SVIDEO_ON,
+			.amux = CX231XX_AMUX_LINE_IN,
+			.gpio = NULL,
+		} },
+	},
 	[CX231XX_BOARD_HAUPPAUGE_USBLIVE2] = {
 		.name = "Hauppauge USB Live 2",
 		.tuner_type = TUNER_ABSENT,
@@ -965,6 +1083,12 @@ struct usb_device_id cx231xx_id_table[]
 	 .driver_info = CX231XX_BOARD_HAUPPAUGE_930C_HD_1114xx},
 	{USB_DEVICE(0x2040, 0xb140),
 	 .driver_info = CX231XX_BOARD_HAUPPAUGE_EXETER},
+	{USB_DEVICE(0x2040, 0xb151),
+	 .driver_info = CX231XX_BOARD_HAUPPAUGE_935C},
+	{USB_DEVICE(0x2040, 0xb123),
+	 .driver_info = CX231XX_BOARD_HAUPPAUGE_EXETER_955Q},
+	{USB_DEVICE(0x2040, 0xb150),
+	 .driver_info = CX231XX_BOARD_HAUPPAUGE_975},
 	{USB_DEVICE(0x2040, 0xc200),
 	 .driver_info = CX231XX_BOARD_HAUPPAUGE_USBLIVE2},
 	/* PCTV QuatroStick 521e */
@@ -1024,7 +1148,7 @@ int cx231xx_tuner_callback(void *ptr, in
 					       1);
 			msleep(10);
 		}
-	} else if (dev->tuner_type == TUNER_NXP_TDA18271) {
+	} else if (dev->tuner_type == TUNER_NXP_TDA18271 || dev->tuner_type == TUNER_SILABS_TERCAB) {
 		switch (command) {
 		case TDA18271_CALLBACK_CMD_AGC_ENABLE:
 			if (dev->model == CX231XX_BOARD_PV_PLAYTV_USB_HYBRID)
@@ -1173,7 +1297,6 @@ static int read_eeprom(struct cx231xx *d
 
 void cx231xx_card_setup(struct cx231xx *dev)
 {
-
 	cx231xx_set_model(dev);
 
 	dev->tuner_type = cx231xx_boards[dev->model].tuner_type;
@@ -1211,6 +1334,9 @@ void cx231xx_card_setup(struct cx231xx *
 	case CX231XX_BOARD_HAUPPAUGE_930C_HD_1113xx:
 	case CX231XX_BOARD_HAUPPAUGE_930C_HD_1114xx:
 	case CX231XX_BOARD_HAUPPAUGE_955Q:
+	case CX231XX_BOARD_HAUPPAUGE_EXETER_955Q:
+	case CX231XX_BOARD_HAUPPAUGE_935C:
+	case CX231XX_BOARD_HAUPPAUGE_975:
 		{
 			struct eeprom {
 				struct tveeprom tvee;
--- linux-4.15/drivers/media/usb/cx231xx/cx231xx-core.c.0140~	2018-02-12 11:32:52.018576686 +0100
+++ linux-4.15/drivers/media/usb/cx231xx/cx231xx-core.c	2018-02-12 11:32:52.775582231 +0100
@@ -720,6 +720,9 @@ int cx231xx_set_mode(struct cx231xx *dev
 			break;
 		case CX231XX_BOARD_HAUPPAUGE_EXETER:
 		case CX231XX_BOARD_HAUPPAUGE_930C_HD_1113xx:
+		case CX231XX_BOARD_HAUPPAUGE_EXETER_955Q:
+		case CX231XX_BOARD_HAUPPAUGE_935C:
+		case CX231XX_BOARD_HAUPPAUGE_975:
 			errCode = cx231xx_set_power_mode(dev,
 						POLARIS_AVMODE_DIGITAL);
 			break;
@@ -739,6 +742,9 @@ int cx231xx_set_mode(struct cx231xx *dev
 		case CX231XX_BOARD_CNXT_RDU_253S:
 		case CX231XX_BOARD_HAUPPAUGE_EXETER:
 		case CX231XX_BOARD_HAUPPAUGE_930C_HD_1113xx:
+		case CX231XX_BOARD_HAUPPAUGE_EXETER_955Q:
+		case CX231XX_BOARD_HAUPPAUGE_935C:
+		case CX231XX_BOARD_HAUPPAUGE_975:
 		case CX231XX_BOARD_PV_PLAYTV_USB_HYBRID:
 		case CX231XX_BOARD_HAUPPAUGE_USB2_FM_PAL:
 		case CX231XX_BOARD_HAUPPAUGE_USB2_FM_NTSC:
@@ -1443,6 +1449,9 @@ int cx231xx_dev_init(struct cx231xx *dev
 	case CX231XX_BOARD_CNXT_RDU_253S:
 	case CX231XX_BOARD_HAUPPAUGE_EXETER:
 	case CX231XX_BOARD_HAUPPAUGE_930C_HD_1113xx:
+	case CX231XX_BOARD_HAUPPAUGE_EXETER_955Q:
+	case CX231XX_BOARD_HAUPPAUGE_935C:
+	case CX231XX_BOARD_HAUPPAUGE_975:
 	case CX231XX_BOARD_PV_PLAYTV_USB_HYBRID:
 	case CX231XX_BOARD_HAUPPAUGE_USB2_FM_PAL:
 	case CX231XX_BOARD_HAUPPAUGE_USB2_FM_NTSC:
--- linux-4.15/drivers/media/usb/cx231xx/cx231xx-dvb.c.0140~	2018-02-12 11:32:52.018576686 +0100
+++ linux-4.15/drivers/media/usb/cx231xx/cx231xx-dvb.c	2018-02-12 11:32:52.775582231 +0100
@@ -34,8 +34,11 @@
 #include "lgdt3305.h"
 #include "si2165.h"
 #include "si2168.h"
+#include "si2168b.h"
+#include "silg.h"
 #include "mb86a20s.h"
 #include "si2157.h"
+#include "silabs_tercab.h"
 #include "lgdt3306a.h"
 #include "r820t.h"
 #include "mn88473.h"
@@ -131,6 +134,38 @@ static struct lgdt3305_config hcw_lgdt33
 	.vsb_if_khz         = 3250,
 };
 
+static struct lgdt3306a_config hcw_lgdt3306a_config = {
+	/* LG3306A demodulator configuration */
+	.i2c_addr           = 0xB2 >> 1,
+
+	/* user defined IF frequency in KHz */
+	.qam_if_khz         = HVR19x5_QAM_IF, //needs to match tuner
+	.vsb_if_khz         = HVR19x5_VSB_IF, //needs to match tuner
+
+	/* disable i2c repeater - 0:repeater enabled 1:repeater disabled */
+	.deny_i2c_rptr      = 1,
+
+	/* spectral inversion - 0:disabled 1:enabled */
+	.spectral_inversion = 1,
+
+	.mpeg_mode          = LGDT3306A_MPEG_SERIAL,
+	.tpclk_edge         = LGDT3306A_TPCLK_RISING_EDGE,
+	.tpvalid_polarity   = LGDT3306A_TP_VALID_HIGH,
+
+	.xtalMHz            = 25, //demod clock freq in MHz; 24 or 25 supported
+};
+
+static struct silabs_tercab_config hauppauge_si2157_config = {
+	.tuner_address           = 0xC0 >> 1,      /* address of the tuner for ATSC/DVB-T */
+	.qam_if_khz              = HVR19x5_QAM_IF, /* needs to match demods qam if */
+	.vsb_if_khz              = HVR19x5_VSB_IF, /* needs to match demods vsb if */
+	.tuner_clock_control     = 1, /* 0:always off 1:always on 2:clock managed */
+	.tuner_agc_control       = 1,
+	.fef_mode                = 0, /* fef mode slow normal agc */
+	.crystal_trim_xo_cap     = 2,
+	.indirect_i2c_connection = 1, /* Si2157 connected directly */
+};
+
 static struct tda18271_std_map hauppauge_tda18271_std_map = {
 	.atsc_6   = { .if_freq = 3250, .agc_mode = 3, .std = 4,
 		      .if_lvl = 1, .rfagc_top = 0x58, },
@@ -173,6 +208,50 @@ static struct r820t_config astrometa_t2h
 	.max_i2c_msg_len	= 2,
 };
 
+static const struct si2168b_config hauppauge_935C_si2168b_config = {
+	.demod_address           = 0xC8 >> 1,
+	.min_delay_ms            = 85,
+	.ts_bus_mode             = 1, /*1-serial, 2-parallel.*/
+	.ts_clock_mode           = 1, /*0-auto_fixed, 1-auto_adapt, 2-manual.*/
+	.clk_gapped_en           = 1, /*0-disabled, 1-enabled.*/
+	.ts_par_clk_invert       = 1, /*0-not-invert, 1-invert*/
+	.ts_par_clk_shift        = 0,
+	.fef_mode                = 0, /* needs to match tuner */
+	.fef_pin                 = 3,
+	.fef_level               = 0,
+	.indirect_i2c_connection = 1, /*Si2177 connected directly*/
+	.start_ctrl              = NULL,
+};
+
+static struct silg_config hauppauge_975_silg_config = {
+	/* Si2168B demodulator configuration */
+	.si_demod_enable         = !0,
+	.si_i2c_addr             = 0xC8 >> 1,
+	.min_delay_ms            = 85,
+	.ts_bus_mode             = 1, /*1-serial, 2-parallel.*/
+	.ts_clock_mode           = 1, /*0-auto_fixed, 1-auto_adapt, 2-manual.*/
+	.clk_gapped_en           = 1, /*0-disabled, 1-enabled.*/
+	.ts_par_clk_invert       = 1, /*0-not-invert, 1-invert*/
+	.ts_par_clk_shift        = 0,
+	.fef_mode                = 0, /* needs to match tuner */
+	.fef_pin                 = 3,
+	.fef_level               = 0,
+	.indirect_i2c_connection = 1, /*Si2177 connected directly*/
+	.start_ctrl              = NULL,
+
+	/* LG3306A demodulator configuration */
+	.lg_demod_enable         = !0,
+	.lg_i2c_addr             = 0xB2 >> 1,
+	.mpeg_mode               = LGDT3306A_MPEG_SERIAL,
+	.tpclk_edge              = LGDT3306A_TPCLK_RISING_EDGE,
+	.tpvalid_polarity        = LGDT3306A_TP_VALID_HIGH,
+	.deny_i2c_rptr           = 1,
+	.spectral_inversion      = 1,
+	.qam_if_khz              = HVR19x5_QAM_IF, /* needs to match tuner */
+	.vsb_if_khz              = HVR19x5_VSB_IF, /* needs to match tuner */
+	.xtalMHz                 = 25,
+};
+
 static inline void print_err_status(struct cx231xx *dev, int packet, int status)
 {
 	char *errmsg = "Unknown";
@@ -275,7 +354,7 @@ static int start_streaming(struct cx231x
 
 	if (dev->USE_ISO) {
 		dev_dbg(dev->dev, "DVB transfer mode is ISO.\n");
-		cx231xx_set_alt_setting(dev, INDEX_TS1, 4);
+		cx231xx_set_alt_setting(dev, INDEX_TS1, 5);
 		rc = cx231xx_set_mode(dev, CX231XX_DIGITAL_MODE);
 		if (rc < 0)
 			return rc;
@@ -933,6 +1012,87 @@ static int dvb_init(struct cx231xx *dev)
 		dev->dvb->i2c_client_tuner = client;
 		break;
 	}
+	case CX231XX_BOARD_HAUPPAUGE_EXETER_955Q:
+
+		dev_info(dev->dev,
+			"%s: looking for tuner / demod on i2c bus: %d\n",
+			__func__, i2c_adapter_id(tuner_i2c));
+
+		dev->dvb->frontend = dvb_attach(lgdt3306a_attach,
+			&hcw_lgdt3306a_config,
+			tuner_i2c);
+
+		if (dev->dvb->frontend == NULL) {
+			dev_info(dev->dev,
+			       ": Failed to attach LG3306A front end\n");
+			result = -EINVAL;
+			goto out_free;
+		}
+
+		dev->dvb->frontend->ops.i2c_gate_ctrl = NULL;
+
+		/* define general-purpose callback pointer */
+		dvb->frontend->callback = cx231xx_tuner_callback;
+
+		dvb_attach(silabs_tercab_attach, dev->dvb->frontend,
+			tuner_i2c,
+			&hauppauge_si2157_config);
+		break;
+
+	case CX231XX_BOARD_HAUPPAUGE_935C:
+
+		dev_info(dev->dev,
+			"%s: looking for tuner / demod on i2c bus: %d\n",
+			__func__, i2c_adapter_id(tuner_i2c));
+
+		dev->dvb->frontend = dvb_attach(si2168b_attach,
+			&hauppauge_935C_si2168b_config,
+			tuner_i2c);
+
+		if (dev->dvb->frontend == NULL) {
+			dev_info(dev->dev,
+			       ": Failed to attach Si2168B front end\n");
+			result = -EINVAL;
+			goto out_free;
+		}
+
+		dev->dvb->frontend->ops.i2c_gate_ctrl = NULL;
+
+		/* define general-purpose callback pointer */
+		dvb->frontend->callback = cx231xx_tuner_callback;
+
+		dvb_attach(silabs_tercab_attach, dev->dvb->frontend,
+			tuner_i2c,
+			&hauppauge_si2157_config);
+		break;
+
+	case CX231XX_BOARD_HAUPPAUGE_975:
+
+		dev_info(dev->dev,
+			"%s: looking for tuner / demod on i2c bus: %d\n",
+			__func__, i2c_adapter_id(tuner_i2c));
+
+		dev->dvb->frontend = dvb_attach(silg_attach,
+			&hauppauge_975_silg_config,
+			tuner_i2c);
+
+		if (dev->dvb->frontend == NULL) {
+			dev_info(dev->dev,
+			       ": Failed to attach SILG front end\n");
+			result = -EINVAL;
+			goto out_free;
+		}
+
+		dev->dvb->frontend->ops.i2c_gate_ctrl = NULL;
+
+		/* define general-purpose callback pointer */
+		dvb->frontend->callback = cx231xx_tuner_callback;
+
+		dvb_attach(silabs_tercab_attach, dev->dvb->frontend,
+			tuner_i2c,
+			&hauppauge_si2157_config);
+		break;
+
 	case CX231XX_BOARD_PV_PLAYTV_USB_HYBRID:
 	case CX231XX_BOARD_KWORLD_UB430_USB_HYBRID:
 
@@ -1103,12 +1263,20 @@ out_free:
 
 static int dvb_fini(struct cx231xx *dev)
 {
+	struct i2c_client *client;
+
 	if (!dev->board.has_dvb) {
 		/* This device does not support the extension */
 		return 0;
 	}
 
 	if (dev->dvb) {
+		client = dev->dvb->i2c_client_tuner;
+		/* remove I2C tuner */
+		if (client) {
+			module_put(client->dev.driver->owner);
+			i2c_unregister_device(client);
+		}
 		unregister_dvb(dev->dvb);
 		dev->dvb = NULL;
 	}
--- linux-4.15/drivers/media/usb/cx231xx/cx231xx.h.0140~	2018-02-12 11:32:52.775582231 +0100
+++ linux-4.15/drivers/media/usb/cx231xx/cx231xx.h	2018-02-12 11:34:17.881187893 +0100
@@ -81,6 +81,9 @@
 #define CX231XX_BOARD_EVROMEDIA_FULL_HYBRID_FULLHD 23
 #define CX231XX_BOARD_ASTROMETA_T2HYBRID 24
 #define CX231XX_BOARD_THE_IMAGING_SOURCE_DFG_USB2_PRO 25
+#define CX231XX_BOARD_HAUPPAUGE_EXETER_955Q 26
+#define CX231XX_BOARD_HAUPPAUGE_935C 27
+#define CX231XX_BOARD_HAUPPAUGE_975 28
 
 /* Limits minimum and default number of buffers */
 #define CX231XX_MIN_BUF                 4
--- linux-4.15/drivers/media/usb/cx231xx/cx231xx-video.c.0140~	2018-02-12 11:32:52.018576686 +0100
+++ linux-4.15/drivers/media/usb/cx231xx/cx231xx-video.c	2018-02-12 11:32:52.776582239 +0100
@@ -1094,6 +1094,18 @@ static int vidioc_s_std(struct file *fil
 	/* do mode control overrides */
 	cx231xx_do_mode_ctrl_overrides(dev);
 
+	dev_info(dev->dev,
+			"%s(): calling cx231xx_dif_set_standards(): norm=0x%08llX\n",
+			__func__, dev->norm);
+	rc = cx231xx_dif_set_standard(dev, dev->norm);
+	if (rc < 0) {
+		dev_err(dev->dev,
+				"%s: cx231xx_dif set to By pass"
+				" mode- errCode [%d]!\n",
+				__func__, rc);
+		return -EIO;
+	}
+
 	return 0;
 }
 
@@ -1317,7 +1329,7 @@ int cx231xx_s_frequency(struct file *fil
 	/* set post channel change settings in DIF first */
 	rc = cx231xx_tuner_post_channel_change(dev);
 
-	if (dev->tuner_type == TUNER_NXP_TDA18271) {
+	if (dev->tuner_type == TUNER_NXP_TDA18271 || dev->tuner_type == TUNER_SILABS_TERCAB) {
 		if (dev->norm & (V4L2_STD_MN | V4L2_STD_NTSC_443))
 			if_frequency = 5400000;  /*5.4MHz	*/
 		else if (dev->norm & V4L2_STD_B)
--- linux-4.15/drivers/media/usb/cx231xx/Kconfig.0140~	2018-01-28 22:20:33.000000000 +0100
+++ linux-4.15/drivers/media/usb/cx231xx/Kconfig	2018-02-12 11:32:52.776582239 +0100
@@ -45,12 +45,15 @@ config VIDEO_CX231XX_DVB
 	select VIDEOBUF_DVB
 	select MEDIA_TUNER_XC5000 if MEDIA_SUBDRV_AUTOSELECT
 	select MEDIA_TUNER_TDA18271 if MEDIA_SUBDRV_AUTOSELECT
+	select MEDIA_TUNER_SILABS_TERCAB if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_MB86A20S if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_LGDT3305 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_LGDT3306A if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_TDA18271C2DD if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_SI2165 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_SI2168 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_SI2168B if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_SILG if MEDIA_SUBDRV_AUTOSELECT
 	select MEDIA_TUNER_SI2157 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_MN88473 if MEDIA_SUBDRV_AUTOSELECT
 	select MEDIA_TUNER_R820T if MEDIA_SUBDRV_AUTOSELECT
--- linux-4.15/drivers/media/usb/pvrusb2/Kconfig.0140~	2018-01-28 22:20:33.000000000 +0100
+++ linux-4.15/drivers/media/usb/pvrusb2/Kconfig	2018-02-12 11:32:52.776582239 +0100
@@ -39,10 +39,13 @@ config VIDEO_PVRUSB2_DVB
 	select DVB_LGDT330X if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_S5H1409 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_S5H1411 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_SI2168B if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_SILG if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_TDA10048 if MEDIA_SUBDRV_AUTOSELECT
 	select MEDIA_TUNER_TDA18271 if MEDIA_SUBDRV_AUTOSELECT
 	select MEDIA_TUNER_SIMPLE if MEDIA_SUBDRV_AUTOSELECT
 	select MEDIA_TUNER_TDA8290 if MEDIA_SUBDRV_AUTOSELECT
++	select MEDIA_TUNER_SILABS_TERCAB if MEDIA_SUBDRV_AUTOSELECT
 	---help---
 	  This option enables a DVB interface for the pvrusb2 driver.
 	  If your device does not support digital television, this
--- linux-4.15/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.c.0140~	2018-01-28 22:20:33.000000000 +0100
+++ linux-4.15/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.c	2018-02-12 11:32:52.776582239 +0100
@@ -112,10 +112,35 @@ static const struct routing_scheme routi
 	.cnt = ARRAY_SIZE(routing_schemeav400),
 };
 
+static const struct routing_scheme_item routing_scheme160xxx[] = {
+	[PVR2_CVAL_INPUT_TV] = {
+		.vid = CX25840_COMPOSITE7,
+		.aud = CX25840_AUDIO8,
+	},
+	[PVR2_CVAL_INPUT_RADIO] = {
+		.vid = CX25840_COMPOSITE4,
+		.aud = CX25840_AUDIO6,
+	},
+	[PVR2_CVAL_INPUT_COMPOSITE] = {
+		.vid = CX25840_COMPOSITE3,
+		.aud = CX25840_AUDIO_SERIAL,
+	},
+	[PVR2_CVAL_INPUT_SVIDEO] = {
+		.vid = CX25840_SVIDEO1,
+		.aud = CX25840_AUDIO_SERIAL,
+	},
+};
+
+static const struct routing_scheme routing_def160xxx = {
+	.def = routing_scheme160xxx,
+	.cnt = ARRAY_SIZE(routing_scheme160xxx),
+};
+
 static const struct routing_scheme *routing_schemes[] = {
 	[PVR2_ROUTING_SCHEME_HAUPPAUGE] = &routing_def0,
 	[PVR2_ROUTING_SCHEME_GOTVIEW] = &routing_defgv,
 	[PVR2_ROUTING_SCHEME_AV400] = &routing_defav400,
+	[PVR2_ROUTING_SCHEME_HAUP160XXX] = &routing_def160xxx,
 };
 
 void pvr2_cx25840_subdev_update(struct pvr2_hdw *hdw, struct v4l2_subdev *sd)
--- linux-4.15/drivers/media/usb/pvrusb2/pvrusb2-devattr.c.0140~	2018-02-12 11:32:52.020576701 +0100
+++ linux-4.15/drivers/media/usb/pvrusb2/pvrusb2-devattr.c	2018-02-12 11:32:52.776582239 +0100
@@ -31,15 +31,18 @@ pvr2_device_desc structures.
 #ifdef CONFIG_VIDEO_PVRUSB2_DVB
 #include "pvrusb2-hdw-internal.h"
 #include "lgdt330x.h"
+#include "lgdt3306a.h"
 #include "s5h1409.h"
 #include "s5h1411.h"
 #include "tda10048.h"
 #include "tda18271.h"
 #include "tda8290.h"
 #include "tuner-simple.h"
+#include "silabs_tercab.h"
+#include "si2168b.h"
+#include "silg.h"
 #endif
 
-
 /*------------------------------------------------------------------------*/
 /* Hauppauge PVR-USB2 Model 29xxx */
 
@@ -474,6 +477,143 @@ static const struct pvr2_dvb_props pvr2_
 };
 #endif
 
+/*------------------------------------------------------------------------*/
+/* Hauppauge PVR-USB2 Models 160xxx */
+
+#ifdef CONFIG_VIDEO_PVRUSB2_DVB
+#define HVR19x5_QAM_IF 4000
+#define HVR19x5_VSB_IF 3250
+
+static struct silabs_tercab_config hauppauge_si2177_config = {
+	.tuner_address           = 0xC0 >> 1,      /* address of the tuner for ATSC/DVB-T */
+	.qam_if_khz              = HVR19x5_QAM_IF, /* needs to match demods qam if */
+	.vsb_if_khz              = HVR19x5_VSB_IF, /* needs to match demods vsb if */
+	.tuner_clock_control     = 2, /*0-always off 1-always on 2-clock managed */
+	.tuner_agc_control       = 1,
+	.fef_mode                = 0, /*0-slow normal AGC, 1-freeze pin, 2-slow initial AGC*/
+	.crystal_trim_xo_cap     = 8,
+	.indirect_i2c_connection = 1, /* Si2177 connected directly */
+};
+
+static int pvr2_si2177_attach(struct pvr2_dvb_adapter *adap)
+{
+	pr_info("%s()\n", __func__);
+
+	dvb_attach(silabs_tercab_attach, adap->fe,
+		   &adap->channel.hdw->i2c_adap,
+		   &hauppauge_si2177_config);
+
+	return 0;
+}
+
+/*------------------------------------------------------------------------*/
+/* Hauppauge PVR-USB2 Model 160000 */
+
+static struct silg_config pvr2_hvr1975_silg_config = {
+	/* Si2168B demodulator configuration */
+	.si_demod_enable         = !0,
+	.si_i2c_addr             = 0xC8 >> 1,
+	.min_delay_ms            = 85,
+	.ts_bus_mode             = 2, /*1-serial, 2-parallel.*/
+	.ts_clock_mode           = 2, /*0-auto_fixed, 1-auto_adapt, 2-manual.*/
+	.clk_gapped_en           = 1, /*0-disabled, 1-enabled.*/
+	.ts_par_clk_invert       = 0, /*0-not-invert, 1-invert*/
+	.ts_par_clk_shift        = 3, /*DVB-C QAM256 fix*/
+	.fef_mode                = 0, /* needs to match tuner */
+	.fef_pin                 = 3,
+	.fef_level               = 0,
+	.indirect_i2c_connection = 1, /*Si2177 connected directly*/
+	.start_ctrl              = NULL,
+
+	/* LG3306A demodulator configuration */
+	.lg_demod_enable         = !0,
+	.lg_i2c_addr             = 0xB2 >> 1,
+	.mpeg_mode               = LGDT3306A_MPEG_PARALLEL,
+	.tpclk_edge              = LGDT3306A_TPCLK_FALLING_EDGE,
+	.tpvalid_polarity        = LGDT3306A_TP_VALID_LOW,
+	.deny_i2c_rptr           = 1,
+	.spectral_inversion      = 1,
+	.qam_if_khz              = HVR19x5_QAM_IF, /* needs to match tuner */
+	.vsb_if_khz              = HVR19x5_VSB_IF, /* needs to match tuner */
+	.xtalMHz                 = 25,
+};
+
+static int pvr2_silg_attach(struct pvr2_dvb_adapter *adap)
+{
+	pr_info("%s()\n", __func__);
+
+	adap->fe = dvb_attach(silg_attach,
+				  &pvr2_hvr1975_silg_config,
+			      &adap->channel.hdw->i2c_adap);
+	if (adap->fe) {
+		pr_info("%s(): attached silg\n", __func__);
+		return 0;
+	}
+
+	return -EIO;
+}
+
+static const struct pvr2_dvb_props pvr2_160000_dvb_props = {
+	.frontend_attach = pvr2_silg_attach,
+	.tuner_attach    = pvr2_si2177_attach,
+};
+
+static const struct pvr2_device_client_desc pvr2_cli_160000[] = {
+	{ .module_id = PVR2_CLIENT_ID_CX25840 },
+	{ .module_id = PVR2_CLIENT_ID_TUNER,
+	  .i2c_address_list = "\x60" },
+	{ .module_id = PVR2_CLIENT_ID_DEMOD,
+	  .i2c_address_list = "\x59" },	//LG3306a addr
+};
+
+/*------------------------------------------------------------------------*/
+/* Hauppauge PVR-USB2 Model 160111 */
+
+static struct lgdt3306a_config pvr2_lgdt3306a_config = {
+	/* LG3306A demodulator configuration */
+	.i2c_addr           = 0xB2 >> 1,
+
+	/* user defined IF frequency in KHz */
+	.qam_if_khz         = HVR19x5_QAM_IF, //FGR - BUGBUG - needs to match tuner
+	.vsb_if_khz         = HVR19x5_VSB_IF, //FGR - BUGBUG - needs to match tuner
+
+	/* disable i2c repeater - 0:repeater enabled 1:repeater disabled */
+	.deny_i2c_rptr      = 1,
+
+	/* spectral inversion - 0:disabled 1:enabled */
+	.spectral_inversion = 1,
+
+	.mpeg_mode          = LGDT3306A_MPEG_PARALLEL,
+	.tpclk_edge         = LGDT3306A_TPCLK_FALLING_EDGE,
+	.tpvalid_polarity   = LGDT3306A_TP_VALID_LOW,
+
+	.xtalMHz            = 25, //demod clock freq in MHz; 24 or 25 supported
+};
+
+static int pvr2_lgdt3306a_attach(struct pvr2_dvb_adapter *adap)
+{
+	adap->fe = dvb_attach(lgdt3306a_attach, &pvr2_lgdt3306a_config,
+			      &adap->channel.hdw->i2c_adap);
+	if (adap->fe)
+		return 0;
+
+	return -EIO;
+}
+
+static const struct pvr2_dvb_props pvr2_160111_dvb_props = {
+	.frontend_attach = pvr2_lgdt3306a_attach,
+	.tuner_attach    = pvr2_si2177_attach,
+};
+
+static const struct pvr2_device_client_desc pvr2_cli_160111[] = {
+	{ .module_id = PVR2_CLIENT_ID_CX25840 },
+	{ .module_id = PVR2_CLIENT_ID_TUNER,
+	  .i2c_address_list = "\x60" },
+	{ .module_id = PVR2_CLIENT_ID_DEMOD,
+	  .i2c_address_list = "\x59" },	//LG3306a addr
+};
+#endif
+
 #define PVR2_FIRMWARE_75xxx "v4l-pvrusb2-73xxx-01.fw"
 static const char *pvr2_fw1_names_75xxx[] = {
 		PVR2_FIRMWARE_75xxx,
@@ -525,7 +665,58 @@ static const struct pvr2_device_desc pvr
 #endif
 };
 
+#define PVR2_FIRMWARE_160xxx "v4l-pvrusb2-160xxx-01.fw"
+static const char *pvr2_fw1_names_160xxx[] = {
+		PVR2_FIRMWARE_160xxx,
+};
 
+static const struct pvr2_device_desc pvr2_device_160000 = {
+		.description = "WinTV HVR-1975 Model 160000",
+		.shortname = "160000",
+		.client_table.lst = pvr2_cli_160000,
+		.client_table.cnt = ARRAY_SIZE(pvr2_cli_160000),
+		.fx2_firmware.lst = pvr2_fw1_names_160xxx,
+		.fx2_firmware.cnt = ARRAY_SIZE(pvr2_fw1_names_160xxx),
+		.default_tuner_type = TUNER_SILABS_TERCAB,
+		.flag_has_cx25840 = !0,
+		.flag_has_hauppauge_rom = !0,
+		.flag_has_analogtuner = !0,
+		.flag_has_composite = !0,
+		.flag_has_svideo = !0,
+		.flag_fx2_16kb = !0,
+		.signal_routing_scheme = PVR2_ROUTING_SCHEME_HAUPPAUGE,
+		.digital_control_scheme = PVR2_DIGITAL_SCHEME_HAUPPAUGE,
+		.default_std_mask = V4L2_STD_NTSC_M,
+		.led_scheme = PVR2_LED_SCHEME_HAUPPAUGE,
+		.ir_scheme = PVR2_IR_SCHEME_ZILOG,
+#ifdef CONFIG_VIDEO_PVRUSB2_DVB
+		.dvb_props = &pvr2_160000_dvb_props,
+#endif
+};
+
+static const struct pvr2_device_desc pvr2_device_160111 = {
+		.description = "WinTV HVR-1955 Model 160111",
+		.shortname = "160111",
+		.client_table.lst = pvr2_cli_160111,
+		.client_table.cnt = ARRAY_SIZE(pvr2_cli_160111),
+		.fx2_firmware.lst = pvr2_fw1_names_160xxx,
+		.fx2_firmware.cnt = ARRAY_SIZE(pvr2_fw1_names_160xxx),
+		.default_tuner_type = TUNER_SILABS_TERCAB,
+		.flag_has_cx25840 = !0,
+		.flag_has_hauppauge_rom = !0,
+		.flag_has_analogtuner = !0,
+		.flag_has_composite = !0,
+		.flag_has_svideo = !0,
+		.flag_fx2_16kb = !0,
+		.signal_routing_scheme = PVR2_ROUTING_SCHEME_HAUPPAUGE,
+		.digital_control_scheme = PVR2_DIGITAL_SCHEME_HAUPPAUGE,
+		.default_std_mask = V4L2_STD_NTSC_M,
+		.led_scheme = PVR2_LED_SCHEME_HAUPPAUGE,
+		.ir_scheme = PVR2_IR_SCHEME_ZILOG,
+#ifdef CONFIG_VIDEO_PVRUSB2_DVB
+		.dvb_props = &pvr2_160111_dvb_props,
+#endif
+};
 
 /*------------------------------------------------------------------------*/
 
@@ -552,6 +743,10 @@ struct usb_device_id pvr2_device_table[]
 	  .driver_info = (kernel_ulong_t)&pvr2_device_751xx},
 	{ USB_DEVICE(0x0ccd, 0x0039),
 	  .driver_info = (kernel_ulong_t)&pvr2_device_av400},
+	{ USB_DEVICE(0x2040, 0x7502), /* HVR-1955 */
+	  .driver_info = (kernel_ulong_t)&pvr2_device_160111},
+	{ USB_DEVICE(0x2040, 0x7510), /* HVR-1975 */
+	  .driver_info = (kernel_ulong_t)&pvr2_device_160000},
 	{ }
 };
 
@@ -560,3 +755,4 @@ MODULE_FIRMWARE(PVR2_FIRMWARE_29xxx);
 MODULE_FIRMWARE(PVR2_FIRMWARE_24xxx);
 MODULE_FIRMWARE(PVR2_FIRMWARE_73xxx);
 MODULE_FIRMWARE(PVR2_FIRMWARE_75xxx);
+MODULE_FIRMWARE(PVR2_FIRMWARE_160xxx);
--- linux-4.15/drivers/media/usb/pvrusb2/pvrusb2-devattr.h.0140~	2018-01-28 22:20:33.000000000 +0100
+++ linux-4.15/drivers/media/usb/pvrusb2/pvrusb2-devattr.h	2018-02-12 11:32:52.776582239 +0100
@@ -66,6 +66,7 @@ struct pvr2_string_table {
 #define PVR2_ROUTING_SCHEME_GOTVIEW 1
 #define PVR2_ROUTING_SCHEME_ONAIR 2
 #define PVR2_ROUTING_SCHEME_AV400 3
+#define PVR2_ROUTING_SCHEME_HAUP160XXX 4
 
 #define PVR2_DIGITAL_SCHEME_NONE 0
 #define PVR2_DIGITAL_SCHEME_HAUPPAUGE 1
--- linux-4.15/drivers/media/usb/pvrusb2/pvrusb2-dvb.c.0140~	2018-02-12 11:32:52.020576701 +0100
+++ linux-4.15/drivers/media/usb/pvrusb2/pvrusb2-dvb.c	2018-02-12 11:32:52.776582239 +0100
@@ -244,6 +244,13 @@ static int pvr2_dvb_stop_feed(struct dvb
 static int pvr2_dvb_bus_ctrl(struct dvb_frontend *fe, int acquire)
 {
 	struct pvr2_dvb_adapter *adap = fe->dvb->priv;
+	const struct pvr2_hdw *hdw = adap->channel.hdw;
+
+	pvr2_trace(PVR2_TRACE_DVB_FEED, "%s(): dvb bus ctrl: %d", __func__, acquire);
+
+	if (hdw->fe_ts_bus_ctrl)
+		hdw->fe_ts_bus_ctrl(fe, acquire);
+
 	return pvr2_channel_limit_inputs(
 	    &adap->channel,
 	    (acquire ? (1 << PVR2_CVAL_INPUT_DTV) : 0));
@@ -361,8 +368,10 @@ static int pvr2_dvb_frontend_init(struct
 			adap->fe->ops.analog_ops.standby(adap->fe);
 
 		/* Ensure all frontends negotiate bus access */
+		/* save the original function pointer */
+		hdw->fe_ts_bus_ctrl = adap->fe->ops.ts_bus_ctrl;
+		pvr2_trace(PVR2_TRACE_INFO, "transferring ts_bus_ctrl() to pvr2_dvb_bus_ctrl()");
 		adap->fe->ops.ts_bus_ctrl = pvr2_dvb_bus_ctrl;
-
 	} else {
 		pvr2_trace(PVR2_TRACE_ERROR_LEGS,
 			   "no frontend was attached!");
--- linux-4.15/drivers/media/usb/pvrusb2/pvrusb2-fx2-cmd.h.0140~	2018-01-28 22:20:33.000000000 +0100
+++ linux-4.15/drivers/media/usb/pvrusb2/pvrusb2-fx2-cmd.h	2018-02-12 11:32:52.776582239 +0100
@@ -38,6 +38,10 @@
 
 #define FX2CMD_FWPOST1          0x52u
 
+/* These 2 only exist on Model 160xxx */
+#define FX2CMD_HCW_DEMOD_RESET_PIN 0xd4u
+#define FX2CMD_HCW_MAKO_SLEEP_PIN  0xd5u
+
 #define FX2CMD_POWER_OFF        0xdcu
 #define FX2CMD_POWER_ON         0xdeu
 
--- linux-4.15/drivers/media/usb/pvrusb2/pvrusb2-hdw.c.0140~	2018-02-12 11:32:52.020576701 +0100
+++ linux-4.15/drivers/media/usb/pvrusb2/pvrusb2-hdw.c	2018-02-12 11:32:52.777582246 +0100
@@ -316,6 +316,8 @@ static const struct pvr2_fx2cmd_descdef
 	{FX2CMD_ONAIR_DTV_STREAMING_OFF, "onair dtv stream off"},
 	{FX2CMD_ONAIR_DTV_POWER_ON, "onair dtv power on"},
 	{FX2CMD_ONAIR_DTV_POWER_OFF, "onair dtv power off"},
+	{FX2CMD_HCW_DEMOD_RESET_PIN, "hcw demod reset pin"},
+	{FX2CMD_HCW_MAKO_SLEEP_PIN, "hcw mako sleep pin"},
 };
 
 
@@ -2093,6 +2095,7 @@ static void pvr2_hdw_setup_low(struct pv
 	unsigned int idx;
 	struct pvr2_ctrl *cptr;
 	int reloadFl = 0;
+
 	if (hdw->hdw_desc->fx2_firmware.cnt) {
 		if (!reloadFl) {
 			reloadFl =
@@ -2141,6 +2144,23 @@ static void pvr2_hdw_setup_low(struct pv
 	pvr2_i2c_core_init(hdw);
 	if (!pvr2_hdw_dev_ok(hdw)) return;
 
+	/* reset demod only on Hauppauge 160xxx platform */
+	if (hdw->usb_dev->descriptor.idVendor == 0x2040 &&
+			(hdw->usb_dev->descriptor.idProduct == 0x7502 || hdw->usb_dev->descriptor.idProduct == 0x7510)) {
+		pr_info("%s(): resetting 160xxx demod\n", __func__);
+		//FGR - not sure this is the proper place to reset demods once only
+		pvr2_issue_simple_cmd(hdw,
+				     FX2CMD_HCW_DEMOD_RESET_PIN |
+				     (1 << 8) |
+				     ((0) << 16));
+		msleep(10);
+		pvr2_issue_simple_cmd(hdw,
+				     FX2CMD_HCW_DEMOD_RESET_PIN |
+				     (1 << 8) |
+				     ((1) << 16));
+		msleep(10);
+	}
+
 	pvr2_hdw_load_modules(hdw);
 	if (!pvr2_hdw_dev_ok(hdw)) return;
 
@@ -2205,7 +2225,6 @@ static void pvr2_hdw_setup_low(struct pv
 			   hdw->tuner_type);
 	}
 
-
 	if (!pvr2_hdw_dev_ok(hdw)) return;
 
 	if (hdw->hdw_desc->signal_routing_scheme ==
@@ -4011,6 +4030,17 @@ int pvr2_hdw_cmd_decoder_reset(struct pv
 static int pvr2_hdw_cmd_hcw_demod_reset(struct pvr2_hdw *hdw, int onoff)
 {
 	hdw->flag_ok = !0;
+
+	//BUGBUG - use this for 160xxx, but how can we tell it's the right HW
+	if (hdw->usb_dev->descriptor.idVendor == 0x2040 &&
+			(hdw->usb_dev->descriptor.idProduct == 0x7502 || hdw->usb_dev->descriptor.idProduct == 0x7510)) {
+		pr_info("%s(): resetting demod on Hauppauge 160xxx platform skipped\n", __func__);
+		//FGR don't want Demod reset on 160xxx or it will trash Demod tristate
+		return pvr2_issue_simple_cmd(hdw,
+				     FX2CMD_HCW_MAKO_SLEEP_PIN |
+				     (1 << 8) |
+				     ((onoff ? 1 : 0) << 16));
+	}
 	return pvr2_issue_simple_cmd(hdw,
 				     FX2CMD_HCW_DEMOD_RESETIN |
 				     (1 << 8) |
--- linux-4.15/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h.0140~	2018-01-28 22:20:33.000000000 +0100
+++ linux-4.15/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h	2018-02-12 11:32:52.777582246 +0100
@@ -381,6 +381,9 @@ struct pvr2_hdw {
 
 	struct pvr2_ctrl *controls;
 	unsigned int control_cnt;
+
+	/* experimental... */
+	int (*fe_ts_bus_ctrl) (struct dvb_frontend*, int);
 };
 
 /* This function gets the current frequency */
--- linux-4.15/drivers/media/v4l2-core/tuner-core.c.0140~	2018-01-28 22:20:33.000000000 +0100
+++ linux-4.15/drivers/media/v4l2-core/tuner-core.c	2018-02-12 11:32:52.778582253 +0100
@@ -40,6 +40,7 @@
 #include "xc5000.h"
 #include "tda18271.h"
 #include "xc4000.h"
+#include "silabs_tercab.h"
 
 #define UNSET (-1U)
 
@@ -396,6 +397,30 @@ static void set_type(struct i2c_client *
 		tune_now = 0;
 		break;
 	}
+	case TUNER_SILABS_TERCAB:
+	{
+		static struct silabs_tercab_config silabs_config = {
+			.tuner_address           = 0xC0 >> 1,      /* address of the tuner for ATSC/DVB-T */
+			.qam_if_khz              = HVR19x5_QAM_IF, /* needs to match demods qam if */
+			.vsb_if_khz              = HVR19x5_VSB_IF, /* needs to match demods vsb if */
+			.tuner_clock_control     = 1, /* 0:always off 1:always on 2:clock managed */
+			.tuner_agc_control       = 1,
+			.fef_mode                = 0, /* fef mode slow normal agc */
+			.crystal_trim_xo_cap     = 8,
+			.indirect_i2c_connection = 1, /* tuner connected directly(?) */
+		};
+
+		printk(KERN_INFO "%s: looking for Silicon Labs tuner on i2c bus: %d\n",
+		       __func__, i2c_adapter_id(t->i2c->adapter));
+
+		if (!dvb_attach(silabs_tercab_attach, &t->fe, t->i2c->adapter, &silabs_config)) {
+			printk(KERN_ERR "%s: attaching Silicon Labs tuner failed\n", __func__);
+			goto attach_failed;
+		}
+		printk(KERN_INFO "%s: Silicon Labs tuner attached\n", __func__);
+		tune_now = 0;
+		break;
+	}
 	default:
 		if (!dvb_attach(simple_tuner_attach, &t->fe,
 				t->i2c->adapter, t->i2c->addr, t->type))
@@ -643,17 +668,27 @@ static int tuner_probe(struct i2c_client
 			}
 			break;
 		case 0x60:
-			if (tuner_symbol_probe(tea5767_autodetection,
+			if (tuner_symbol_probe(silabs_tercab_autodetection,
 					       t->i2c->adapter, t->i2c->addr)
-					>= 0) {
-				t->type = TUNER_TEA5767;
-				t->mode_mask = T_RADIO;
-				/* Sets freq to FM range */
-				tuner_lookup(t->i2c->adapter, &radio, &tv);
-				if (tv)
-					tv->mode_mask &= ~T_RADIO;
-
+					== 0) {
+				dprintk("Silicon Labs tuner @ 0x%02X detected\n", t->i2c->addr);
+				t->type = TUNER_SILABS_TERCAB;
+				t->mode_mask = T_ANALOG_TV;
 				goto register_client;
+			} else {
+				dprintk("i2c addr 0x60: tea5767_autodetection\n");
+				if (tuner_symbol_probe(tea5767_autodetection,
+					       	   t->i2c->adapter, t->i2c->addr)
+						>= 0) {
+					t->type = TUNER_TEA5767;
+					t->mode_mask = T_RADIO;
+					/* Sets freq to FM range */
+					tuner_lookup(t->i2c->adapter, &radio, &tv);
+					if (tv)
+						tv->mode_mask &= ~T_RADIO;
+
+					goto register_client;
+				}
 			}
 			break;
 		}
--- linux-4.15/include/media/tuner.h.0140~	2018-01-28 22:20:33.000000000 +0100
+++ linux-4.15/include/media/tuner.h	2018-02-12 11:32:52.778582253 +0100
@@ -142,6 +142,8 @@
 #define TUNER_SONY_BTF_PK467Z		90	/* NTSC_JP */
 #define TUNER_SONY_BTF_PB463Z		91	/* NTSC */
 
+#define TUNER_SILABS_TERCAB		92	/* Silicon Labs terrestrial/cable tuner series */
+
 /* tv card specific */
 #define TDA9887_PRESENT			(1<<0)
 #define TDA9887_PORT1_INACTIVE		(1<<1)
